/// Provides a Cloudflare Access Application resource. Access
/// Applications are used to restrict access to a whole application using an
/// authorisation gateway managed by Cloudflare.
///
/// > It's required that an `account_id` or `zone_id` is provided and in
///    most cases using either is fine. However, if you're using a scoped
///    access token, you must provide the argument that matches the token's
///    scope. For example, an access token that is scoped to the "example.com"
///    zone needs to use the `zone_id` argument.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// // With CORS configuration
/// const stagingApp = new cloudflare.AccessApplication("stagingApp", {
///     corsHeaders: [{
///         allowCredentials: true,
///         allowedMethods: [
///             "GET",
///             "POST",
///             "OPTIONS",
///         ],
///         allowedOrigins: ["https://example.com"],
///         maxAge: 10,
///     }],
///     domain: "staging.example.com",
///     name: "staging application",
///     sessionDuration: "24h",
///     type: "self_hosted",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// # With CORS configuration
/// staging_app = cloudflare.AccessApplication("stagingApp",
///     cors_headers=[cloudflare.AccessApplicationCorsHeaderArgs(
///         allow_credentials=True,
///         allowed_methods=[
///             "GET",
///             "POST",
///             "OPTIONS",
///         ],
///         allowed_origins=["https://example.com"],
///         max_age=10,
///     )],
///     domain="staging.example.com",
///     name="staging application",
///     session_duration="24h",
///     type="self_hosted",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     // With CORS configuration
///     var stagingApp = new Cloudflare.AccessApplication("stagingApp", new()
///     {
///         CorsHeaders = new[]
///         {
///             new Cloudflare.Inputs.AccessApplicationCorsHeaderArgs
///             {
///                 AllowCredentials = true,
///                 AllowedMethods = new[]
///                 {
///                     "GET",
///                     "POST",
///                     "OPTIONS",
///                 },
///                 AllowedOrigins = new[]
///                 {
///                     "https://example.com",
///                 },
///                 MaxAge = 10,
///             },
///         },
///         Domain = "staging.example.com",
///         Name = "staging application",
///         SessionDuration = "24h",
///         Type = "self_hosted",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// With CORS configuration
/// 		_, err := cloudflare.NewAccessApplication(ctx, "stagingApp", &cloudflare.AccessApplicationArgs{
/// 			CorsHeaders: cloudflare.AccessApplicationCorsHeaderArray{
/// 				&cloudflare.AccessApplicationCorsHeaderArgs{
/// 					AllowCredentials: pulumi.Bool(true),
/// 					AllowedMethods: pulumi.StringArray{
/// 						pulumi.String("GET"),
/// 						pulumi.String("POST"),
/// 						pulumi.String("OPTIONS"),
/// 					},
/// 					AllowedOrigins: pulumi.StringArray{
/// 						pulumi.String("https://example.com"),
/// 					},
/// 					MaxAge: pulumi.Int(10),
/// 				},
/// 			},
/// 			Domain:          pulumi.String("staging.example.com"),
/// 			Name:            pulumi.String("staging application"),
/// 			SessionDuration: pulumi.String("24h"),
/// 			Type:            pulumi.String("self_hosted"),
/// 			ZoneId:          pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.AccessApplication;
/// import com.pulumi.cloudflare.AccessApplicationArgs;
/// import com.pulumi.cloudflare.inputs.AccessApplicationCorsHeaderArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // With CORS configuration
///         var stagingApp = new AccessApplication("stagingApp", AccessApplicationArgs.builder()        
///             .corsHeaders(AccessApplicationCorsHeaderArgs.builder()
///                 .allowCredentials(true)
///                 .allowedMethods(                
///                     "GET",
///                     "POST",
///                     "OPTIONS")
///                 .allowedOrigins("https://example.com")
///                 .maxAge(10)
///                 .build())
///             .domain("staging.example.com")
///             .name("staging application")
///             .sessionDuration("24h")
///             .type("self_hosted")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # With CORS configuration
///   stagingApp:
///     type: cloudflare:AccessApplication
///     properties:
///       corsHeaders:
///         - allowCredentials: true
///           allowedMethods:
///             - GET
///             - POST
///             - OPTIONS
///           allowedOrigins:
///             - https://example.com
///           maxAge: 10
///       domain: staging.example.com
///       name: staging application
///       sessionDuration: 24h
///       type: self_hosted
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/accessApplication:AccessApplication example <account_id>/<application_id>
/// ```
///
pub mod access_application {

    pub struct AccessApplicationArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// When set to true, users can authenticate to this application using their WARP session. When set to false this application will always require direct IdP authentication. This setting always overrides the organization setting for WARP authentication.
        pub allow_authenticate_via_warp: pulumi_wasm_rust::Output<Option<bool>>,
        /// The identity providers selected for the application.
        pub allowed_idps: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The logo URL of the app launcher.
        pub app_launcher_logo_url: pulumi_wasm_rust::Output<Option<String>>,
        /// Option to show/hide applications in App Launcher. Defaults to `true`.
        pub app_launcher_visible: pulumi_wasm_rust::Output<Option<bool>>,
        /// Option to skip identity provider selection if only one is configured in `allowed_idps`. Defaults to `false`.
        pub auto_redirect_to_identity: pulumi_wasm_rust::Output<Option<bool>>,
        /// The background color of the app launcher.
        pub bg_color: pulumi_wasm_rust::Output<Option<String>>,
        /// CORS configuration for the Access Application. See below for reference structure.
        pub cors_headers:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::AccessApplicationCorsHeader>>>,
        /// Option that returns a custom error message when a user is denied access to the application.
        pub custom_deny_message: pulumi_wasm_rust::Output<Option<String>>,
        /// Option that redirects to a custom URL when a user is denied access to the application via identity based rules.
        pub custom_deny_url: pulumi_wasm_rust::Output<Option<String>>,
        /// Option that redirects to a custom URL when a user is denied access to the application via non identity rules.
        pub custom_non_identity_deny_url: pulumi_wasm_rust::Output<Option<String>>,
        /// The custom pages selected for the application.
        pub custom_pages: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The primary hostname and path that Access will secure. If the app is visible in the App Launcher dashboard, this is the domain that will be displayed.
        pub domain: pulumi_wasm_rust::Output<Option<String>>,
        /// Option to provide increased security against compromised authorization tokens and CSRF attacks by requiring an additional "binding" cookie on requests. Defaults to `false`.
        pub enable_binding_cookie: pulumi_wasm_rust::Output<Option<bool>>,
        /// The footer links of the app launcher.
        pub footer_links:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::AccessApplicationFooterLink>>>,
        /// The background color of the header bar in the app launcher.
        pub header_bg_color: pulumi_wasm_rust::Output<Option<String>>,
        /// Option to add the `HttpOnly` cookie flag to access tokens.
        pub http_only_cookie_attribute: pulumi_wasm_rust::Output<Option<bool>>,
        /// The landing page design of the app launcher.
        pub landing_page_design:
            pulumi_wasm_rust::Output<Option<crate::types::AccessApplicationLandingPageDesign>>,
        /// Image URL for the logo shown in the app launcher dashboard.
        pub logo_url: pulumi_wasm_rust::Output<Option<String>>,
        /// The name of the footer link.
        pub name: pulumi_wasm_rust::Output<Option<String>>,
        /// SaaS configuration for the Access Application.
        pub saas_app: pulumi_wasm_rust::Output<Option<crate::types::AccessApplicationSaasApp>>,
        /// Defines the same-site cookie setting for access tokens. Available values: `none`, `lax`, `strict`.
        pub same_site_cookie_attribute: pulumi_wasm_rust::Output<Option<String>>,
        /// List of domains that access will secure. Only present for self_hosted, vnc, and ssh applications. Always includes the value set as `domain`.
        pub self_hosted_domains: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Option to return a 401 status code in service authentication rules on failed requests. Defaults to `false`.
        pub service_auth401_redirect: pulumi_wasm_rust::Output<Option<bool>>,
        /// How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`. Defaults to `24h`.
        pub session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// Option to skip the authorization interstitial when using the CLI. Defaults to `false`.
        pub skip_interstitial: pulumi_wasm_rust::Output<Option<bool>>,
        /// The itags associated with the application.
        pub tags: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The application type. Available values: `app_launcher`, `bookmark`, `biso`, `dash_sso`, `saas`, `self_hosted`, `ssh`, `vnc`, `warp`. Defaults to `self_hosted`.
        pub type_: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct AccessApplicationResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// When set to true, users can authenticate to this application using their WARP session. When set to false this application will always require direct IdP authentication. This setting always overrides the organization setting for WARP authentication.
        pub allow_authenticate_via_warp: pulumi_wasm_rust::Output<Option<bool>>,
        /// The identity providers selected for the application.
        pub allowed_idps: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The logo URL of the app launcher.
        pub app_launcher_logo_url: pulumi_wasm_rust::Output<Option<String>>,
        /// Option to show/hide applications in App Launcher. Defaults to `true`.
        pub app_launcher_visible: pulumi_wasm_rust::Output<Option<bool>>,
        /// Application Audience (AUD) Tag of the application.
        pub aud: pulumi_wasm_rust::Output<String>,
        /// Option to skip identity provider selection if only one is configured in `allowed_idps`. Defaults to `false`.
        pub auto_redirect_to_identity: pulumi_wasm_rust::Output<Option<bool>>,
        /// The background color of the app launcher.
        pub bg_color: pulumi_wasm_rust::Output<Option<String>>,
        /// CORS configuration for the Access Application. See below for reference structure.
        pub cors_headers:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::AccessApplicationCorsHeader>>>,
        /// Option that returns a custom error message when a user is denied access to the application.
        pub custom_deny_message: pulumi_wasm_rust::Output<Option<String>>,
        /// Option that redirects to a custom URL when a user is denied access to the application via identity based rules.
        pub custom_deny_url: pulumi_wasm_rust::Output<Option<String>>,
        /// Option that redirects to a custom URL when a user is denied access to the application via non identity rules.
        pub custom_non_identity_deny_url: pulumi_wasm_rust::Output<Option<String>>,
        /// The custom pages selected for the application.
        pub custom_pages: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The primary hostname and path that Access will secure. If the app is visible in the App Launcher dashboard, this is the domain that will be displayed.
        pub domain: pulumi_wasm_rust::Output<String>,
        /// Option to provide increased security against compromised authorization tokens and CSRF attacks by requiring an additional "binding" cookie on requests. Defaults to `false`.
        pub enable_binding_cookie: pulumi_wasm_rust::Output<Option<bool>>,
        /// The footer links of the app launcher.
        pub footer_links:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::AccessApplicationFooterLink>>>,
        /// The background color of the header bar in the app launcher.
        pub header_bg_color: pulumi_wasm_rust::Output<Option<String>>,
        /// Option to add the `HttpOnly` cookie flag to access tokens.
        pub http_only_cookie_attribute: pulumi_wasm_rust::Output<Option<bool>>,
        /// The landing page design of the app launcher.
        pub landing_page_design:
            pulumi_wasm_rust::Output<Option<crate::types::AccessApplicationLandingPageDesign>>,
        /// Image URL for the logo shown in the app launcher dashboard.
        pub logo_url: pulumi_wasm_rust::Output<Option<String>>,
        /// The name of the footer link.
        pub name: pulumi_wasm_rust::Output<String>,
        /// SaaS configuration for the Access Application.
        pub saas_app: pulumi_wasm_rust::Output<Option<crate::types::AccessApplicationSaasApp>>,
        /// Defines the same-site cookie setting for access tokens. Available values: `none`, `lax`, `strict`.
        pub same_site_cookie_attribute: pulumi_wasm_rust::Output<Option<String>>,
        /// List of domains that access will secure. Only present for self_hosted, vnc, and ssh applications. Always includes the value set as `domain`.
        pub self_hosted_domains: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Option to return a 401 status code in service authentication rules on failed requests. Defaults to `false`.
        pub service_auth401_redirect: pulumi_wasm_rust::Output<Option<bool>>,
        /// How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`. Defaults to `24h`.
        pub session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// Option to skip the authorization interstitial when using the CLI. Defaults to `false`.
        pub skip_interstitial: pulumi_wasm_rust::Output<Option<bool>>,
        /// The itags associated with the application.
        pub tags: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The application type. Available values: `app_launcher`, `bookmark`, `biso`, `dash_sso`, `saas`, `self_hosted`, `ssh`, `vnc`, `warp`. Defaults to `self_hosted`.
        pub type_: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn access_application(name: &str, args: AccessApplicationArgs) -> AccessApplicationResult {
        let result = crate::bindings::pulumi::cloudflare::access_application::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::access_application::Args {
                account_id: args.account_id.get_inner(),
                allow_authenticate_via_warp: args.allow_authenticate_via_warp.get_inner(),
                allowed_idps: args.allowed_idps.get_inner(),
                app_launcher_logo_url: args.app_launcher_logo_url.get_inner(),
                app_launcher_visible: args.app_launcher_visible.get_inner(),
                auto_redirect_to_identity: args.auto_redirect_to_identity.get_inner(),
                bg_color: args.bg_color.get_inner(),
                cors_headers: args.cors_headers.get_inner(),
                custom_deny_message: args.custom_deny_message.get_inner(),
                custom_deny_url: args.custom_deny_url.get_inner(),
                custom_non_identity_deny_url: args.custom_non_identity_deny_url.get_inner(),
                custom_pages: args.custom_pages.get_inner(),
                domain: args.domain.get_inner(),
                enable_binding_cookie: args.enable_binding_cookie.get_inner(),
                footer_links: args.footer_links.get_inner(),
                header_bg_color: args.header_bg_color.get_inner(),
                http_only_cookie_attribute: args.http_only_cookie_attribute.get_inner(),
                landing_page_design: args.landing_page_design.get_inner(),
                logo_url: args.logo_url.get_inner(),
                name: args.name.get_inner(),
                saas_app: args.saas_app.get_inner(),
                same_site_cookie_attribute: args.same_site_cookie_attribute.get_inner(),
                self_hosted_domains: args.self_hosted_domains.get_inner(),
                service_auth401_redirect: args.service_auth401_redirect.get_inner(),
                session_duration: args.session_duration.get_inner(),
                skip_interstitial: args.skip_interstitial.get_inner(),
                tags: args.tags.get_inner(),
                type_: args.type_.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        AccessApplicationResult {
            account_id: crate::into_domain(result.account_id),
            allow_authenticate_via_warp: crate::into_domain(result.allow_authenticate_via_warp),
            allowed_idps: crate::into_domain(result.allowed_idps),
            app_launcher_logo_url: crate::into_domain(result.app_launcher_logo_url),
            app_launcher_visible: crate::into_domain(result.app_launcher_visible),
            aud: crate::into_domain(result.aud),
            auto_redirect_to_identity: crate::into_domain(result.auto_redirect_to_identity),
            bg_color: crate::into_domain(result.bg_color),
            cors_headers: crate::into_domain(result.cors_headers),
            custom_deny_message: crate::into_domain(result.custom_deny_message),
            custom_deny_url: crate::into_domain(result.custom_deny_url),
            custom_non_identity_deny_url: crate::into_domain(result.custom_non_identity_deny_url),
            custom_pages: crate::into_domain(result.custom_pages),
            domain: crate::into_domain(result.domain),
            enable_binding_cookie: crate::into_domain(result.enable_binding_cookie),
            footer_links: crate::into_domain(result.footer_links),
            header_bg_color: crate::into_domain(result.header_bg_color),
            http_only_cookie_attribute: crate::into_domain(result.http_only_cookie_attribute),
            landing_page_design: crate::into_domain(result.landing_page_design),
            logo_url: crate::into_domain(result.logo_url),
            name: crate::into_domain(result.name),
            saas_app: crate::into_domain(result.saas_app),
            same_site_cookie_attribute: crate::into_domain(result.same_site_cookie_attribute),
            self_hosted_domains: crate::into_domain(result.self_hosted_domains),
            service_auth401_redirect: crate::into_domain(result.service_auth401_redirect),
            session_duration: crate::into_domain(result.session_duration),
            skip_interstitial: crate::into_domain(result.skip_interstitial),
            tags: crate::into_domain(result.tags),
            type_: crate::into_domain(result.type_),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Cloudflare Access can replace traditional SSH key models with
/// short-lived certificates issued to your users based on the token
/// generated by their Access login.
///
/// > It's required that an `account_id` or `zone_id` is provided and in
///    most cases using either is fine. However, if you're using a scoped
///    access token, you must provide the argument that matches the token's
///    scope. For example, an access token that is scoped to the "example.com"
///    zone needs to use the `zone_id` argument.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// // account level
/// const example = new cloudflare.AccessCaCertificate("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     applicationId: "6cd6cea3-3ef2-4542-9aea-85a0bbcd5414",
/// });
/// // zone level
/// const anotherExample = new cloudflare.AccessCaCertificate("anotherExample", {
///     applicationId: "fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// # account level
/// example = cloudflare.AccessCaCertificate("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     application_id="6cd6cea3-3ef2-4542-9aea-85a0bbcd5414")
/// # zone level
/// another_example = cloudflare.AccessCaCertificate("anotherExample",
///     application_id="fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     // account level
///     var example = new Cloudflare.AccessCaCertificate("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         ApplicationId = "6cd6cea3-3ef2-4542-9aea-85a0bbcd5414",
///     });
///
///     // zone level
///     var anotherExample = new Cloudflare.AccessCaCertificate("anotherExample", new()
///     {
///         ApplicationId = "fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// account level
/// 		_, err := cloudflare.NewAccessCaCertificate(ctx, "example", &cloudflare.AccessCaCertificateArgs{
/// 			AccountId:     pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			ApplicationId: pulumi.String("6cd6cea3-3ef2-4542-9aea-85a0bbcd5414"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// zone level
/// 		_, err = cloudflare.NewAccessCaCertificate(ctx, "anotherExample", &cloudflare.AccessCaCertificateArgs{
/// 			ApplicationId: pulumi.String("fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2"),
/// 			ZoneId:        pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.AccessCaCertificate;
/// import com.pulumi.cloudflare.AccessCaCertificateArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // account level
///         var example = new AccessCaCertificate("example", AccessCaCertificateArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .applicationId("6cd6cea3-3ef2-4542-9aea-85a0bbcd5414")
///             .build());
///
///         // zone level
///         var anotherExample = new AccessCaCertificate("anotherExample", AccessCaCertificateArgs.builder()        
///             .applicationId("fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # account level
///   example:
///     type: cloudflare:AccessCaCertificate
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       applicationId: 6cd6cea3-3ef2-4542-9aea-85a0bbcd5414
///   # zone level
///   anotherExample:
///     type: cloudflare:AccessCaCertificate
///     properties:
///       applicationId: fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// Account level CA certificate import.
///
/// ```sh
/// $ pulumi import cloudflare:index/accessCaCertificate:AccessCaCertificate example account/<account_id>/<application_id>
/// ```
///
/// Zone level CA certificate import.
///
/// ```sh
/// $ pulumi import cloudflare:index/accessCaCertificate:AccessCaCertificate example account/<zone_id>/<application_id>
/// ```
///
pub mod access_ca_certificate {

    pub struct AccessCaCertificateArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The Access Application ID to associate with the CA certificate.
        pub application_id: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct AccessCaCertificateResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The Access Application ID to associate with the CA certificate.
        pub application_id: pulumi_wasm_rust::Output<String>,
        /// Application Audience (AUD) Tag of the CA certificate.
        pub aud: pulumi_wasm_rust::Output<String>,
        /// Cryptographic public key of the generated CA certificate.
        pub public_key: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn access_ca_certificate(
        name: &str,
        args: AccessCaCertificateArgs,
    ) -> AccessCaCertificateResult {
        let result = crate::bindings::pulumi::cloudflare::access_ca_certificate::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::access_ca_certificate::Args {
                account_id: args.account_id.get_inner(),
                application_id: args.application_id.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        AccessCaCertificateResult {
            account_id: crate::into_domain(result.account_id),
            application_id: crate::into_domain(result.application_id),
            aud: crate::into_domain(result.aud),
            public_key: crate::into_domain(result.public_key),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a resource to customize the pages your end users will see
/// when trying to reach applications behind Cloudflare Access.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.AccessCustomPage("example", {
///     customHtml: "<html><body><h1>Forbidden</h1></body></html>",
///     name: "example",
///     type: "forbidden",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.AccessCustomPage("example",
///     custom_html="<html><body><h1>Forbidden</h1></body></html>",
///     name="example",
///     type="forbidden",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.AccessCustomPage("example", new()
///     {
///         CustomHtml = "<html><body><h1>Forbidden</h1></body></html>",
///         Name = "example",
///         Type = "forbidden",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewAccessCustomPage(ctx, "example", &cloudflare.AccessCustomPageArgs{
/// 			CustomHtml: pulumi.String("<html><body><h1>Forbidden</h1></body></html>"),
/// 			Name:       pulumi.String("example"),
/// 			Type:       pulumi.String("forbidden"),
/// 			ZoneId:     pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.AccessCustomPage;
/// import com.pulumi.cloudflare.AccessCustomPageArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new AccessCustomPage("example", AccessCustomPageArgs.builder()        
///             .customHtml("<html><body><h1>Forbidden</h1></body></html>")
///             .name("example")
///             .type("forbidden")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:AccessCustomPage
///     properties:
///       customHtml: <html><body><h1>Forbidden</h1></body></html>
///       name: example
///       type: forbidden
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
pub mod access_custom_page {

    pub struct AccessCustomPageArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Number of apps to display on the custom page.
        pub app_count: pulumi_wasm_rust::Output<Option<i32>>,
        /// Custom HTML to display on the custom page.
        pub custom_html: pulumi_wasm_rust::Output<Option<String>>,
        /// Friendly name of the Access Custom Page configuration.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Type of Access custom page to create. Available values: `identity_denied`, `forbidden`.
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct AccessCustomPageResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Number of apps to display on the custom page.
        pub app_count: pulumi_wasm_rust::Output<Option<i32>>,
        /// Custom HTML to display on the custom page.
        pub custom_html: pulumi_wasm_rust::Output<Option<String>>,
        /// Friendly name of the Access Custom Page configuration.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Type of Access custom page to create. Available values: `identity_denied`, `forbidden`.
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn access_custom_page(name: &str, args: AccessCustomPageArgs) -> AccessCustomPageResult {
        let result = crate::bindings::pulumi::cloudflare::access_custom_page::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::access_custom_page::Args {
                account_id: args.account_id.get_inner(),
                app_count: args.app_count.get_inner(),
                custom_html: args.custom_html.get_inner(),
                name: args.name.get_inner(),
                type_: args.type_.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        AccessCustomPageResult {
            account_id: crate::into_domain(result.account_id),
            app_count: crate::into_domain(result.app_count),
            custom_html: crate::into_domain(result.custom_html),
            name: crate::into_domain(result.name),
            type_: crate::into_domain(result.type_),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare Access Group resource. Access Groups are used
/// in conjunction with Access Policies to restrict access to a
/// particular resource based on group membership.
///
/// > It's required that an `account_id` or `zone_id` is provided and in
///    most cases using either is fine. However, if you're using a scoped
///    access token, you must provide the argument that matches the token's
///    scope. For example, an access token that is scoped to the "example.com"
///    zone needs to use the `zone_id` argument.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// // Allowing access to `test@example.com` email address only
/// const exampleAccessGroup = new cloudflare.AccessGroup("exampleAccessGroup", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "staging group",
///     includes: [{
///         emails: ["test@example.com"],
///     }],
/// });
/// // Allowing `test@example.com` to access but only when coming from a
/// // specific IP.
/// const exampleIndex_accessGroupAccessGroup = new cloudflare.AccessGroup("exampleIndex/accessGroupAccessGroup", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "staging group",
///     includes: [{
///         emails: ["test@example.com"],
///     }],
///     requires: [{
///         ips: [_var.office_ip],
///     }],
/// });
/// // Allow members of an Azure Group. The ID is the group UUID (id) in Azure.
/// const exampleCloudflareIndex_accessGroupAccessGroup = new cloudflare.AccessGroup("exampleCloudflareIndex/accessGroupAccessGroup", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "test_group",
///     includes: [{
///         azures: [{
///             identityProviderId: "ca298b82-93b5-41bf-bc2d-10493f09b761",
///             ids: ["86773093-5feb-48dd-814b-7ccd3676ff50"],
///         }],
///     }],
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// # Allowing access to `test@example.com` email address only
/// example_access_group = cloudflare.AccessGroup("exampleAccessGroup",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="staging group",
///     includes=[cloudflare.AccessGroupIncludeArgs(
///         emails=["test@example.com"],
///     )])
/// # Allowing `test@example.com` to access but only when coming from a
/// # specific IP.
/// example_index_access_group_access_group = cloudflare.AccessGroup("exampleIndex/accessGroupAccessGroup",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="staging group",
///     includes=[cloudflare.AccessGroupIncludeArgs(
///         emails=["test@example.com"],
///     )],
///     requires=[cloudflare.AccessGroupRequireArgs(
///         ips=[var["office_ip"]],
///     )])
/// # Allow members of an Azure Group. The ID is the group UUID (id) in Azure.
/// example_cloudflare_index_access_group_access_group = cloudflare.AccessGroup("exampleCloudflareIndex/accessGroupAccessGroup",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="test_group",
///     includes=[cloudflare.AccessGroupIncludeArgs(
///         azures=[cloudflare.AccessGroupIncludeAzureArgs(
///             identity_provider_id="ca298b82-93b5-41bf-bc2d-10493f09b761",
///             ids=["86773093-5feb-48dd-814b-7ccd3676ff50"],
///         )],
///     )])
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     // Allowing access to `test@example.com` email address only
///     var exampleAccessGroup = new Cloudflare.AccessGroup("exampleAccessGroup", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "staging group",
///         Includes = new[]
///         {
///             new Cloudflare.Inputs.AccessGroupIncludeArgs
///             {
///                 Emails = new[]
///                 {
///                     "test@example.com",
///                 },
///             },
///         },
///     });
///
///     // Allowing `test@example.com` to access but only when coming from a
///     // specific IP.
///     var exampleIndex_accessGroupAccessGroup = new Cloudflare.AccessGroup("exampleIndex/accessGroupAccessGroup", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "staging group",
///         Includes = new[]
///         {
///             new Cloudflare.Inputs.AccessGroupIncludeArgs
///             {
///                 Emails = new[]
///                 {
///                     "test@example.com",
///                 },
///             },
///         },
///         Requires = new[]
///         {
///             new Cloudflare.Inputs.AccessGroupRequireArgs
///             {
///                 Ips = new[]
///                 {
///                     @var.Office_ip,
///                 },
///             },
///         },
///     });
///
///     // Allow members of an Azure Group. The ID is the group UUID (id) in Azure.
///     var exampleCloudflareIndex_accessGroupAccessGroup = new Cloudflare.AccessGroup("exampleCloudflareIndex/accessGroupAccessGroup", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "test_group",
///         Includes = new[]
///         {
///             new Cloudflare.Inputs.AccessGroupIncludeArgs
///             {
///                 Azures = new[]
///                 {
///                     new Cloudflare.Inputs.AccessGroupIncludeAzureArgs
///                     {
///                         IdentityProviderId = "ca298b82-93b5-41bf-bc2d-10493f09b761",
///                         Ids = new[]
///                         {
///                             "86773093-5feb-48dd-814b-7ccd3676ff50",
///                         },
///                     },
///                 },
///             },
///         },
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// Allowing access to `test@example.com` email address only
/// 		_, err := cloudflare.NewAccessGroup(ctx, "exampleAccessGroup", &cloudflare.AccessGroupArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:      pulumi.String("staging group"),
/// 			Includes: cloudflare.AccessGroupIncludeArray{
/// 				&cloudflare.AccessGroupIncludeArgs{
/// 					Emails: pulumi.StringArray{
/// 						pulumi.String("test@example.com"),
/// 					},
/// 				},
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// Allowing `test@example.com` to access but only when coming from a
/// 		// specific IP.
/// 		_, err = cloudflare.NewAccessGroup(ctx, "exampleIndex/accessGroupAccessGroup", &cloudflare.AccessGroupArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:      pulumi.String("staging group"),
/// 			Includes: cloudflare.AccessGroupIncludeArray{
/// 				&cloudflare.AccessGroupIncludeArgs{
/// 					Emails: pulumi.StringArray{
/// 						pulumi.String("test@example.com"),
/// 					},
/// 				},
/// 			},
/// 			Requires: cloudflare.AccessGroupRequireArray{
/// 				&cloudflare.AccessGroupRequireArgs{
/// 					Ips: pulumi.StringArray{
/// 						_var.Office_ip,
/// 					},
/// 				},
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// Allow members of an Azure Group. The ID is the group UUID (id) in Azure.
/// 		_, err = cloudflare.NewAccessGroup(ctx, "exampleCloudflareIndex/accessGroupAccessGroup", &cloudflare.AccessGroupArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:      pulumi.String("test_group"),
/// 			Includes: cloudflare.AccessGroupIncludeArray{
/// 				&cloudflare.AccessGroupIncludeArgs{
/// 					Azures: cloudflare.AccessGroupIncludeAzureArray{
/// 						&cloudflare.AccessGroupIncludeAzureArgs{
/// 							IdentityProviderId: pulumi.String("ca298b82-93b5-41bf-bc2d-10493f09b761"),
/// 							Ids: pulumi.StringArray{
/// 								pulumi.String("86773093-5feb-48dd-814b-7ccd3676ff50"),
/// 							},
/// 						},
/// 					},
/// 				},
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.AccessGroup;
/// import com.pulumi.cloudflare.AccessGroupArgs;
/// import com.pulumi.cloudflare.inputs.AccessGroupIncludeArgs;
/// import com.pulumi.cloudflare.inputs.AccessGroupRequireArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // Allowing access to `test@example.com` email address only
///         var exampleAccessGroup = new AccessGroup("exampleAccessGroup", AccessGroupArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("staging group")
///             .includes(AccessGroupIncludeArgs.builder()
///                 .emails("test@example.com")
///                 .build())
///             .build());
///
///         // Allowing `test@example.com` to access but only when coming from a
///         // specific IP.
///         var exampleIndex_accessGroupAccessGroup = new AccessGroup("exampleIndex/accessGroupAccessGroup", AccessGroupArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("staging group")
///             .includes(AccessGroupIncludeArgs.builder()
///                 .emails("test@example.com")
///                 .build())
///             .requires(AccessGroupRequireArgs.builder()
///                 .ips(var_.office_ip())
///                 .build())
///             .build());
///
///         // Allow members of an Azure Group. The ID is the group UUID (id) in Azure.
///         var exampleCloudflareIndex_accessGroupAccessGroup = new AccessGroup("exampleCloudflareIndex/accessGroupAccessGroup", AccessGroupArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("test_group")
///             .includes(AccessGroupIncludeArgs.builder()
///                 .azures(AccessGroupIncludeAzureArgs.builder()
///                     .identityProviderId("ca298b82-93b5-41bf-bc2d-10493f09b761")
///                     .ids("86773093-5feb-48dd-814b-7ccd3676ff50")
///                     .build())
///                 .build())
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # Allowing access to `test@example.com` email address only
///   exampleAccessGroup:
///     type: cloudflare:AccessGroup
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       name: staging group
///       includes:
///         - emails:
///             - test@example.com
///   # Allowing `test@example.com` to access but only when coming from a
///   # specific IP.
///   exampleIndex/accessGroupAccessGroup:
///     type: cloudflare:AccessGroup
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       name: staging group
///       includes:
///         - emails:
///             - test@example.com
///       requires:
///         - ips:
///             - ${var.office_ip}
///   # Allow members of an Azure Group. The ID is the group UUID (id) in Azure.
///   exampleCloudflareIndex/accessGroupAccessGroup:
///     type: cloudflare:AccessGroup
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       name: test_group
///       includes:
///         - azures:
///             - identityProviderId: ca298b82-93b5-41bf-bc2d-10493f09b761
///               ids:
///                 - 86773093-5feb-48dd-814b-7ccd3676ff50
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/accessGroup:AccessGroup example <account_id>/<group_id>
/// ```
///
pub mod access_group {

    pub struct AccessGroupArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        pub excludes: pulumi_wasm_rust::Output<Option<Vec<crate::types::AccessGroupExclude>>>,
        pub includes: pulumi_wasm_rust::Output<Vec<crate::types::AccessGroupInclude>>,
        pub name: pulumi_wasm_rust::Output<String>,
        pub requires: pulumi_wasm_rust::Output<Option<Vec<crate::types::AccessGroupRequire>>>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct AccessGroupResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        pub excludes: pulumi_wasm_rust::Output<Option<Vec<crate::types::AccessGroupExclude>>>,
        pub includes: pulumi_wasm_rust::Output<Vec<crate::types::AccessGroupInclude>>,
        pub name: pulumi_wasm_rust::Output<String>,
        pub requires: pulumi_wasm_rust::Output<Option<Vec<crate::types::AccessGroupRequire>>>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn access_group(name: &str, args: AccessGroupArgs) -> AccessGroupResult {
        let result = crate::bindings::pulumi::cloudflare::access_group::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::access_group::Args {
                account_id: args.account_id.get_inner(),
                excludes: args.excludes.get_inner(),
                includes: args.includes.get_inner(),
                name: args.name.get_inner(),
                requires: args.requires.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        AccessGroupResult {
            account_id: crate::into_domain(result.account_id),
            excludes: crate::into_domain(result.excludes),
            includes: crate::into_domain(result.includes),
            name: crate::into_domain(result.name),
            requires: crate::into_domain(result.requires),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare Access Identity Provider resource. Identity
/// Providers are used as an authentication or authorisation source
/// within Access.
///
/// > It's required that an `account_id` or `zone_id` is provided and in
///    most cases using either is fine. However, if you're using a scoped
///    access token, you must provide the argument that matches the token's
///    scope. For example, an access token that is scoped to the "example.com"
///    zone needs to use the `zone_id` argument.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// // one time pin
/// const pinLogin = new cloudflare.AccessIdentityProvider("pinLogin", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "PIN login",
///     type: "onetimepin",
/// });
/// // oauth
/// const githubOauth = new cloudflare.AccessIdentityProvider("githubOauth", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     configs: [{
///         clientId: "example",
///         clientSecret: "secret_key",
///     }],
///     name: "GitHub OAuth",
///     type: "github",
/// });
/// // saml
/// const jumpcloudSaml = new cloudflare.AccessIdentityProvider("jumpcloudSaml", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     configs: [{
///         attributes: [
///             "email",
///             "username",
///         ],
///         idpPublicCert: `MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg
/// uTnQyuOqPuHbnN83d/2l1NSYKCbHt24o
/// `,
///         issuerUrl: "jumpcloud",
///         signRequest: false,
///         ssoTargetUrl: "https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess",
///     }],
///     name: "JumpCloud SAML",
///     type: "saml",
/// });
/// // okta
/// const okta = new cloudflare.AccessIdentityProvider("okta", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     configs: [{
///         apiToken: "okta_api_token",
///         clientId: "example",
///         clientSecret: "secret_key",
///         oktaAccount: "https://example.com",
///     }],
///     name: "Okta",
///     type: "okta",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// # one time pin
/// pin_login = cloudflare.AccessIdentityProvider("pinLogin",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="PIN login",
///     type="onetimepin")
/// # oauth
/// github_oauth = cloudflare.AccessIdentityProvider("githubOauth",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     configs=[cloudflare.AccessIdentityProviderConfigArgs(
///         client_id="example",
///         client_secret="secret_key",
///     )],
///     name="GitHub OAuth",
///     type="github")
/// # saml
/// jumpcloud_saml = cloudflare.AccessIdentityProvider("jumpcloudSaml",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     configs=[cloudflare.AccessIdentityProviderConfigArgs(
///         attributes=[
///             "email",
///             "username",
///         ],
///         idp_public_cert="""MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg
/// uTnQyuOqPuHbnN83d/2l1NSYKCbHt24o
/// """,
///         issuer_url="jumpcloud",
///         sign_request=False,
///         sso_target_url="https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess",
///     )],
///     name="JumpCloud SAML",
///     type="saml")
/// # okta
/// okta = cloudflare.AccessIdentityProvider("okta",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     configs=[cloudflare.AccessIdentityProviderConfigArgs(
///         api_token="okta_api_token",
///         client_id="example",
///         client_secret="secret_key",
///         okta_account="https://example.com",
///     )],
///     name="Okta",
///     type="okta")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     // one time pin
///     var pinLogin = new Cloudflare.AccessIdentityProvider("pinLogin", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "PIN login",
///         Type = "onetimepin",
///     });
///
///     // oauth
///     var githubOauth = new Cloudflare.AccessIdentityProvider("githubOauth", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Configs = new[]
///         {
///             new Cloudflare.Inputs.AccessIdentityProviderConfigArgs
///             {
///                 ClientId = "example",
///                 ClientSecret = "secret_key",
///             },
///         },
///         Name = "GitHub OAuth",
///         Type = "github",
///     });
///
///     // saml
///     var jumpcloudSaml = new Cloudflare.AccessIdentityProvider("jumpcloudSaml", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Configs = new[]
///         {
///             new Cloudflare.Inputs.AccessIdentityProviderConfigArgs
///             {
///                 Attributes = new[]
///                 {
///                     "email",
///                     "username",
///                 },
///                 IdpPublicCert = @"MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg
/// uTnQyuOqPuHbnN83d/2l1NSYKCbHt24o
/// ",
///                 IssuerUrl = "jumpcloud",
///                 SignRequest = false,
///                 SsoTargetUrl = "https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess",
///             },
///         },
///         Name = "JumpCloud SAML",
///         Type = "saml",
///     });
///
///     // okta
///     var okta = new Cloudflare.AccessIdentityProvider("okta", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Configs = new[]
///         {
///             new Cloudflare.Inputs.AccessIdentityProviderConfigArgs
///             {
///                 ApiToken = "okta_api_token",
///                 ClientId = "example",
///                 ClientSecret = "secret_key",
///                 OktaAccount = "https://example.com",
///             },
///         },
///         Name = "Okta",
///         Type = "okta",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// one time pin
/// 		_, err := cloudflare.NewAccessIdentityProvider(ctx, "pinLogin", &cloudflare.AccessIdentityProviderArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:      pulumi.String("PIN login"),
/// 			Type:      pulumi.String("onetimepin"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// oauth
/// 		_, err = cloudflare.NewAccessIdentityProvider(ctx, "githubOauth", &cloudflare.AccessIdentityProviderArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Configs: cloudflare.AccessIdentityProviderConfigArray{
/// 				&cloudflare.AccessIdentityProviderConfigArgs{
/// 					ClientId:     pulumi.String("example"),
/// 					ClientSecret: pulumi.String("secret_key"),
/// 				},
/// 			},
/// 			Name: pulumi.String("GitHub OAuth"),
/// 			Type: pulumi.String("github"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// saml
/// 		_, err = cloudflare.NewAccessIdentityProvider(ctx, "jumpcloudSaml", &cloudflare.AccessIdentityProviderArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Configs: cloudflare.AccessIdentityProviderConfigArray{
/// 				&cloudflare.AccessIdentityProviderConfigArgs{
/// 					Attributes: pulumi.StringArray{
/// 						pulumi.String("email"),
/// 						pulumi.String("username"),
/// 					},
/// 					IdpPublicCert: pulumi.String("MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o\n"),
/// 					IssuerUrl:     pulumi.String("jumpcloud"),
/// 					SignRequest:   pulumi.Bool(false),
/// 					SsoTargetUrl:  pulumi.String("https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess"),
/// 				},
/// 			},
/// 			Name: pulumi.String("JumpCloud SAML"),
/// 			Type: pulumi.String("saml"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// okta
/// 		_, err = cloudflare.NewAccessIdentityProvider(ctx, "okta", &cloudflare.AccessIdentityProviderArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Configs: cloudflare.AccessIdentityProviderConfigArray{
/// 				&cloudflare.AccessIdentityProviderConfigArgs{
/// 					ApiToken:     pulumi.String("okta_api_token"),
/// 					ClientId:     pulumi.String("example"),
/// 					ClientSecret: pulumi.String("secret_key"),
/// 					OktaAccount:  pulumi.String("https://example.com"),
/// 				},
/// 			},
/// 			Name: pulumi.String("Okta"),
/// 			Type: pulumi.String("okta"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.AccessIdentityProvider;
/// import com.pulumi.cloudflare.AccessIdentityProviderArgs;
/// import com.pulumi.cloudflare.inputs.AccessIdentityProviderConfigArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // one time pin
///         var pinLogin = new AccessIdentityProvider("pinLogin", AccessIdentityProviderArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("PIN login")
///             .type("onetimepin")
///             .build());
///
///         // oauth
///         var githubOauth = new AccessIdentityProvider("githubOauth", AccessIdentityProviderArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .configs(AccessIdentityProviderConfigArgs.builder()
///                 .clientId("example")
///                 .clientSecret("secret_key")
///                 .build())
///             .name("GitHub OAuth")
///             .type("github")
///             .build());
///
///         // saml
///         var jumpcloudSaml = new AccessIdentityProvider("jumpcloudSaml", AccessIdentityProviderArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .configs(AccessIdentityProviderConfigArgs.builder()
///                 .attributes(                
///                     "email",
///                     "username")
///                 .idpPublicCert("""
/// MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg
/// uTnQyuOqPuHbnN83d/2l1NSYKCbHt24o
///                 """)
///                 .issuerUrl("jumpcloud")
///                 .signRequest(false)
///                 .ssoTargetUrl("https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess")
///                 .build())
///             .name("JumpCloud SAML")
///             .type("saml")
///             .build());
///
///         // okta
///         var okta = new AccessIdentityProvider("okta", AccessIdentityProviderArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .configs(AccessIdentityProviderConfigArgs.builder()
///                 .apiToken("okta_api_token")
///                 .clientId("example")
///                 .clientSecret("secret_key")
///                 .oktaAccount("https://example.com")
///                 .build())
///             .name("Okta")
///             .type("okta")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # one time pin
///   pinLogin:
///     type: cloudflare:AccessIdentityProvider
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       name: PIN login
///       type: onetimepin
///   # oauth
///   githubOauth:
///     type: cloudflare:AccessIdentityProvider
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       configs:
///         - clientId: example
///           clientSecret: secret_key
///       name: GitHub OAuth
///       type: github
///   # saml
///   jumpcloudSaml:
///     type: cloudflare:AccessIdentityProvider
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       configs:
///         - attributes:
///             - email
///             - username
///           idpPublicCert: |
///             MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg
///             uTnQyuOqPuHbnN83d/2l1NSYKCbHt24o
///           issuerUrl: jumpcloud
///           signRequest: false
///           ssoTargetUrl: https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess
///       name: JumpCloud SAML
///       type: saml
///   # okta
///   okta:
///     type: cloudflare:AccessIdentityProvider
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       configs:
///         - apiToken: okta_api_token
///           clientId: example
///           clientSecret: secret_key
///           oktaAccount: https://example.com
///       name: Okta
///       type: okta
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/accessIdentityProvider:AccessIdentityProvider example <account_id>/<identity_provider_id>
/// ```
///
pub mod access_identity_provider {

    pub struct AccessIdentityProviderArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Provider configuration from the [developer documentation](https://developers.cloudflare.com/access/configuring-identity-providers/).
        pub configs:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::AccessIdentityProviderConfig>>>,
        /// Friendly name of the Access Identity Provider configuration.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Configuration for SCIM settings for a given IDP.
        pub scim_configs:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::AccessIdentityProviderScimConfig>>>,
        /// The provider type to use. Available values: `azureAD`, `centrify`, `facebook`, `github`, `google`, `google-apps`, `linkedin`, `oidc`, `okta`, `onelogin`, `onetimepin`, `pingone`, `saml`, `yandex`.
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct AccessIdentityProviderResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Provider configuration from the [developer documentation](https://developers.cloudflare.com/access/configuring-identity-providers/).
        pub configs: pulumi_wasm_rust::Output<Vec<crate::types::AccessIdentityProviderConfig>>,
        /// Friendly name of the Access Identity Provider configuration.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Configuration for SCIM settings for a given IDP.
        pub scim_configs:
            pulumi_wasm_rust::Output<Vec<crate::types::AccessIdentityProviderScimConfig>>,
        /// The provider type to use. Available values: `azureAD`, `centrify`, `facebook`, `github`, `google`, `google-apps`, `linkedin`, `oidc`, `okta`, `onelogin`, `onetimepin`, `pingone`, `saml`, `yandex`.
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn access_identity_provider(
        name: &str,
        args: AccessIdentityProviderArgs,
    ) -> AccessIdentityProviderResult {
        let result = crate::bindings::pulumi::cloudflare::access_identity_provider::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::access_identity_provider::Args {
                account_id: args.account_id.get_inner(),
                configs: args.configs.get_inner(),
                name: args.name.get_inner(),
                scim_configs: args.scim_configs.get_inner(),
                type_: args.type_.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        AccessIdentityProviderResult {
            account_id: crate::into_domain(result.account_id),
            configs: crate::into_domain(result.configs),
            name: crate::into_domain(result.name),
            scim_configs: crate::into_domain(result.scim_configs),
            type_: crate::into_domain(result.type_),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Access Keys Configuration defines the rotation policy for the keys
/// that access will use to sign data.
pub mod access_keys_configuration {

    pub struct AccessKeysConfigurationArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Number of days to trigger a rotation of the keys.
        pub key_rotation_interval_days: pulumi_wasm_rust::Output<Option<i32>>,
    }

    pub struct AccessKeysConfigurationResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Number of days to trigger a rotation of the keys.
        pub key_rotation_interval_days: pulumi_wasm_rust::Output<i32>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn access_keys_configuration(
        name: &str,
        args: AccessKeysConfigurationArgs,
    ) -> AccessKeysConfigurationResult {
        let result = crate::bindings::pulumi::cloudflare::access_keys_configuration::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::access_keys_configuration::Args {
                account_id: args.account_id.get_inner(),
                key_rotation_interval_days: args.key_rotation_interval_days.get_inner(),
            },
        );

        AccessKeysConfigurationResult {
            account_id: crate::into_domain(result.account_id),
            key_rotation_interval_days: crate::into_domain(result.key_rotation_interval_days),
        }
    }
}

/// Provides a Cloudflare Access Mutual TLS Certificate resource.
/// Mutual TLS authentication ensures that the traffic is secure and
/// trusted in both directions between a client and server and can be
///  used with Access to only allows requests from devices with a
///  corresponding client certificate.
///
/// > It's required that an `account_id` or `zone_id` is provided and in
///    most cases using either is fine. However, if you're using a scoped
///    access token, you must provide the argument that matches the token's
///    scope. For example, an access token that is scoped to the "example.com"
///    zone needs to use the `zone_id` argument.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const myCert = new cloudflare.AccessMutualTlsCertificate("myCert", {
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
///     name: "My Root Cert",
///     certificate: _var.ca_pem,
///     associatedHostnames: ["staging.example.com"],
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// my_cert = cloudflare.AccessMutualTlsCertificate("myCert",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711",
///     name="My Root Cert",
///     certificate=var["ca_pem"],
///     associated_hostnames=["staging.example.com"])
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var myCert = new Cloudflare.AccessMutualTlsCertificate("myCert", new()
///     {
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///         Name = "My Root Cert",
///         Certificate = @var.Ca_pem,
///         AssociatedHostnames = new[]
///         {
///             "staging.example.com",
///         },
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewAccessMutualTlsCertificate(ctx, "myCert", &cloudflare.AccessMutualTlsCertificateArgs{
/// 			ZoneId:      pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 			Name:        pulumi.String("My Root Cert"),
/// 			Certificate: pulumi.Any(_var.Ca_pem),
/// 			AssociatedHostnames: pulumi.StringArray{
/// 				pulumi.String("staging.example.com"),
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.AccessMutualTlsCertificate;
/// import com.pulumi.cloudflare.AccessMutualTlsCertificateArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var myCert = new AccessMutualTlsCertificate("myCert", AccessMutualTlsCertificateArgs.builder()        
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .name("My Root Cert")
///             .certificate(var_.ca_pem())
///             .associatedHostnames("staging.example.com")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   myCert:
///     type: cloudflare:AccessMutualTlsCertificate
///     properties:
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///       name: My Root Cert
///       certificate: ${var.ca_pem}
///       associatedHostnames:
///         - staging.example.com
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// Account level import.
///
/// ```sh
/// $ pulumi import cloudflare:index/accessMutualTlsCertificate:AccessMutualTlsCertificate example account/<account_id>/<mutual_tls_certificate_id>
/// ```
///
/// Zone level import.
///
/// ```sh
/// $ pulumi import cloudflare:index/accessMutualTlsCertificate:AccessMutualTlsCertificate example zone/<zone_id>/<mutual_tls_certificate_id>
/// ```
///
pub mod access_mutual_tls_certificate {

    pub struct AccessMutualTlsCertificateArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The hostnames that will be prompted for this certificate.
        pub associated_hostnames: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The Root CA for your certificates.
        pub certificate: pulumi_wasm_rust::Output<Option<String>>,
        /// The name of the certificate.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct AccessMutualTlsCertificateResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The hostnames that will be prompted for this certificate.
        pub associated_hostnames: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The Root CA for your certificates.
        pub certificate: pulumi_wasm_rust::Output<Option<String>>,
        pub fingerprint: pulumi_wasm_rust::Output<String>,
        /// The name of the certificate.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn access_mutual_tls_certificate(
        name: &str,
        args: AccessMutualTlsCertificateArgs,
    ) -> AccessMutualTlsCertificateResult {
        let result = crate::bindings::pulumi::cloudflare::access_mutual_tls_certificate::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::access_mutual_tls_certificate::Args {
                account_id: args.account_id.get_inner(),
                associated_hostnames: args.associated_hostnames.get_inner(),
                certificate: args.certificate.get_inner(),
                name: args.name.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        AccessMutualTlsCertificateResult {
            account_id: crate::into_domain(result.account_id),
            associated_hostnames: crate::into_domain(result.associated_hostnames),
            certificate: crate::into_domain(result.certificate),
            fingerprint: crate::into_domain(result.fingerprint),
            name: crate::into_domain(result.name),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare Access Mutual TLS Certificate Settings resource.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.AccessMutualTlsHostnameSettings("example", {
///     settings: [{
///         chinaNetwork: false,
///         clientCertificateForwarding: true,
///         hostname: "example.com",
///     }],
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.AccessMutualTlsHostnameSettings("example",
///     settings=[cloudflare.AccessMutualTlsHostnameSettingsSettingArgs(
///         china_network=False,
///         client_certificate_forwarding=True,
///         hostname="example.com",
///     )],
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.AccessMutualTlsHostnameSettings("example", new()
///     {
///         Settings = new[]
///         {
///             new Cloudflare.Inputs.AccessMutualTlsHostnameSettingsSettingArgs
///             {
///                 ChinaNetwork = false,
///                 ClientCertificateForwarding = true,
///                 Hostname = "example.com",
///             },
///         },
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewAccessMutualTlsHostnameSettings(ctx, "example", &cloudflare.AccessMutualTlsHostnameSettingsArgs{
/// 			Settings: cloudflare.AccessMutualTlsHostnameSettingsSettingArray{
/// 				&cloudflare.AccessMutualTlsHostnameSettingsSettingArgs{
/// 					ChinaNetwork:                pulumi.Bool(false),
/// 					ClientCertificateForwarding: pulumi.Bool(true),
/// 					Hostname:                    pulumi.String("example.com"),
/// 				},
/// 			},
/// 			ZoneId: pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.AccessMutualTlsHostnameSettings;
/// import com.pulumi.cloudflare.AccessMutualTlsHostnameSettingsArgs;
/// import com.pulumi.cloudflare.inputs.AccessMutualTlsHostnameSettingsSettingArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new AccessMutualTlsHostnameSettings("example", AccessMutualTlsHostnameSettingsArgs.builder()        
///             .settings(AccessMutualTlsHostnameSettingsSettingArgs.builder()
///                 .chinaNetwork(false)
///                 .clientCertificateForwarding(true)
///                 .hostname("example.com")
///                 .build())
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:AccessMutualTlsHostnameSettings
///     properties:
///       settings:
///         - chinaNetwork: false
///           clientCertificateForwarding: true
///           hostname: example.com
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// Account level mTLS hostname settings import.
///
/// ```sh
/// $ pulumi import cloudflare:index/accessMutualTlsHostnameSettings:AccessMutualTlsHostnameSettings example account/<account_id>
/// ```
///
/// Zone level mTLS hostname settings import.
///
/// ```sh
/// $ pulumi import cloudflare:index/accessMutualTlsHostnameSettings:AccessMutualTlsHostnameSettings example zone/<zone_id>
/// ```
///
pub mod access_mutual_tls_hostname_settings {

    pub struct AccessMutualTlsHostnameSettingsArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        pub settings: pulumi_wasm_rust::Output<
            Option<Vec<crate::types::AccessMutualTlsHostnameSettingsSetting>>,
        >,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct AccessMutualTlsHostnameSettingsResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        pub settings: pulumi_wasm_rust::Output<
            Option<Vec<crate::types::AccessMutualTlsHostnameSettingsSetting>>,
        >,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn access_mutual_tls_hostname_settings(
        name: &str,
        args: AccessMutualTlsHostnameSettingsArgs,
    ) -> AccessMutualTlsHostnameSettingsResult {
        let result =
            crate::bindings::pulumi::cloudflare::access_mutual_tls_hostname_settings::invoke(
                name,
                &crate::bindings::pulumi::cloudflare::access_mutual_tls_hostname_settings::Args {
                    account_id: args.account_id.get_inner(),
                    settings: args.settings.get_inner(),
                    zone_id: args.zone_id.get_inner(),
                },
            );

        AccessMutualTlsHostnameSettingsResult {
            account_id: crate::into_domain(result.account_id),
            settings: crate::into_domain(result.settings),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// A Zero Trust organization defines the user login experience.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.AccessOrganization("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     authDomain: "example.cloudflareaccess.com",
///     autoRedirectToIdentity: false,
///     isUiReadOnly: false,
///     loginDesigns: [{
///         backgroundColor: "#ffffff",
///         footerText: "My footer text",
///         headerText: "My header text",
///         logoPath: "https://example.com/logo.png",
///         textColor: "#000000",
///     }],
///     name: "example.cloudflareaccess.com",
///     userSeatExpirationInactiveTime: "720h",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.AccessOrganization("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     auth_domain="example.cloudflareaccess.com",
///     auto_redirect_to_identity=False,
///     is_ui_read_only=False,
///     login_designs=[cloudflare.AccessOrganizationLoginDesignArgs(
///         background_color="#ffffff",
///         footer_text="My footer text",
///         header_text="My header text",
///         logo_path="https://example.com/logo.png",
///         text_color="#000000",
///     )],
///     name="example.cloudflareaccess.com",
///     user_seat_expiration_inactive_time="720h")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.AccessOrganization("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         AuthDomain = "example.cloudflareaccess.com",
///         AutoRedirectToIdentity = false,
///         IsUiReadOnly = false,
///         LoginDesigns = new[]
///         {
///             new Cloudflare.Inputs.AccessOrganizationLoginDesignArgs
///             {
///                 BackgroundColor = "#ffffff",
///                 FooterText = "My footer text",
///                 HeaderText = "My header text",
///                 LogoPath = "https://example.com/logo.png",
///                 TextColor = "#000000",
///             },
///         },
///         Name = "example.cloudflareaccess.com",
///         UserSeatExpirationInactiveTime = "720h",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewAccessOrganization(ctx, "example", &cloudflare.AccessOrganizationArgs{
/// 			AccountId:              pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			AuthDomain:             pulumi.String("example.cloudflareaccess.com"),
/// 			AutoRedirectToIdentity: pulumi.Bool(false),
/// 			IsUiReadOnly:           pulumi.Bool(false),
/// 			LoginDesigns: cloudflare.AccessOrganizationLoginDesignArray{
/// 				&cloudflare.AccessOrganizationLoginDesignArgs{
/// 					BackgroundColor: pulumi.String("#ffffff"),
/// 					FooterText:      pulumi.String("My footer text"),
/// 					HeaderText:      pulumi.String("My header text"),
/// 					LogoPath:        pulumi.String("https://example.com/logo.png"),
/// 					TextColor:       pulumi.String("#000000"),
/// 				},
/// 			},
/// 			Name:                           pulumi.String("example.cloudflareaccess.com"),
/// 			UserSeatExpirationInactiveTime: pulumi.String("720h"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.AccessOrganization;
/// import com.pulumi.cloudflare.AccessOrganizationArgs;
/// import com.pulumi.cloudflare.inputs.AccessOrganizationLoginDesignArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new AccessOrganization("example", AccessOrganizationArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .authDomain("example.cloudflareaccess.com")
///             .autoRedirectToIdentity(false)
///             .isUiReadOnly(false)
///             .loginDesigns(AccessOrganizationLoginDesignArgs.builder()
///                 .backgroundColor("#ffffff")
///                 .footerText("My footer text")
///                 .headerText("My header text")
///                 .logoPath("https://example.com/logo.png")
///                 .textColor("#000000")
///                 .build())
///             .name("example.cloudflareaccess.com")
///             .userSeatExpirationInactiveTime("720h")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:AccessOrganization
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       authDomain: example.cloudflareaccess.com
///       autoRedirectToIdentity: false
///       isUiReadOnly: false
///       loginDesigns:
///         - backgroundColor: '#ffffff'
///           footerText: My footer text
///           headerText: My header text
///           logoPath: https://example.com/logo.png
///           textColor: '#000000'
///       name: example.cloudflareaccess.com
///       userSeatExpirationInactiveTime: 720h
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/accessOrganization:AccessOrganization example <account_id>
/// ```
///
pub mod access_organization {

    pub struct AccessOrganizationArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// When set to true, users can authenticate via WARP for any application in your organization. Application settings will take precedence over this value.
        pub allow_authenticate_via_warp: pulumi_wasm_rust::Output<Option<bool>>,
        /// The unique subdomain assigned to your Zero Trust organization.
        pub auth_domain: pulumi_wasm_rust::Output<String>,
        /// When set to true, users skip the identity provider selection step during login.
        pub auto_redirect_to_identity: pulumi_wasm_rust::Output<Option<bool>>,
        /// Custom pages for your Zero Trust organization.
        pub custom_pages:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::AccessOrganizationCustomPage>>>,
        /// When set to true, this will disable all editing of Access resources via the Zero Trust Dashboard.
        pub is_ui_read_only: pulumi_wasm_rust::Output<Option<bool>>,
        pub login_designs:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::AccessOrganizationLoginDesign>>>,
        /// The name of your Zero Trust organization.
        pub name: pulumi_wasm_rust::Output<Option<String>>,
        /// How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.
        pub session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// A description of the reason why the UI read only field is being toggled.
        pub ui_read_only_toggle_reason: pulumi_wasm_rust::Output<Option<String>>,
        /// The amount of time a user seat is inactive before it expires. When the user seat exceeds the set time of inactivity, the user is removed as an active seat and no longer counts against your Teams seat count. Must be in the format `300ms` or `2h45m`.
        pub user_seat_expiration_inactive_time: pulumi_wasm_rust::Output<Option<String>>,
        /// The amount of time that tokens issued for applications will be valid. Must be in the format 30m or 2h45m. Valid time units are: m, h.
        pub warp_auth_session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct AccessOrganizationResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// When set to true, users can authenticate via WARP for any application in your organization. Application settings will take precedence over this value.
        pub allow_authenticate_via_warp: pulumi_wasm_rust::Output<Option<bool>>,
        /// The unique subdomain assigned to your Zero Trust organization.
        pub auth_domain: pulumi_wasm_rust::Output<String>,
        /// When set to true, users skip the identity provider selection step during login.
        pub auto_redirect_to_identity: pulumi_wasm_rust::Output<Option<bool>>,
        /// Custom pages for your Zero Trust organization.
        pub custom_pages:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::AccessOrganizationCustomPage>>>,
        /// When set to true, this will disable all editing of Access resources via the Zero Trust Dashboard.
        pub is_ui_read_only: pulumi_wasm_rust::Output<Option<bool>>,
        pub login_designs:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::AccessOrganizationLoginDesign>>>,
        /// The name of your Zero Trust organization.
        pub name: pulumi_wasm_rust::Output<Option<String>>,
        /// How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.
        pub session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// A description of the reason why the UI read only field is being toggled.
        pub ui_read_only_toggle_reason: pulumi_wasm_rust::Output<Option<String>>,
        /// The amount of time a user seat is inactive before it expires. When the user seat exceeds the set time of inactivity, the user is removed as an active seat and no longer counts against your Teams seat count. Must be in the format `300ms` or `2h45m`.
        pub user_seat_expiration_inactive_time: pulumi_wasm_rust::Output<Option<String>>,
        /// The amount of time that tokens issued for applications will be valid. Must be in the format 30m or 2h45m. Valid time units are: m, h.
        pub warp_auth_session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn access_organization(
        name: &str,
        args: AccessOrganizationArgs,
    ) -> AccessOrganizationResult {
        let result = crate::bindings::pulumi::cloudflare::access_organization::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::access_organization::Args {
                account_id: args.account_id.get_inner(),
                allow_authenticate_via_warp: args.allow_authenticate_via_warp.get_inner(),
                auth_domain: args.auth_domain.get_inner(),
                auto_redirect_to_identity: args.auto_redirect_to_identity.get_inner(),
                custom_pages: args.custom_pages.get_inner(),
                is_ui_read_only: args.is_ui_read_only.get_inner(),
                login_designs: args.login_designs.get_inner(),
                name: args.name.get_inner(),
                session_duration: args.session_duration.get_inner(),
                ui_read_only_toggle_reason: args.ui_read_only_toggle_reason.get_inner(),
                user_seat_expiration_inactive_time: args
                    .user_seat_expiration_inactive_time
                    .get_inner(),
                warp_auth_session_duration: args.warp_auth_session_duration.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        AccessOrganizationResult {
            account_id: crate::into_domain(result.account_id),
            allow_authenticate_via_warp: crate::into_domain(result.allow_authenticate_via_warp),
            auth_domain: crate::into_domain(result.auth_domain),
            auto_redirect_to_identity: crate::into_domain(result.auto_redirect_to_identity),
            custom_pages: crate::into_domain(result.custom_pages),
            is_ui_read_only: crate::into_domain(result.is_ui_read_only),
            login_designs: crate::into_domain(result.login_designs),
            name: crate::into_domain(result.name),
            session_duration: crate::into_domain(result.session_duration),
            ui_read_only_toggle_reason: crate::into_domain(result.ui_read_only_toggle_reason),
            user_seat_expiration_inactive_time: crate::into_domain(
                result.user_seat_expiration_inactive_time,
            ),
            warp_auth_session_duration: crate::into_domain(result.warp_auth_session_duration),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare Access Policy resource. Access Policies are
/// used in conjunction with Access Applications to restrict access to
/// a particular resource.
///
/// > It's required that an `account_id` or `zone_id` is provided and in
///    most cases using either is fine. However, if you're using a scoped
///    access token, you must provide the argument that matches the token's
///    scope. For example, an access token that is scoped to the "example.com"
///    zone needs to use the `zone_id` argument.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// // Allowing access to `test@example.com` email address only
/// const testPolicyAccessPolicy = new cloudflare.AccessPolicy("testPolicyAccessPolicy", {
///     applicationId: "cb029e245cfdd66dc8d2e570d5dd3322",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
///     name: "staging policy",
///     precedence: 1,
///     decision: "allow",
///     includes: [{
///         emails: ["test@example.com"],
///     }],
///     requires: [{
///         emails: ["test@example.com"],
///     }],
/// });
/// // Allowing `test@example.com` to access but only when coming from a
/// // specific IP.
/// const testPolicyIndex_accessPolicyAccessPolicy = new cloudflare.AccessPolicy("testPolicyIndex/accessPolicyAccessPolicy", {
///     applicationId: "cb029e245cfdd66dc8d2e570d5dd3322",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
///     name: "staging policy",
///     precedence: 1,
///     decision: "allow",
///     includes: [{
///         emails: ["test@example.com"],
///     }],
///     requires: [{
///         ips: [_var.office_ip],
///     }],
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// # Allowing access to `test@example.com` email address only
/// test_policy_access_policy = cloudflare.AccessPolicy("testPolicyAccessPolicy",
///     application_id="cb029e245cfdd66dc8d2e570d5dd3322",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711",
///     name="staging policy",
///     precedence=1,
///     decision="allow",
///     includes=[cloudflare.AccessPolicyIncludeArgs(
///         emails=["test@example.com"],
///     )],
///     requires=[cloudflare.AccessPolicyRequireArgs(
///         emails=["test@example.com"],
///     )])
/// # Allowing `test@example.com` to access but only when coming from a
/// # specific IP.
/// test_policy_index_access_policy_access_policy = cloudflare.AccessPolicy("testPolicyIndex/accessPolicyAccessPolicy",
///     application_id="cb029e245cfdd66dc8d2e570d5dd3322",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711",
///     name="staging policy",
///     precedence=1,
///     decision="allow",
///     includes=[cloudflare.AccessPolicyIncludeArgs(
///         emails=["test@example.com"],
///     )],
///     requires=[cloudflare.AccessPolicyRequireArgs(
///         ips=[var["office_ip"]],
///     )])
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     // Allowing access to `test@example.com` email address only
///     var testPolicyAccessPolicy = new Cloudflare.AccessPolicy("testPolicyAccessPolicy", new()
///     {
///         ApplicationId = "cb029e245cfdd66dc8d2e570d5dd3322",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///         Name = "staging policy",
///         Precedence = 1,
///         Decision = "allow",
///         Includes = new[]
///         {
///             new Cloudflare.Inputs.AccessPolicyIncludeArgs
///             {
///                 Emails = new[]
///                 {
///                     "test@example.com",
///                 },
///             },
///         },
///         Requires = new[]
///         {
///             new Cloudflare.Inputs.AccessPolicyRequireArgs
///             {
///                 Emails = new[]
///                 {
///                     "test@example.com",
///                 },
///             },
///         },
///     });
///
///     // Allowing `test@example.com` to access but only when coming from a
///     // specific IP.
///     var testPolicyIndex_accessPolicyAccessPolicy = new Cloudflare.AccessPolicy("testPolicyIndex/accessPolicyAccessPolicy", new()
///     {
///         ApplicationId = "cb029e245cfdd66dc8d2e570d5dd3322",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///         Name = "staging policy",
///         Precedence = 1,
///         Decision = "allow",
///         Includes = new[]
///         {
///             new Cloudflare.Inputs.AccessPolicyIncludeArgs
///             {
///                 Emails = new[]
///                 {
///                     "test@example.com",
///                 },
///             },
///         },
///         Requires = new[]
///         {
///             new Cloudflare.Inputs.AccessPolicyRequireArgs
///             {
///                 Ips = new[]
///                 {
///                     @var.Office_ip,
///                 },
///             },
///         },
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// Allowing access to `test@example.com` email address only
/// 		_, err := cloudflare.NewAccessPolicy(ctx, "testPolicyAccessPolicy", &cloudflare.AccessPolicyArgs{
/// 			ApplicationId: pulumi.String("cb029e245cfdd66dc8d2e570d5dd3322"),
/// 			ZoneId:        pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 			Name:          pulumi.String("staging policy"),
/// 			Precedence:    pulumi.Int(1),
/// 			Decision:      pulumi.String("allow"),
/// 			Includes: cloudflare.AccessPolicyIncludeArray{
/// 				&cloudflare.AccessPolicyIncludeArgs{
/// 					Emails: pulumi.StringArray{
/// 						pulumi.String("test@example.com"),
/// 					},
/// 				},
/// 			},
/// 			Requires: cloudflare.AccessPolicyRequireArray{
/// 				&cloudflare.AccessPolicyRequireArgs{
/// 					Emails: pulumi.StringArray{
/// 						pulumi.String("test@example.com"),
/// 					},
/// 				},
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// Allowing `test@example.com` to access but only when coming from a
/// 		// specific IP.
/// 		_, err = cloudflare.NewAccessPolicy(ctx, "testPolicyIndex/accessPolicyAccessPolicy", &cloudflare.AccessPolicyArgs{
/// 			ApplicationId: pulumi.String("cb029e245cfdd66dc8d2e570d5dd3322"),
/// 			ZoneId:        pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 			Name:          pulumi.String("staging policy"),
/// 			Precedence:    pulumi.Int(1),
/// 			Decision:      pulumi.String("allow"),
/// 			Includes: cloudflare.AccessPolicyIncludeArray{
/// 				&cloudflare.AccessPolicyIncludeArgs{
/// 					Emails: pulumi.StringArray{
/// 						pulumi.String("test@example.com"),
/// 					},
/// 				},
/// 			},
/// 			Requires: cloudflare.AccessPolicyRequireArray{
/// 				&cloudflare.AccessPolicyRequireArgs{
/// 					Ips: pulumi.StringArray{
/// 						_var.Office_ip,
/// 					},
/// 				},
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.AccessPolicy;
/// import com.pulumi.cloudflare.AccessPolicyArgs;
/// import com.pulumi.cloudflare.inputs.AccessPolicyIncludeArgs;
/// import com.pulumi.cloudflare.inputs.AccessPolicyRequireArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // Allowing access to `test@example.com` email address only
///         var testPolicyAccessPolicy = new AccessPolicy("testPolicyAccessPolicy", AccessPolicyArgs.builder()        
///             .applicationId("cb029e245cfdd66dc8d2e570d5dd3322")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .name("staging policy")
///             .precedence("1")
///             .decision("allow")
///             .includes(AccessPolicyIncludeArgs.builder()
///                 .emails("test@example.com")
///                 .build())
///             .requires(AccessPolicyRequireArgs.builder()
///                 .emails("test@example.com")
///                 .build())
///             .build());
///
///         // Allowing `test@example.com` to access but only when coming from a
///         // specific IP.
///         var testPolicyIndex_accessPolicyAccessPolicy = new AccessPolicy("testPolicyIndex/accessPolicyAccessPolicy", AccessPolicyArgs.builder()        
///             .applicationId("cb029e245cfdd66dc8d2e570d5dd3322")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .name("staging policy")
///             .precedence("1")
///             .decision("allow")
///             .includes(AccessPolicyIncludeArgs.builder()
///                 .emails("test@example.com")
///                 .build())
///             .requires(AccessPolicyRequireArgs.builder()
///                 .ips(var_.office_ip())
///                 .build())
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # Allowing access to `test@example.com` email address only
///   testPolicyAccessPolicy:
///     type: cloudflare:AccessPolicy
///     properties:
///       applicationId: cb029e245cfdd66dc8d2e570d5dd3322
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///       name: staging policy
///       precedence: '1'
///       decision: allow
///       includes:
///         - emails:
///             - test@example.com
///       requires:
///         - emails:
///             - test@example.com
///   # Allowing `test@example.com` to access but only when coming from a
///   # specific IP.
///   testPolicyIndex/accessPolicyAccessPolicy:
///     type: cloudflare:AccessPolicy
///     properties:
///       applicationId: cb029e245cfdd66dc8d2e570d5dd3322
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///       name: staging policy
///       precedence: '1'
///       decision: allow
///       includes:
///         - emails:
///             - test@example.com
///       requires:
///         - ips:
///             - ${var.office_ip}
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// Account level import.
///
/// ```sh
/// $ pulumi import cloudflare:index/accessPolicy:AccessPolicy example account/<account_id>/<application_id>/<policy_id>
/// ```
///
/// Zone level import.
///
/// ```sh
/// $ pulumi import cloudflare:index/accessPolicy:AccessPolicy example zone/<zone_id>/<application_id>/<policy_id>
/// ```
///
pub mod access_policy {

    pub struct AccessPolicyArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The ID of the application the policy is associated with.
        pub application_id: pulumi_wasm_rust::Output<String>,
        pub approval_groups:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::AccessPolicyApprovalGroup>>>,
        pub approval_required: pulumi_wasm_rust::Output<Option<bool>>,
        /// Defines the action Access will take if the policy matches the user. Available values: `allow`, `deny`, `non_identity`, `bypass`.
        pub decision: pulumi_wasm_rust::Output<String>,
        /// A series of access conditions, see Access Groups.
        pub excludes: pulumi_wasm_rust::Output<Option<Vec<crate::types::AccessPolicyExclude>>>,
        /// A series of access conditions, see Access Groups.
        pub includes: pulumi_wasm_rust::Output<Vec<crate::types::AccessPolicyInclude>>,
        /// Require this application to be served in an isolated browser for users matching this policy.
        pub isolation_required: pulumi_wasm_rust::Output<Option<bool>>,
        /// Friendly name of the Access Policy.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The unique precedence for policies on a single application.
        pub precedence: pulumi_wasm_rust::Output<i32>,
        /// The prompt to display to the user for a justification for accessing the resource. Required when using `purpose_justification_required`.
        pub purpose_justification_prompt: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether to prompt the user for a justification for accessing the resource.
        pub purpose_justification_required: pulumi_wasm_rust::Output<Option<bool>>,
        /// A series of access conditions, see Access Groups.
        pub requires: pulumi_wasm_rust::Output<Option<Vec<crate::types::AccessPolicyRequire>>>,
        /// How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.
        pub session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct AccessPolicyResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The ID of the application the policy is associated with.
        pub application_id: pulumi_wasm_rust::Output<String>,
        pub approval_groups:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::AccessPolicyApprovalGroup>>>,
        pub approval_required: pulumi_wasm_rust::Output<Option<bool>>,
        /// Defines the action Access will take if the policy matches the user. Available values: `allow`, `deny`, `non_identity`, `bypass`.
        pub decision: pulumi_wasm_rust::Output<String>,
        /// A series of access conditions, see Access Groups.
        pub excludes: pulumi_wasm_rust::Output<Option<Vec<crate::types::AccessPolicyExclude>>>,
        /// A series of access conditions, see Access Groups.
        pub includes: pulumi_wasm_rust::Output<Vec<crate::types::AccessPolicyInclude>>,
        /// Require this application to be served in an isolated browser for users matching this policy.
        pub isolation_required: pulumi_wasm_rust::Output<Option<bool>>,
        /// Friendly name of the Access Policy.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The unique precedence for policies on a single application.
        pub precedence: pulumi_wasm_rust::Output<i32>,
        /// The prompt to display to the user for a justification for accessing the resource. Required when using `purpose_justification_required`.
        pub purpose_justification_prompt: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether to prompt the user for a justification for accessing the resource.
        pub purpose_justification_required: pulumi_wasm_rust::Output<Option<bool>>,
        /// A series of access conditions, see Access Groups.
        pub requires: pulumi_wasm_rust::Output<Option<Vec<crate::types::AccessPolicyRequire>>>,
        /// How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.
        pub session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn access_policy(name: &str, args: AccessPolicyArgs) -> AccessPolicyResult {
        let result = crate::bindings::pulumi::cloudflare::access_policy::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::access_policy::Args {
                account_id: args.account_id.get_inner(),
                application_id: args.application_id.get_inner(),
                approval_groups: args.approval_groups.get_inner(),
                approval_required: args.approval_required.get_inner(),
                decision: args.decision.get_inner(),
                excludes: args.excludes.get_inner(),
                includes: args.includes.get_inner(),
                isolation_required: args.isolation_required.get_inner(),
                name: args.name.get_inner(),
                precedence: args.precedence.get_inner(),
                purpose_justification_prompt: args.purpose_justification_prompt.get_inner(),
                purpose_justification_required: args.purpose_justification_required.get_inner(),
                requires: args.requires.get_inner(),
                session_duration: args.session_duration.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        AccessPolicyResult {
            account_id: crate::into_domain(result.account_id),
            application_id: crate::into_domain(result.application_id),
            approval_groups: crate::into_domain(result.approval_groups),
            approval_required: crate::into_domain(result.approval_required),
            decision: crate::into_domain(result.decision),
            excludes: crate::into_domain(result.excludes),
            includes: crate::into_domain(result.includes),
            isolation_required: crate::into_domain(result.isolation_required),
            name: crate::into_domain(result.name),
            precedence: crate::into_domain(result.precedence),
            purpose_justification_prompt: crate::into_domain(result.purpose_justification_prompt),
            purpose_justification_required: crate::into_domain(
                result.purpose_justification_required,
            ),
            requires: crate::into_domain(result.requires),
            session_duration: crate::into_domain(result.session_duration),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare IP Firewall Access Rule resource. Access
/// control can be applied on basis of IP addresses, IP ranges, AS
/// numbers or countries.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// // Challenge requests coming from known Tor exit nodes.
/// const torExitNodes = new cloudflare.AccessRule("torExitNodes", {
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
///     notes: "Requests coming from known Tor exit nodes",
///     mode: "challenge",
///     configuration: {
///         target: "country",
///         value: "T1",
///     },
/// });
/// // Allowlist requests coming from Antarctica, but only for single zone.
/// const antarctica = new cloudflare.AccessRule("antarctica", {
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
///     notes: "Requests coming from Antarctica",
///     mode: "whitelist",
///     configuration: {
///         target: "country",
///         value: "AQ",
///     },
/// });
/// const config = new pulumi.Config();
/// const myOffice = config.getObject<Array<string>>("myOffice") || [
///     "192.0.2.0/24",
///     "198.51.100.0/24",
///     "2001:db8::/56",
/// ];
/// const officeNetwork: cloudflare.AccessRule[] = [];
/// for (const range = {value: 0}; range.value < myOffice.length; range.value++) {
///     officeNetwork.push(new cloudflare.AccessRule(`officeNetwork-${range.value}`, {
///         accountId: "f037e56e89293a057740de681ac9abbe",
///         notes: "Requests coming from office network",
///         mode: "whitelist",
///         configuration: {
///             target: "ip_range",
///             value: myOffice[count.index],
///         },
///     }));
/// }
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// # Challenge requests coming from known Tor exit nodes.
/// tor_exit_nodes = cloudflare.AccessRule("torExitNodes",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711",
///     notes="Requests coming from known Tor exit nodes",
///     mode="challenge",
///     configuration=cloudflare.AccessRuleConfigurationArgs(
///         target="country",
///         value="T1",
///     ))
/// # Allowlist requests coming from Antarctica, but only for single zone.
/// antarctica = cloudflare.AccessRule("antarctica",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711",
///     notes="Requests coming from Antarctica",
///     mode="whitelist",
///     configuration=cloudflare.AccessRuleConfigurationArgs(
///         target="country",
///         value="AQ",
///     ))
/// config = pulumi.Config()
/// my_office = config.get_object("myOffice")
/// if my_office is None:
///     my_office = [
///         "192.0.2.0/24",
///         "198.51.100.0/24",
///         "2001:db8::/56",
///     ]
/// office_network = []
/// for range in [{"value": i} for i in range(0, len(my_office))]:
///     office_network.append(cloudflare.AccessRule(f"officeNetwork-{range['value']}",
///         account_id="f037e56e89293a057740de681ac9abbe",
///         notes="Requests coming from office network",
///         mode="whitelist",
///         configuration=cloudflare.AccessRuleConfigurationArgs(
///             target="ip_range",
///             value=my_office[count["index"]],
///         )))
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     // Challenge requests coming from known Tor exit nodes.
///     var torExitNodes = new Cloudflare.AccessRule("torExitNodes", new()
///     {
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///         Notes = "Requests coming from known Tor exit nodes",
///         Mode = "challenge",
///         Configuration = new Cloudflare.Inputs.AccessRuleConfigurationArgs
///         {
///             Target = "country",
///             Value = "T1",
///         },
///     });
///
///     // Allowlist requests coming from Antarctica, but only for single zone.
///     var antarctica = new Cloudflare.AccessRule("antarctica", new()
///     {
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///         Notes = "Requests coming from Antarctica",
///         Mode = "whitelist",
///         Configuration = new Cloudflare.Inputs.AccessRuleConfigurationArgs
///         {
///             Target = "country",
///             Value = "AQ",
///         },
///     });
///
///     var config = new Config();
///     var myOffice = config.GetObject<string[]>("myOffice") ?? new[]
///     {
///         "192.0.2.0/24",
///         "198.51.100.0/24",
///         "2001:db8::/56",
///     };
///     var officeNetwork = new List<Cloudflare.AccessRule>();
///     for (var rangeIndex = 0; rangeIndex < myOffice.Length; rangeIndex++)
///     {
///         var range = new { Value = rangeIndex };
///         officeNetwork.Add(new Cloudflare.AccessRule($"officeNetwork-{range.Value}", new()
///         {
///             AccountId = "f037e56e89293a057740de681ac9abbe",
///             Notes = "Requests coming from office network",
///             Mode = "whitelist",
///             Configuration = new Cloudflare.Inputs.AccessRuleConfigurationArgs
///             {
///                 Target = "ip_range",
///                 Value = myOffice[count.Index],
///             },
///         }));
///     }
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// Challenge requests coming from known Tor exit nodes.
/// 		_, err := cloudflare.NewAccessRule(ctx, "torExitNodes", &cloudflare.AccessRuleArgs{
/// 			ZoneId: pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 			Notes:  pulumi.String("Requests coming from known Tor exit nodes"),
/// 			Mode:   pulumi.String("challenge"),
/// 			Configuration: &cloudflare.AccessRuleConfigurationArgs{
/// 				Target: pulumi.String("country"),
/// 				Value:  pulumi.String("T1"),
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// Allowlist requests coming from Antarctica, but only for single zone.
/// 		_, err = cloudflare.NewAccessRule(ctx, "antarctica", &cloudflare.AccessRuleArgs{
/// 			ZoneId: pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 			Notes:  pulumi.String("Requests coming from Antarctica"),
/// 			Mode:   pulumi.String("whitelist"),
/// 			Configuration: &cloudflare.AccessRuleConfigurationArgs{
/// 				Target: pulumi.String("country"),
/// 				Value:  pulumi.String("AQ"),
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		cfg := config.New(ctx, "")
/// 		myOffice := []string{
/// 			"192.0.2.0/24",
/// 			"198.51.100.0/24",
/// 			"2001:db8::/56",
/// 		}
/// 		if param := cfg.GetObject("myOffice"); param != nil {
/// 			myOffice = param
/// 		}
/// 		var officeNetwork []*cloudflare.AccessRule
/// 		for index := 0; index < len(myOffice); index++ {
/// 			key0 := index
/// 			_ := index
/// 			__res, err := cloudflare.NewAccessRule(ctx, fmt.Sprintf("officeNetwork-%v", key0), &cloudflare.AccessRuleArgs{
/// 				AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 				Notes:     pulumi.String("Requests coming from office network"),
/// 				Mode:      pulumi.String("whitelist"),
/// 				Configuration: &cloudflare.AccessRuleConfigurationArgs{
/// 					Target: pulumi.String("ip_range"),
/// 					Value:  "TODO: call element",
/// 				},
/// 			})
/// 			if err != nil {
/// 				return err
/// 			}
/// 			officeNetwork = append(officeNetwork, __res)
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.AccessRule;
/// import com.pulumi.cloudflare.AccessRuleArgs;
/// import com.pulumi.cloudflare.inputs.AccessRuleConfigurationArgs;
/// import com.pulumi.codegen.internal.KeyedValue;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         final var config = ctx.config();
///         // Challenge requests coming from known Tor exit nodes.
///         var torExitNodes = new AccessRule("torExitNodes", AccessRuleArgs.builder()        
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .notes("Requests coming from known Tor exit nodes")
///             .mode("challenge")
///             .configuration(AccessRuleConfigurationArgs.builder()
///                 .target("country")
///                 .value("T1")
///                 .build())
///             .build());
///
///         // Allowlist requests coming from Antarctica, but only for single zone.
///         var antarctica = new AccessRule("antarctica", AccessRuleArgs.builder()        
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .notes("Requests coming from Antarctica")
///             .mode("whitelist")
///             .configuration(AccessRuleConfigurationArgs.builder()
///                 .target("country")
///                 .value("AQ")
///                 .build())
///             .build());
///
///         final var myOffice = config.get("myOffice").orElse(        
///             "192.0.2.0/24",
///             "198.51.100.0/24",
///             "2001:db8::/56");
///         for (var i = 0; i < myOffice.length(); i++) {
///             new AccessRule("officeNetwork-" + i, AccessRuleArgs.builder()            
///                 .accountId("f037e56e89293a057740de681ac9abbe")
///                 .notes("Requests coming from office network")
///                 .mode("whitelist")
///                 .configuration(AccessRuleConfigurationArgs.builder()
///                     .target("ip_range")
///                     .value(myOffice[count.index()])
///                     .build())
///                 .build());
///
///         
/// }
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// configuration:
///   # Allowlist office's network IP ranges on all account zones (or other lists of
///   # resources).
///   myOffice:
///     type: list(string)
///     default:
///       - 192.0.2.0/24
///       - 198.51.100.0/24
///       - 2001:db8::/56
/// resources:
///   # Challenge requests coming from known Tor exit nodes.
///   torExitNodes:
///     type: cloudflare:AccessRule
///     properties:
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///       notes: Requests coming from known Tor exit nodes
///       mode: challenge
///       configuration:
///         target: country
///         value: T1
///   # Allowlist requests coming from Antarctica, but only for single zone.
///   antarctica:
///     type: cloudflare:AccessRule
///     properties:
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///       notes: Requests coming from Antarctica
///       mode: whitelist
///       configuration:
///         target: country
///         value: AQ
///   officeNetwork:
///     type: cloudflare:AccessRule
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       notes: Requests coming from office network
///       mode: whitelist
///       configuration:
///         target: ip_range
///         value:
///           fn::select:
///             - ${count.index}
///             - ${myOffice}
///     options: {}
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// User level access rule import.
///
/// ```sh
/// $ pulumi import cloudflare:index/accessRule:AccessRule default user/<user_id>/<rule_id>
/// ```
///
/// Zone level access rule import.
///
/// ```sh
/// $ pulumi import cloudflare:index/accessRule:AccessRule default zone/<zone_id>/<rule_id>
/// ```
///
/// Account level access rule import.
///
/// ```sh
/// $ pulumi import cloudflare:index/accessRule:AccessRule default account/<account_id>/<rule_id>
/// ```
///
pub mod access_rule {

    pub struct AccessRuleArgs {
        /// The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Rule configuration to apply to a matched request. **Modifying this attribute will force creation of a new resource.**
        pub configuration: pulumi_wasm_rust::Output<crate::types::AccessRuleConfiguration>,
        /// The action to apply to a matched request. Available values: `block`, `challenge`, `whitelist`, `js_challenge`, `managed_challenge`.
        pub mode: pulumi_wasm_rust::Output<String>,
        /// A personal note about the rule. Typically used as a reminder or explanation for the rule.
        pub notes: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct AccessRuleResult {
        /// The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Rule configuration to apply to a matched request. **Modifying this attribute will force creation of a new resource.**
        pub configuration: pulumi_wasm_rust::Output<crate::types::AccessRuleConfiguration>,
        /// The action to apply to a matched request. Available values: `block`, `challenge`, `whitelist`, `js_challenge`, `managed_challenge`.
        pub mode: pulumi_wasm_rust::Output<String>,
        /// A personal note about the rule. Typically used as a reminder or explanation for the rule.
        pub notes: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn access_rule(name: &str, args: AccessRuleArgs) -> AccessRuleResult {
        let result = crate::bindings::pulumi::cloudflare::access_rule::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::access_rule::Args {
                account_id: args.account_id.get_inner(),
                configuration: args.configuration.get_inner(),
                mode: args.mode.get_inner(),
                notes: args.notes.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        AccessRuleResult {
            account_id: crate::into_domain(result.account_id),
            configuration: crate::into_domain(result.configuration),
            mode: crate::into_domain(result.mode),
            notes: crate::into_domain(result.notes),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Access Service Tokens are used for service-to-service communication
/// when an application is behind Cloudflare Access.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// // Generate a service token that will renew if terraform is ran within 30 days of expiration
/// const myApp = new cloudflare.AccessServiceToken("myApp", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     minDaysForRenewal: 30,
///     name: "CI/CD app renewed",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// # Generate a service token that will renew if terraform is ran within 30 days of expiration
/// my_app = cloudflare.AccessServiceToken("myApp",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     min_days_for_renewal=30,
///     name="CI/CD app renewed")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     // Generate a service token that will renew if terraform is ran within 30 days of expiration
///     var myApp = new Cloudflare.AccessServiceToken("myApp", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         MinDaysForRenewal = 30,
///         Name = "CI/CD app renewed",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// Generate a service token that will renew if terraform is ran within 30 days of expiration
/// 		_, err := cloudflare.NewAccessServiceToken(ctx, "myApp", &cloudflare.AccessServiceTokenArgs{
/// 			AccountId:         pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			MinDaysForRenewal: pulumi.Int(30),
/// 			Name:              pulumi.String("CI/CD app renewed"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.AccessServiceToken;
/// import com.pulumi.cloudflare.AccessServiceTokenArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // Generate a service token that will renew if terraform is ran within 30 days of expiration
///         var myApp = new AccessServiceToken("myApp", AccessServiceTokenArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .minDaysForRenewal(30)
///             .name("CI/CD app renewed")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # Generate a service token that will renew if terraform is ran within 30 days of expiration
///   myApp:
///     type: cloudflare:AccessServiceToken
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       minDaysForRenewal: 30
///       name: CI/CD app renewed
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// If you are importing an Access Service Token you will not have the
///
/// client_secret available in the state for use. The client_secret is only
///
/// available once, at creation. In most cases, it is better to just create a new
///
/// resource should you need to reference it in other resources.
///
/// ```sh
/// $ pulumi import cloudflare:index/accessServiceToken:AccessServiceToken example <account_id>/<service_token_id>
/// ```
///
pub mod access_service_token {

    pub struct AccessServiceTokenArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Length of time the service token is valid for. Available values: `8760h`, `17520h`, `43800h`, `87600h`, `forever`.
        pub duration: pulumi_wasm_rust::Output<Option<String>>,
        /// Refresh the token if terraform is run within the specified amount of days before expiration.
        pub min_days_for_renewal: pulumi_wasm_rust::Output<Option<i32>>,
        /// Friendly name of the token's intent.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct AccessServiceTokenResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Client ID associated with the Service Token. **Modifying this attribute will force creation of a new resource.**
        pub client_id: pulumi_wasm_rust::Output<String>,
        /// A secret for interacting with Access protocols. **Modifying this attribute will force creation of a new resource.**
        pub client_secret: pulumi_wasm_rust::Output<String>,
        /// Length of time the service token is valid for. Available values: `8760h`, `17520h`, `43800h`, `87600h`, `forever`.
        pub duration: pulumi_wasm_rust::Output<String>,
        /// Date when the token expires.
        pub expires_at: pulumi_wasm_rust::Output<String>,
        /// Refresh the token if terraform is run within the specified amount of days before expiration.
        pub min_days_for_renewal: pulumi_wasm_rust::Output<Option<i32>>,
        /// Friendly name of the token's intent.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn access_service_token(
        name: &str,
        args: AccessServiceTokenArgs,
    ) -> AccessServiceTokenResult {
        let result = crate::bindings::pulumi::cloudflare::access_service_token::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::access_service_token::Args {
                account_id: args.account_id.get_inner(),
                duration: args.duration.get_inner(),
                min_days_for_renewal: args.min_days_for_renewal.get_inner(),
                name: args.name.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        AccessServiceTokenResult {
            account_id: crate::into_domain(result.account_id),
            client_id: crate::into_domain(result.client_id),
            client_secret: crate::into_domain(result.client_secret),
            duration: crate::into_domain(result.duration),
            expires_at: crate::into_domain(result.expires_at),
            min_days_for_renewal: crate::into_domain(result.min_days_for_renewal),
            name: crate::into_domain(result.name),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a resource to customize the pages your end users will see
/// when trying to reach applications behind Cloudflare Access.
pub mod access_tag {

    pub struct AccessTagArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Number of apps associated with the tag.
        pub app_count: pulumi_wasm_rust::Output<Option<i32>>,
        /// Friendly name of the Access Tag.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct AccessTagResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Number of apps associated with the tag.
        pub app_count: pulumi_wasm_rust::Output<i32>,
        /// Friendly name of the Access Tag.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn access_tag(name: &str, args: AccessTagArgs) -> AccessTagResult {
        let result = crate::bindings::pulumi::cloudflare::access_tag::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::access_tag::Args {
                account_id: args.account_id.get_inner(),
                app_count: args.app_count.get_inner(),
                name: args.name.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        AccessTagResult {
            account_id: crate::into_domain(result.account_id),
            app_count: crate::into_domain(result.app_count),
            name: crate::into_domain(result.name),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare Account resource. Account is the basic resource for
/// working with Cloudflare zones, teams and users.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.Account("example", {
///     enforceTwofactor: true,
///     name: "some-enterprise-account",
///     type: "enterprise",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.Account("example",
///     enforce_twofactor=True,
///     name="some-enterprise-account",
///     type="enterprise")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.Account("example", new()
///     {
///         EnforceTwofactor = true,
///         Name = "some-enterprise-account",
///         Type = "enterprise",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewAccount(ctx, "example", &cloudflare.AccountArgs{
/// 			EnforceTwofactor: pulumi.Bool(true),
/// 			Name:             pulumi.String("some-enterprise-account"),
/// 			Type:             pulumi.String("enterprise"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.Account;
/// import com.pulumi.cloudflare.AccountArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new Account("example", AccountArgs.builder()        
///             .enforceTwofactor(true)
///             .name("some-enterprise-account")
///             .type("enterprise")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:Account
///     properties:
///       enforceTwofactor: true
///       name: some-enterprise-account
///       type: enterprise
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/account:Account example <account_id>
/// ```
///
pub mod account {

    pub struct AccountArgs {
        /// Whether 2FA is enforced on the account. Defaults to `false`.
        pub enforce_twofactor: pulumi_wasm_rust::Output<Option<bool>>,
        /// The name of the account that is displayed in the Cloudflare dashboard.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Account type. Available values: `enterprise`, `standard`. Defaults to `standard`. **Modifying this attribute will force creation of a new resource.**
        pub type_: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct AccountResult {
        /// Whether 2FA is enforced on the account. Defaults to `false`.
        pub enforce_twofactor: pulumi_wasm_rust::Output<Option<bool>>,
        /// The name of the account that is displayed in the Cloudflare dashboard.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Account type. Available values: `enterprise`, `standard`. Defaults to `standard`. **Modifying this attribute will force creation of a new resource.**
        pub type_: pulumi_wasm_rust::Output<Option<String>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn account(name: &str, args: AccountArgs) -> AccountResult {
        let result = crate::bindings::pulumi::cloudflare::account::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::account::Args {
                enforce_twofactor: args.enforce_twofactor.get_inner(),
                name: args.name.get_inner(),
                type_: args.type_.get_inner(),
            },
        );

        AccountResult {
            enforce_twofactor: crate::into_domain(result.enforce_twofactor),
            name: crate::into_domain(result.name),
            type_: crate::into_domain(result.type_),
        }
    }
}

/// Provides a resource which manages Cloudflare account members.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.AccountMember("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     emailAddress: "user@example.com",
///     roleIds: [
///         "68b329da9893e34099c7d8ad5cb9c940",
///         "d784fa8b6d98d27699781bd9a7cf19f0",
///     ],
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.AccountMember("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     email_address="user@example.com",
///     role_ids=[
///         "68b329da9893e34099c7d8ad5cb9c940",
///         "d784fa8b6d98d27699781bd9a7cf19f0",
///     ])
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.AccountMember("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         EmailAddress = "user@example.com",
///         RoleIds = new[]
///         {
///             "68b329da9893e34099c7d8ad5cb9c940",
///             "d784fa8b6d98d27699781bd9a7cf19f0",
///         },
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewAccountMember(ctx, "example", &cloudflare.AccountMemberArgs{
/// 			AccountId:    pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			EmailAddress: pulumi.String("user@example.com"),
/// 			RoleIds: pulumi.StringArray{
/// 				pulumi.String("68b329da9893e34099c7d8ad5cb9c940"),
/// 				pulumi.String("d784fa8b6d98d27699781bd9a7cf19f0"),
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.AccountMember;
/// import com.pulumi.cloudflare.AccountMemberArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new AccountMember("example", AccountMemberArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .emailAddress("user@example.com")
///             .roleIds(            
///                 "68b329da9893e34099c7d8ad5cb9c940",
///                 "d784fa8b6d98d27699781bd9a7cf19f0")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:AccountMember
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       emailAddress: user@example.com
///       roleIds:
///         - 68b329da9893e34099c7d8ad5cb9c940
///         - d784fa8b6d98d27699781bd9a7cf19f0
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/accountMember:AccountMember example <account_id>/<member_id>
/// ```
///
pub mod account_member {

    pub struct AccountMemberArgs {
        /// Account ID to create the account member in.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The email address of the user who you wish to manage. Following creation, this field becomes read only via the API and cannot be updated.
        pub email_address: pulumi_wasm_rust::Output<String>,
        /// List of account role IDs that you want to assign to a member.
        pub role_ids: pulumi_wasm_rust::Output<Vec<String>>,
        /// A member's status in the account. Available values: `accepted`, `pending`.
        pub status: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct AccountMemberResult {
        /// Account ID to create the account member in.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The email address of the user who you wish to manage. Following creation, this field becomes read only via the API and cannot be updated.
        pub email_address: pulumi_wasm_rust::Output<String>,
        /// List of account role IDs that you want to assign to a member.
        pub role_ids: pulumi_wasm_rust::Output<Vec<String>>,
        /// A member's status in the account. Available values: `accepted`, `pending`.
        pub status: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn account_member(name: &str, args: AccountMemberArgs) -> AccountMemberResult {
        let result = crate::bindings::pulumi::cloudflare::account_member::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::account_member::Args {
                account_id: args.account_id.get_inner(),
                email_address: args.email_address.get_inner(),
                role_ids: args.role_ids.get_inner(),
                status: args.status.get_inner(),
            },
        );

        AccountMemberResult {
            account_id: crate::into_domain(result.account_id),
            email_address: crate::into_domain(result.email_address),
            role_ids: crate::into_domain(result.role_ids),
            status: crate::into_domain(result.status),
        }
    }
}

/// Provides the ability to manage IP addresses that can be used by DNS records when
/// they are proxied through Cloudflare.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.AddressMap("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     defaultSni: "*.example.com",
///     description: "My address map",
///     enabled: true,
///     ips: [
///         {
///             ip: "192.0.2.1",
///         },
///         {
///             ip: "203.0.113.1",
///         },
///     ],
///     memberships: [
///         {
///             identifier: "92f17202ed8bd63d69a66b86a49a8f6b",
///             kind: "account",
///         },
///         {
///             identifier: "023e105f4ecef8ad9ca31a8372d0c353",
///             kind: "zone",
///         },
///     ],
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.AddressMap("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     default_sni="*.example.com",
///     description="My address map",
///     enabled=True,
///     ips=[
///         cloudflare.AddressMapIpArgs(
///             ip="192.0.2.1",
///         ),
///         cloudflare.AddressMapIpArgs(
///             ip="203.0.113.1",
///         ),
///     ],
///     memberships=[
///         cloudflare.AddressMapMembershipArgs(
///             identifier="92f17202ed8bd63d69a66b86a49a8f6b",
///             kind="account",
///         ),
///         cloudflare.AddressMapMembershipArgs(
///             identifier="023e105f4ecef8ad9ca31a8372d0c353",
///             kind="zone",
///         ),
///     ])
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.AddressMap("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         DefaultSni = "*.example.com",
///         Description = "My address map",
///         Enabled = true,
///         Ips = new[]
///         {
///             new Cloudflare.Inputs.AddressMapIpArgs
///             {
///                 Ip = "192.0.2.1",
///             },
///             new Cloudflare.Inputs.AddressMapIpArgs
///             {
///                 Ip = "203.0.113.1",
///             },
///         },
///         Memberships = new[]
///         {
///             new Cloudflare.Inputs.AddressMapMembershipArgs
///             {
///                 Identifier = "92f17202ed8bd63d69a66b86a49a8f6b",
///                 Kind = "account",
///             },
///             new Cloudflare.Inputs.AddressMapMembershipArgs
///             {
///                 Identifier = "023e105f4ecef8ad9ca31a8372d0c353",
///                 Kind = "zone",
///             },
///         },
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewAddressMap(ctx, "example", &cloudflare.AddressMapArgs{
/// 			AccountId:   pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			DefaultSni:  pulumi.String("*.example.com"),
/// 			Description: pulumi.String("My address map"),
/// 			Enabled:     pulumi.Bool(true),
/// 			Ips: cloudflare.AddressMapIpArray{
/// 				&cloudflare.AddressMapIpArgs{
/// 					Ip: pulumi.String("192.0.2.1"),
/// 				},
/// 				&cloudflare.AddressMapIpArgs{
/// 					Ip: pulumi.String("203.0.113.1"),
/// 				},
/// 			},
/// 			Memberships: cloudflare.AddressMapMembershipArray{
/// 				&cloudflare.AddressMapMembershipArgs{
/// 					Identifier: pulumi.String("92f17202ed8bd63d69a66b86a49a8f6b"),
/// 					Kind:       pulumi.String("account"),
/// 				},
/// 				&cloudflare.AddressMapMembershipArgs{
/// 					Identifier: pulumi.String("023e105f4ecef8ad9ca31a8372d0c353"),
/// 					Kind:       pulumi.String("zone"),
/// 				},
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.AddressMap;
/// import com.pulumi.cloudflare.AddressMapArgs;
/// import com.pulumi.cloudflare.inputs.AddressMapIpArgs;
/// import com.pulumi.cloudflare.inputs.AddressMapMembershipArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new AddressMap("example", AddressMapArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .defaultSni("*.example.com")
///             .description("My address map")
///             .enabled(true)
///             .ips(            
///                 AddressMapIpArgs.builder()
///                     .ip("192.0.2.1")
///                     .build(),
///                 AddressMapIpArgs.builder()
///                     .ip("203.0.113.1")
///                     .build())
///             .memberships(            
///                 AddressMapMembershipArgs.builder()
///                     .identifier("92f17202ed8bd63d69a66b86a49a8f6b")
///                     .kind("account")
///                     .build(),
///                 AddressMapMembershipArgs.builder()
///                     .identifier("023e105f4ecef8ad9ca31a8372d0c353")
///                     .kind("zone")
///                     .build())
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:AddressMap
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       defaultSni: '*.example.com'
///       description: My address map
///       enabled: true
///       ips:
///         - ip: 192.0.2.1
///         - ip: 203.0.113.1
///       memberships:
///         - identifier: 92f17202ed8bd63d69a66b86a49a8f6b
///           kind: account
///         - identifier: 023e105f4ecef8ad9ca31a8372d0c353
///           kind: zone
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/addressMap:AddressMap example <account_id>/<address_map_id>
/// ```
///
pub mod address_map {

    pub struct AddressMapArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map.
        pub default_sni: pulumi_wasm_rust::Output<Option<String>>,
        /// Description of the address map.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether the Address Map is enabled or not.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The set of IPs on the Address Map.
        pub ips: pulumi_wasm_rust::Output<Option<Vec<crate::types::AddressMapIp>>>,
        /// Zones and Accounts which will be assigned IPs on this Address Map.
        pub memberships: pulumi_wasm_rust::Output<Option<Vec<crate::types::AddressMapMembership>>>,
    }

    pub struct AddressMapResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Controls whether the membership can be deleted via the API or not.
        pub can_delete: pulumi_wasm_rust::Output<bool>,
        /// If set to false, then the IPs on the Address Map cannot be modified via the API. This is true for Cloudflare-managed maps.
        pub can_modify_ips: pulumi_wasm_rust::Output<bool>,
        /// If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map.
        pub default_sni: pulumi_wasm_rust::Output<Option<String>>,
        /// Description of the address map.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether the Address Map is enabled or not.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The set of IPs on the Address Map.
        pub ips: pulumi_wasm_rust::Output<Option<Vec<crate::types::AddressMapIp>>>,
        /// Zones and Accounts which will be assigned IPs on this Address Map.
        pub memberships: pulumi_wasm_rust::Output<Option<Vec<crate::types::AddressMapMembership>>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn address_map(name: &str, args: AddressMapArgs) -> AddressMapResult {
        let result = crate::bindings::pulumi::cloudflare::address_map::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::address_map::Args {
                account_id: args.account_id.get_inner(),
                default_sni: args.default_sni.get_inner(),
                description: args.description.get_inner(),
                enabled: args.enabled.get_inner(),
                ips: args.ips.get_inner(),
                memberships: args.memberships.get_inner(),
            },
        );

        AddressMapResult {
            account_id: crate::into_domain(result.account_id),
            can_delete: crate::into_domain(result.can_delete),
            can_modify_ips: crate::into_domain(result.can_modify_ips),
            default_sni: crate::into_domain(result.default_sni),
            description: crate::into_domain(result.description),
            enabled: crate::into_domain(result.enabled),
            ips: crate::into_domain(result.ips),
            memberships: crate::into_domain(result.memberships),
        }
    }
}

/// Provides a resource to manage API Shield configurations.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.ApiShield("example", {
///     authIdCharacteristics: [{
///         name: "my-example-header",
///         type: "header",
///     }],
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.ApiShield("example",
///     auth_id_characteristics=[cloudflare.ApiShieldAuthIdCharacteristicArgs(
///         name="my-example-header",
///         type="header",
///     )],
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.ApiShield("example", new()
///     {
///         AuthIdCharacteristics = new[]
///         {
///             new Cloudflare.Inputs.ApiShieldAuthIdCharacteristicArgs
///             {
///                 Name = "my-example-header",
///                 Type = "header",
///             },
///         },
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewApiShield(ctx, "example", &cloudflare.ApiShieldArgs{
/// 			AuthIdCharacteristics: cloudflare.ApiShieldAuthIdCharacteristicArray{
/// 				&cloudflare.ApiShieldAuthIdCharacteristicArgs{
/// 					Name: pulumi.String("my-example-header"),
/// 					Type: pulumi.String("header"),
/// 				},
/// 			},
/// 			ZoneId: pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.ApiShield;
/// import com.pulumi.cloudflare.ApiShieldArgs;
/// import com.pulumi.cloudflare.inputs.ApiShieldAuthIdCharacteristicArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new ApiShield("example", ApiShieldArgs.builder()        
///             .authIdCharacteristics(ApiShieldAuthIdCharacteristicArgs.builder()
///                 .name("my-example-header")
///                 .type("header")
///                 .build())
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:ApiShield
///     properties:
///       authIdCharacteristics:
///         - name: my-example-header
///           type: header
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
pub mod api_shield {

    pub struct ApiShieldArgs {
        /// Characteristics define properties across which auth-ids can be computed in a privacy-preserving manner.
        pub auth_id_characteristics:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::ApiShieldAuthIdCharacteristic>>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct ApiShieldResult {
        /// Characteristics define properties across which auth-ids can be computed in a privacy-preserving manner.
        pub auth_id_characteristics:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::ApiShieldAuthIdCharacteristic>>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn api_shield(name: &str, args: ApiShieldArgs) -> ApiShieldResult {
        let result = crate::bindings::pulumi::cloudflare::api_shield::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::api_shield::Args {
                auth_id_characteristics: args.auth_id_characteristics.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        ApiShieldResult {
            auth_id_characteristics: crate::into_domain(result.auth_id_characteristics),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a resource to manage an operation in API Shield Endpoint Management.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.ApiShieldOperation("example", {
///     endpoint: "/path",
///     host: "api.example.com",
///     method: "GET",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.ApiShieldOperation("example",
///     endpoint="/path",
///     host="api.example.com",
///     method="GET",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.ApiShieldOperation("example", new()
///     {
///         Endpoint = "/path",
///         Host = "api.example.com",
///         Method = "GET",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewApiShieldOperation(ctx, "example", &cloudflare.ApiShieldOperationArgs{
/// 			Endpoint: pulumi.String("/path"),
/// 			Host:     pulumi.String("api.example.com"),
/// 			Method:   pulumi.String("GET"),
/// 			ZoneId:   pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.ApiShieldOperation;
/// import com.pulumi.cloudflare.ApiShieldOperationArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new ApiShieldOperation("example", ApiShieldOperationArgs.builder()        
///             .endpoint("/path")
///             .host("api.example.com")
///             .method("GET")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:ApiShieldOperation
///     properties:
///       endpoint: /path
///       host: api.example.com
///       method: GET
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
pub mod api_shield_operation {

    pub struct ApiShieldOperationArgs {
        /// The endpoint which can contain path parameter templates in curly braces, each will be replaced from left to right with `{varN}`, starting with `{var1}`. This will then be [Cloudflare-normalized](https://developers.cloudflare.com/rules/normalization/how-it-works/). **Modifying this attribute will force creation of a new resource.**
        pub endpoint: pulumi_wasm_rust::Output<String>,
        /// RFC3986-compliant host. **Modifying this attribute will force creation of a new resource.**
        pub host: pulumi_wasm_rust::Output<String>,
        /// The HTTP method used to access the endpoint. **Modifying this attribute will force creation of a new resource.**
        pub method: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct ApiShieldOperationResult {
        /// The endpoint which can contain path parameter templates in curly braces, each will be replaced from left to right with `{varN}`, starting with `{var1}`. This will then be [Cloudflare-normalized](https://developers.cloudflare.com/rules/normalization/how-it-works/). **Modifying this attribute will force creation of a new resource.**
        pub endpoint: pulumi_wasm_rust::Output<String>,
        /// RFC3986-compliant host. **Modifying this attribute will force creation of a new resource.**
        pub host: pulumi_wasm_rust::Output<String>,
        /// The HTTP method used to access the endpoint. **Modifying this attribute will force creation of a new resource.**
        pub method: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn api_shield_operation(
        name: &str,
        args: ApiShieldOperationArgs,
    ) -> ApiShieldOperationResult {
        let result = crate::bindings::pulumi::cloudflare::api_shield_operation::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::api_shield_operation::Args {
                endpoint: args.endpoint.get_inner(),
                host: args.host.get_inner(),
                method: args.method.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        ApiShieldOperationResult {
            endpoint: crate::into_domain(result.endpoint),
            host: crate::into_domain(result.host),
            method: crate::into_domain(result.method),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a resource to manage operation-level settings in API Shield Schema Validation 2.0.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const exampleApiShieldOperation = new cloudflare.ApiShieldOperation("exampleApiShieldOperation", {
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
///     method: "GET",
///     host: "api.example.com",
///     endpoint: "/path",
/// });
/// const exampleApiShieldOperationSchemaValidationSettings = new cloudflare.ApiShieldOperationSchemaValidationSettings("exampleApiShieldOperationSchemaValidationSettings", {
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
///     operationId: exampleApiShieldOperation.id,
///     mitigationAction: "block",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example_api_shield_operation = cloudflare.ApiShieldOperation("exampleApiShieldOperation",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711",
///     method="GET",
///     host="api.example.com",
///     endpoint="/path")
/// example_api_shield_operation_schema_validation_settings = cloudflare.ApiShieldOperationSchemaValidationSettings("exampleApiShieldOperationSchemaValidationSettings",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711",
///     operation_id=example_api_shield_operation.id,
///     mitigation_action="block")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var exampleApiShieldOperation = new Cloudflare.ApiShieldOperation("exampleApiShieldOperation", new()
///     {
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///         Method = "GET",
///         Host = "api.example.com",
///         Endpoint = "/path",
///     });
///
///     var exampleApiShieldOperationSchemaValidationSettings = new Cloudflare.ApiShieldOperationSchemaValidationSettings("exampleApiShieldOperationSchemaValidationSettings", new()
///     {
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///         OperationId = exampleApiShieldOperation.Id,
///         MitigationAction = "block",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		exampleApiShieldOperation, err := cloudflare.NewApiShieldOperation(ctx, "exampleApiShieldOperation", &cloudflare.ApiShieldOperationArgs{
/// 			ZoneId:   pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 			Method:   pulumi.String("GET"),
/// 			Host:     pulumi.String("api.example.com"),
/// 			Endpoint: pulumi.String("/path"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		_, err = cloudflare.NewApiShieldOperationSchemaValidationSettings(ctx, "exampleApiShieldOperationSchemaValidationSettings", &cloudflare.ApiShieldOperationSchemaValidationSettingsArgs{
/// 			ZoneId:           pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 			OperationId:      exampleApiShieldOperation.ID(),
/// 			MitigationAction: pulumi.String("block"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.ApiShieldOperation;
/// import com.pulumi.cloudflare.ApiShieldOperationArgs;
/// import com.pulumi.cloudflare.ApiShieldOperationSchemaValidationSettings;
/// import com.pulumi.cloudflare.ApiShieldOperationSchemaValidationSettingsArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var exampleApiShieldOperation = new ApiShieldOperation("exampleApiShieldOperation", ApiShieldOperationArgs.builder()        
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .method("GET")
///             .host("api.example.com")
///             .endpoint("/path")
///             .build());
///
///         var exampleApiShieldOperationSchemaValidationSettings = new ApiShieldOperationSchemaValidationSettings("exampleApiShieldOperationSchemaValidationSettings", ApiShieldOperationSchemaValidationSettingsArgs.builder()        
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .operationId(exampleApiShieldOperation.id())
///             .mitigationAction("block")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   exampleApiShieldOperation:
///     type: cloudflare:ApiShieldOperation
///     properties:
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///       method: GET
///       host: api.example.com
///       endpoint: /path
///   exampleApiShieldOperationSchemaValidationSettings:
///     type: cloudflare:ApiShieldOperationSchemaValidationSettings
///     properties:
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///       operationId: ${exampleApiShieldOperation.id}
///       mitigationAction: block
/// ```
/// <!--End PulumiCodeChooser -->
pub mod api_shield_operation_schema_validation_settings {

    pub struct ApiShieldOperationSchemaValidationSettingsArgs {
        /// The mitigation action to apply to this operation.
        pub mitigation_action: pulumi_wasm_rust::Output<Option<String>>,
        /// Operation ID these settings should apply to. **Modifying this attribute will force creation of a new resource.**
        pub operation_id: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct ApiShieldOperationSchemaValidationSettingsResult {
        /// The mitigation action to apply to this operation.
        pub mitigation_action: pulumi_wasm_rust::Output<Option<String>>,
        /// Operation ID these settings should apply to. **Modifying this attribute will force creation of a new resource.**
        pub operation_id: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn api_shield_operation_schema_validation_settings(
        name: &str,
        args: ApiShieldOperationSchemaValidationSettingsArgs,
    ) -> ApiShieldOperationSchemaValidationSettingsResult {
        let result = crate::bindings::pulumi::cloudflare::api_shield_operation_schema_validation_settings::invoke(name, &crate::bindings::pulumi::cloudflare::api_shield_operation_schema_validation_settings::Args {
            mitigation_action: args.mitigation_action.get_inner(),
            operation_id: args.operation_id.get_inner(),
            zone_id: args.zone_id.get_inner(),
        });

        ApiShieldOperationSchemaValidationSettingsResult {
            mitigation_action: crate::into_domain(result.mitigation_action),
            operation_id: crate::into_domain(result.operation_id),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a resource to manage a schema in API Shield Schema Validation 2.0.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
/// import * as fs from "fs";
///
/// const petstoreSchema = new cloudflare.ApiShieldSchema("petstoreSchema", {
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
///     name: "myschema",
///     kind: "openapi_v3",
///     validationEnabled: true,
///     source: fs.readFileSync("./schemas/petstore.json", "utf8"),
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// petstore_schema = cloudflare.ApiShieldSchema("petstoreSchema",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711",
///     name="myschema",
///     kind="openapi_v3",
///     validation_enabled=True,
///     source=(lambda path: open(path).read())("./schemas/petstore.json"))
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.IO;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var petstoreSchema = new Cloudflare.ApiShieldSchema("petstoreSchema", new()
///     {
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///         Name = "myschema",
///         Kind = "openapi_v3",
///         ValidationEnabled = true,
///         Source = File.ReadAllText("./schemas/petstore.json"),
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"os"
///
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func readFileOrPanic(path string) pulumi.StringPtrInput {
/// 	data, err := os.ReadFile(path)
/// 	if err != nil {
/// 		panic(err.Error())
/// 	}
/// 	return pulumi.String(string(data))
/// }
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewApiShieldSchema(ctx, "petstoreSchema", &cloudflare.ApiShieldSchemaArgs{
/// 			ZoneId:            pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 			Name:              pulumi.String("myschema"),
/// 			Kind:              pulumi.String("openapi_v3"),
/// 			ValidationEnabled: pulumi.Bool(true),
/// 			Source:            readFileOrPanic("./schemas/petstore.json"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.ApiShieldSchema;
/// import com.pulumi.cloudflare.ApiShieldSchemaArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var petstoreSchema = new ApiShieldSchema("petstoreSchema", ApiShieldSchemaArgs.builder()        
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .name("myschema")
///             .kind("openapi_v3")
///             .validationEnabled(true)
///             .source(Files.readString(Paths.get("./schemas/petstore.json")))
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   petstoreSchema:
///     type: cloudflare:ApiShieldSchema
///     properties:
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///       name: myschema
///       kind: openapi_v3
///       # optional
///       validationEnabled: true
///       # optional, default false
///       source:
///         fn::readFile: ./schemas/petstore.json
/// ```
/// <!--End PulumiCodeChooser -->
pub mod api_shield_schema {

    pub struct ApiShieldSchemaArgs {
        /// Kind of schema. Defaults to `openapi_v3`. **Modifying this attribute will force creation of a new resource.**
        pub kind: pulumi_wasm_rust::Output<Option<String>>,
        /// Name of the schema. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
        /// Schema file bytes. **Modifying this attribute will force creation of a new resource.**
        pub source: pulumi_wasm_rust::Output<String>,
        /// Flag whether schema is enabled for validation.
        pub validation_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct ApiShieldSchemaResult {
        /// Kind of schema. Defaults to `openapi_v3`. **Modifying this attribute will force creation of a new resource.**
        pub kind: pulumi_wasm_rust::Output<Option<String>>,
        /// Name of the schema. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
        /// Schema file bytes. **Modifying this attribute will force creation of a new resource.**
        pub source: pulumi_wasm_rust::Output<String>,
        /// Flag whether schema is enabled for validation.
        pub validation_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn api_shield_schema(name: &str, args: ApiShieldSchemaArgs) -> ApiShieldSchemaResult {
        let result = crate::bindings::pulumi::cloudflare::api_shield_schema::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::api_shield_schema::Args {
                kind: args.kind.get_inner(),
                name: args.name.get_inner(),
                source: args.source.get_inner(),
                validation_enabled: args.validation_enabled.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        ApiShieldSchemaResult {
            kind: crate::into_domain(result.kind),
            name: crate::into_domain(result.name),
            source: crate::into_domain(result.source),
            validation_enabled: crate::into_domain(result.validation_enabled),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a resource to manage settings in API Shield Schema Validation 2.0.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.ApiShieldSchemaValidationSettings("example", {
///     validationDefaultMitigationAction: "log",
///     validationOverrideMitigationAction: "none",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.ApiShieldSchemaValidationSettings("example",
///     validation_default_mitigation_action="log",
///     validation_override_mitigation_action="none",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.ApiShieldSchemaValidationSettings("example", new()
///     {
///         ValidationDefaultMitigationAction = "log",
///         ValidationOverrideMitigationAction = "none",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewApiShieldSchemaValidationSettings(ctx, "example", &cloudflare.ApiShieldSchemaValidationSettingsArgs{
/// 			ValidationDefaultMitigationAction:  pulumi.String("log"),
/// 			ValidationOverrideMitigationAction: pulumi.String("none"),
/// 			ZoneId:                             pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.ApiShieldSchemaValidationSettings;
/// import com.pulumi.cloudflare.ApiShieldSchemaValidationSettingsArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new ApiShieldSchemaValidationSettings("example", ApiShieldSchemaValidationSettingsArgs.builder()        
///             .validationDefaultMitigationAction("log")
///             .validationOverrideMitigationAction("none")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:ApiShieldSchemaValidationSettings
///     properties:
///       validationDefaultMitigationAction: log
///       validationOverrideMitigationAction: none
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
pub mod api_shield_schema_validation_settings {

    pub struct ApiShieldSchemaValidationSettingsArgs {
        /// The default mitigation action used when there is no mitigation action defined on the operation.
        pub validation_default_mitigation_action: pulumi_wasm_rust::Output<String>,
        /// When set, this overrides both zone level and operation level mitigation actions.
        pub validation_override_mitigation_action: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct ApiShieldSchemaValidationSettingsResult {
        /// The default mitigation action used when there is no mitigation action defined on the operation.
        pub validation_default_mitigation_action: pulumi_wasm_rust::Output<String>,
        /// When set, this overrides both zone level and operation level mitigation actions.
        pub validation_override_mitigation_action: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn api_shield_schema_validation_settings(
        name: &str,
        args: ApiShieldSchemaValidationSettingsArgs,
    ) -> ApiShieldSchemaValidationSettingsResult {
        let result =
            crate::bindings::pulumi::cloudflare::api_shield_schema_validation_settings::invoke(
                name,
                &crate::bindings::pulumi::cloudflare::api_shield_schema_validation_settings::Args {
                    validation_default_mitigation_action: args
                        .validation_default_mitigation_action
                        .get_inner(),
                    validation_override_mitigation_action: args
                        .validation_override_mitigation_action
                        .get_inner(),
                    zone_id: args.zone_id.get_inner(),
                },
            );

        ApiShieldSchemaValidationSettingsResult {
            validation_default_mitigation_action: crate::into_domain(
                result.validation_default_mitigation_action,
            ),
            validation_override_mitigation_action: crate::into_domain(
                result.validation_override_mitigation_action,
            ),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a resource which manages Cloudflare API tokens.
///
/// Read more about permission groups and their applicable scopes in the
/// [developer documentation](https://developers.cloudflare.com/api/tokens/create/permissions).
///
pub mod api_token {

    pub struct ApiTokenArgs {
        /// Conditions under which the token should be considered valid.
        pub condition: pulumi_wasm_rust::Output<Option<crate::types::ApiTokenCondition>>,
        /// The expiration time on or after which the token MUST NOT be accepted for processing.
        pub expires_on: pulumi_wasm_rust::Output<Option<String>>,
        /// Name of the API Token.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The time before which the token MUST NOT be accepted for processing.
        pub not_before: pulumi_wasm_rust::Output<Option<String>>,
        /// Permissions policy. Multiple policy blocks can be defined.
        pub policies: pulumi_wasm_rust::Output<Vec<crate::types::ApiTokenPolicy>>,
    }

    pub struct ApiTokenResult {
        /// Conditions under which the token should be considered valid.
        pub condition: pulumi_wasm_rust::Output<Option<crate::types::ApiTokenCondition>>,
        /// The expiration time on or after which the token MUST NOT be accepted for processing.
        pub expires_on: pulumi_wasm_rust::Output<Option<String>>,
        /// Timestamp of when the token was issued.
        pub issued_on: pulumi_wasm_rust::Output<String>,
        /// Timestamp of when the token was last modified.
        pub modified_on: pulumi_wasm_rust::Output<String>,
        /// Name of the API Token.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The time before which the token MUST NOT be accepted for processing.
        pub not_before: pulumi_wasm_rust::Output<Option<String>>,
        /// Permissions policy. Multiple policy blocks can be defined.
        pub policies: pulumi_wasm_rust::Output<Vec<crate::types::ApiTokenPolicy>>,
        pub status: pulumi_wasm_rust::Output<String>,
        /// The value of the API Token.
        pub value: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn api_token(name: &str, args: ApiTokenArgs) -> ApiTokenResult {
        let result = crate::bindings::pulumi::cloudflare::api_token::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::api_token::Args {
                condition: args.condition.get_inner(),
                expires_on: args.expires_on.get_inner(),
                name: args.name.get_inner(),
                not_before: args.not_before.get_inner(),
                policies: args.policies.get_inner(),
            },
        );

        ApiTokenResult {
            condition: crate::into_domain(result.condition),
            expires_on: crate::into_domain(result.expires_on),
            issued_on: crate::into_domain(result.issued_on),
            modified_on: crate::into_domain(result.modified_on),
            name: crate::into_domain(result.name),
            not_before: crate::into_domain(result.not_before),
            policies: crate::into_domain(result.policies),
            status: crate::into_domain(result.status),
            value: crate::into_domain(result.value),
        }
    }
}

/// Cloudflare Argo controls the routing to your origin and tiered
/// caching options to speed up your website browsing experience.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.Argo("example", {
///     smartRouting: "on",
///     tieredCaching: "on",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.Argo("example",
///     smart_routing="on",
///     tiered_caching="on",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.Argo("example", new()
///     {
///         SmartRouting = "on",
///         TieredCaching = "on",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewArgo(ctx, "example", &cloudflare.ArgoArgs{
/// 			SmartRouting:  pulumi.String("on"),
/// 			TieredCaching: pulumi.String("on"),
/// 			ZoneId:        pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.Argo;
/// import com.pulumi.cloudflare.ArgoArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new Argo("example", ArgoArgs.builder()        
///             .smartRouting("on")
///             .tieredCaching("on")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:Argo
///     properties:
///       smartRouting: on
///       tieredCaching: on
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/argo:Argo example <zone_id>
/// ```
///
pub mod argo {

    pub struct ArgoArgs {
        /// Whether smart routing is enabled. Available values: `on`, `off`.
        pub smart_routing: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether tiered caching is enabled. Available values: `on`, `off`.
        pub tiered_caching: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct ArgoResult {
        /// Whether smart routing is enabled. Available values: `on`, `off`.
        pub smart_routing: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether tiered caching is enabled. Available values: `on`, `off`.
        pub tiered_caching: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn argo(name: &str, args: ArgoArgs) -> ArgoResult {
        let result = crate::bindings::pulumi::cloudflare::argo::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::argo::Args {
                smart_routing: args.smart_routing.get_inner(),
                tiered_caching: args.tiered_caching.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        ArgoResult {
            smart_routing: crate::into_domain(result.smart_routing),
            tiered_caching: crate::into_domain(result.tiered_caching),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare Authenticated Origin Pulls resource. A `cloudflare.AuthenticatedOriginPulls`
/// resource is required to use Per-Zone or Per-Hostname Authenticated
/// Origin Pulls.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// // Authenticated Origin Pulls
/// const myAop = new cloudflare.AuthenticatedOriginPulls("myAop", {
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
///     enabled: true,
/// });
/// // Per-Zone Authenticated Origin Pulls
/// const myPerZoneAopCert = new cloudflare.AuthenticatedOriginPullsCertificate("myPerZoneAopCert", {
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
///     certificate: "-----INSERT CERTIFICATE-----",
///     privateKey: "-----INSERT PRIVATE KEY-----",
///     type: "per-zone",
/// });
/// const myPerZoneAop = new cloudflare.AuthenticatedOriginPulls("myPerZoneAop", {
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
///     authenticatedOriginPullsCertificate: myPerZoneAopCert.id,
///     enabled: true,
/// });
/// // Per-Hostname Authenticated Origin Pulls
/// const myPerHostnameAopCert = new cloudflare.AuthenticatedOriginPullsCertificate("myPerHostnameAopCert", {
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
///     certificate: "-----INSERT CERTIFICATE-----",
///     privateKey: "-----INSERT PRIVATE KEY-----",
///     type: "per-hostname",
/// });
/// const myPerHostnameAop = new cloudflare.AuthenticatedOriginPulls("myPerHostnameAop", {
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
///     authenticatedOriginPullsCertificate: myPerHostnameAopCert.id,
///     hostname: "aop.example.com",
///     enabled: true,
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// # Authenticated Origin Pulls
/// my_aop = cloudflare.AuthenticatedOriginPulls("myAop",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711",
///     enabled=True)
/// # Per-Zone Authenticated Origin Pulls
/// my_per_zone_aop_cert = cloudflare.AuthenticatedOriginPullsCertificate("myPerZoneAopCert",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711",
///     certificate="-----INSERT CERTIFICATE-----",
///     private_key="-----INSERT PRIVATE KEY-----",
///     type="per-zone")
/// my_per_zone_aop = cloudflare.AuthenticatedOriginPulls("myPerZoneAop",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711",
///     authenticated_origin_pulls_certificate=my_per_zone_aop_cert.id,
///     enabled=True)
/// # Per-Hostname Authenticated Origin Pulls
/// my_per_hostname_aop_cert = cloudflare.AuthenticatedOriginPullsCertificate("myPerHostnameAopCert",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711",
///     certificate="-----INSERT CERTIFICATE-----",
///     private_key="-----INSERT PRIVATE KEY-----",
///     type="per-hostname")
/// my_per_hostname_aop = cloudflare.AuthenticatedOriginPulls("myPerHostnameAop",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711",
///     authenticated_origin_pulls_certificate=my_per_hostname_aop_cert.id,
///     hostname="aop.example.com",
///     enabled=True)
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     // Authenticated Origin Pulls
///     var myAop = new Cloudflare.AuthenticatedOriginPulls("myAop", new()
///     {
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///         Enabled = true,
///     });
///
///     // Per-Zone Authenticated Origin Pulls
///     var myPerZoneAopCert = new Cloudflare.AuthenticatedOriginPullsCertificate("myPerZoneAopCert", new()
///     {
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///         Certificate = "-----INSERT CERTIFICATE-----",
///         PrivateKey = "-----INSERT PRIVATE KEY-----",
///         Type = "per-zone",
///     });
///
///     var myPerZoneAop = new Cloudflare.AuthenticatedOriginPulls("myPerZoneAop", new()
///     {
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///         AuthenticatedOriginPullsCertificate = myPerZoneAopCert.Id,
///         Enabled = true,
///     });
///
///     // Per-Hostname Authenticated Origin Pulls
///     var myPerHostnameAopCert = new Cloudflare.AuthenticatedOriginPullsCertificate("myPerHostnameAopCert", new()
///     {
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///         Certificate = "-----INSERT CERTIFICATE-----",
///         PrivateKey = "-----INSERT PRIVATE KEY-----",
///         Type = "per-hostname",
///     });
///
///     var myPerHostnameAop = new Cloudflare.AuthenticatedOriginPulls("myPerHostnameAop", new()
///     {
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///         AuthenticatedOriginPullsCertificate = myPerHostnameAopCert.Id,
///         Hostname = "aop.example.com",
///         Enabled = true,
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// Authenticated Origin Pulls
/// 		_, err := cloudflare.NewAuthenticatedOriginPulls(ctx, "myAop", &cloudflare.AuthenticatedOriginPullsArgs{
/// 			ZoneId:  pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 			Enabled: pulumi.Bool(true),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// Per-Zone Authenticated Origin Pulls
/// 		myPerZoneAopCert, err := cloudflare.NewAuthenticatedOriginPullsCertificate(ctx, "myPerZoneAopCert", &cloudflare.AuthenticatedOriginPullsCertificateArgs{
/// 			ZoneId:      pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 			Certificate: pulumi.String("-----INSERT CERTIFICATE-----"),
/// 			PrivateKey:  pulumi.String("-----INSERT PRIVATE KEY-----"),
/// 			Type:        pulumi.String("per-zone"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		_, err = cloudflare.NewAuthenticatedOriginPulls(ctx, "myPerZoneAop", &cloudflare.AuthenticatedOriginPullsArgs{
/// 			ZoneId:                              pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 			AuthenticatedOriginPullsCertificate: myPerZoneAopCert.ID(),
/// 			Enabled:                             pulumi.Bool(true),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// Per-Hostname Authenticated Origin Pulls
/// 		myPerHostnameAopCert, err := cloudflare.NewAuthenticatedOriginPullsCertificate(ctx, "myPerHostnameAopCert", &cloudflare.AuthenticatedOriginPullsCertificateArgs{
/// 			ZoneId:      pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 			Certificate: pulumi.String("-----INSERT CERTIFICATE-----"),
/// 			PrivateKey:  pulumi.String("-----INSERT PRIVATE KEY-----"),
/// 			Type:        pulumi.String("per-hostname"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		_, err = cloudflare.NewAuthenticatedOriginPulls(ctx, "myPerHostnameAop", &cloudflare.AuthenticatedOriginPullsArgs{
/// 			ZoneId:                              pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 			AuthenticatedOriginPullsCertificate: myPerHostnameAopCert.ID(),
/// 			Hostname:                            pulumi.String("aop.example.com"),
/// 			Enabled:                             pulumi.Bool(true),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.AuthenticatedOriginPulls;
/// import com.pulumi.cloudflare.AuthenticatedOriginPullsArgs;
/// import com.pulumi.cloudflare.AuthenticatedOriginPullsCertificate;
/// import com.pulumi.cloudflare.AuthenticatedOriginPullsCertificateArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // Authenticated Origin Pulls
///         var myAop = new AuthenticatedOriginPulls("myAop", AuthenticatedOriginPullsArgs.builder()        
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .enabled(true)
///             .build());
///
///         // Per-Zone Authenticated Origin Pulls
///         var myPerZoneAopCert = new AuthenticatedOriginPullsCertificate("myPerZoneAopCert", AuthenticatedOriginPullsCertificateArgs.builder()        
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .certificate("-----INSERT CERTIFICATE-----")
///             .privateKey("-----INSERT PRIVATE KEY-----")
///             .type("per-zone")
///             .build());
///
///         var myPerZoneAop = new AuthenticatedOriginPulls("myPerZoneAop", AuthenticatedOriginPullsArgs.builder()        
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .authenticatedOriginPullsCertificate(myPerZoneAopCert.id())
///             .enabled(true)
///             .build());
///
///         // Per-Hostname Authenticated Origin Pulls
///         var myPerHostnameAopCert = new AuthenticatedOriginPullsCertificate("myPerHostnameAopCert", AuthenticatedOriginPullsCertificateArgs.builder()        
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .certificate("-----INSERT CERTIFICATE-----")
///             .privateKey("-----INSERT PRIVATE KEY-----")
///             .type("per-hostname")
///             .build());
///
///         var myPerHostnameAop = new AuthenticatedOriginPulls("myPerHostnameAop", AuthenticatedOriginPullsArgs.builder()        
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .authenticatedOriginPullsCertificate(myPerHostnameAopCert.id())
///             .hostname("aop.example.com")
///             .enabled(true)
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # Authenticated Origin Pulls
///   myAop:
///     type: cloudflare:AuthenticatedOriginPulls
///     properties:
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///       enabled: true
///   # Per-Zone Authenticated Origin Pulls
///   myPerZoneAopCert:
///     type: cloudflare:AuthenticatedOriginPullsCertificate
///     properties:
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///       certificate: '-----INSERT CERTIFICATE-----'
///       privateKey: '-----INSERT PRIVATE KEY-----'
///       type: per-zone
///   myPerZoneAop:
///     type: cloudflare:AuthenticatedOriginPulls
///     properties:
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///       authenticatedOriginPullsCertificate: ${myPerZoneAopCert.id}
///       enabled: true
///   # Per-Hostname Authenticated Origin Pulls
///   myPerHostnameAopCert:
///     type: cloudflare:AuthenticatedOriginPullsCertificate
///     properties:
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///       certificate: '-----INSERT CERTIFICATE-----'
///       privateKey: '-----INSERT PRIVATE KEY-----'
///       type: per-hostname
///   myPerHostnameAop:
///     type: cloudflare:AuthenticatedOriginPulls
///     properties:
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///       authenticatedOriginPullsCertificate: ${myPerHostnameAopCert.id}
///       hostname: aop.example.com
///       enabled: true
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// global
///
/// ```sh
/// $ pulumi import cloudflare:index/authenticatedOriginPulls:AuthenticatedOriginPulls example <zone_id>
/// ```
///
/// per zone
///
/// ```sh
/// $ pulumi import cloudflare:index/authenticatedOriginPulls:AuthenticatedOriginPulls example <zone_id>/<certificate_id>
/// ```
///
/// per hostname
///
/// ```sh
/// $ pulumi import cloudflare:index/authenticatedOriginPulls:AuthenticatedOriginPulls example <zone_id>/<certificate_id>/<hostname>
/// ```
///
pub mod authenticated_origin_pulls {

    pub struct AuthenticatedOriginPullsArgs {
        /// The ID of an uploaded Authenticated Origin Pulls certificate. If no hostname is provided, this certificate will be used zone wide as Per-Zone Authenticated Origin Pulls.
        pub authenticated_origin_pulls_certificate: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether to enable Authenticated Origin Pulls on the given zone or hostname.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// Specify a hostname to enable Per-Hostname Authenticated Origin Pulls on, using the provided certificate.
        pub hostname: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct AuthenticatedOriginPullsResult {
        /// The ID of an uploaded Authenticated Origin Pulls certificate. If no hostname is provided, this certificate will be used zone wide as Per-Zone Authenticated Origin Pulls.
        pub authenticated_origin_pulls_certificate: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether to enable Authenticated Origin Pulls on the given zone or hostname.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// Specify a hostname to enable Per-Hostname Authenticated Origin Pulls on, using the provided certificate.
        pub hostname: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn authenticated_origin_pulls(
        name: &str,
        args: AuthenticatedOriginPullsArgs,
    ) -> AuthenticatedOriginPullsResult {
        let result = crate::bindings::pulumi::cloudflare::authenticated_origin_pulls::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::authenticated_origin_pulls::Args {
                authenticated_origin_pulls_certificate: args
                    .authenticated_origin_pulls_certificate
                    .get_inner(),
                enabled: args.enabled.get_inner(),
                hostname: args.hostname.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        AuthenticatedOriginPullsResult {
            authenticated_origin_pulls_certificate: crate::into_domain(
                result.authenticated_origin_pulls_certificate,
            ),
            enabled: crate::into_domain(result.enabled),
            hostname: crate::into_domain(result.hostname),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare Authenticated Origin Pulls certificate
/// resource. An uploaded client certificate is required to use Per-Zone
///  or Per-Hostname Authenticated Origin Pulls.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// // Per-Zone Authenticated Origin Pulls certificate
/// const myPerZoneAopCert = new cloudflare.AuthenticatedOriginPullsCertificate("myPerZoneAopCert", {
///     certificate: "-----INSERT CERTIFICATE-----",
///     privateKey: "-----INSERT PRIVATE KEY-----",
///     type: "per-zone",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// // Per-Hostname Authenticated Origin Pulls certificate
/// const myPerHostnameAopCert = new cloudflare.AuthenticatedOriginPullsCertificate("myPerHostnameAopCert", {
///     certificate: "-----INSERT CERTIFICATE-----",
///     privateKey: "-----INSERT PRIVATE KEY-----",
///     type: "per-hostname",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// # Per-Zone Authenticated Origin Pulls certificate
/// my_per_zone_aop_cert = cloudflare.AuthenticatedOriginPullsCertificate("myPerZoneAopCert",
///     certificate="-----INSERT CERTIFICATE-----",
///     private_key="-----INSERT PRIVATE KEY-----",
///     type="per-zone",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// # Per-Hostname Authenticated Origin Pulls certificate
/// my_per_hostname_aop_cert = cloudflare.AuthenticatedOriginPullsCertificate("myPerHostnameAopCert",
///     certificate="-----INSERT CERTIFICATE-----",
///     private_key="-----INSERT PRIVATE KEY-----",
///     type="per-hostname",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     // Per-Zone Authenticated Origin Pulls certificate
///     var myPerZoneAopCert = new Cloudflare.AuthenticatedOriginPullsCertificate("myPerZoneAopCert", new()
///     {
///         Certificate = "-----INSERT CERTIFICATE-----",
///         PrivateKey = "-----INSERT PRIVATE KEY-----",
///         Type = "per-zone",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
///     // Per-Hostname Authenticated Origin Pulls certificate
///     var myPerHostnameAopCert = new Cloudflare.AuthenticatedOriginPullsCertificate("myPerHostnameAopCert", new()
///     {
///         Certificate = "-----INSERT CERTIFICATE-----",
///         PrivateKey = "-----INSERT PRIVATE KEY-----",
///         Type = "per-hostname",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// Per-Zone Authenticated Origin Pulls certificate
/// 		_, err := cloudflare.NewAuthenticatedOriginPullsCertificate(ctx, "myPerZoneAopCert", &cloudflare.AuthenticatedOriginPullsCertificateArgs{
/// 			Certificate: pulumi.String("-----INSERT CERTIFICATE-----"),
/// 			PrivateKey:  pulumi.String("-----INSERT PRIVATE KEY-----"),
/// 			Type:        pulumi.String("per-zone"),
/// 			ZoneId:      pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// Per-Hostname Authenticated Origin Pulls certificate
/// 		_, err = cloudflare.NewAuthenticatedOriginPullsCertificate(ctx, "myPerHostnameAopCert", &cloudflare.AuthenticatedOriginPullsCertificateArgs{
/// 			Certificate: pulumi.String("-----INSERT CERTIFICATE-----"),
/// 			PrivateKey:  pulumi.String("-----INSERT PRIVATE KEY-----"),
/// 			Type:        pulumi.String("per-hostname"),
/// 			ZoneId:      pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.AuthenticatedOriginPullsCertificate;
/// import com.pulumi.cloudflare.AuthenticatedOriginPullsCertificateArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // Per-Zone Authenticated Origin Pulls certificate
///         var myPerZoneAopCert = new AuthenticatedOriginPullsCertificate("myPerZoneAopCert", AuthenticatedOriginPullsCertificateArgs.builder()        
///             .certificate("-----INSERT CERTIFICATE-----")
///             .privateKey("-----INSERT PRIVATE KEY-----")
///             .type("per-zone")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///         // Per-Hostname Authenticated Origin Pulls certificate
///         var myPerHostnameAopCert = new AuthenticatedOriginPullsCertificate("myPerHostnameAopCert", AuthenticatedOriginPullsCertificateArgs.builder()        
///             .certificate("-----INSERT CERTIFICATE-----")
///             .privateKey("-----INSERT PRIVATE KEY-----")
///             .type("per-hostname")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # Per-Zone Authenticated Origin Pulls certificate
///   myPerZoneAopCert:
///     type: cloudflare:AuthenticatedOriginPullsCertificate
///     properties:
///       certificate: '-----INSERT CERTIFICATE-----'
///       privateKey: '-----INSERT PRIVATE KEY-----'
///       type: per-zone
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///   # Per-Hostname Authenticated Origin Pulls certificate
///   myPerHostnameAopCert:
///     type: cloudflare:AuthenticatedOriginPullsCertificate
///     properties:
///       certificate: '-----INSERT CERTIFICATE-----'
///       privateKey: '-----INSERT PRIVATE KEY-----'
///       type: per-hostname
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/authenticatedOriginPullsCertificate:AuthenticatedOriginPullsCertificate example <zone_id>/<certificate_type>/<certificate_id>
/// ```
///
pub mod authenticated_origin_pulls_certificate {

    pub struct AuthenticatedOriginPullsCertificateArgs {
        /// The public client certificate. **Modifying this attribute will force creation of a new resource.**
        pub certificate: pulumi_wasm_rust::Output<String>,
        /// The private key of the client certificate. **Modifying this attribute will force creation of a new resource.**
        pub private_key: pulumi_wasm_rust::Output<String>,
        /// The form of Authenticated Origin Pulls to upload the certificate to. Available values: `per-zone`, `per-hostname`. **Modifying this attribute will force creation of a new resource.**
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct AuthenticatedOriginPullsCertificateResult {
        /// The public client certificate. **Modifying this attribute will force creation of a new resource.**
        pub certificate: pulumi_wasm_rust::Output<String>,
        /// **Modifying this attribute will force creation of a new resource.**
        pub expires_on: pulumi_wasm_rust::Output<String>,
        /// **Modifying this attribute will force creation of a new resource.**
        pub issuer: pulumi_wasm_rust::Output<String>,
        /// The private key of the client certificate. **Modifying this attribute will force creation of a new resource.**
        pub private_key: pulumi_wasm_rust::Output<String>,
        /// **Modifying this attribute will force creation of a new resource.**
        pub serial_number: pulumi_wasm_rust::Output<String>,
        /// **Modifying this attribute will force creation of a new resource.**
        pub signature: pulumi_wasm_rust::Output<String>,
        /// **Modifying this attribute will force creation of a new resource.**
        pub status: pulumi_wasm_rust::Output<String>,
        /// The form of Authenticated Origin Pulls to upload the certificate to. Available values: `per-zone`, `per-hostname`. **Modifying this attribute will force creation of a new resource.**
        pub type_: pulumi_wasm_rust::Output<String>,
        /// **Modifying this attribute will force creation of a new resource.**
        pub uploaded_on: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn authenticated_origin_pulls_certificate(
        name: &str,
        args: AuthenticatedOriginPullsCertificateArgs,
    ) -> AuthenticatedOriginPullsCertificateResult {
        let result = crate::bindings::pulumi::cloudflare::authenticated_origin_pulls_certificate::invoke(name, &crate::bindings::pulumi::cloudflare::authenticated_origin_pulls_certificate::Args {
            certificate: args.certificate.get_inner(),
            private_key: args.private_key.get_inner(),
            type_: args.type_.get_inner(),
            zone_id: args.zone_id.get_inner(),
        });

        AuthenticatedOriginPullsCertificateResult {
            certificate: crate::into_domain(result.certificate),
            expires_on: crate::into_domain(result.expires_on),
            issuer: crate::into_domain(result.issuer),
            private_key: crate::into_domain(result.private_key),
            serial_number: crate::into_domain(result.serial_number),
            signature: crate::into_domain(result.signature),
            status: crate::into_domain(result.status),
            type_: crate::into_domain(result.type_),
            uploaded_on: crate::into_domain(result.uploaded_on),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a resource to configure Bot Management.
///
/// Specifically, this resource can be used to manage:
///
/// - **Bot Fight Mode**
/// - **Super Bot Fight Mode**
/// - **Bot Management for Enterprise**
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.BotManagement("example", {
///     enableJs: true,
///     optimizeWordpress: true,
///     sbfmDefinitelyAutomated: "block",
///     sbfmLikelyAutomated: "managed_challenge",
///     sbfmStaticResourceProtection: false,
///     sbfmVerifiedBots: "allow",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.BotManagement("example",
///     enable_js=True,
///     optimize_wordpress=True,
///     sbfm_definitely_automated="block",
///     sbfm_likely_automated="managed_challenge",
///     sbfm_static_resource_protection=False,
///     sbfm_verified_bots="allow",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.BotManagement("example", new()
///     {
///         EnableJs = true,
///         OptimizeWordpress = true,
///         SbfmDefinitelyAutomated = "block",
///         SbfmLikelyAutomated = "managed_challenge",
///         SbfmStaticResourceProtection = false,
///         SbfmVerifiedBots = "allow",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewBotManagement(ctx, "example", &cloudflare.BotManagementArgs{
/// 			EnableJs:                     pulumi.Bool(true),
/// 			OptimizeWordpress:            pulumi.Bool(true),
/// 			SbfmDefinitelyAutomated:      pulumi.String("block"),
/// 			SbfmLikelyAutomated:          pulumi.String("managed_challenge"),
/// 			SbfmStaticResourceProtection: pulumi.Bool(false),
/// 			SbfmVerifiedBots:             pulumi.String("allow"),
/// 			ZoneId:                       pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.BotManagement;
/// import com.pulumi.cloudflare.BotManagementArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new BotManagement("example", BotManagementArgs.builder()        
///             .enableJs(true)
///             .optimizeWordpress(true)
///             .sbfmDefinitelyAutomated("block")
///             .sbfmLikelyAutomated("managed_challenge")
///             .sbfmStaticResourceProtection(false)
///             .sbfmVerifiedBots("allow")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:BotManagement
///     properties:
///       enableJs: true
///       optimizeWordpress: true
///       sbfmDefinitelyAutomated: block
///       sbfmLikelyAutomated: managed_challenge
///       sbfmStaticResourceProtection: false
///       sbfmVerifiedBots: allow
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/botManagement:BotManagement example <zone_id>
/// ```
///
pub mod bot_management {

    pub struct BotManagementArgs {
        /// Automatically update to the newest bot detection models created by Cloudflare as they are released. [Learn more.](https://developers.cloudflare.com/bots/reference/machine-learning-models#model-versions-and-release-notes).
        pub auto_update_model: pulumi_wasm_rust::Output<Option<bool>>,
        /// Use lightweight, invisible JavaScript detections to improve Bot Management. [Learn more about JavaScript Detections](https://developers.cloudflare.com/bots/reference/javascript-detections/).
        pub enable_js: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to enable Bot Fight Mode.
        pub fight_mode: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to optimize Super Bot Fight Mode protections for Wordpress.
        pub optimize_wordpress: pulumi_wasm_rust::Output<Option<bool>>,
        /// Super Bot Fight Mode (SBFM) action to take on definitely automated requests.
        pub sbfm_definitely_automated: pulumi_wasm_rust::Output<Option<String>>,
        /// Super Bot Fight Mode (SBFM) action to take on likely automated requests.
        pub sbfm_likely_automated: pulumi_wasm_rust::Output<Option<String>>,
        /// Super Bot Fight Mode (SBFM) to enable static resource protection. Enable if static resources on your application need bot protection. Note: Static resource protection can also result in legitimate traffic being blocked.
        pub sbfm_static_resource_protection: pulumi_wasm_rust::Output<Option<bool>>,
        /// Super Bot Fight Mode (SBFM) action to take on verified bots requests.
        pub sbfm_verified_bots: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether to disable tracking the highest bot score for a session in the Bot Management cookie.
        pub suppress_session_score: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct BotManagementResult {
        /// Automatically update to the newest bot detection models created by Cloudflare as they are released. [Learn more.](https://developers.cloudflare.com/bots/reference/machine-learning-models#model-versions-and-release-notes).
        pub auto_update_model: pulumi_wasm_rust::Output<Option<bool>>,
        /// Use lightweight, invisible JavaScript detections to improve Bot Management. [Learn more about JavaScript Detections](https://developers.cloudflare.com/bots/reference/javascript-detections/).
        pub enable_js: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to enable Bot Fight Mode.
        pub fight_mode: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to optimize Super Bot Fight Mode protections for Wordpress.
        pub optimize_wordpress: pulumi_wasm_rust::Output<Option<bool>>,
        /// Super Bot Fight Mode (SBFM) action to take on definitely automated requests.
        pub sbfm_definitely_automated: pulumi_wasm_rust::Output<Option<String>>,
        /// Super Bot Fight Mode (SBFM) action to take on likely automated requests.
        pub sbfm_likely_automated: pulumi_wasm_rust::Output<Option<String>>,
        /// Super Bot Fight Mode (SBFM) to enable static resource protection. Enable if static resources on your application need bot protection. Note: Static resource protection can also result in legitimate traffic being blocked.
        pub sbfm_static_resource_protection: pulumi_wasm_rust::Output<Option<bool>>,
        /// Super Bot Fight Mode (SBFM) action to take on verified bots requests.
        pub sbfm_verified_bots: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether to disable tracking the highest bot score for a session in the Bot Management cookie.
        pub suppress_session_score: pulumi_wasm_rust::Output<Option<bool>>,
        /// A read-only field that indicates whether the zone currently is running the latest ML model.
        pub using_latest_model: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn bot_management(name: &str, args: BotManagementArgs) -> BotManagementResult {
        let result = crate::bindings::pulumi::cloudflare::bot_management::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::bot_management::Args {
                auto_update_model: args.auto_update_model.get_inner(),
                enable_js: args.enable_js.get_inner(),
                fight_mode: args.fight_mode.get_inner(),
                optimize_wordpress: args.optimize_wordpress.get_inner(),
                sbfm_definitely_automated: args.sbfm_definitely_automated.get_inner(),
                sbfm_likely_automated: args.sbfm_likely_automated.get_inner(),
                sbfm_static_resource_protection: args.sbfm_static_resource_protection.get_inner(),
                sbfm_verified_bots: args.sbfm_verified_bots.get_inner(),
                suppress_session_score: args.suppress_session_score.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        BotManagementResult {
            auto_update_model: crate::into_domain(result.auto_update_model),
            enable_js: crate::into_domain(result.enable_js),
            fight_mode: crate::into_domain(result.fight_mode),
            optimize_wordpress: crate::into_domain(result.optimize_wordpress),
            sbfm_definitely_automated: crate::into_domain(result.sbfm_definitely_automated),
            sbfm_likely_automated: crate::into_domain(result.sbfm_likely_automated),
            sbfm_static_resource_protection: crate::into_domain(
                result.sbfm_static_resource_protection,
            ),
            sbfm_verified_bots: crate::into_domain(result.sbfm_verified_bots),
            suppress_session_score: crate::into_domain(result.suppress_session_score),
            using_latest_model: crate::into_domain(result.using_latest_model),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides the ability to manage Bring-Your-Own-IP prefixes (BYOIP)
/// which are used with or without Magic Transit.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.ByoIpPrefix("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     advertisement: "on",
///     description: "Example IP Prefix",
///     prefixId: "d41d8cd98f00b204e9800998ecf8427e",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.ByoIpPrefix("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     advertisement="on",
///     description="Example IP Prefix",
///     prefix_id="d41d8cd98f00b204e9800998ecf8427e")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.ByoIpPrefix("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Advertisement = "on",
///         Description = "Example IP Prefix",
///         PrefixId = "d41d8cd98f00b204e9800998ecf8427e",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewByoIpPrefix(ctx, "example", &cloudflare.ByoIpPrefixArgs{
/// 			AccountId:     pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Advertisement: pulumi.String("on"),
/// 			Description:   pulumi.String("Example IP Prefix"),
/// 			PrefixId:      pulumi.String("d41d8cd98f00b204e9800998ecf8427e"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.ByoIpPrefix;
/// import com.pulumi.cloudflare.ByoIpPrefixArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new ByoIpPrefix("example", ByoIpPrefixArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .advertisement("on")
///             .description("Example IP Prefix")
///             .prefixId("d41d8cd98f00b204e9800998ecf8427e")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:ByoIpPrefix
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       advertisement: on
///       description: Example IP Prefix
///       prefixId: d41d8cd98f00b204e9800998ecf8427e
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/byoIpPrefix:ByoIpPrefix example <account_id>/<prefix_id>
/// ```
///
pub mod byo_ip_prefix {

    pub struct ByoIpPrefixArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether or not the prefix shall be announced. A prefix can be activated or deactivated once every 15 minutes (attempting more regular updates will trigger rate limiting). Available values: `on`, `off`.
        pub advertisement: pulumi_wasm_rust::Output<Option<String>>,
        /// Description of the BYO IP prefix.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The assigned Bring-Your-Own-IP prefix ID. **Modifying this attribute will force creation of a new resource.**
        pub prefix_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct ByoIpPrefixResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether or not the prefix shall be announced. A prefix can be activated or deactivated once every 15 minutes (attempting more regular updates will trigger rate limiting). Available values: `on`, `off`.
        pub advertisement: pulumi_wasm_rust::Output<String>,
        /// Description of the BYO IP prefix.
        pub description: pulumi_wasm_rust::Output<String>,
        /// The assigned Bring-Your-Own-IP prefix ID. **Modifying this attribute will force creation of a new resource.**
        pub prefix_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn byo_ip_prefix(name: &str, args: ByoIpPrefixArgs) -> ByoIpPrefixResult {
        let result = crate::bindings::pulumi::cloudflare::byo_ip_prefix::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::byo_ip_prefix::Args {
                account_id: args.account_id.get_inner(),
                advertisement: args.advertisement.get_inner(),
                description: args.description.get_inner(),
                prefix_id: args.prefix_id.get_inner(),
            },
        );

        ByoIpPrefixResult {
            account_id: crate::into_domain(result.account_id),
            advertisement: crate::into_domain(result.advertisement),
            description: crate::into_domain(result.description),
            prefix_id: crate::into_domain(result.prefix_id),
        }
    }
}

/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// // Advanced certificate manager for Let's Encrypt
/// const example = new cloudflare.CertificatePack("example", {
///     certificateAuthority: "lets_encrypt",
///     cloudflareBranding: false,
///     hosts: [
///         "example.com",
///         "*.example.com",
///     ],
///     type: "advanced",
///     validationMethod: "http",
///     validityDays: 90,
///     waitForActiveStatus: true,
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// # Advanced certificate manager for Let's Encrypt
/// example = cloudflare.CertificatePack("example",
///     certificate_authority="lets_encrypt",
///     cloudflare_branding=False,
///     hosts=[
///         "example.com",
///         "*.example.com",
///     ],
///     type="advanced",
///     validation_method="http",
///     validity_days=90,
///     wait_for_active_status=True,
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     // Advanced certificate manager for Let's Encrypt
///     var example = new Cloudflare.CertificatePack("example", new()
///     {
///         CertificateAuthority = "lets_encrypt",
///         CloudflareBranding = false,
///         Hosts = new[]
///         {
///             "example.com",
///             "*.example.com",
///         },
///         Type = "advanced",
///         ValidationMethod = "http",
///         ValidityDays = 90,
///         WaitForActiveStatus = true,
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// Advanced certificate manager for Let's Encrypt
/// 		_, err := cloudflare.NewCertificatePack(ctx, "example", &cloudflare.CertificatePackArgs{
/// 			CertificateAuthority: pulumi.String("lets_encrypt"),
/// 			CloudflareBranding:   pulumi.Bool(false),
/// 			Hosts: pulumi.StringArray{
/// 				pulumi.String("example.com"),
/// 				pulumi.String("*.example.com"),
/// 			},
/// 			Type:                pulumi.String("advanced"),
/// 			ValidationMethod:    pulumi.String("http"),
/// 			ValidityDays:        pulumi.Int(90),
/// 			WaitForActiveStatus: pulumi.Bool(true),
/// 			ZoneId:              pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.CertificatePack;
/// import com.pulumi.cloudflare.CertificatePackArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // Advanced certificate manager for Let's Encrypt
///         var example = new CertificatePack("example", CertificatePackArgs.builder()        
///             .certificateAuthority("lets_encrypt")
///             .cloudflareBranding(false)
///             .hosts(            
///                 "example.com",
///                 "*.example.com")
///             .type("advanced")
///             .validationMethod("http")
///             .validityDays(90)
///             .waitForActiveStatus(true)
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # Advanced certificate manager for Let's Encrypt
///   example:
///     type: cloudflare:CertificatePack
///     properties:
///       certificateAuthority: lets_encrypt
///       cloudflareBranding: false
///       hosts:
///         - example.com
///         - '*.example.com'
///       type: advanced
///       validationMethod: http
///       validityDays: 90
///       waitForActiveStatus: true
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/certificatePack:CertificatePack example <zone_id>/<certificate_pack_id>
/// ```
///
/// While supported, importing isn't recommended and it is advised to replace the
///
/// certificate entirely instead.
///
pub mod certificate_pack {

    pub struct CertificatePackArgs {
        /// Which certificate authority to issue the certificate pack. Available values: `digicert`, `lets_encrypt`, `google`. **Modifying this attribute will force creation of a new resource.**
        pub certificate_authority: pulumi_wasm_rust::Output<String>,
        /// Whether or not to include Cloudflare branding. This will add `sni.cloudflaressl.com` as the Common Name if set to `true`. **Modifying this attribute will force creation of a new resource.**
        pub cloudflare_branding: pulumi_wasm_rust::Output<Option<bool>>,
        /// List of hostnames to provision the certificate pack for. The zone name must be included as a host. Note: If using Let's Encrypt, you cannot use individual subdomains and only a wildcard for subdomain is available. **Modifying this attribute will force creation of a new resource.**
        pub hosts: pulumi_wasm_rust::Output<Vec<String>>,
        /// Certificate pack configuration type. Available values: `advanced`. **Modifying this attribute will force creation of a new resource.**
        pub type_: pulumi_wasm_rust::Output<String>,
        pub validation_errors:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::CertificatePackValidationError>>>,
        /// Which validation method to use in order to prove domain ownership. Available values: `txt`, `http`, `email`. **Modifying this attribute will force creation of a new resource.**
        pub validation_method: pulumi_wasm_rust::Output<String>,
        pub validation_records:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::CertificatePackValidationRecord>>>,
        /// How long the certificate is valid for. Note: If using Let's Encrypt, this value can only be 90 days. Available values: `14`, `30`, `90`, `365`. **Modifying this attribute will force creation of a new resource.**
        pub validity_days: pulumi_wasm_rust::Output<i32>,
        /// Whether or not to wait for a certificate pack to reach status `active` during creation. Defaults to `false`. **Modifying this attribute will force creation of a new resource.**
        pub wait_for_active_status: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct CertificatePackResult {
        /// Which certificate authority to issue the certificate pack. Available values: `digicert`, `lets_encrypt`, `google`. **Modifying this attribute will force creation of a new resource.**
        pub certificate_authority: pulumi_wasm_rust::Output<String>,
        /// Whether or not to include Cloudflare branding. This will add `sni.cloudflaressl.com` as the Common Name if set to `true`. **Modifying this attribute will force creation of a new resource.**
        pub cloudflare_branding: pulumi_wasm_rust::Output<Option<bool>>,
        /// List of hostnames to provision the certificate pack for. The zone name must be included as a host. Note: If using Let's Encrypt, you cannot use individual subdomains and only a wildcard for subdomain is available. **Modifying this attribute will force creation of a new resource.**
        pub hosts: pulumi_wasm_rust::Output<Vec<String>>,
        /// Certificate pack configuration type. Available values: `advanced`. **Modifying this attribute will force creation of a new resource.**
        pub type_: pulumi_wasm_rust::Output<String>,
        pub validation_errors:
            pulumi_wasm_rust::Output<Vec<crate::types::CertificatePackValidationError>>,
        /// Which validation method to use in order to prove domain ownership. Available values: `txt`, `http`, `email`. **Modifying this attribute will force creation of a new resource.**
        pub validation_method: pulumi_wasm_rust::Output<String>,
        pub validation_records:
            pulumi_wasm_rust::Output<Vec<crate::types::CertificatePackValidationRecord>>,
        /// How long the certificate is valid for. Note: If using Let's Encrypt, this value can only be 90 days. Available values: `14`, `30`, `90`, `365`. **Modifying this attribute will force creation of a new resource.**
        pub validity_days: pulumi_wasm_rust::Output<i32>,
        /// Whether or not to wait for a certificate pack to reach status `active` during creation. Defaults to `false`. **Modifying this attribute will force creation of a new resource.**
        pub wait_for_active_status: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn certificate_pack(name: &str, args: CertificatePackArgs) -> CertificatePackResult {
        let result = crate::bindings::pulumi::cloudflare::certificate_pack::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::certificate_pack::Args {
                certificate_authority: args.certificate_authority.get_inner(),
                cloudflare_branding: args.cloudflare_branding.get_inner(),
                hosts: args.hosts.get_inner(),
                type_: args.type_.get_inner(),
                validation_errors: args.validation_errors.get_inner(),
                validation_method: args.validation_method.get_inner(),
                validation_records: args.validation_records.get_inner(),
                validity_days: args.validity_days.get_inner(),
                wait_for_active_status: args.wait_for_active_status.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        CertificatePackResult {
            certificate_authority: crate::into_domain(result.certificate_authority),
            cloudflare_branding: crate::into_domain(result.cloudflare_branding),
            hosts: crate::into_domain(result.hosts),
            type_: crate::into_domain(result.type_),
            validation_errors: crate::into_domain(result.validation_errors),
            validation_method: crate::into_domain(result.validation_method),
            validation_records: crate::into_domain(result.validation_records),
            validity_days: crate::into_domain(result.validity_days),
            wait_for_active_status: crate::into_domain(result.wait_for_active_status),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare custom hostname (also known as SSL for SaaS) resource.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.CustomHostname("example", {
///     hostname: "hostname.example.com",
///     ssls: [{
///         method: "txt",
///     }],
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.CustomHostname("example",
///     hostname="hostname.example.com",
///     ssls=[cloudflare.CustomHostnameSslArgs(
///         method="txt",
///     )],
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.CustomHostname("example", new()
///     {
///         Hostname = "hostname.example.com",
///         Ssls = new[]
///         {
///             new Cloudflare.Inputs.CustomHostnameSslArgs
///             {
///                 Method = "txt",
///             },
///         },
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewCustomHostname(ctx, "example", &cloudflare.CustomHostnameArgs{
/// 			Hostname: pulumi.String("hostname.example.com"),
/// 			Ssls: cloudflare.CustomHostnameSslArray{
/// 				&cloudflare.CustomHostnameSslArgs{
/// 					Method: pulumi.String("txt"),
/// 				},
/// 			},
/// 			ZoneId: pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.CustomHostname;
/// import com.pulumi.cloudflare.CustomHostnameArgs;
/// import com.pulumi.cloudflare.inputs.CustomHostnameSslArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new CustomHostname("example", CustomHostnameArgs.builder()        
///             .hostname("hostname.example.com")
///             .ssls(CustomHostnameSslArgs.builder()
///                 .method("txt")
///                 .build())
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:CustomHostname
///     properties:
///       hostname: hostname.example.com
///       ssls:
///         - method: txt
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/customHostname:CustomHostname example 1d5fdc9e88c8a8c4518b068cd94331fe/0d89c70d-ad9f-4843-b99f-6cc0252067e9
/// ```
///
pub mod custom_hostname {

    pub struct CustomHostnameArgs {
        /// Custom metadata associated with custom hostname. Only supports primitive string values, all other values are accessible via the API directly.
        pub custom_metadata:
            pulumi_wasm_rust::Output<Option<std::collections::HashMap<String, String>>>,
        /// The custom origin server used for certificates.
        pub custom_origin_server: pulumi_wasm_rust::Output<Option<String>>,
        /// The [custom origin SNI](https://developers.cloudflare.com/ssl/ssl-for-saas/hostname-specific-behavior/custom-origin) used for certificates.
        pub custom_origin_sni: pulumi_wasm_rust::Output<Option<String>>,
        /// Hostname you intend to request a certificate for. **Modifying this attribute will force creation of a new resource.**
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// SSL properties used when creating the custom hostname.
        pub ssls: pulumi_wasm_rust::Output<Option<Vec<crate::types::CustomHostnameSsl>>>,
        /// Whether to wait for a custom hostname SSL sub-object to reach status `pending_validation` during creation. Defaults to `false`.
        pub wait_for_ssl_pending_validation: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct CustomHostnameResult {
        /// Custom metadata associated with custom hostname. Only supports primitive string values, all other values are accessible via the API directly.
        pub custom_metadata:
            pulumi_wasm_rust::Output<Option<std::collections::HashMap<String, String>>>,
        /// The custom origin server used for certificates.
        pub custom_origin_server: pulumi_wasm_rust::Output<Option<String>>,
        /// The [custom origin SNI](https://developers.cloudflare.com/ssl/ssl-for-saas/hostname-specific-behavior/custom-origin) used for certificates.
        pub custom_origin_sni: pulumi_wasm_rust::Output<Option<String>>,
        /// Hostname you intend to request a certificate for. **Modifying this attribute will force creation of a new resource.**
        pub hostname: pulumi_wasm_rust::Output<String>,
        pub ownership_verification:
            pulumi_wasm_rust::Output<std::collections::HashMap<String, String>>,
        pub ownership_verification_http:
            pulumi_wasm_rust::Output<std::collections::HashMap<String, String>>,
        /// SSL properties used when creating the custom hostname.
        pub ssls: pulumi_wasm_rust::Output<Option<Vec<crate::types::CustomHostnameSsl>>>,
        /// Status of the certificate.
        pub status: pulumi_wasm_rust::Output<String>,
        /// Whether to wait for a custom hostname SSL sub-object to reach status `pending_validation` during creation. Defaults to `false`.
        pub wait_for_ssl_pending_validation: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn custom_hostname(name: &str, args: CustomHostnameArgs) -> CustomHostnameResult {
        let result = crate::bindings::pulumi::cloudflare::custom_hostname::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::custom_hostname::Args {
                custom_metadata: args.custom_metadata.get_inner(),
                custom_origin_server: args.custom_origin_server.get_inner(),
                custom_origin_sni: args.custom_origin_sni.get_inner(),
                hostname: args.hostname.get_inner(),
                ssls: args.ssls.get_inner(),
                wait_for_ssl_pending_validation: args.wait_for_ssl_pending_validation.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        CustomHostnameResult {
            custom_metadata: crate::into_domain(result.custom_metadata),
            custom_origin_server: crate::into_domain(result.custom_origin_server),
            custom_origin_sni: crate::into_domain(result.custom_origin_sni),
            hostname: crate::into_domain(result.hostname),
            ownership_verification: crate::into_domain(result.ownership_verification),
            ownership_verification_http: crate::into_domain(result.ownership_verification_http),
            ssls: crate::into_domain(result.ssls),
            status: crate::into_domain(result.status),
            wait_for_ssl_pending_validation: crate::into_domain(
                result.wait_for_ssl_pending_validation,
            ),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare custom hostname fallback origin resource.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.CustomHostnameFallbackOrigin("example", {
///     origin: "fallback.example.com",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.CustomHostnameFallbackOrigin("example",
///     origin="fallback.example.com",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.CustomHostnameFallbackOrigin("example", new()
///     {
///         Origin = "fallback.example.com",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewCustomHostnameFallbackOrigin(ctx, "example", &cloudflare.CustomHostnameFallbackOriginArgs{
/// 			Origin: pulumi.String("fallback.example.com"),
/// 			ZoneId: pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.CustomHostnameFallbackOrigin;
/// import com.pulumi.cloudflare.CustomHostnameFallbackOriginArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new CustomHostnameFallbackOrigin("example", CustomHostnameFallbackOriginArgs.builder()        
///             .origin("fallback.example.com")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:CustomHostnameFallbackOrigin
///     properties:
///       origin: fallback.example.com
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/customHostnameFallbackOrigin:CustomHostnameFallbackOrigin example <zone_id>/<fallback_hostname>
/// ```
///
pub mod custom_hostname_fallback_origin {

    pub struct CustomHostnameFallbackOriginArgs {
        /// Hostname you intend to fallback requests to. Origin must be a proxied A/AAAA/CNAME DNS record within Clouldflare.
        pub origin: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct CustomHostnameFallbackOriginResult {
        /// Hostname you intend to fallback requests to. Origin must be a proxied A/AAAA/CNAME DNS record within Clouldflare.
        pub origin: pulumi_wasm_rust::Output<String>,
        /// Status of the fallback origin's activation.
        pub status: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn custom_hostname_fallback_origin(
        name: &str,
        args: CustomHostnameFallbackOriginArgs,
    ) -> CustomHostnameFallbackOriginResult {
        let result = crate::bindings::pulumi::cloudflare::custom_hostname_fallback_origin::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::custom_hostname_fallback_origin::Args {
                origin: args.origin.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        CustomHostnameFallbackOriginResult {
            origin: crate::into_domain(result.origin),
            status: crate::into_domain(result.status),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a resource which manages Cloudflare custom error pages.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.CustomPages("example", {
///     state: "customized",
///     type: "basic_challenge",
///     url: "https://example.com/challenge.html",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.CustomPages("example",
///     state="customized",
///     type="basic_challenge",
///     url="https://example.com/challenge.html",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.CustomPages("example", new()
///     {
///         State = "customized",
///         Type = "basic_challenge",
///         Url = "https://example.com/challenge.html",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewCustomPages(ctx, "example", &cloudflare.CustomPagesArgs{
/// 			State:  pulumi.String("customized"),
/// 			Type:   pulumi.String("basic_challenge"),
/// 			Url:    pulumi.String("https://example.com/challenge.html"),
/// 			ZoneId: pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.CustomPages;
/// import com.pulumi.cloudflare.CustomPagesArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new CustomPages("example", CustomPagesArgs.builder()        
///             .state("customized")
///             .type("basic_challenge")
///             .url("https://example.com/challenge.html")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:CustomPages
///     properties:
///       state: customized
///       type: basic_challenge
///       url: https://example.com/challenge.html
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/customPages:CustomPages example <resource_level>/<resource_id>/<custom_page_type>
/// ```
///
pub mod custom_pages {

    pub struct CustomPagesArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Managed state of the custom page. Available values: `default`, `customized`.
        pub state: pulumi_wasm_rust::Output<Option<String>>,
        /// The type of custom page you wish to update. Available values: `basic_challenge`, `waf_challenge`, `waf_block`, `ratelimit_block`, `country_challenge`, `ip_block`, `under_attack`, `500_errors`, `1000_errors`, `managed_challenge`.
        pub type_: pulumi_wasm_rust::Output<String>,
        /// URL of where the custom page source is located.
        pub url: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct CustomPagesResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Managed state of the custom page. Available values: `default`, `customized`.
        pub state: pulumi_wasm_rust::Output<Option<String>>,
        /// The type of custom page you wish to update. Available values: `basic_challenge`, `waf_challenge`, `waf_block`, `ratelimit_block`, `country_challenge`, `ip_block`, `under_attack`, `500_errors`, `1000_errors`, `managed_challenge`.
        pub type_: pulumi_wasm_rust::Output<String>,
        /// URL of where the custom page source is located.
        pub url: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn custom_pages(name: &str, args: CustomPagesArgs) -> CustomPagesResult {
        let result = crate::bindings::pulumi::cloudflare::custom_pages::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::custom_pages::Args {
                account_id: args.account_id.get_inner(),
                state: args.state.get_inner(),
                type_: args.type_.get_inner(),
                url: args.url.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        CustomPagesResult {
            account_id: crate::into_domain(result.account_id),
            state: crate::into_domain(result.state),
            type_: crate::into_domain(result.type_),
            url: crate::into_domain(result.url),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare custom SSL resource.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.CustomSsl("example", {
///     customSslOptions: {
///         bundleMethod: "ubiquitous",
///         certificate: "-----INSERT CERTIFICATE-----",
///         geoRestrictions: "us",
///         privateKey: "-----INSERT PRIVATE KEY-----",
///         type: "legacy_custom",
///     },
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.CustomSsl("example",
///     custom_ssl_options=cloudflare.CustomSslCustomSslOptionsArgs(
///         bundle_method="ubiquitous",
///         certificate="-----INSERT CERTIFICATE-----",
///         geo_restrictions="us",
///         private_key="-----INSERT PRIVATE KEY-----",
///         type="legacy_custom",
///     ),
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.CustomSsl("example", new()
///     {
///         CustomSslOptions = new Cloudflare.Inputs.CustomSslCustomSslOptionsArgs
///         {
///             BundleMethod = "ubiquitous",
///             Certificate = "-----INSERT CERTIFICATE-----",
///             GeoRestrictions = "us",
///             PrivateKey = "-----INSERT PRIVATE KEY-----",
///             Type = "legacy_custom",
///         },
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewCustomSsl(ctx, "example", &cloudflare.CustomSslArgs{
/// 			CustomSslOptions: &cloudflare.CustomSslCustomSslOptionsArgs{
/// 				BundleMethod:    pulumi.String("ubiquitous"),
/// 				Certificate:     pulumi.String("-----INSERT CERTIFICATE-----"),
/// 				GeoRestrictions: pulumi.String("us"),
/// 				PrivateKey:      pulumi.String("-----INSERT PRIVATE KEY-----"),
/// 				Type:            pulumi.String("legacy_custom"),
/// 			},
/// 			ZoneId: pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.CustomSsl;
/// import com.pulumi.cloudflare.CustomSslArgs;
/// import com.pulumi.cloudflare.inputs.CustomSslCustomSslOptionsArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new CustomSsl("example", CustomSslArgs.builder()        
///             .customSslOptions(CustomSslCustomSslOptionsArgs.builder()
///                 .bundleMethod("ubiquitous")
///                 .certificate("-----INSERT CERTIFICATE-----")
///                 .geoRestrictions("us")
///                 .privateKey("-----INSERT PRIVATE KEY-----")
///                 .type("legacy_custom")
///                 .build())
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:CustomSsl
///     properties:
///       customSslOptions:
///         bundleMethod: ubiquitous
///         certificate: '-----INSERT CERTIFICATE-----'
///         geoRestrictions: us
///         privateKey: '-----INSERT PRIVATE KEY-----'
///         type: legacy_custom
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/customSsl:CustomSsl example <zone_id>/<certificate_id>
/// ```
///
pub mod custom_ssl {

    pub struct CustomSslArgs {
        /// The certificate associated parameters. **Modifying this attribute will force creation of a new resource.**
        pub custom_ssl_options:
            pulumi_wasm_rust::Output<Option<crate::types::CustomSslCustomSslOptions>>,
        pub custom_ssl_priorities:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::CustomSslCustomSslPriority>>>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct CustomSslResult {
        /// The certificate associated parameters. **Modifying this attribute will force creation of a new resource.**
        pub custom_ssl_options:
            pulumi_wasm_rust::Output<Option<crate::types::CustomSslCustomSslOptions>>,
        pub custom_ssl_priorities:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::CustomSslCustomSslPriority>>>,
        pub expires_on: pulumi_wasm_rust::Output<String>,
        pub hosts: pulumi_wasm_rust::Output<Vec<String>>,
        pub issuer: pulumi_wasm_rust::Output<String>,
        pub modified_on: pulumi_wasm_rust::Output<String>,
        pub priority: pulumi_wasm_rust::Output<i32>,
        pub signature: pulumi_wasm_rust::Output<String>,
        pub status: pulumi_wasm_rust::Output<String>,
        pub uploaded_on: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn custom_ssl(name: &str, args: CustomSslArgs) -> CustomSslResult {
        let result = crate::bindings::pulumi::cloudflare::custom_ssl::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::custom_ssl::Args {
                custom_ssl_options: args.custom_ssl_options.get_inner(),
                custom_ssl_priorities: args.custom_ssl_priorities.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        CustomSslResult {
            custom_ssl_options: crate::into_domain(result.custom_ssl_options),
            custom_ssl_priorities: crate::into_domain(result.custom_ssl_priorities),
            expires_on: crate::into_domain(result.expires_on),
            hosts: crate::into_domain(result.hosts),
            issuer: crate::into_domain(result.issuer),
            modified_on: crate::into_domain(result.modified_on),
            priority: crate::into_domain(result.priority),
            signature: crate::into_domain(result.signature),
            status: crate::into_domain(result.status),
            uploaded_on: crate::into_domain(result.uploaded_on),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// The [D1 Database](https://developers.cloudflare.com/d1/) resource allows you to manage Cloudflare D1 databases.
///
/// !> When a D1 Database is replaced all the data is lost. Please ensure you have a
///    backup of your data before replacing a D1 Database.
///
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.D1Database("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "terraform-database",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.D1Database("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="terraform-database")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.D1Database("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "terraform-database",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewD1Database(ctx, "example", &cloudflare.D1DatabaseArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:      pulumi.String("terraform-database"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.D1Database;
/// import com.pulumi.cloudflare.D1DatabaseArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new D1Database("example", D1DatabaseArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("terraform-database")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:D1Database
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       name: terraform-database
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/d1Database:D1Database example <account id>/<database id>
/// ```
///
pub mod d1_database {

    pub struct D1DatabaseArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the D1 Database.
        pub name: pulumi_wasm_rust::Output<String>,
    }

    pub struct D1DatabaseResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the D1 Database.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The backend version of the database.
        pub version: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn d_1_database(name: &str, args: D1DatabaseArgs) -> D1DatabaseResult {
        let result = crate::bindings::pulumi::cloudflare::d1_database::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::d1_database::Args {
                account_id: args.account_id.get_inner(),
                name: args.name.get_inner(),
            },
        );

        D1DatabaseResult {
            account_id: crate::into_domain(result.account_id),
            name: crate::into_domain(result.name),
            version: crate::into_domain(result.version),
        }
    }
}

/// Provides a Cloudflare Device Dex Test resource. Device Dex Tests allow for building location-aware device settings policies.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.DeviceDexTest("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     data: {
///         host: "https://example.com/home",
///         kind: "http",
///         method: "GET",
///     },
///     description: "Send a HTTP GET request to the home endpoint every half hour.",
///     enabled: true,
///     interval: "0h30m0s",
///     name: "GET homepage",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.DeviceDexTest("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     data=cloudflare.DeviceDexTestDataArgs(
///         host="https://example.com/home",
///         kind="http",
///         method="GET",
///     ),
///     description="Send a HTTP GET request to the home endpoint every half hour.",
///     enabled=True,
///     interval="0h30m0s",
///     name="GET homepage")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.DeviceDexTest("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Data = new Cloudflare.Inputs.DeviceDexTestDataArgs
///         {
///             Host = "https://example.com/home",
///             Kind = "http",
///             Method = "GET",
///         },
///         Description = "Send a HTTP GET request to the home endpoint every half hour.",
///         Enabled = true,
///         Interval = "0h30m0s",
///         Name = "GET homepage",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewDeviceDexTest(ctx, "example", &cloudflare.DeviceDexTestArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Data: &cloudflare.DeviceDexTestDataArgs{
/// 				Host:   pulumi.String("https://example.com/home"),
/// 				Kind:   pulumi.String("http"),
/// 				Method: pulumi.String("GET"),
/// 			},
/// 			Description: pulumi.String("Send a HTTP GET request to the home endpoint every half hour."),
/// 			Enabled:     pulumi.Bool(true),
/// 			Interval:    pulumi.String("0h30m0s"),
/// 			Name:        pulumi.String("GET homepage"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.DeviceDexTest;
/// import com.pulumi.cloudflare.DeviceDexTestArgs;
/// import com.pulumi.cloudflare.inputs.DeviceDexTestDataArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new DeviceDexTest("example", DeviceDexTestArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .data(DeviceDexTestDataArgs.builder()
///                 .host("https://example.com/home")
///                 .kind("http")
///                 .method("GET")
///                 .build())
///             .description("Send a HTTP GET request to the home endpoint every half hour.")
///             .enabled(true)
///             .interval("0h30m0s")
///             .name("GET homepage")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:DeviceDexTest
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       data:
///         host: https://example.com/home
///         kind: http
///         method: GET
///       description: Send a HTTP GET request to the home endpoint every half hour.
///       enabled: true
///       interval: 0h30m0s
///       name: GET homepage
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/deviceDexTest:DeviceDexTest example <account_id>/<device_dex_test_id>
/// ```
///
pub mod device_dex_test {

    pub struct DeviceDexTestArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The configuration object which contains the details for the WARP client to conduct the test.
        pub data: pulumi_wasm_rust::Output<crate::types::DeviceDexTestData>,
        /// Additional details about the test.
        pub description: pulumi_wasm_rust::Output<String>,
        /// Determines whether or not the test is active.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// How often the test will run.
        pub interval: pulumi_wasm_rust::Output<String>,
        /// The name of the Device Dex Test. Must be unique.
        pub name: pulumi_wasm_rust::Output<String>,
    }

    pub struct DeviceDexTestResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Timestamp of when the Dex Test was created.
        pub created: pulumi_wasm_rust::Output<String>,
        /// The configuration object which contains the details for the WARP client to conduct the test.
        pub data: pulumi_wasm_rust::Output<crate::types::DeviceDexTestData>,
        /// Additional details about the test.
        pub description: pulumi_wasm_rust::Output<String>,
        /// Determines whether or not the test is active.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// How often the test will run.
        pub interval: pulumi_wasm_rust::Output<String>,
        /// The name of the Device Dex Test. Must be unique.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Timestamp of when the Dex Test was last updated.
        pub updated: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn device_dex_test(name: &str, args: DeviceDexTestArgs) -> DeviceDexTestResult {
        let result = crate::bindings::pulumi::cloudflare::device_dex_test::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::device_dex_test::Args {
                account_id: args.account_id.get_inner(),
                data: args.data.get_inner(),
                description: args.description.get_inner(),
                enabled: args.enabled.get_inner(),
                interval: args.interval.get_inner(),
                name: args.name.get_inner(),
            },
        );

        DeviceDexTestResult {
            account_id: crate::into_domain(result.account_id),
            created: crate::into_domain(result.created),
            data: crate::into_domain(result.data),
            description: crate::into_domain(result.description),
            enabled: crate::into_domain(result.enabled),
            interval: crate::into_domain(result.interval),
            name: crate::into_domain(result.name),
            updated: crate::into_domain(result.updated),
        }
    }
}

/// Provides a Cloudflare Device Managed Network resource. Device managed networks allow for building location-aware device settings policies.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const managedNetworks = new cloudflare.DeviceManagedNetworks("managedNetworks", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     config: {
///         sha256: "b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c",
///         tlsSockaddr: "foobar:1234",
///     },
///     name: "managed-network-1",
///     type: "tls",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// managed_networks = cloudflare.DeviceManagedNetworks("managedNetworks",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     config=cloudflare.DeviceManagedNetworksConfigArgs(
///         sha256="b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c",
///         tls_sockaddr="foobar:1234",
///     ),
///     name="managed-network-1",
///     type="tls")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var managedNetworks = new Cloudflare.DeviceManagedNetworks("managedNetworks", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Config = new Cloudflare.Inputs.DeviceManagedNetworksConfigArgs
///         {
///             Sha256 = "b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c",
///             TlsSockaddr = "foobar:1234",
///         },
///         Name = "managed-network-1",
///         Type = "tls",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewDeviceManagedNetworks(ctx, "managedNetworks", &cloudflare.DeviceManagedNetworksArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Config: &cloudflare.DeviceManagedNetworksConfigArgs{
/// 				Sha256:      pulumi.String("b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c"),
/// 				TlsSockaddr: pulumi.String("foobar:1234"),
/// 			},
/// 			Name: pulumi.String("managed-network-1"),
/// 			Type: pulumi.String("tls"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.DeviceManagedNetworks;
/// import com.pulumi.cloudflare.DeviceManagedNetworksArgs;
/// import com.pulumi.cloudflare.inputs.DeviceManagedNetworksConfigArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var managedNetworks = new DeviceManagedNetworks("managedNetworks", DeviceManagedNetworksArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .config(DeviceManagedNetworksConfigArgs.builder()
///                 .sha256("b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c")
///                 .tlsSockaddr("foobar:1234")
///                 .build())
///             .name("managed-network-1")
///             .type("tls")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   managedNetworks:
///     type: cloudflare:DeviceManagedNetworks
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       config:
///         sha256: b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c
///         tlsSockaddr: foobar:1234
///       name: managed-network-1
///       type: tls
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/deviceManagedNetworks:DeviceManagedNetworks example <account_id>/<device_managed_networks_id>
/// ```
///
pub mod device_managed_networks {

    pub struct DeviceManagedNetworksArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The configuration containing information for the WARP client to detect the managed network.
        pub config: pulumi_wasm_rust::Output<crate::types::DeviceManagedNetworksConfig>,
        /// The name of the Device Managed Network. Must be unique.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The type of Device Managed Network. Available values: `tls`.
        pub type_: pulumi_wasm_rust::Output<String>,
    }

    pub struct DeviceManagedNetworksResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The configuration containing information for the WARP client to detect the managed network.
        pub config: pulumi_wasm_rust::Output<crate::types::DeviceManagedNetworksConfig>,
        /// The name of the Device Managed Network. Must be unique.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The type of Device Managed Network. Available values: `tls`.
        pub type_: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn device_managed_networks(
        name: &str,
        args: DeviceManagedNetworksArgs,
    ) -> DeviceManagedNetworksResult {
        let result = crate::bindings::pulumi::cloudflare::device_managed_networks::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::device_managed_networks::Args {
                account_id: args.account_id.get_inner(),
                config: args.config.get_inner(),
                name: args.name.get_inner(),
                type_: args.type_.get_inner(),
            },
        );

        DeviceManagedNetworksResult {
            account_id: crate::into_domain(result.account_id),
            config: crate::into_domain(result.config),
            name: crate::into_domain(result.name),
            type_: crate::into_domain(result.type_),
        }
    }
}

/// Provides a Cloudflare device policy certificates resource. Device
/// policy certificate resources enable client device certificate
/// generation.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.DevicePolicyCertificates("example", {
///     enabled: true,
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.DevicePolicyCertificates("example",
///     enabled=True,
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.DevicePolicyCertificates("example", new()
///     {
///         Enabled = true,
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewDevicePolicyCertificates(ctx, "example", &cloudflare.DevicePolicyCertificatesArgs{
/// 			Enabled: pulumi.Bool(true),
/// 			ZoneId:  pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.DevicePolicyCertificates;
/// import com.pulumi.cloudflare.DevicePolicyCertificatesArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new DevicePolicyCertificates("example", DevicePolicyCertificatesArgs.builder()        
///             .enabled(true)
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:DevicePolicyCertificates
///     properties:
///       enabled: true
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/devicePolicyCertificates:DevicePolicyCertificates example <zone_id>
/// ```
///
pub mod device_policy_certificates {

    pub struct DevicePolicyCertificatesArgs {
        /// `true` if certificate generation is enabled.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct DevicePolicyCertificatesResult {
        /// `true` if certificate generation is enabled.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn device_policy_certificates(
        name: &str,
        args: DevicePolicyCertificatesArgs,
    ) -> DevicePolicyCertificatesResult {
        let result = crate::bindings::pulumi::cloudflare::device_policy_certificates::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::device_policy_certificates::Args {
                enabled: args.enabled.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        DevicePolicyCertificatesResult {
            enabled: crate::into_domain(result.enabled),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare Device Posture Integration resource. Device
/// posture integrations configure third-party data providers for device
/// posture rules.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.DevicePostureIntegration("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     configs: [{
///         apiUrl: "https://example.com/api",
///         authUrl: "https://example.com/connect/token",
///         clientId: "client-id",
///         clientSecret: "client-secret",
///     }],
///     interval: "24h",
///     name: "Device posture integration",
///     type: "workspace_one",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.DevicePostureIntegration("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     configs=[cloudflare.DevicePostureIntegrationConfigArgs(
///         api_url="https://example.com/api",
///         auth_url="https://example.com/connect/token",
///         client_id="client-id",
///         client_secret="client-secret",
///     )],
///     interval="24h",
///     name="Device posture integration",
///     type="workspace_one")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.DevicePostureIntegration("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Configs = new[]
///         {
///             new Cloudflare.Inputs.DevicePostureIntegrationConfigArgs
///             {
///                 ApiUrl = "https://example.com/api",
///                 AuthUrl = "https://example.com/connect/token",
///                 ClientId = "client-id",
///                 ClientSecret = "client-secret",
///             },
///         },
///         Interval = "24h",
///         Name = "Device posture integration",
///         Type = "workspace_one",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewDevicePostureIntegration(ctx, "example", &cloudflare.DevicePostureIntegrationArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Configs: cloudflare.DevicePostureIntegrationConfigArray{
/// 				&cloudflare.DevicePostureIntegrationConfigArgs{
/// 					ApiUrl:       pulumi.String("https://example.com/api"),
/// 					AuthUrl:      pulumi.String("https://example.com/connect/token"),
/// 					ClientId:     pulumi.String("client-id"),
/// 					ClientSecret: pulumi.String("client-secret"),
/// 				},
/// 			},
/// 			Interval: pulumi.String("24h"),
/// 			Name:     pulumi.String("Device posture integration"),
/// 			Type:     pulumi.String("workspace_one"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.DevicePostureIntegration;
/// import com.pulumi.cloudflare.DevicePostureIntegrationArgs;
/// import com.pulumi.cloudflare.inputs.DevicePostureIntegrationConfigArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new DevicePostureIntegration("example", DevicePostureIntegrationArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .configs(DevicePostureIntegrationConfigArgs.builder()
///                 .apiUrl("https://example.com/api")
///                 .authUrl("https://example.com/connect/token")
///                 .clientId("client-id")
///                 .clientSecret("client-secret")
///                 .build())
///             .interval("24h")
///             .name("Device posture integration")
///             .type("workspace_one")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:DevicePostureIntegration
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       configs:
///         - apiUrl: https://example.com/api
///           authUrl: https://example.com/connect/token
///           clientId: client-id
///           clientSecret: client-secret
///       interval: 24h
///       name: Device posture integration
///       type: workspace_one
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/devicePostureIntegration:DevicePostureIntegration example <account_id>/<device_posture_integration_id>
/// ```
///
pub mod device_posture_integration {

    pub struct DevicePostureIntegrationArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The device posture integration's connection authorization parameters.
        pub configs:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::DevicePostureIntegrationConfig>>>,
        pub identifier: pulumi_wasm_rust::Output<Option<String>>,
        /// Indicates the frequency with which to poll the third-party API. Must be in the format `1h` or `30m`.
        pub interval: pulumi_wasm_rust::Output<Option<String>>,
        /// Name of the device posture integration.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The device posture integration type. Available values: `workspace_one`, `uptycs`, `crowdstrike_s2s`, `intune`, `kolide`, `sentinelone_s2s`, `tanium_s2s`.
        pub type_: pulumi_wasm_rust::Output<String>,
    }

    pub struct DevicePostureIntegrationResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The device posture integration's connection authorization parameters.
        pub configs:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::DevicePostureIntegrationConfig>>>,
        pub identifier: pulumi_wasm_rust::Output<Option<String>>,
        /// Indicates the frequency with which to poll the third-party API. Must be in the format `1h` or `30m`.
        pub interval: pulumi_wasm_rust::Output<Option<String>>,
        /// Name of the device posture integration.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The device posture integration type. Available values: `workspace_one`, `uptycs`, `crowdstrike_s2s`, `intune`, `kolide`, `sentinelone_s2s`, `tanium_s2s`.
        pub type_: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn device_posture_integration(
        name: &str,
        args: DevicePostureIntegrationArgs,
    ) -> DevicePostureIntegrationResult {
        let result = crate::bindings::pulumi::cloudflare::device_posture_integration::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::device_posture_integration::Args {
                account_id: args.account_id.get_inner(),
                configs: args.configs.get_inner(),
                identifier: args.identifier.get_inner(),
                interval: args.interval.get_inner(),
                name: args.name.get_inner(),
                type_: args.type_.get_inner(),
            },
        );

        DevicePostureIntegrationResult {
            account_id: crate::into_domain(result.account_id),
            configs: crate::into_domain(result.configs),
            identifier: crate::into_domain(result.identifier),
            interval: crate::into_domain(result.interval),
            name: crate::into_domain(result.name),
            type_: crate::into_domain(result.type_),
        }
    }
}

/// Provides a Cloudflare Device Posture Rule resource. Device posture rules configure security policies for device posture checks.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const eaxmple = new cloudflare.DevicePostureRule("eaxmple", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "Corporate devices posture rule",
///     type: "os_version",
///     description: "Device posture rule for corporate devices.",
///     schedule: "24h",
///     expiration: "24h",
///     matches: [{
///         platform: "linux",
///     }],
///     inputs: [{
///         id: cloudflare_teams_list.corporate_devices.id,
///         version: "1.0.0",
///         operator: "<",
///         osDistroName: "ubuntu",
///         osDistroRevision: "1.0.0",
///     }],
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// eaxmple = cloudflare.DevicePostureRule("eaxmple",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="Corporate devices posture rule",
///     type="os_version",
///     description="Device posture rule for corporate devices.",
///     schedule="24h",
///     expiration="24h",
///     matches=[cloudflare.DevicePostureRuleMatchArgs(
///         platform="linux",
///     )],
///     inputs=[cloudflare.DevicePostureRuleInputArgs(
///         id=cloudflare_teams_list["corporate_devices"]["id"],
///         version="1.0.0",
///         operator="<",
///         os_distro_name="ubuntu",
///         os_distro_revision="1.0.0",
///     )])
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var eaxmple = new Cloudflare.DevicePostureRule("eaxmple", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "Corporate devices posture rule",
///         Type = "os_version",
///         Description = "Device posture rule for corporate devices.",
///         Schedule = "24h",
///         Expiration = "24h",
///         Matches = new[]
///         {
///             new Cloudflare.Inputs.DevicePostureRuleMatchArgs
///             {
///                 Platform = "linux",
///             },
///         },
///         Inputs = new[]
///         {
///             new Cloudflare.Inputs.DevicePostureRuleInputArgs
///             {
///                 Id = cloudflare_teams_list.Corporate_devices.Id,
///                 Version = "1.0.0",
///                 Operator = "<",
///                 OsDistroName = "ubuntu",
///                 OsDistroRevision = "1.0.0",
///             },
///         },
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewDevicePostureRule(ctx, "eaxmple", &cloudflare.DevicePostureRuleArgs{
/// 			AccountId:   pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:        pulumi.String("Corporate devices posture rule"),
/// 			Type:        pulumi.String("os_version"),
/// 			Description: pulumi.String("Device posture rule for corporate devices."),
/// 			Schedule:    pulumi.String("24h"),
/// 			Expiration:  pulumi.String("24h"),
/// 			Matches: cloudflare.DevicePostureRuleMatchArray{
/// 				&cloudflare.DevicePostureRuleMatchArgs{
/// 					Platform: pulumi.String("linux"),
/// 				},
/// 			},
/// 			Inputs: cloudflare.DevicePostureRuleInputTypeArray{
/// 				&cloudflare.DevicePostureRuleInputTypeArgs{
/// 					Id:               pulumi.Any(cloudflare_teams_list.Corporate_devices.Id),
/// 					Version:          pulumi.String("1.0.0"),
/// 					Operator:         pulumi.String("<"),
/// 					OsDistroName:     pulumi.String("ubuntu"),
/// 					OsDistroRevision: pulumi.String("1.0.0"),
/// 				},
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.DevicePostureRule;
/// import com.pulumi.cloudflare.DevicePostureRuleArgs;
/// import com.pulumi.cloudflare.inputs.DevicePostureRuleMatchArgs;
/// import com.pulumi.cloudflare.inputs.DevicePostureRuleInputArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var eaxmple = new DevicePostureRule("eaxmple", DevicePostureRuleArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("Corporate devices posture rule")
///             .type("os_version")
///             .description("Device posture rule for corporate devices.")
///             .schedule("24h")
///             .expiration("24h")
///             .matches(DevicePostureRuleMatchArgs.builder()
///                 .platform("linux")
///                 .build())
///             .inputs(DevicePostureRuleInputArgs.builder()
///                 .id(cloudflare_teams_list.corporate_devices().id())
///                 .version("1.0.0")
///                 .operator("<")
///                 .osDistroName("ubuntu")
///                 .osDistroRevision("1.0.0")
///                 .build())
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   eaxmple:
///     type: cloudflare:DevicePostureRule
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       name: Corporate devices posture rule
///       type: os_version
///       description: Device posture rule for corporate devices.
///       schedule: 24h
///       expiration: 24h
///       matches:
///         - platform: linux
///       inputs:
///         - id: ${cloudflare_teams_list.corporate_devices.id}
///           version: 1.0.0
///           operator: <
///           osDistroName: ubuntu
///           osDistroRevision: 1.0.0
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/devicePostureRule:DevicePostureRule example <account_id>/<device_posture_rule_id>
/// ```
///
pub mod device_posture_rule {

    pub struct DevicePostureRuleArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Expire posture results after the specified amount of time. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.
        pub expiration: pulumi_wasm_rust::Output<Option<String>>,
        /// Required for all rule types except `warp`, `gateway`, and `tanium`.
        pub inputs: pulumi_wasm_rust::Output<Option<Vec<crate::types::DevicePostureRuleInput>>>,
        /// The conditions that the client must match to run the rule.
        pub matches: pulumi_wasm_rust::Output<Option<Vec<crate::types::DevicePostureRuleMatch>>>,
        /// Name of the device posture rule.
        pub name: pulumi_wasm_rust::Output<Option<String>>,
        /// Tells the client when to run the device posture check. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.
        pub schedule: pulumi_wasm_rust::Output<Option<String>>,
        /// The device posture rule type. Available values: `serial_number`, `file`, `application`, `gateway`, `warp`, `domain_joined`, `os_version`, `disk_encryption`, `firewall`, `client_certificate`, `workspace_one`, `unique_client_id`, `crowdstrike_s2s`, `sentinelone`, `kolide`, `tanium_s2s`, `intune`, `sentinelone_s2s`.
        pub type_: pulumi_wasm_rust::Output<String>,
    }

    pub struct DevicePostureRuleResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Expire posture results after the specified amount of time. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.
        pub expiration: pulumi_wasm_rust::Output<Option<String>>,
        /// Required for all rule types except `warp`, `gateway`, and `tanium`.
        pub inputs: pulumi_wasm_rust::Output<Vec<crate::types::DevicePostureRuleInput>>,
        /// The conditions that the client must match to run the rule.
        pub matches: pulumi_wasm_rust::Output<Option<Vec<crate::types::DevicePostureRuleMatch>>>,
        /// Name of the device posture rule.
        pub name: pulumi_wasm_rust::Output<Option<String>>,
        /// Tells the client when to run the device posture check. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.
        pub schedule: pulumi_wasm_rust::Output<Option<String>>,
        /// The device posture rule type. Available values: `serial_number`, `file`, `application`, `gateway`, `warp`, `domain_joined`, `os_version`, `disk_encryption`, `firewall`, `client_certificate`, `workspace_one`, `unique_client_id`, `crowdstrike_s2s`, `sentinelone`, `kolide`, `tanium_s2s`, `intune`, `sentinelone_s2s`.
        pub type_: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn device_posture_rule(name: &str, args: DevicePostureRuleArgs) -> DevicePostureRuleResult {
        let result = crate::bindings::pulumi::cloudflare::device_posture_rule::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::device_posture_rule::Args {
                account_id: args.account_id.get_inner(),
                description: args.description.get_inner(),
                expiration: args.expiration.get_inner(),
                inputs: args.inputs.get_inner(),
                matches: args.matches.get_inner(),
                name: args.name.get_inner(),
                schedule: args.schedule.get_inner(),
                type_: args.type_.get_inner(),
            },
        );

        DevicePostureRuleResult {
            account_id: crate::into_domain(result.account_id),
            description: crate::into_domain(result.description),
            expiration: crate::into_domain(result.expiration),
            inputs: crate::into_domain(result.inputs),
            matches: crate::into_domain(result.matches),
            name: crate::into_domain(result.name),
            schedule: crate::into_domain(result.schedule),
            type_: crate::into_domain(result.type_),
        }
    }
}

/// Provides a Cloudflare Device Settings Policy resource. Device policies configure settings applied to WARP devices.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const developerWarpPolicy = new cloudflare.DeviceSettingsPolicy("developerWarpPolicy", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     allowModeSwitch: true,
///     allowUpdates: true,
///     allowedToLeave: true,
///     autoConnect: 0,
///     captivePortal: 5,
///     "default": false,
///     description: "Developers WARP settings policy description",
///     disableAutoFallback: true,
///     enabled: true,
///     excludeOfficeIps: false,
///     match: "any(identity.groups.name[*] in {\"Developers\"})",
///     name: "Developers WARP settings policy",
///     precedence: 10,
///     serviceModeV2Mode: "warp",
///     serviceModeV2Port: 3000,
///     supportUrl: "https://cloudflare.com",
///     switchLocked: true,
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// developer_warp_policy = cloudflare.DeviceSettingsPolicy("developerWarpPolicy",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     allow_mode_switch=True,
///     allow_updates=True,
///     allowed_to_leave=True,
///     auto_connect=0,
///     captive_portal=5,
///     default=False,
///     description="Developers WARP settings policy description",
///     disable_auto_fallback=True,
///     enabled=True,
///     exclude_office_ips=False,
///     match="any(identity.groups.name[*] in {\"Developers\"})",
///     name="Developers WARP settings policy",
///     precedence=10,
///     service_mode_v2_mode="warp",
///     service_mode_v2_port=3000,
///     support_url="https://cloudflare.com",
///     switch_locked=True)
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var developerWarpPolicy = new Cloudflare.DeviceSettingsPolicy("developerWarpPolicy", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         AllowModeSwitch = true,
///         AllowUpdates = true,
///         AllowedToLeave = true,
///         AutoConnect = 0,
///         CaptivePortal = 5,
///         Default = false,
///         Description = "Developers WARP settings policy description",
///         DisableAutoFallback = true,
///         Enabled = true,
///         ExcludeOfficeIps = false,
///         Match = "any(identity.groups.name[*] in {\"Developers\"})",
///         Name = "Developers WARP settings policy",
///         Precedence = 10,
///         ServiceModeV2Mode = "warp",
///         ServiceModeV2Port = 3000,
///         SupportUrl = "https://cloudflare.com",
///         SwitchLocked = true,
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewDeviceSettingsPolicy(ctx, "developerWarpPolicy", &cloudflare.DeviceSettingsPolicyArgs{
/// 			AccountId:           pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			AllowModeSwitch:     pulumi.Bool(true),
/// 			AllowUpdates:        pulumi.Bool(true),
/// 			AllowedToLeave:      pulumi.Bool(true),
/// 			AutoConnect:         pulumi.Int(0),
/// 			CaptivePortal:       pulumi.Int(5),
/// 			Default:             pulumi.Bool(false),
/// 			Description:         pulumi.String("Developers WARP settings policy description"),
/// 			DisableAutoFallback: pulumi.Bool(true),
/// 			Enabled:             pulumi.Bool(true),
/// 			ExcludeOfficeIps:    pulumi.Bool(false),
/// 			Match:               pulumi.String("any(identity.groups.name[*] in {\"Developers\"})"),
/// 			Name:                pulumi.String("Developers WARP settings policy"),
/// 			Precedence:          pulumi.Int(10),
/// 			ServiceModeV2Mode:   pulumi.String("warp"),
/// 			ServiceModeV2Port:   pulumi.Int(3000),
/// 			SupportUrl:          pulumi.String("https://cloudflare.com"),
/// 			SwitchLocked:        pulumi.Bool(true),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.DeviceSettingsPolicy;
/// import com.pulumi.cloudflare.DeviceSettingsPolicyArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var developerWarpPolicy = new DeviceSettingsPolicy("developerWarpPolicy", DeviceSettingsPolicyArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .allowModeSwitch(true)
///             .allowUpdates(true)
///             .allowedToLeave(true)
///             .autoConnect(0)
///             .captivePortal(5)
///             .default_(false)
///             .description("Developers WARP settings policy description")
///             .disableAutoFallback(true)
///             .enabled(true)
///             .excludeOfficeIps(false)
///             .match("any(identity.groups.name[*] in {\"Developers\"})")
///             .name("Developers WARP settings policy")
///             .precedence(10)
///             .serviceModeV2Mode("warp")
///             .serviceModeV2Port(3000)
///             .supportUrl("https://cloudflare.com")
///             .switchLocked(true)
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   developerWarpPolicy:
///     type: cloudflare:DeviceSettingsPolicy
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       allowModeSwitch: true
///       allowUpdates: true
///       allowedToLeave: true
///       autoConnect: 0
///       captivePortal: 5
///       default: false
///       description: Developers WARP settings policy description
///       disableAutoFallback: true
///       enabled: true
///       excludeOfficeIps: false
///       match: any(identity.groups.name[*] in {"Developers"})
///       name: Developers WARP settings policy
///       precedence: 10
///       serviceModeV2Mode: warp
///       serviceModeV2Port: 3000
///       supportUrl: https://cloudflare.com
///       switchLocked: true
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// For default device settings policies you must use "default" as the policy ID.
///
/// ```sh
/// $ pulumi import cloudflare:index/deviceSettingsPolicy:DeviceSettingsPolicy example <account_id>/<device_policy_id>
/// ```
///
pub mod device_settings_policy {

    pub struct DeviceSettingsPolicyArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether to allow mode switch for this policy.
        pub allow_mode_switch: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to allow updates under this policy.
        pub allow_updates: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to allow devices to leave the organization. Defaults to `true`.
        pub allowed_to_leave: pulumi_wasm_rust::Output<Option<bool>>,
        /// The amount of time in seconds to reconnect after having been disabled.
        pub auto_connect: pulumi_wasm_rust::Output<Option<i32>>,
        /// The captive portal value for this policy. Defaults to `180`.
        pub captive_portal: pulumi_wasm_rust::Output<Option<i32>>,
        /// Whether the policy refers to the default account policy.
        pub default: pulumi_wasm_rust::Output<Option<bool>>,
        /// Description of Policy.
        pub description: pulumi_wasm_rust::Output<String>,
        /// Whether to disable auto fallback for this policy.
        pub disable_auto_fallback: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether the policy is enabled (cannot be set for default policies). Defaults to `true`.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to add Microsoft IPs to split tunnel exclusions.
        pub exclude_office_ips: pulumi_wasm_rust::Output<Option<bool>>,
        /// Wirefilter expression to match a device against when evaluating whether this policy should take effect for that device.
        pub match_: pulumi_wasm_rust::Output<Option<String>>,
        /// Name of the policy.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The precedence of the policy. Lower values indicate higher precedence.
        pub precedence: pulumi_wasm_rust::Output<Option<i32>>,
        /// The service mode. Available values: `1dot1`, `warp`, `proxy`, `posture_only`, `warp_tunnel_only`. Defaults to `warp`.
        pub service_mode_v2_mode: pulumi_wasm_rust::Output<Option<String>>,
        /// The port to use for the proxy service mode. Required when using `service_mode_v2_mode`.
        pub service_mode_v2_port: pulumi_wasm_rust::Output<Option<i32>>,
        /// The support URL that will be opened when sending feedback.
        pub support_url: pulumi_wasm_rust::Output<Option<String>>,
        /// Enablement of the ZT client switch lock.
        pub switch_locked: pulumi_wasm_rust::Output<Option<bool>>,
    }

    pub struct DeviceSettingsPolicyResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether to allow mode switch for this policy.
        pub allow_mode_switch: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to allow updates under this policy.
        pub allow_updates: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to allow devices to leave the organization. Defaults to `true`.
        pub allowed_to_leave: pulumi_wasm_rust::Output<Option<bool>>,
        /// The amount of time in seconds to reconnect after having been disabled.
        pub auto_connect: pulumi_wasm_rust::Output<Option<i32>>,
        /// The captive portal value for this policy. Defaults to `180`.
        pub captive_portal: pulumi_wasm_rust::Output<Option<i32>>,
        /// Whether the policy refers to the default account policy.
        pub default: pulumi_wasm_rust::Output<Option<bool>>,
        /// Description of Policy.
        pub description: pulumi_wasm_rust::Output<String>,
        /// Whether to disable auto fallback for this policy.
        pub disable_auto_fallback: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether the policy is enabled (cannot be set for default policies). Defaults to `true`.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to add Microsoft IPs to split tunnel exclusions.
        pub exclude_office_ips: pulumi_wasm_rust::Output<Option<bool>>,
        /// Wirefilter expression to match a device against when evaluating whether this policy should take effect for that device.
        pub match_: pulumi_wasm_rust::Output<Option<String>>,
        /// Name of the policy.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The precedence of the policy. Lower values indicate higher precedence.
        pub precedence: pulumi_wasm_rust::Output<Option<i32>>,
        /// The service mode. Available values: `1dot1`, `warp`, `proxy`, `posture_only`, `warp_tunnel_only`. Defaults to `warp`.
        pub service_mode_v2_mode: pulumi_wasm_rust::Output<Option<String>>,
        /// The port to use for the proxy service mode. Required when using `service_mode_v2_mode`.
        pub service_mode_v2_port: pulumi_wasm_rust::Output<Option<i32>>,
        /// The support URL that will be opened when sending feedback.
        pub support_url: pulumi_wasm_rust::Output<Option<String>>,
        /// Enablement of the ZT client switch lock.
        pub switch_locked: pulumi_wasm_rust::Output<Option<bool>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn device_settings_policy(
        name: &str,
        args: DeviceSettingsPolicyArgs,
    ) -> DeviceSettingsPolicyResult {
        let result = crate::bindings::pulumi::cloudflare::device_settings_policy::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::device_settings_policy::Args {
                account_id: args.account_id.get_inner(),
                allow_mode_switch: args.allow_mode_switch.get_inner(),
                allow_updates: args.allow_updates.get_inner(),
                allowed_to_leave: args.allowed_to_leave.get_inner(),
                auto_connect: args.auto_connect.get_inner(),
                captive_portal: args.captive_portal.get_inner(),
                default: args.default.get_inner(),
                description: args.description.get_inner(),
                disable_auto_fallback: args.disable_auto_fallback.get_inner(),
                enabled: args.enabled.get_inner(),
                exclude_office_ips: args.exclude_office_ips.get_inner(),
                match_: args.match_.get_inner(),
                name: args.name.get_inner(),
                precedence: args.precedence.get_inner(),
                service_mode_v2_mode: args.service_mode_v2_mode.get_inner(),
                service_mode_v2_port: args.service_mode_v2_port.get_inner(),
                support_url: args.support_url.get_inner(),
                switch_locked: args.switch_locked.get_inner(),
            },
        );

        DeviceSettingsPolicyResult {
            account_id: crate::into_domain(result.account_id),
            allow_mode_switch: crate::into_domain(result.allow_mode_switch),
            allow_updates: crate::into_domain(result.allow_updates),
            allowed_to_leave: crate::into_domain(result.allowed_to_leave),
            auto_connect: crate::into_domain(result.auto_connect),
            captive_portal: crate::into_domain(result.captive_portal),
            default: crate::into_domain(result.default),
            description: crate::into_domain(result.description),
            disable_auto_fallback: crate::into_domain(result.disable_auto_fallback),
            enabled: crate::into_domain(result.enabled),
            exclude_office_ips: crate::into_domain(result.exclude_office_ips),
            match_: crate::into_domain(result.match_),
            name: crate::into_domain(result.name),
            precedence: crate::into_domain(result.precedence),
            service_mode_v2_mode: crate::into_domain(result.service_mode_v2_mode),
            service_mode_v2_port: crate::into_domain(result.service_mode_v2_port),
            support_url: crate::into_domain(result.support_url),
            switch_locked: crate::into_domain(result.switch_locked),
        }
    }
}

/// Provides a Cloudflare DLP Profile resource. Data Loss Prevention profiles
/// are a set of entries that can be matched in HTTP bodies or files.
/// They are referenced in Zero Trust Gateway rules.
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/dlpProfile:DlpProfile example <account_id>/<dlp_profile_id>
/// ```
///
pub mod dlp_profile {

    pub struct DlpProfileArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Related DLP policies will trigger when the match count exceeds the number set.
        pub allowed_match_count: pulumi_wasm_rust::Output<i32>,
        /// Scan the context of predefined entries to only return matches surrounded by keywords.
        pub context_awareness:
            pulumi_wasm_rust::Output<Option<crate::types::DlpProfileContextAwareness>>,
        /// Brief summary of the profile and its intended use.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// List of entries to apply to the profile.
        pub entries: pulumi_wasm_rust::Output<Vec<crate::types::DlpProfileEntry>>,
        /// Name of the entry to deploy.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The type of the profile. Available values: `custom`, `predefined`. **Modifying this attribute will force creation of a new resource.**
        pub type_: pulumi_wasm_rust::Output<String>,
    }

    pub struct DlpProfileResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Related DLP policies will trigger when the match count exceeds the number set.
        pub allowed_match_count: pulumi_wasm_rust::Output<i32>,
        /// Scan the context of predefined entries to only return matches surrounded by keywords.
        pub context_awareness: pulumi_wasm_rust::Output<crate::types::DlpProfileContextAwareness>,
        /// Brief summary of the profile and its intended use.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// List of entries to apply to the profile.
        pub entries: pulumi_wasm_rust::Output<Vec<crate::types::DlpProfileEntry>>,
        /// Name of the entry to deploy.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The type of the profile. Available values: `custom`, `predefined`. **Modifying this attribute will force creation of a new resource.**
        pub type_: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn dlp_profile(name: &str, args: DlpProfileArgs) -> DlpProfileResult {
        let result = crate::bindings::pulumi::cloudflare::dlp_profile::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::dlp_profile::Args {
                account_id: args.account_id.get_inner(),
                allowed_match_count: args.allowed_match_count.get_inner(),
                context_awareness: args.context_awareness.get_inner(),
                description: args.description.get_inner(),
                entries: args.entries.get_inner(),
                name: args.name.get_inner(),
                type_: args.type_.get_inner(),
            },
        );

        DlpProfileResult {
            account_id: crate::into_domain(result.account_id),
            allowed_match_count: crate::into_domain(result.allowed_match_count),
            context_awareness: crate::into_domain(result.context_awareness),
            description: crate::into_domain(result.description),
            entries: crate::into_domain(result.entries),
            name: crate::into_domain(result.name),
            type_: crate::into_domain(result.type_),
        }
    }
}

/// The [Email Routing Address](https://developers.cloudflare.com/email-routing/setup/email-routing-addresses/#destination-addresses) resource allows you to manage Cloudflare Email Routing Destination Addresses.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.EmailRoutingAddress("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     email: "user@example.com",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.EmailRoutingAddress("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     email="user@example.com")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.EmailRoutingAddress("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Email = "user@example.com",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewEmailRoutingAddress(ctx, "example", &cloudflare.EmailRoutingAddressArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Email:     pulumi.String("user@example.com"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.EmailRoutingAddress;
/// import com.pulumi.cloudflare.EmailRoutingAddressArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new EmailRoutingAddress("example", EmailRoutingAddressArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .email("user@example.com")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:EmailRoutingAddress
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       email: user@example.com
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/emailRoutingAddress:EmailRoutingAddress example <account_id>/<email_routing_id>
/// ```
///
pub mod email_routing_address {

    pub struct EmailRoutingAddressArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The contact email address of the user.
        pub email: pulumi_wasm_rust::Output<String>,
    }

    pub struct EmailRoutingAddressResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The date and time the destination address has been created.
        pub created: pulumi_wasm_rust::Output<String>,
        /// The contact email address of the user.
        pub email: pulumi_wasm_rust::Output<String>,
        /// The date and time the destination address has been modified.
        pub modified: pulumi_wasm_rust::Output<String>,
        /// Destination address identifier.
        pub tag: pulumi_wasm_rust::Output<String>,
        /// The date and time the destination address has been verified. Null means not verified yet.
        pub verified: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn email_routing_address(
        name: &str,
        args: EmailRoutingAddressArgs,
    ) -> EmailRoutingAddressResult {
        let result = crate::bindings::pulumi::cloudflare::email_routing_address::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::email_routing_address::Args {
                account_id: args.account_id.get_inner(),
                email: args.email.get_inner(),
            },
        );

        EmailRoutingAddressResult {
            account_id: crate::into_domain(result.account_id),
            created: crate::into_domain(result.created),
            email: crate::into_domain(result.email),
            modified: crate::into_domain(result.modified),
            tag: crate::into_domain(result.tag),
            verified: crate::into_domain(result.verified),
        }
    }
}

/// Provides a resource for managing Email Routing Addresses catch all behaviour.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.EmailRoutingCatchAll("example", {
///     actions: [{
///         type: "forward",
///         values: ["destinationaddress@example.net"],
///     }],
///     enabled: true,
///     matchers: [{
///         type: "all",
///     }],
///     name: "example catch all",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.EmailRoutingCatchAll("example",
///     actions=[cloudflare.EmailRoutingCatchAllActionArgs(
///         type="forward",
///         values=["destinationaddress@example.net"],
///     )],
///     enabled=True,
///     matchers=[cloudflare.EmailRoutingCatchAllMatcherArgs(
///         type="all",
///     )],
///     name="example catch all",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.EmailRoutingCatchAll("example", new()
///     {
///         Actions = new[]
///         {
///             new Cloudflare.Inputs.EmailRoutingCatchAllActionArgs
///             {
///                 Type = "forward",
///                 Values = new[]
///                 {
///                     "destinationaddress@example.net",
///                 },
///             },
///         },
///         Enabled = true,
///         Matchers = new[]
///         {
///             new Cloudflare.Inputs.EmailRoutingCatchAllMatcherArgs
///             {
///                 Type = "all",
///             },
///         },
///         Name = "example catch all",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewEmailRoutingCatchAll(ctx, "example", &cloudflare.EmailRoutingCatchAllArgs{
/// 			Actions: cloudflare.EmailRoutingCatchAllActionArray{
/// 				&cloudflare.EmailRoutingCatchAllActionArgs{
/// 					Type: pulumi.String("forward"),
/// 					Values: pulumi.StringArray{
/// 						pulumi.String("destinationaddress@example.net"),
/// 					},
/// 				},
/// 			},
/// 			Enabled: pulumi.Bool(true),
/// 			Matchers: cloudflare.EmailRoutingCatchAllMatcherArray{
/// 				&cloudflare.EmailRoutingCatchAllMatcherArgs{
/// 					Type: pulumi.String("all"),
/// 				},
/// 			},
/// 			Name:   pulumi.String("example catch all"),
/// 			ZoneId: pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.EmailRoutingCatchAll;
/// import com.pulumi.cloudflare.EmailRoutingCatchAllArgs;
/// import com.pulumi.cloudflare.inputs.EmailRoutingCatchAllActionArgs;
/// import com.pulumi.cloudflare.inputs.EmailRoutingCatchAllMatcherArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new EmailRoutingCatchAll("example", EmailRoutingCatchAllArgs.builder()        
///             .actions(EmailRoutingCatchAllActionArgs.builder()
///                 .type("forward")
///                 .values("destinationaddress@example.net")
///                 .build())
///             .enabled(true)
///             .matchers(EmailRoutingCatchAllMatcherArgs.builder()
///                 .type("all")
///                 .build())
///             .name("example catch all")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:EmailRoutingCatchAll
///     properties:
///       actions:
///         - type: forward
///           values:
///             - destinationaddress@example.net
///       enabled: true
///       matchers:
///         - type: all
///       name: example catch all
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
pub mod email_routing_catch_all {

    pub struct EmailRoutingCatchAllArgs {
        /// List actions patterns.
        pub actions: pulumi_wasm_rust::Output<Vec<crate::types::EmailRoutingCatchAllAction>>,
        /// Routing rule status.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Matching patterns to forward to your actions.
        pub matchers: pulumi_wasm_rust::Output<Vec<crate::types::EmailRoutingCatchAllMatcher>>,
        /// Routing rule name.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct EmailRoutingCatchAllResult {
        /// List actions patterns.
        pub actions: pulumi_wasm_rust::Output<Vec<crate::types::EmailRoutingCatchAllAction>>,
        /// Routing rule status.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Matching patterns to forward to your actions.
        pub matchers: pulumi_wasm_rust::Output<Vec<crate::types::EmailRoutingCatchAllMatcher>>,
        /// Routing rule name.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Routing rule identifier.
        pub tag: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn email_routing_catch_all(
        name: &str,
        args: EmailRoutingCatchAllArgs,
    ) -> EmailRoutingCatchAllResult {
        let result = crate::bindings::pulumi::cloudflare::email_routing_catch_all::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::email_routing_catch_all::Args {
                actions: args.actions.get_inner(),
                enabled: args.enabled.get_inner(),
                matchers: args.matchers.get_inner(),
                name: args.name.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        EmailRoutingCatchAllResult {
            actions: crate::into_domain(result.actions),
            enabled: crate::into_domain(result.enabled),
            matchers: crate::into_domain(result.matchers),
            name: crate::into_domain(result.name),
            tag: crate::into_domain(result.tag),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// The [Email Routing Rule](https://developers.cloudflare.com/email-routing/setup/email-routing-addresses/#email-rule-actions) resource allows you to create and manage email routing rules for a zone.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const main = new cloudflare.EmailRoutingRule("main", {
///     actions: [{
///         type: "forward",
///         values: ["destinationaddress@example.net"],
///     }],
///     enabled: true,
///     matchers: [{
///         field: "to",
///         type: "literal",
///         value: "test@example.com",
///     }],
///     name: "terraform rule",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// main = cloudflare.EmailRoutingRule("main",
///     actions=[cloudflare.EmailRoutingRuleActionArgs(
///         type="forward",
///         values=["destinationaddress@example.net"],
///     )],
///     enabled=True,
///     matchers=[cloudflare.EmailRoutingRuleMatcherArgs(
///         field="to",
///         type="literal",
///         value="test@example.com",
///     )],
///     name="terraform rule",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var main = new Cloudflare.EmailRoutingRule("main", new()
///     {
///         Actions = new[]
///         {
///             new Cloudflare.Inputs.EmailRoutingRuleActionArgs
///             {
///                 Type = "forward",
///                 Values = new[]
///                 {
///                     "destinationaddress@example.net",
///                 },
///             },
///         },
///         Enabled = true,
///         Matchers = new[]
///         {
///             new Cloudflare.Inputs.EmailRoutingRuleMatcherArgs
///             {
///                 Field = "to",
///                 Type = "literal",
///                 Value = "test@example.com",
///             },
///         },
///         Name = "terraform rule",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewEmailRoutingRule(ctx, "main", &cloudflare.EmailRoutingRuleArgs{
/// 			Actions: cloudflare.EmailRoutingRuleActionArray{
/// 				&cloudflare.EmailRoutingRuleActionArgs{
/// 					Type: pulumi.String("forward"),
/// 					Values: pulumi.StringArray{
/// 						pulumi.String("destinationaddress@example.net"),
/// 					},
/// 				},
/// 			},
/// 			Enabled: pulumi.Bool(true),
/// 			Matchers: cloudflare.EmailRoutingRuleMatcherArray{
/// 				&cloudflare.EmailRoutingRuleMatcherArgs{
/// 					Field: pulumi.String("to"),
/// 					Type:  pulumi.String("literal"),
/// 					Value: pulumi.String("test@example.com"),
/// 				},
/// 			},
/// 			Name:   pulumi.String("terraform rule"),
/// 			ZoneId: pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.EmailRoutingRule;
/// import com.pulumi.cloudflare.EmailRoutingRuleArgs;
/// import com.pulumi.cloudflare.inputs.EmailRoutingRuleActionArgs;
/// import com.pulumi.cloudflare.inputs.EmailRoutingRuleMatcherArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var main = new EmailRoutingRule("main", EmailRoutingRuleArgs.builder()        
///             .actions(EmailRoutingRuleActionArgs.builder()
///                 .type("forward")
///                 .values("destinationaddress@example.net")
///                 .build())
///             .enabled(true)
///             .matchers(EmailRoutingRuleMatcherArgs.builder()
///                 .field("to")
///                 .type("literal")
///                 .value("test@example.com")
///                 .build())
///             .name("terraform rule")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   main:
///     type: cloudflare:EmailRoutingRule
///     properties:
///       actions:
///         - type: forward
///           values:
///             - destinationaddress@example.net
///       enabled: true
///       matchers:
///         - field: to
///           type: literal
///           value: test@example.com
///       name: terraform rule
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/emailRoutingRule:EmailRoutingRule example <zone_id>/<email_routing_rule_id>
/// ```
///
pub mod email_routing_rule {

    pub struct EmailRoutingRuleArgs {
        /// Actions to take when a match is found.
        pub actions: pulumi_wasm_rust::Output<Option<Vec<crate::types::EmailRoutingRuleAction>>>,
        /// Whether the email routing rule is enabled.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Matching patterns to forward to your actions.
        pub matchers: pulumi_wasm_rust::Output<Option<Vec<crate::types::EmailRoutingRuleMatcher>>>,
        /// Routing rule name.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The priority of the email routing rule.
        pub priority: pulumi_wasm_rust::Output<Option<i32>>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct EmailRoutingRuleResult {
        /// Actions to take when a match is found.
        pub actions: pulumi_wasm_rust::Output<Option<Vec<crate::types::EmailRoutingRuleAction>>>,
        /// Whether the email routing rule is enabled.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Matching patterns to forward to your actions.
        pub matchers: pulumi_wasm_rust::Output<Option<Vec<crate::types::EmailRoutingRuleMatcher>>>,
        /// Routing rule name.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The priority of the email routing rule.
        pub priority: pulumi_wasm_rust::Output<i32>,
        /// The tag of the email routing rule.
        pub tag: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn email_routing_rule(name: &str, args: EmailRoutingRuleArgs) -> EmailRoutingRuleResult {
        let result = crate::bindings::pulumi::cloudflare::email_routing_rule::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::email_routing_rule::Args {
                actions: args.actions.get_inner(),
                enabled: args.enabled.get_inner(),
                matchers: args.matchers.get_inner(),
                name: args.name.get_inner(),
                priority: args.priority.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        EmailRoutingRuleResult {
            actions: crate::into_domain(result.actions),
            enabled: crate::into_domain(result.enabled),
            matchers: crate::into_domain(result.matchers),
            name: crate::into_domain(result.name),
            priority: crate::into_domain(result.priority),
            tag: crate::into_domain(result.tag),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a resource for managing Email Routing settings.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const myZone = new cloudflare.EmailRoutingSettings("myZone", {
///     enabled: true,
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// my_zone = cloudflare.EmailRoutingSettings("myZone",
///     enabled=True,
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var myZone = new Cloudflare.EmailRoutingSettings("myZone", new()
///     {
///         Enabled = true,
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewEmailRoutingSettings(ctx, "myZone", &cloudflare.EmailRoutingSettingsArgs{
/// 			Enabled: pulumi.Bool(true),
/// 			ZoneId:  pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.EmailRoutingSettings;
/// import com.pulumi.cloudflare.EmailRoutingSettingsArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var myZone = new EmailRoutingSettings("myZone", EmailRoutingSettingsArgs.builder()        
///             .enabled("true")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   myZone:
///     type: cloudflare:EmailRoutingSettings
///     properties:
///       enabled: 'true'
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
pub mod email_routing_settings {

    pub struct EmailRoutingSettingsArgs {
        /// State of the zone settings for Email Routing. **Modifying this attribute will force creation of a new resource.**
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// Flag to check if the user skipped the configuration wizard.
        pub skip_wizard: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct EmailRoutingSettingsResult {
        /// The date and time the settings have been created.
        pub created: pulumi_wasm_rust::Output<String>,
        /// State of the zone settings for Email Routing. **Modifying this attribute will force creation of a new resource.**
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The date and time the settings have been modified.
        pub modified: pulumi_wasm_rust::Output<String>,
        /// Domain of your zone.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Flag to check if the user skipped the configuration wizard.
        pub skip_wizard: pulumi_wasm_rust::Output<bool>,
        /// Show the state of your account, and the type or configuration error.
        pub status: pulumi_wasm_rust::Output<String>,
        /// Email Routing settings identifier.
        pub tag: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn email_routing_settings(
        name: &str,
        args: EmailRoutingSettingsArgs,
    ) -> EmailRoutingSettingsResult {
        let result = crate::bindings::pulumi::cloudflare::email_routing_settings::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::email_routing_settings::Args {
                enabled: args.enabled.get_inner(),
                skip_wizard: args.skip_wizard.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        EmailRoutingSettingsResult {
            created: crate::into_domain(result.created),
            enabled: crate::into_domain(result.enabled),
            modified: crate::into_domain(result.modified),
            name: crate::into_domain(result.name),
            skip_wizard: crate::into_domain(result.skip_wizard),
            status: crate::into_domain(result.status),
            tag: crate::into_domain(result.tag),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare Fallback Domain resource. Fallback domains are
/// used to ignore DNS requests to a given list of domains. These DNS
/// requests will be passed back to other DNS servers configured on
/// existing network interfaces on the device.
///
/// ## Import
///
/// Fallback Domains for default device policies must use "default" as the policy ID.
///
/// ```sh
/// $ pulumi import cloudflare:index/fallbackDomain:FallbackDomain example <account_id>/<policy_id>
/// ```
///
pub mod fallback_domain {

    pub struct FallbackDomainArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        pub domains: pulumi_wasm_rust::Output<Vec<crate::types::FallbackDomainDomain>>,
        /// The settings policy for which to configure this fallback domain policy.
        pub policy_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct FallbackDomainResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        pub domains: pulumi_wasm_rust::Output<Vec<crate::types::FallbackDomainDomain>>,
        /// The settings policy for which to configure this fallback domain policy.
        pub policy_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn fallback_domain(name: &str, args: FallbackDomainArgs) -> FallbackDomainResult {
        let result = crate::bindings::pulumi::cloudflare::fallback_domain::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::fallback_domain::Args {
                account_id: args.account_id.get_inner(),
                domains: args.domains.get_inner(),
                policy_id: args.policy_id.get_inner(),
            },
        );

        FallbackDomainResult {
            account_id: crate::into_domain(result.account_id),
            domains: crate::into_domain(result.domains),
            policy_id: crate::into_domain(result.policy_id),
        }
    }
}

/// Filter expressions that can be referenced across multiple features,
/// e.g. Firewall Rules. See [what is a filter](https://developers.cloudflare.com/firewall/api/cf-filters/what-is-a-filter/)
/// for more details and available fields and operators.
///
/// > `cloudflare.Filter` is in a deprecation phase that will last for one
///   year (May 1st, 2024). During this time period, this resource is still fully
///   supported but you are strongly advised to move to the
///   `cloudflare.Ruleset` resource. Full details can be found in the
///   developer documentation.
///
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const wordpress = new cloudflare.Filter("wordpress", {
///     description: "Wordpress break-in attempts that are outside of the office",
///     expression: "(http.request.uri.path ~ \".*wp-login.php\" or http.request.uri.path ~ \".*xmlrpc.php\") and ip.src ne 192.0.2.1",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// wordpress = cloudflare.Filter("wordpress",
///     description="Wordpress break-in attempts that are outside of the office",
///     expression="(http.request.uri.path ~ \".*wp-login.php\" or http.request.uri.path ~ \".*xmlrpc.php\") and ip.src ne 192.0.2.1",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var wordpress = new Cloudflare.Filter("wordpress", new()
///     {
///         Description = "Wordpress break-in attempts that are outside of the office",
///         Expression = "(http.request.uri.path ~ \".*wp-login.php\" or http.request.uri.path ~ \".*xmlrpc.php\") and ip.src ne 192.0.2.1",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewFilter(ctx, "wordpress", &cloudflare.FilterArgs{
/// 			Description: pulumi.String("Wordpress break-in attempts that are outside of the office"),
/// 			Expression:  pulumi.String("(http.request.uri.path ~ \".*wp-login.php\" or http.request.uri.path ~ \".*xmlrpc.php\") and ip.src ne 192.0.2.1"),
/// 			ZoneId:      pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.Filter;
/// import com.pulumi.cloudflare.FilterArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var wordpress = new Filter("wordpress", FilterArgs.builder()        
///             .description("Wordpress break-in attempts that are outside of the office")
///             .expression("(http.request.uri.path ~ \".*wp-login.php\" or http.request.uri.path ~ \".*xmlrpc.php\") and ip.src ne 192.0.2.1")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   wordpress:
///     type: cloudflare:Filter
///     properties:
///       description: Wordpress break-in attempts that are outside of the office
///       expression: (http.request.uri.path ~ ".*wp-login.php" or http.request.uri.path ~ ".*xmlrpc.php") and ip.src ne 192.0.2.1
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/filter:Filter example <zone_id>/<filter_id>
/// ```
///
pub mod filter {

    pub struct FilterArgs {
        /// A note that you can use to describe the purpose of the filter.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The filter expression to be used.
        pub expression: pulumi_wasm_rust::Output<String>,
        /// Whether this filter is currently paused.
        pub paused: pulumi_wasm_rust::Output<Option<bool>>,
        /// Short reference tag to quickly select related rules.
        pub ref_: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct FilterResult {
        /// A note that you can use to describe the purpose of the filter.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The filter expression to be used.
        pub expression: pulumi_wasm_rust::Output<String>,
        /// Whether this filter is currently paused.
        pub paused: pulumi_wasm_rust::Output<Option<bool>>,
        /// Short reference tag to quickly select related rules.
        pub ref_: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn filter(name: &str, args: FilterArgs) -> FilterResult {
        let result = crate::bindings::pulumi::cloudflare::filter::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::filter::Args {
                description: args.description.get_inner(),
                expression: args.expression.get_inner(),
                paused: args.paused.get_inner(),
                ref_: args.ref_.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        FilterResult {
            description: crate::into_domain(result.description),
            expression: crate::into_domain(result.expression),
            paused: crate::into_domain(result.paused),
            ref_: crate::into_domain(result.ref_),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Define Firewall rules using filter expressions for more control over
/// how traffic is matched to the rule. A filter expression permits
/// selecting traffic by multiple criteria allowing greater freedom in
/// rule creation.
///
/// Filter expressions needs to be created first before using Firewall
/// Rule.
///
/// > `cloudflare.FirewallRule` is in a deprecation phase that will last for one
///   year (May 1st, 2024). During this time period, this resource is still fully
///   supported but you are strongly advised  to move to the `cloudflare.Ruleset`
///   resource. Full details can be found in the
///   developer documentation.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const wordpressFilter = new cloudflare.Filter("wordpressFilter", {
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
///     description: "Wordpress break-in attempts that are outside of the office",
///     expression: "(http.request.uri.path ~ \".*wp-login.php\" or http.request.uri.path ~ \".*xmlrpc.php\") and ip.src ne 192.0.2.1",
/// });
/// const wordpressFirewallRule = new cloudflare.FirewallRule("wordpressFirewallRule", {
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
///     description: "Block wordpress break-in attempts",
///     filterId: wordpressFilter.id,
///     action: "block",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// wordpress_filter = cloudflare.Filter("wordpressFilter",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711",
///     description="Wordpress break-in attempts that are outside of the office",
///     expression="(http.request.uri.path ~ \".*wp-login.php\" or http.request.uri.path ~ \".*xmlrpc.php\") and ip.src ne 192.0.2.1")
/// wordpress_firewall_rule = cloudflare.FirewallRule("wordpressFirewallRule",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711",
///     description="Block wordpress break-in attempts",
///     filter_id=wordpress_filter.id,
///     action="block")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var wordpressFilter = new Cloudflare.Filter("wordpressFilter", new()
///     {
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///         Description = "Wordpress break-in attempts that are outside of the office",
///         Expression = "(http.request.uri.path ~ \".*wp-login.php\" or http.request.uri.path ~ \".*xmlrpc.php\") and ip.src ne 192.0.2.1",
///     });
///
///     var wordpressFirewallRule = new Cloudflare.FirewallRule("wordpressFirewallRule", new()
///     {
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///         Description = "Block wordpress break-in attempts",
///         FilterId = wordpressFilter.Id,
///         Action = "block",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		wordpressFilter, err := cloudflare.NewFilter(ctx, "wordpressFilter", &cloudflare.FilterArgs{
/// 			ZoneId:      pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 			Description: pulumi.String("Wordpress break-in attempts that are outside of the office"),
/// 			Expression:  pulumi.String("(http.request.uri.path ~ \".*wp-login.php\" or http.request.uri.path ~ \".*xmlrpc.php\") and ip.src ne 192.0.2.1"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		_, err = cloudflare.NewFirewallRule(ctx, "wordpressFirewallRule", &cloudflare.FirewallRuleArgs{
/// 			ZoneId:      pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 			Description: pulumi.String("Block wordpress break-in attempts"),
/// 			FilterId:    wordpressFilter.ID(),
/// 			Action:      pulumi.String("block"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.Filter;
/// import com.pulumi.cloudflare.FilterArgs;
/// import com.pulumi.cloudflare.FirewallRule;
/// import com.pulumi.cloudflare.FirewallRuleArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var wordpressFilter = new Filter("wordpressFilter", FilterArgs.builder()        
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .description("Wordpress break-in attempts that are outside of the office")
///             .expression("(http.request.uri.path ~ \".*wp-login.php\" or http.request.uri.path ~ \".*xmlrpc.php\") and ip.src ne 192.0.2.1")
///             .build());
///
///         var wordpressFirewallRule = new FirewallRule("wordpressFirewallRule", FirewallRuleArgs.builder()        
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .description("Block wordpress break-in attempts")
///             .filterId(wordpressFilter.id())
///             .action("block")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   wordpressFilter:
///     type: cloudflare:Filter
///     properties:
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///       description: Wordpress break-in attempts that are outside of the office
///       expression: (http.request.uri.path ~ ".*wp-login.php" or http.request.uri.path ~ ".*xmlrpc.php") and ip.src ne 192.0.2.1
///   wordpressFirewallRule:
///     type: cloudflare:FirewallRule
///     properties:
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///       description: Block wordpress break-in attempts
///       filterId: ${wordpressFilter.id}
///       action: block
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/firewallRule:FirewallRule example <zone_id>/<firewall_rule_id>
/// ```
///
pub mod firewall_rule {

    pub struct FirewallRuleArgs {
        /// The action to apply to a matched request. Available values: `block`, `challenge`, `allow`, `js_challenge`, `managed_challenge`, `log`, `bypass`.
        pub action: pulumi_wasm_rust::Output<String>,
        /// A description of the rule to help identify it.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The identifier of the Filter to use for determining if the Firewall Rule should be triggered.
        pub filter_id: pulumi_wasm_rust::Output<String>,
        /// Whether this filter based firewall rule is currently paused.
        pub paused: pulumi_wasm_rust::Output<Option<bool>>,
        /// The priority of the rule to allow control of processing order. A lower number indicates high priority. If not provided, any rules with a priority will be sequenced before those without.
        pub priority: pulumi_wasm_rust::Output<Option<i32>>,
        /// List of products to bypass for a request when the bypass action is used. Available values: `zoneLockdown`, `uaBlock`, `bic`, `hot`, `securityLevel`, `rateLimit`, `waf`.
        pub products: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct FirewallRuleResult {
        /// The action to apply to a matched request. Available values: `block`, `challenge`, `allow`, `js_challenge`, `managed_challenge`, `log`, `bypass`.
        pub action: pulumi_wasm_rust::Output<String>,
        /// A description of the rule to help identify it.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The identifier of the Filter to use for determining if the Firewall Rule should be triggered.
        pub filter_id: pulumi_wasm_rust::Output<String>,
        /// Whether this filter based firewall rule is currently paused.
        pub paused: pulumi_wasm_rust::Output<Option<bool>>,
        /// The priority of the rule to allow control of processing order. A lower number indicates high priority. If not provided, any rules with a priority will be sequenced before those without.
        pub priority: pulumi_wasm_rust::Output<Option<i32>>,
        /// List of products to bypass for a request when the bypass action is used. Available values: `zoneLockdown`, `uaBlock`, `bic`, `hot`, `securityLevel`, `rateLimit`, `waf`.
        pub products: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn firewall_rule(name: &str, args: FirewallRuleArgs) -> FirewallRuleResult {
        let result = crate::bindings::pulumi::cloudflare::firewall_rule::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::firewall_rule::Args {
                action: args.action.get_inner(),
                description: args.description.get_inner(),
                filter_id: args.filter_id.get_inner(),
                paused: args.paused.get_inner(),
                priority: args.priority.get_inner(),
                products: args.products.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        FirewallRuleResult {
            action: crate::into_domain(result.action),
            description: crate::into_domain(result.description),
            filter_id: crate::into_domain(result.filter_id),
            paused: crate::into_domain(result.paused),
            priority: crate::into_domain(result.priority),
            products: crate::into_domain(result.products),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a resource, that manages GRE tunnels for Magic Transit.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.GreTunnel("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     cloudflareGreEndpoint: "203.0.113.2",
///     customerGreEndpoint: "203.0.113.1",
///     description: "Tunnel for ISP X",
///     healthCheckEnabled: true,
///     healthCheckTarget: "203.0.113.1",
///     healthCheckType: "reply",
///     interfaceAddress: "192.0.2.0/31",
///     mtu: 1476,
///     name: "GRE_1",
///     ttl: 64,
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.GreTunnel("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     cloudflare_gre_endpoint="203.0.113.2",
///     customer_gre_endpoint="203.0.113.1",
///     description="Tunnel for ISP X",
///     health_check_enabled=True,
///     health_check_target="203.0.113.1",
///     health_check_type="reply",
///     interface_address="192.0.2.0/31",
///     mtu=1476,
///     name="GRE_1",
///     ttl=64)
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.GreTunnel("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         CloudflareGreEndpoint = "203.0.113.2",
///         CustomerGreEndpoint = "203.0.113.1",
///         Description = "Tunnel for ISP X",
///         HealthCheckEnabled = true,
///         HealthCheckTarget = "203.0.113.1",
///         HealthCheckType = "reply",
///         InterfaceAddress = "192.0.2.0/31",
///         Mtu = 1476,
///         Name = "GRE_1",
///         Ttl = 64,
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewGreTunnel(ctx, "example", &cloudflare.GreTunnelArgs{
/// 			AccountId:             pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			CloudflareGreEndpoint: pulumi.String("203.0.113.2"),
/// 			CustomerGreEndpoint:   pulumi.String("203.0.113.1"),
/// 			Description:           pulumi.String("Tunnel for ISP X"),
/// 			HealthCheckEnabled:    pulumi.Bool(true),
/// 			HealthCheckTarget:     pulumi.String("203.0.113.1"),
/// 			HealthCheckType:       pulumi.String("reply"),
/// 			InterfaceAddress:      pulumi.String("192.0.2.0/31"),
/// 			Mtu:                   pulumi.Int(1476),
/// 			Name:                  pulumi.String("GRE_1"),
/// 			Ttl:                   pulumi.Int(64),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.GreTunnel;
/// import com.pulumi.cloudflare.GreTunnelArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new GreTunnel("example", GreTunnelArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .cloudflareGreEndpoint("203.0.113.2")
///             .customerGreEndpoint("203.0.113.1")
///             .description("Tunnel for ISP X")
///             .healthCheckEnabled(true)
///             .healthCheckTarget("203.0.113.1")
///             .healthCheckType("reply")
///             .interfaceAddress("192.0.2.0/31")
///             .mtu(1476)
///             .name("GRE_1")
///             .ttl(64)
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:GreTunnel
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       cloudflareGreEndpoint: 203.0.113.2
///       customerGreEndpoint: 203.0.113.1
///       description: Tunnel for ISP X
///       healthCheckEnabled: true
///       healthCheckTarget: 203.0.113.1
///       healthCheckType: reply
///       interfaceAddress: 192.0.2.0/31
///       mtu: 1476
///       name: GRE_1
///       ttl: 64
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/greTunnel:GreTunnel example <account_id>/<tunnel_id>
/// ```
///
pub mod gre_tunnel {

    pub struct GreTunnelArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The IP address assigned to the Cloudflare side of the GRE tunnel.
        pub cloudflare_gre_endpoint: pulumi_wasm_rust::Output<String>,
        /// The IP address assigned to the customer side of the GRE tunnel.
        pub customer_gre_endpoint: pulumi_wasm_rust::Output<String>,
        /// Description of the GRE tunnel intent.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies if ICMP tunnel health checks are enabled.
        pub health_check_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The IP address of the customer endpoint that will receive tunnel health checks.
        pub health_check_target: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies the ICMP echo type for the health check. Available values: `request`, `reply`.
        pub health_check_type: pulumi_wasm_rust::Output<Option<String>>,
        /// 31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.
        pub interface_address: pulumi_wasm_rust::Output<String>,
        /// Maximum Transmission Unit (MTU) in bytes for the GRE tunnel.
        pub mtu: pulumi_wasm_rust::Output<Option<i32>>,
        /// Name of the GRE tunnel.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Time To Live (TTL) in number of hops of the GRE tunnel.
        pub ttl: pulumi_wasm_rust::Output<Option<i32>>,
    }

    pub struct GreTunnelResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The IP address assigned to the Cloudflare side of the GRE tunnel.
        pub cloudflare_gre_endpoint: pulumi_wasm_rust::Output<String>,
        /// The IP address assigned to the customer side of the GRE tunnel.
        pub customer_gre_endpoint: pulumi_wasm_rust::Output<String>,
        /// Description of the GRE tunnel intent.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies if ICMP tunnel health checks are enabled.
        pub health_check_enabled: pulumi_wasm_rust::Output<bool>,
        /// The IP address of the customer endpoint that will receive tunnel health checks.
        pub health_check_target: pulumi_wasm_rust::Output<String>,
        /// Specifies the ICMP echo type for the health check. Available values: `request`, `reply`.
        pub health_check_type: pulumi_wasm_rust::Output<String>,
        /// 31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.
        pub interface_address: pulumi_wasm_rust::Output<String>,
        /// Maximum Transmission Unit (MTU) in bytes for the GRE tunnel.
        pub mtu: pulumi_wasm_rust::Output<i32>,
        /// Name of the GRE tunnel.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Time To Live (TTL) in number of hops of the GRE tunnel.
        pub ttl: pulumi_wasm_rust::Output<i32>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn gre_tunnel(name: &str, args: GreTunnelArgs) -> GreTunnelResult {
        let result = crate::bindings::pulumi::cloudflare::gre_tunnel::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::gre_tunnel::Args {
                account_id: args.account_id.get_inner(),
                cloudflare_gre_endpoint: args.cloudflare_gre_endpoint.get_inner(),
                customer_gre_endpoint: args.customer_gre_endpoint.get_inner(),
                description: args.description.get_inner(),
                health_check_enabled: args.health_check_enabled.get_inner(),
                health_check_target: args.health_check_target.get_inner(),
                health_check_type: args.health_check_type.get_inner(),
                interface_address: args.interface_address.get_inner(),
                mtu: args.mtu.get_inner(),
                name: args.name.get_inner(),
                ttl: args.ttl.get_inner(),
            },
        );

        GreTunnelResult {
            account_id: crate::into_domain(result.account_id),
            cloudflare_gre_endpoint: crate::into_domain(result.cloudflare_gre_endpoint),
            customer_gre_endpoint: crate::into_domain(result.customer_gre_endpoint),
            description: crate::into_domain(result.description),
            health_check_enabled: crate::into_domain(result.health_check_enabled),
            health_check_target: crate::into_domain(result.health_check_target),
            health_check_type: crate::into_domain(result.health_check_type),
            interface_address: crate::into_domain(result.interface_address),
            mtu: crate::into_domain(result.mtu),
            name: crate::into_domain(result.name),
            ttl: crate::into_domain(result.ttl),
        }
    }
}

/// Standalone Health Checks provide a way to monitor origin servers
/// without needing a Cloudflare Load Balancer.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// // HTTPS Healthcheck
/// const httpHealthCheck = new cloudflare.Healthcheck("httpHealthCheck", {
///     zoneId: _var.cloudflare_zone_id,
///     name: "http-health-check",
///     description: "example http health check",
///     address: "example.com",
///     suspended: false,
///     checkRegions: [
///         "WEU",
///         "EEU",
///     ],
///     type: "HTTPS",
///     port: 443,
///     method: "GET",
///     path: "/health",
///     expectedBody: "alive",
///     expectedCodes: [
///         "2xx",
///         "301",
///     ],
///     followRedirects: true,
///     allowInsecure: false,
///     headers: [{
///         header: "Host",
///         values: ["example.com"],
///     }],
///     timeout: 10,
///     retries: 2,
///     interval: 60,
///     consecutiveFails: 3,
///     consecutiveSuccesses: 2,
/// });
/// // TCP Healthcheck
/// const tcpHealthCheck = new cloudflare.Healthcheck("tcpHealthCheck", {
///     zoneId: _var.cloudflare_zone_id,
///     name: "tcp-health-check",
///     description: "example tcp health check",
///     address: "example.com",
///     suspended: false,
///     checkRegions: [
///         "WEU",
///         "EEU",
///     ],
///     type: "TCP",
///     port: 22,
///     method: "connection_established",
///     timeout: 10,
///     retries: 2,
///     interval: 60,
///     consecutiveFails: 3,
///     consecutiveSuccesses: 2,
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// # HTTPS Healthcheck
/// http_health_check = cloudflare.Healthcheck("httpHealthCheck",
///     zone_id=var["cloudflare_zone_id"],
///     name="http-health-check",
///     description="example http health check",
///     address="example.com",
///     suspended=False,
///     check_regions=[
///         "WEU",
///         "EEU",
///     ],
///     type="HTTPS",
///     port=443,
///     method="GET",
///     path="/health",
///     expected_body="alive",
///     expected_codes=[
///         "2xx",
///         "301",
///     ],
///     follow_redirects=True,
///     allow_insecure=False,
///     headers=[cloudflare.HealthcheckHeaderArgs(
///         header="Host",
///         values=["example.com"],
///     )],
///     timeout=10,
///     retries=2,
///     interval=60,
///     consecutive_fails=3,
///     consecutive_successes=2)
/// # TCP Healthcheck
/// tcp_health_check = cloudflare.Healthcheck("tcpHealthCheck",
///     zone_id=var["cloudflare_zone_id"],
///     name="tcp-health-check",
///     description="example tcp health check",
///     address="example.com",
///     suspended=False,
///     check_regions=[
///         "WEU",
///         "EEU",
///     ],
///     type="TCP",
///     port=22,
///     method="connection_established",
///     timeout=10,
///     retries=2,
///     interval=60,
///     consecutive_fails=3,
///     consecutive_successes=2)
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     // HTTPS Healthcheck
///     var httpHealthCheck = new Cloudflare.Healthcheck("httpHealthCheck", new()
///     {
///         ZoneId = @var.Cloudflare_zone_id,
///         Name = "http-health-check",
///         Description = "example http health check",
///         Address = "example.com",
///         Suspended = false,
///         CheckRegions = new[]
///         {
///             "WEU",
///             "EEU",
///         },
///         Type = "HTTPS",
///         Port = 443,
///         Method = "GET",
///         Path = "/health",
///         ExpectedBody = "alive",
///         ExpectedCodes = new[]
///         {
///             "2xx",
///             "301",
///         },
///         FollowRedirects = true,
///         AllowInsecure = false,
///         Headers = new[]
///         {
///             new Cloudflare.Inputs.HealthcheckHeaderArgs
///             {
///                 Header = "Host",
///                 Values = new[]
///                 {
///                     "example.com",
///                 },
///             },
///         },
///         Timeout = 10,
///         Retries = 2,
///         Interval = 60,
///         ConsecutiveFails = 3,
///         ConsecutiveSuccesses = 2,
///     });
///
///     // TCP Healthcheck
///     var tcpHealthCheck = new Cloudflare.Healthcheck("tcpHealthCheck", new()
///     {
///         ZoneId = @var.Cloudflare_zone_id,
///         Name = "tcp-health-check",
///         Description = "example tcp health check",
///         Address = "example.com",
///         Suspended = false,
///         CheckRegions = new[]
///         {
///             "WEU",
///             "EEU",
///         },
///         Type = "TCP",
///         Port = 22,
///         Method = "connection_established",
///         Timeout = 10,
///         Retries = 2,
///         Interval = 60,
///         ConsecutiveFails = 3,
///         ConsecutiveSuccesses = 2,
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// HTTPS Healthcheck
/// 		_, err := cloudflare.NewHealthcheck(ctx, "httpHealthCheck", &cloudflare.HealthcheckArgs{
/// 			ZoneId:      pulumi.Any(_var.Cloudflare_zone_id),
/// 			Name:        pulumi.String("http-health-check"),
/// 			Description: pulumi.String("example http health check"),
/// 			Address:     pulumi.String("example.com"),
/// 			Suspended:   pulumi.Bool(false),
/// 			CheckRegions: pulumi.StringArray{
/// 				pulumi.String("WEU"),
/// 				pulumi.String("EEU"),
/// 			},
/// 			Type:         pulumi.String("HTTPS"),
/// 			Port:         pulumi.Int(443),
/// 			Method:       pulumi.String("GET"),
/// 			Path:         pulumi.String("/health"),
/// 			ExpectedBody: pulumi.String("alive"),
/// 			ExpectedCodes: pulumi.StringArray{
/// 				pulumi.String("2xx"),
/// 				pulumi.String("301"),
/// 			},
/// 			FollowRedirects: pulumi.Bool(true),
/// 			AllowInsecure:   pulumi.Bool(false),
/// 			Headers: cloudflare.HealthcheckHeaderArray{
/// 				&cloudflare.HealthcheckHeaderArgs{
/// 					Header: pulumi.String("Host"),
/// 					Values: pulumi.StringArray{
/// 						pulumi.String("example.com"),
/// 					},
/// 				},
/// 			},
/// 			Timeout:              pulumi.Int(10),
/// 			Retries:              pulumi.Int(2),
/// 			Interval:             pulumi.Int(60),
/// 			ConsecutiveFails:     pulumi.Int(3),
/// 			ConsecutiveSuccesses: pulumi.Int(2),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// TCP Healthcheck
/// 		_, err = cloudflare.NewHealthcheck(ctx, "tcpHealthCheck", &cloudflare.HealthcheckArgs{
/// 			ZoneId:      pulumi.Any(_var.Cloudflare_zone_id),
/// 			Name:        pulumi.String("tcp-health-check"),
/// 			Description: pulumi.String("example tcp health check"),
/// 			Address:     pulumi.String("example.com"),
/// 			Suspended:   pulumi.Bool(false),
/// 			CheckRegions: pulumi.StringArray{
/// 				pulumi.String("WEU"),
/// 				pulumi.String("EEU"),
/// 			},
/// 			Type:                 pulumi.String("TCP"),
/// 			Port:                 pulumi.Int(22),
/// 			Method:               pulumi.String("connection_established"),
/// 			Timeout:              pulumi.Int(10),
/// 			Retries:              pulumi.Int(2),
/// 			Interval:             pulumi.Int(60),
/// 			ConsecutiveFails:     pulumi.Int(3),
/// 			ConsecutiveSuccesses: pulumi.Int(2),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.Healthcheck;
/// import com.pulumi.cloudflare.HealthcheckArgs;
/// import com.pulumi.cloudflare.inputs.HealthcheckHeaderArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // HTTPS Healthcheck
///         var httpHealthCheck = new Healthcheck("httpHealthCheck", HealthcheckArgs.builder()        
///             .zoneId(var_.cloudflare_zone_id())
///             .name("http-health-check")
///             .description("example http health check")
///             .address("example.com")
///             .suspended(false)
///             .checkRegions(            
///                 "WEU",
///                 "EEU")
///             .type("HTTPS")
///             .port(443)
///             .method("GET")
///             .path("/health")
///             .expectedBody("alive")
///             .expectedCodes(            
///                 "2xx",
///                 "301")
///             .followRedirects(true)
///             .allowInsecure(false)
///             .headers(HealthcheckHeaderArgs.builder()
///                 .header("Host")
///                 .values("example.com")
///                 .build())
///             .timeout(10)
///             .retries(2)
///             .interval(60)
///             .consecutiveFails(3)
///             .consecutiveSuccesses(2)
///             .build());
///
///         // TCP Healthcheck
///         var tcpHealthCheck = new Healthcheck("tcpHealthCheck", HealthcheckArgs.builder()        
///             .zoneId(var_.cloudflare_zone_id())
///             .name("tcp-health-check")
///             .description("example tcp health check")
///             .address("example.com")
///             .suspended(false)
///             .checkRegions(            
///                 "WEU",
///                 "EEU")
///             .type("TCP")
///             .port(22)
///             .method("connection_established")
///             .timeout(10)
///             .retries(2)
///             .interval(60)
///             .consecutiveFails(3)
///             .consecutiveSuccesses(2)
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # HTTPS Healthcheck
///   httpHealthCheck:
///     type: cloudflare:Healthcheck
///     properties:
///       zoneId: ${var.cloudflare_zone_id}
///       name: http-health-check
///       description: example http health check
///       address: example.com
///       suspended: false
///       checkRegions:
///         - WEU
///         - EEU
///       type: HTTPS
///       port: 443
///       method: GET
///       path: /health
///       expectedBody: alive
///       expectedCodes:
///         - 2xx
///         - '301'
///       followRedirects: true
///       allowInsecure: false
///       headers:
///         - header: Host
///           values:
///             - example.com
///       timeout: 10
///       retries: 2
///       interval: 60
///       consecutiveFails: 3
///       consecutiveSuccesses: 2
///   # TCP Healthcheck
///   tcpHealthCheck:
///     type: cloudflare:Healthcheck
///     properties:
///       zoneId: ${var.cloudflare_zone_id}
///       name: tcp-health-check
///       description: example tcp health check
///       address: example.com
///       suspended: false
///       checkRegions:
///         - WEU
///         - EEU
///       type: TCP
///       port: 22
///       method: connection_established
///       timeout: 10
///       retries: 2
///       interval: 60
///       consecutiveFails: 3
///       consecutiveSuccesses: 2
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// Use the Zone ID and Healthcheck ID to import.
///
/// ```sh
/// $ pulumi import cloudflare:index/healthcheck:Healthcheck example <zone_id>/<healthcheck_id>
/// ```
///
pub mod healthcheck {

    pub struct HealthcheckArgs {
        /// The hostname or IP address of the origin server to run health checks on.
        pub address: pulumi_wasm_rust::Output<String>,
        /// Do not validate the certificate when the health check uses HTTPS. Defaults to `false`.
        pub allow_insecure: pulumi_wasm_rust::Output<Option<bool>>,
        /// A list of regions from which to run health checks. If not set, Cloudflare will pick a default region. Available values: `WNAM`, `ENAM`, `WEU`, `EEU`, `NSAM`, `SSAM`, `OC`, `ME`, `NAF`, `SAF`, `IN`, `SEAS`, `NEAS`, `ALL_REGIONS`.
        pub check_regions: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The number of consecutive fails required from a health check before changing the health to unhealthy. Defaults to `1`.
        pub consecutive_fails: pulumi_wasm_rust::Output<Option<i32>>,
        /// The number of consecutive successes required from a health check before changing the health to healthy. Defaults to `1`.
        pub consecutive_successes: pulumi_wasm_rust::Output<Option<i32>>,
        /// A human-readable description of the health check.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// A case-insensitive sub-string to look for in the response body. If this string is not found the origin will be marked as unhealthy.
        pub expected_body: pulumi_wasm_rust::Output<Option<String>>,
        /// The expected HTTP response codes (e.g. '200') or code ranges (e.g. '2xx' for all codes starting with 2) of the health check.
        pub expected_codes: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Follow redirects if the origin returns a 3xx status code. Defaults to `false`.
        pub follow_redirects: pulumi_wasm_rust::Output<Option<bool>>,
        /// The header name.
        pub headers: pulumi_wasm_rust::Output<Option<Vec<crate::types::HealthcheckHeader>>>,
        /// The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase the load on the origin as we check from multiple locations. Defaults to `60`.
        pub interval: pulumi_wasm_rust::Output<Option<i32>>,
        /// The HTTP method to use for the health check. Available values: `connection_established`, `GET`, `HEAD`.
        pub method: pulumi_wasm_rust::Output<Option<String>>,
        /// A short name to identify the health check. Only alphanumeric characters, hyphens, and underscores are allowed.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The endpoint path to health check against. Defaults to `/`.
        pub path: pulumi_wasm_rust::Output<Option<String>>,
        /// Port number to connect to for the health check. Defaults to `80`.
        pub port: pulumi_wasm_rust::Output<Option<i32>>,
        /// The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Defaults to `2`.
        pub retries: pulumi_wasm_rust::Output<Option<i32>>,
        /// If suspended, no health checks are sent to the origin. Defaults to `false`.
        pub suspended: pulumi_wasm_rust::Output<Option<bool>>,
        /// The timeout (in seconds) before marking the health check as failed. Defaults to `5`.
        pub timeout: pulumi_wasm_rust::Output<Option<i32>>,
        /// The protocol to use for the health check. Available values: `TCP`, `HTTP`, `HTTPS`.
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct HealthcheckResult {
        /// The hostname or IP address of the origin server to run health checks on.
        pub address: pulumi_wasm_rust::Output<String>,
        /// Do not validate the certificate when the health check uses HTTPS. Defaults to `false`.
        pub allow_insecure: pulumi_wasm_rust::Output<Option<bool>>,
        /// A list of regions from which to run health checks. If not set, Cloudflare will pick a default region. Available values: `WNAM`, `ENAM`, `WEU`, `EEU`, `NSAM`, `SSAM`, `OC`, `ME`, `NAF`, `SAF`, `IN`, `SEAS`, `NEAS`, `ALL_REGIONS`.
        pub check_regions: pulumi_wasm_rust::Output<Vec<String>>,
        /// The number of consecutive fails required from a health check before changing the health to unhealthy. Defaults to `1`.
        pub consecutive_fails: pulumi_wasm_rust::Output<Option<i32>>,
        /// The number of consecutive successes required from a health check before changing the health to healthy. Defaults to `1`.
        pub consecutive_successes: pulumi_wasm_rust::Output<Option<i32>>,
        /// Creation time.
        pub created_on: pulumi_wasm_rust::Output<String>,
        /// A human-readable description of the health check.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// A case-insensitive sub-string to look for in the response body. If this string is not found the origin will be marked as unhealthy.
        pub expected_body: pulumi_wasm_rust::Output<Option<String>>,
        /// The expected HTTP response codes (e.g. '200') or code ranges (e.g. '2xx' for all codes starting with 2) of the health check.
        pub expected_codes: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Follow redirects if the origin returns a 3xx status code. Defaults to `false`.
        pub follow_redirects: pulumi_wasm_rust::Output<Option<bool>>,
        /// The header name.
        pub headers: pulumi_wasm_rust::Output<Option<Vec<crate::types::HealthcheckHeader>>>,
        /// The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase the load on the origin as we check from multiple locations. Defaults to `60`.
        pub interval: pulumi_wasm_rust::Output<Option<i32>>,
        /// The HTTP method to use for the health check. Available values: `connection_established`, `GET`, `HEAD`.
        pub method: pulumi_wasm_rust::Output<String>,
        /// Last modified time.
        pub modified_on: pulumi_wasm_rust::Output<String>,
        /// A short name to identify the health check. Only alphanumeric characters, hyphens, and underscores are allowed.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The endpoint path to health check against. Defaults to `/`.
        pub path: pulumi_wasm_rust::Output<Option<String>>,
        /// Port number to connect to for the health check. Defaults to `80`.
        pub port: pulumi_wasm_rust::Output<Option<i32>>,
        /// The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Defaults to `2`.
        pub retries: pulumi_wasm_rust::Output<Option<i32>>,
        /// If suspended, no health checks are sent to the origin. Defaults to `false`.
        pub suspended: pulumi_wasm_rust::Output<Option<bool>>,
        /// The timeout (in seconds) before marking the health check as failed. Defaults to `5`.
        pub timeout: pulumi_wasm_rust::Output<Option<i32>>,
        /// The protocol to use for the health check. Available values: `TCP`, `HTTP`, `HTTPS`.
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn healthcheck(name: &str, args: HealthcheckArgs) -> HealthcheckResult {
        let result = crate::bindings::pulumi::cloudflare::healthcheck::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::healthcheck::Args {
                address: args.address.get_inner(),
                allow_insecure: args.allow_insecure.get_inner(),
                check_regions: args.check_regions.get_inner(),
                consecutive_fails: args.consecutive_fails.get_inner(),
                consecutive_successes: args.consecutive_successes.get_inner(),
                description: args.description.get_inner(),
                expected_body: args.expected_body.get_inner(),
                expected_codes: args.expected_codes.get_inner(),
                follow_redirects: args.follow_redirects.get_inner(),
                headers: args.headers.get_inner(),
                interval: args.interval.get_inner(),
                method: args.method.get_inner(),
                name: args.name.get_inner(),
                path: args.path.get_inner(),
                port: args.port.get_inner(),
                retries: args.retries.get_inner(),
                suspended: args.suspended.get_inner(),
                timeout: args.timeout.get_inner(),
                type_: args.type_.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        HealthcheckResult {
            address: crate::into_domain(result.address),
            allow_insecure: crate::into_domain(result.allow_insecure),
            check_regions: crate::into_domain(result.check_regions),
            consecutive_fails: crate::into_domain(result.consecutive_fails),
            consecutive_successes: crate::into_domain(result.consecutive_successes),
            created_on: crate::into_domain(result.created_on),
            description: crate::into_domain(result.description),
            expected_body: crate::into_domain(result.expected_body),
            expected_codes: crate::into_domain(result.expected_codes),
            follow_redirects: crate::into_domain(result.follow_redirects),
            headers: crate::into_domain(result.headers),
            interval: crate::into_domain(result.interval),
            method: crate::into_domain(result.method),
            modified_on: crate::into_domain(result.modified_on),
            name: crate::into_domain(result.name),
            path: crate::into_domain(result.path),
            port: crate::into_domain(result.port),
            retries: crate::into_domain(result.retries),
            suspended: crate::into_domain(result.suspended),
            timeout: crate::into_domain(result.timeout),
            type_: crate::into_domain(result.type_),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare per-hostname TLS setting resource. Used to set TLS settings for hostnames under the specified zone.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.HostnameTlsSetting("example", {
///     hostname: "sub.example.com",
///     setting: "min_tls_version",
///     value: "1.2",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.HostnameTlsSetting("example",
///     hostname="sub.example.com",
///     setting="min_tls_version",
///     value="1.2",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.HostnameTlsSetting("example", new()
///     {
///         Hostname = "sub.example.com",
///         Setting = "min_tls_version",
///         Value = "1.2",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewHostnameTlsSetting(ctx, "example", &cloudflare.HostnameTlsSettingArgs{
/// 			Hostname: pulumi.String("sub.example.com"),
/// 			Setting:  pulumi.String("min_tls_version"),
/// 			Value:    pulumi.String("1.2"),
/// 			ZoneId:   pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.HostnameTlsSetting;
/// import com.pulumi.cloudflare.HostnameTlsSettingArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new HostnameTlsSetting("example", HostnameTlsSettingArgs.builder()        
///             .hostname("sub.example.com")
///             .setting("min_tls_version")
///             .value("1.2")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:HostnameTlsSetting
///     properties:
///       hostname: sub.example.com
///       setting: min_tls_version
///       value: '1.2'
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/hostnameTlsSetting:HostnameTlsSetting example <zone_id>/<hostname>/<setting_name>
/// ```
///
pub mod hostname_tls_setting {

    pub struct HostnameTlsSettingArgs {
        /// Hostname that belongs to this zone name. **Modifying this attribute will force creation of a new resource.**
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// TLS setting name. **Modifying this attribute will force creation of a new resource.**
        pub setting: pulumi_wasm_rust::Output<String>,
        /// TLS setting value.
        pub value: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct HostnameTlsSettingResult {
        pub created_at: pulumi_wasm_rust::Output<String>,
        /// Hostname that belongs to this zone name. **Modifying this attribute will force creation of a new resource.**
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// TLS setting name. **Modifying this attribute will force creation of a new resource.**
        pub setting: pulumi_wasm_rust::Output<String>,
        pub updated_at: pulumi_wasm_rust::Output<String>,
        /// TLS setting value.
        pub value: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn hostname_tls_setting(
        name: &str,
        args: HostnameTlsSettingArgs,
    ) -> HostnameTlsSettingResult {
        let result = crate::bindings::pulumi::cloudflare::hostname_tls_setting::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::hostname_tls_setting::Args {
                hostname: args.hostname.get_inner(),
                setting: args.setting.get_inner(),
                value: args.value.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        HostnameTlsSettingResult {
            created_at: crate::into_domain(result.created_at),
            hostname: crate::into_domain(result.hostname),
            setting: crate::into_domain(result.setting),
            updated_at: crate::into_domain(result.updated_at),
            value: crate::into_domain(result.value),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare per-hostname TLS setting resource, specifically for ciphers suites. Used to set ciphers suites for hostnames under the specified zone.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.HostnameTlsSettingCiphers("example", {
///     hostname: "sub.example.com",
///     values: ["ECDHE-RSA-AES128-GCM-SHA256"],
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.HostnameTlsSettingCiphers("example",
///     hostname="sub.example.com",
///     values=["ECDHE-RSA-AES128-GCM-SHA256"],
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.HostnameTlsSettingCiphers("example", new()
///     {
///         Hostname = "sub.example.com",
///         Values = new[]
///         {
///             "ECDHE-RSA-AES128-GCM-SHA256",
///         },
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewHostnameTlsSettingCiphers(ctx, "example", &cloudflare.HostnameTlsSettingCiphersArgs{
/// 			Hostname: pulumi.String("sub.example.com"),
/// 			Values: pulumi.StringArray{
/// 				pulumi.String("ECDHE-RSA-AES128-GCM-SHA256"),
/// 			},
/// 			ZoneId: pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.HostnameTlsSettingCiphers;
/// import com.pulumi.cloudflare.HostnameTlsSettingCiphersArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new HostnameTlsSettingCiphers("example", HostnameTlsSettingCiphersArgs.builder()        
///             .hostname("sub.example.com")
///             .values("ECDHE-RSA-AES128-GCM-SHA256")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:HostnameTlsSettingCiphers
///     properties:
///       hostname: sub.example.com
///       values:
///         - ECDHE-RSA-AES128-GCM-SHA256
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/hostnameTlsSettingCiphers:HostnameTlsSettingCiphers example <zone_id>/<hostname>
/// ```
///
pub mod hostname_tls_setting_ciphers {

    pub struct HostnameTlsSettingCiphersArgs {
        /// Hostname that belongs to this zone name. **Modifying this attribute will force creation of a new resource.**
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// Ports to use within the IP rule.
        pub ports: pulumi_wasm_rust::Output<Option<Vec<i32>>>,
        /// Ciphers suites value.
        pub values: pulumi_wasm_rust::Output<Vec<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct HostnameTlsSettingCiphersResult {
        pub created_at: pulumi_wasm_rust::Output<String>,
        /// Hostname that belongs to this zone name. **Modifying this attribute will force creation of a new resource.**
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// Ports to use within the IP rule.
        pub ports: pulumi_wasm_rust::Output<Option<Vec<i32>>>,
        pub updated_at: pulumi_wasm_rust::Output<String>,
        /// Ciphers suites value.
        pub values: pulumi_wasm_rust::Output<Vec<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn hostname_tls_setting_ciphers(
        name: &str,
        args: HostnameTlsSettingCiphersArgs,
    ) -> HostnameTlsSettingCiphersResult {
        let result = crate::bindings::pulumi::cloudflare::hostname_tls_setting_ciphers::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::hostname_tls_setting_ciphers::Args {
                hostname: args.hostname.get_inner(),
                ports: args.ports.get_inner(),
                values: args.values.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        HostnameTlsSettingCiphersResult {
            created_at: crate::into_domain(result.created_at),
            hostname: crate::into_domain(result.hostname),
            ports: crate::into_domain(result.ports),
            updated_at: crate::into_domain(result.updated_at),
            values: crate::into_domain(result.values),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// The [Hyperdrive Config](https://developers.cloudflare.com/hyperdrive/) resource allows you to manage Cloudflare Hyperdrive Configs.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const noDefaults = new cloudflare.HyperdriveConfig("noDefaults", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "my-hyperdrive-config",
///     origin: {
///         database: "postgres",
///         host: "my-database.example.com",
///         password: "my-password",
///         port: 5432,
///         scheme: "postgres",
///         user: "my-user",
///     },
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// no_defaults = cloudflare.HyperdriveConfig("noDefaults",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="my-hyperdrive-config",
///     origin=cloudflare.HyperdriveConfigOriginArgs(
///         database="postgres",
///         host="my-database.example.com",
///         password="my-password",
///         port=5432,
///         scheme="postgres",
///         user="my-user",
///     ))
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var noDefaults = new Cloudflare.HyperdriveConfig("noDefaults", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "my-hyperdrive-config",
///         Origin = new Cloudflare.Inputs.HyperdriveConfigOriginArgs
///         {
///             Database = "postgres",
///             Host = "my-database.example.com",
///             Password = "my-password",
///             Port = 5432,
///             Scheme = "postgres",
///             User = "my-user",
///         },
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewHyperdriveConfig(ctx, "noDefaults", &cloudflare.HyperdriveConfigArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:      pulumi.String("my-hyperdrive-config"),
/// 			Origin: &cloudflare.HyperdriveConfigOriginArgs{
/// 				Database: pulumi.String("postgres"),
/// 				Host:     pulumi.String("my-database.example.com"),
/// 				Password: pulumi.String("my-password"),
/// 				Port:     pulumi.Int(5432),
/// 				Scheme:   pulumi.String("postgres"),
/// 				User:     pulumi.String("my-user"),
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.HyperdriveConfig;
/// import com.pulumi.cloudflare.HyperdriveConfigArgs;
/// import com.pulumi.cloudflare.inputs.HyperdriveConfigOriginArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var noDefaults = new HyperdriveConfig("noDefaults", HyperdriveConfigArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("my-hyperdrive-config")
///             .origin(HyperdriveConfigOriginArgs.builder()
///                 .database("postgres")
///                 .host("my-database.example.com")
///                 .password("my-password")
///                 .port(5432)
///                 .scheme("postgres")
///                 .user("my-user")
///                 .build())
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   noDefaults:
///     type: cloudflare:HyperdriveConfig
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       name: my-hyperdrive-config
///       origin:
///         database: postgres
///         host: my-database.example.com
///         password: my-password
///         port: 5432
///         scheme: postgres
///         user: my-user
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/hyperdriveConfig:HyperdriveConfig example <account_id>/<hyperdrive_config_id>
/// ```
///
pub mod hyperdrive_config {

    pub struct HyperdriveConfigArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The caching details for the Hyperdrive configuration.
        pub caching: pulumi_wasm_rust::Output<Option<crate::types::HyperdriveConfigCaching>>,
        /// The name of the Hyperdrive configuration.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The origin details for the Hyperdrive configuration.
        pub origin: pulumi_wasm_rust::Output<crate::types::HyperdriveConfigOrigin>,
    }

    pub struct HyperdriveConfigResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The caching details for the Hyperdrive configuration.
        pub caching: pulumi_wasm_rust::Output<crate::types::HyperdriveConfigCaching>,
        /// The name of the Hyperdrive configuration.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The origin details for the Hyperdrive configuration.
        pub origin: pulumi_wasm_rust::Output<crate::types::HyperdriveConfigOrigin>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn hyperdrive_config(name: &str, args: HyperdriveConfigArgs) -> HyperdriveConfigResult {
        let result = crate::bindings::pulumi::cloudflare::hyperdrive_config::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::hyperdrive_config::Args {
                account_id: args.account_id.get_inner(),
                caching: args.caching.get_inner(),
                name: args.name.get_inner(),
                origin: args.origin.get_inner(),
            },
        );

        HyperdriveConfigResult {
            account_id: crate::into_domain(result.account_id),
            caching: crate::into_domain(result.caching),
            name: crate::into_domain(result.name),
            origin: crate::into_domain(result.origin),
        }
    }
}

/// Provides a resource, that manages IPsec tunnels for Magic Transit.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.IpsecTunnel("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     allowNullCipher: false,
///     cloudflareEndpoint: "203.0.113.1",
///     customerEndpoint: "203.0.113.1",
///     description: "Tunnel for ISP X",
///     healthCheckEnabled: true,
///     healthCheckTarget: "203.0.113.1",
///     healthCheckType: "reply",
///     interfaceAddress: "192.0.2.0/31",
///     name: "IPsec_1",
///     psk: "asdf12341234",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.IpsecTunnel("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     allow_null_cipher=False,
///     cloudflare_endpoint="203.0.113.1",
///     customer_endpoint="203.0.113.1",
///     description="Tunnel for ISP X",
///     health_check_enabled=True,
///     health_check_target="203.0.113.1",
///     health_check_type="reply",
///     interface_address="192.0.2.0/31",
///     name="IPsec_1",
///     psk="asdf12341234")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.IpsecTunnel("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         AllowNullCipher = false,
///         CloudflareEndpoint = "203.0.113.1",
///         CustomerEndpoint = "203.0.113.1",
///         Description = "Tunnel for ISP X",
///         HealthCheckEnabled = true,
///         HealthCheckTarget = "203.0.113.1",
///         HealthCheckType = "reply",
///         InterfaceAddress = "192.0.2.0/31",
///         Name = "IPsec_1",
///         Psk = "asdf12341234",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewIpsecTunnel(ctx, "example", &cloudflare.IpsecTunnelArgs{
/// 			AccountId:          pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			AllowNullCipher:    pulumi.Bool(false),
/// 			CloudflareEndpoint: pulumi.String("203.0.113.1"),
/// 			CustomerEndpoint:   pulumi.String("203.0.113.1"),
/// 			Description:        pulumi.String("Tunnel for ISP X"),
/// 			HealthCheckEnabled: pulumi.Bool(true),
/// 			HealthCheckTarget:  pulumi.String("203.0.113.1"),
/// 			HealthCheckType:    pulumi.String("reply"),
/// 			InterfaceAddress:   pulumi.String("192.0.2.0/31"),
/// 			Name:               pulumi.String("IPsec_1"),
/// 			Psk:                pulumi.String("asdf12341234"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.IpsecTunnel;
/// import com.pulumi.cloudflare.IpsecTunnelArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new IpsecTunnel("example", IpsecTunnelArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .allowNullCipher(false)
///             .cloudflareEndpoint("203.0.113.1")
///             .customerEndpoint("203.0.113.1")
///             .description("Tunnel for ISP X")
///             .healthCheckEnabled(true)
///             .healthCheckTarget("203.0.113.1")
///             .healthCheckType("reply")
///             .interfaceAddress("192.0.2.0/31")
///             .name("IPsec_1")
///             .psk("asdf12341234")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:IpsecTunnel
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       allowNullCipher: false
///       cloudflareEndpoint: 203.0.113.1
///       customerEndpoint: 203.0.113.1
///       description: Tunnel for ISP X
///       healthCheckEnabled: true
///       healthCheckTarget: 203.0.113.1
///       healthCheckType: reply
///       interfaceAddress: 192.0.2.0/31
///       name: IPsec_1
///       psk: asdf12341234
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/ipsecTunnel:IpsecTunnel example <account_id>/<tunnel_id>
/// ```
///
pub mod ipsec_tunnel {

    pub struct IpsecTunnelArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies if this tunnel may use a null cipher (ENCR_NULL) in Phase 2. Defaults to `false`.
        pub allow_null_cipher: pulumi_wasm_rust::Output<Option<bool>>,
        /// IP address assigned to the Cloudflare side of the IPsec tunnel.
        pub cloudflare_endpoint: pulumi_wasm_rust::Output<String>,
        /// IP address assigned to the customer side of the IPsec tunnel.
        pub customer_endpoint: pulumi_wasm_rust::Output<String>,
        /// An optional description of the IPsec tunnel.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// `remote_id` in the form of a fqdn. This value is generated by cloudflare.
        pub fqdn_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies the direction for the health check. Available values: `unidirectional`, `bidirectional` Default: `unidirectional`.
        pub health_check_direction: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies if ICMP tunnel health checks are enabled. Default: `true`.
        pub health_check_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Specifies the ICMP rate for the health check. Available values: `low`, `mid`, `high` Default: `mid`.
        pub health_check_rate: pulumi_wasm_rust::Output<Option<String>>,
        /// The IP address of the customer endpoint that will receive tunnel health checks. Default: `<customer_gre_endpoint>`.
        pub health_check_target: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies the ICMP echo type for the health check (`request` or `reply`). Available values: `request`, `reply` Default: `reply`.
        pub health_check_type: pulumi_wasm_rust::Output<Option<String>>,
        /// `remote_id` as a hex string. This value is generated by cloudflare.
        pub hex_id: pulumi_wasm_rust::Output<Option<String>>,
        /// 31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.
        pub interface_address: pulumi_wasm_rust::Output<String>,
        /// Name of the IPsec tunnel.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Pre shared key to be used with the IPsec tunnel. If left unset, it will be autogenerated.
        pub psk: pulumi_wasm_rust::Output<Option<String>>,
        /// ID to be used while setting up the IPsec tunnel. This value is generated by cloudflare.
        pub remote_id: pulumi_wasm_rust::Output<Option<String>>,
        /// `remote_id` in the form of an email address. This value is generated by cloudflare.
        pub user_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct IpsecTunnelResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies if this tunnel may use a null cipher (ENCR_NULL) in Phase 2. Defaults to `false`.
        pub allow_null_cipher: pulumi_wasm_rust::Output<Option<bool>>,
        /// IP address assigned to the Cloudflare side of the IPsec tunnel.
        pub cloudflare_endpoint: pulumi_wasm_rust::Output<String>,
        /// IP address assigned to the customer side of the IPsec tunnel.
        pub customer_endpoint: pulumi_wasm_rust::Output<String>,
        /// An optional description of the IPsec tunnel.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// `remote_id` in the form of a fqdn. This value is generated by cloudflare.
        pub fqdn_id: pulumi_wasm_rust::Output<String>,
        /// Specifies the direction for the health check. Available values: `unidirectional`, `bidirectional` Default: `unidirectional`.
        pub health_check_direction: pulumi_wasm_rust::Output<String>,
        /// Specifies if ICMP tunnel health checks are enabled. Default: `true`.
        pub health_check_enabled: pulumi_wasm_rust::Output<bool>,
        /// Specifies the ICMP rate for the health check. Available values: `low`, `mid`, `high` Default: `mid`.
        pub health_check_rate: pulumi_wasm_rust::Output<String>,
        /// The IP address of the customer endpoint that will receive tunnel health checks. Default: `<customer_gre_endpoint>`.
        pub health_check_target: pulumi_wasm_rust::Output<String>,
        /// Specifies the ICMP echo type for the health check (`request` or `reply`). Available values: `request`, `reply` Default: `reply`.
        pub health_check_type: pulumi_wasm_rust::Output<String>,
        /// `remote_id` as a hex string. This value is generated by cloudflare.
        pub hex_id: pulumi_wasm_rust::Output<String>,
        /// 31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.
        pub interface_address: pulumi_wasm_rust::Output<String>,
        /// Name of the IPsec tunnel.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Pre shared key to be used with the IPsec tunnel. If left unset, it will be autogenerated.
        pub psk: pulumi_wasm_rust::Output<String>,
        /// ID to be used while setting up the IPsec tunnel. This value is generated by cloudflare.
        pub remote_id: pulumi_wasm_rust::Output<String>,
        /// `remote_id` in the form of an email address. This value is generated by cloudflare.
        pub user_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn ipsec_tunnel(name: &str, args: IpsecTunnelArgs) -> IpsecTunnelResult {
        let result = crate::bindings::pulumi::cloudflare::ipsec_tunnel::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::ipsec_tunnel::Args {
                account_id: args.account_id.get_inner(),
                allow_null_cipher: args.allow_null_cipher.get_inner(),
                cloudflare_endpoint: args.cloudflare_endpoint.get_inner(),
                customer_endpoint: args.customer_endpoint.get_inner(),
                description: args.description.get_inner(),
                fqdn_id: args.fqdn_id.get_inner(),
                health_check_direction: args.health_check_direction.get_inner(),
                health_check_enabled: args.health_check_enabled.get_inner(),
                health_check_rate: args.health_check_rate.get_inner(),
                health_check_target: args.health_check_target.get_inner(),
                health_check_type: args.health_check_type.get_inner(),
                hex_id: args.hex_id.get_inner(),
                interface_address: args.interface_address.get_inner(),
                name: args.name.get_inner(),
                psk: args.psk.get_inner(),
                remote_id: args.remote_id.get_inner(),
                user_id: args.user_id.get_inner(),
            },
        );

        IpsecTunnelResult {
            account_id: crate::into_domain(result.account_id),
            allow_null_cipher: crate::into_domain(result.allow_null_cipher),
            cloudflare_endpoint: crate::into_domain(result.cloudflare_endpoint),
            customer_endpoint: crate::into_domain(result.customer_endpoint),
            description: crate::into_domain(result.description),
            fqdn_id: crate::into_domain(result.fqdn_id),
            health_check_direction: crate::into_domain(result.health_check_direction),
            health_check_enabled: crate::into_domain(result.health_check_enabled),
            health_check_rate: crate::into_domain(result.health_check_rate),
            health_check_target: crate::into_domain(result.health_check_target),
            health_check_type: crate::into_domain(result.health_check_type),
            hex_id: crate::into_domain(result.hex_id),
            interface_address: crate::into_domain(result.interface_address),
            name: crate::into_domain(result.name),
            psk: crate::into_domain(result.psk),
            remote_id: crate::into_domain(result.remote_id),
            user_id: crate::into_domain(result.user_id),
        }
    }
}

/// Provides a resource, that manages Keyless certificates.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.KeylessCertificate("example", {
///     bundleMethod: "ubiquitous",
///     certificate: "-----INSERT CERTIFICATE-----",
///     enabled: true,
///     host: "example.com",
///     name: "example.com Keyless SSL",
///     port: 24008,
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.KeylessCertificate("example",
///     bundle_method="ubiquitous",
///     certificate="-----INSERT CERTIFICATE-----",
///     enabled=True,
///     host="example.com",
///     name="example.com Keyless SSL",
///     port=24008,
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.KeylessCertificate("example", new()
///     {
///         BundleMethod = "ubiquitous",
///         Certificate = "-----INSERT CERTIFICATE-----",
///         Enabled = true,
///         Host = "example.com",
///         Name = "example.com Keyless SSL",
///         Port = 24008,
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewKeylessCertificate(ctx, "example", &cloudflare.KeylessCertificateArgs{
/// 			BundleMethod: pulumi.String("ubiquitous"),
/// 			Certificate:  pulumi.String("-----INSERT CERTIFICATE-----"),
/// 			Enabled:      pulumi.Bool(true),
/// 			Host:         pulumi.String("example.com"),
/// 			Name:         pulumi.String("example.com Keyless SSL"),
/// 			Port:         pulumi.Int(24008),
/// 			ZoneId:       pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.KeylessCertificate;
/// import com.pulumi.cloudflare.KeylessCertificateArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new KeylessCertificate("example", KeylessCertificateArgs.builder()        
///             .bundleMethod("ubiquitous")
///             .certificate("-----INSERT CERTIFICATE-----")
///             .enabled(true)
///             .host("example.com")
///             .name("example.com Keyless SSL")
///             .port(24008)
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:KeylessCertificate
///     properties:
///       bundleMethod: ubiquitous
///       certificate: '-----INSERT CERTIFICATE-----'
///       enabled: true
///       host: example.com
///       name: example.com Keyless SSL
///       port: 24008
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/keylessCertificate:KeylessCertificate example <zone_id>/<keyless_certificate_id>
/// ```
///
pub mod keyless_certificate {

    pub struct KeylessCertificateArgs {
        /// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`. Defaults to `ubiquitous`. **Modifying this attribute will force creation of a new resource.**
        pub bundle_method: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone's SSL certificate or SSL certificate and intermediate(s). **Modifying this attribute will force creation of a new resource.**
        pub certificate: pulumi_wasm_rust::Output<String>,
        /// Whether the KeyLess SSL is on.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The KeyLess SSL host.
        pub host: pulumi_wasm_rust::Output<String>,
        /// The KeyLess SSL name.
        pub name: pulumi_wasm_rust::Output<Option<String>>,
        /// The KeyLess SSL port used to communicate between Cloudflare and the client's KeyLess SSL server. Defaults to `24008`.
        pub port: pulumi_wasm_rust::Output<Option<i32>>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct KeylessCertificateResult {
        /// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`. Defaults to `ubiquitous`. **Modifying this attribute will force creation of a new resource.**
        pub bundle_method: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone's SSL certificate or SSL certificate and intermediate(s). **Modifying this attribute will force creation of a new resource.**
        pub certificate: pulumi_wasm_rust::Output<String>,
        /// Whether the KeyLess SSL is on.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The KeyLess SSL host.
        pub host: pulumi_wasm_rust::Output<String>,
        /// The KeyLess SSL name.
        pub name: pulumi_wasm_rust::Output<Option<String>>,
        /// The KeyLess SSL port used to communicate between Cloudflare and the client's KeyLess SSL server. Defaults to `24008`.
        pub port: pulumi_wasm_rust::Output<Option<i32>>,
        /// Status of the KeyLess SSL.
        pub status: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn keyless_certificate(
        name: &str,
        args: KeylessCertificateArgs,
    ) -> KeylessCertificateResult {
        let result = crate::bindings::pulumi::cloudflare::keyless_certificate::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::keyless_certificate::Args {
                bundle_method: args.bundle_method.get_inner(),
                certificate: args.certificate.get_inner(),
                enabled: args.enabled.get_inner(),
                host: args.host.get_inner(),
                name: args.name.get_inner(),
                port: args.port.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        KeylessCertificateResult {
            bundle_method: crate::into_domain(result.bundle_method),
            certificate: crate::into_domain(result.certificate),
            enabled: crate::into_domain(result.enabled),
            host: crate::into_domain(result.host),
            name: crate::into_domain(result.name),
            port: crate::into_domain(result.port),
            status: crate::into_domain(result.status),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.List;
/// import com.pulumi.cloudflare.ListArgs;
/// import com.pulumi.cloudflare.inputs.ListItemArgs;
/// import com.pulumi.cloudflare.inputs.ListItemValueArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // Hostname list
///         var example = new List("example", ListArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .description("example hostnames for a list")
///             .items(            
///                 ListItemArgs.builder()
///                     .comment("one")
///                     .value(ListItemValueArgs.builder()
///                         .hostname(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
///                         .build())
///                     .build(),
///                 ListItemArgs.builder()
///                     .comment("two")
///                     .value(ListItemValueArgs.builder()
///                         .hostname(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
///                         .build())
///                     .build())
///             .kind("hostname")
///             .name("example_list")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # Hostname list
///   example:
///     type: cloudflare:List
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       description: example hostnames for a list
///       items:
///         - comment: one
///           value:
///             hostname:
///               - urlHostname: example.com
///         - comment: two
///           value:
///             hostname:
///               - urlHostname: '*.example.com'
///       kind: hostname
///       name: example_list
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/list:List example <account_id>/<list_id>
/// ```
///
pub mod list {

    pub struct ListArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// An optional description of the list.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        pub items: pulumi_wasm_rust::Output<Option<Vec<crate::types::ListItem>>>,
        /// The type of items the list will contain. Available values: `ip`, `redirect`, `hostname`, `asn`. **Modifying this attribute will force creation of a new resource.**
        pub kind: pulumi_wasm_rust::Output<String>,
        /// The name of the list. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
    }

    pub struct ListResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// An optional description of the list.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        pub items: pulumi_wasm_rust::Output<Option<Vec<crate::types::ListItem>>>,
        /// The type of items the list will contain. Available values: `ip`, `redirect`, `hostname`, `asn`. **Modifying this attribute will force creation of a new resource.**
        pub kind: pulumi_wasm_rust::Output<String>,
        /// The name of the list. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn list(name: &str, args: ListArgs) -> ListResult {
        let result = crate::bindings::pulumi::cloudflare::list::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::list::Args {
                account_id: args.account_id.get_inner(),
                description: args.description.get_inner(),
                items: args.items.get_inner(),
                kind: args.kind.get_inner(),
                name: args.name.get_inner(),
            },
        );

        ListResult {
            account_id: crate::into_domain(result.account_id),
            description: crate::into_domain(result.description),
            items: crate::into_domain(result.items),
            kind: crate::into_domain(result.kind),
            name: crate::into_domain(result.name),
        }
    }
}

/// Provides individual list items (IPs, Redirects, ASNs, Hostnames) to be used in Edge Rules Engine
/// across all zones within the same account.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// // IP List
/// const exampleIpList = new cloudflare.List("exampleIpList", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "example_list",
///     description: "example IPs for a list",
///     kind: "ip",
/// });
/// // IP List Item
/// const exampleIpItem = new cloudflare.ListItem("exampleIpItem", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     listId: exampleIpList.id,
///     comment: "List Item Comment",
///     ip: "192.0.2.0",
/// });
/// // Redirect List
/// const exampleRedirectList = new cloudflare.List("exampleRedirectList", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "example_list",
///     description: "example Redirects for a list",
///     kind: "redirect",
/// });
/// // Redirect List Item
/// const exampleRedirectItem = new cloudflare.ListItem("exampleRedirectItem", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     listId: exampleIpList.id,
///     redirect: {
///         sourceUrl: "https://source.tld/",
///         targetUrl: "https://target.tld",
///         statusCode: 302,
///         subpathMatching: true,
///     },
/// });
/// // ASN List
/// const exampleAsnList = new cloudflare.List("exampleAsnList", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "example_asn_list",
///     description: "example ASNs for a list",
///     kind: "asn",
/// });
/// // ASN List Item
/// const exampleAsnItem = new cloudflare.ListItem("exampleAsnItem", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     listId: exampleAsnList.id,
///     comment: "List Item Comment",
///     asn: 6789,
/// });
/// // Hostname List
/// const exampleHostnameList = new cloudflare.List("exampleHostnameList", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "example_hostname_list",
///     description: "example Hostnames for a list",
///     kind: "hostname",
/// });
/// // Hostname List Item
/// const exampleHostnameItem = new cloudflare.ListItem("exampleHostnameItem", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     listId: exampleHostnameList.id,
///     comment: "List Item Comment",
///     hostname: {
///         urlHostname: "example.com",
///     },
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// # IP List
/// example_ip_list = cloudflare.List("exampleIpList",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="example_list",
///     description="example IPs for a list",
///     kind="ip")
/// # IP List Item
/// example_ip_item = cloudflare.ListItem("exampleIpItem",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     list_id=example_ip_list.id,
///     comment="List Item Comment",
///     ip="192.0.2.0")
/// # Redirect List
/// example_redirect_list = cloudflare.List("exampleRedirectList",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="example_list",
///     description="example Redirects for a list",
///     kind="redirect")
/// # Redirect List Item
/// example_redirect_item = cloudflare.ListItem("exampleRedirectItem",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     list_id=example_ip_list.id,
///     redirect=cloudflare.ListItemRedirectArgs(
///         source_url="https://source.tld/",
///         target_url="https://target.tld",
///         status_code=302,
///         subpath_matching=True,
///     ))
/// # ASN List
/// example_asn_list = cloudflare.List("exampleAsnList",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="example_asn_list",
///     description="example ASNs for a list",
///     kind="asn")
/// # ASN List Item
/// example_asn_item = cloudflare.ListItem("exampleAsnItem",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     list_id=example_asn_list.id,
///     comment="List Item Comment",
///     asn=6789)
/// # Hostname List
/// example_hostname_list = cloudflare.List("exampleHostnameList",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="example_hostname_list",
///     description="example Hostnames for a list",
///     kind="hostname")
/// # Hostname List Item
/// example_hostname_item = cloudflare.ListItem("exampleHostnameItem",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     list_id=example_hostname_list.id,
///     comment="List Item Comment",
///     hostname=cloudflare.ListItemHostnameArgs(
///         url_hostname="example.com",
///     ))
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     // IP List
///     var exampleIpList = new Cloudflare.List("exampleIpList", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "example_list",
///         Description = "example IPs for a list",
///         Kind = "ip",
///     });
///
///     // IP List Item
///     var exampleIpItem = new Cloudflare.ListItem("exampleIpItem", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         ListId = exampleIpList.Id,
///         Comment = "List Item Comment",
///         Ip = "192.0.2.0",
///     });
///
///     // Redirect List
///     var exampleRedirectList = new Cloudflare.List("exampleRedirectList", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "example_list",
///         Description = "example Redirects for a list",
///         Kind = "redirect",
///     });
///
///     // Redirect List Item
///     var exampleRedirectItem = new Cloudflare.ListItem("exampleRedirectItem", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         ListId = exampleIpList.Id,
///         Redirect = new Cloudflare.Inputs.ListItemRedirectArgs
///         {
///             SourceUrl = "https://source.tld/",
///             TargetUrl = "https://target.tld",
///             StatusCode = 302,
///             SubpathMatching = true,
///         },
///     });
///
///     // ASN List
///     var exampleAsnList = new Cloudflare.List("exampleAsnList", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "example_asn_list",
///         Description = "example ASNs for a list",
///         Kind = "asn",
///     });
///
///     // ASN List Item
///     var exampleAsnItem = new Cloudflare.ListItem("exampleAsnItem", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         ListId = exampleAsnList.Id,
///         Comment = "List Item Comment",
///         Asn = 6789,
///     });
///
///     // Hostname List
///     var exampleHostnameList = new Cloudflare.List("exampleHostnameList", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "example_hostname_list",
///         Description = "example Hostnames for a list",
///         Kind = "hostname",
///     });
///
///     // Hostname List Item
///     var exampleHostnameItem = new Cloudflare.ListItem("exampleHostnameItem", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         ListId = exampleHostnameList.Id,
///         Comment = "List Item Comment",
///         Hostname = new Cloudflare.Inputs.ListItemHostnameArgs
///         {
///             UrlHostname = "example.com",
///         },
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// IP List
/// 		exampleIpList, err := cloudflare.NewList(ctx, "exampleIpList", &cloudflare.ListArgs{
/// 			AccountId:   pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:        pulumi.String("example_list"),
/// 			Description: pulumi.String("example IPs for a list"),
/// 			Kind:        pulumi.String("ip"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// IP List Item
/// 		_, err = cloudflare.NewListItem(ctx, "exampleIpItem", &cloudflare.ListItemArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			ListId:    exampleIpList.ID(),
/// 			Comment:   pulumi.String("List Item Comment"),
/// 			Ip:        pulumi.String("192.0.2.0"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// Redirect List
/// 		_, err = cloudflare.NewList(ctx, "exampleRedirectList", &cloudflare.ListArgs{
/// 			AccountId:   pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:        pulumi.String("example_list"),
/// 			Description: pulumi.String("example Redirects for a list"),
/// 			Kind:        pulumi.String("redirect"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// Redirect List Item
/// 		_, err = cloudflare.NewListItem(ctx, "exampleRedirectItem", &cloudflare.ListItemArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			ListId:    exampleIpList.ID(),
/// 			Redirect: &cloudflare.ListItemRedirectArgs{
/// 				SourceUrl:       pulumi.String("https://source.tld/"),
/// 				TargetUrl:       pulumi.String("https://target.tld"),
/// 				StatusCode:      pulumi.Int(302),
/// 				SubpathMatching: pulumi.Bool(true),
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// ASN List
/// 		exampleAsnList, err := cloudflare.NewList(ctx, "exampleAsnList", &cloudflare.ListArgs{
/// 			AccountId:   pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:        pulumi.String("example_asn_list"),
/// 			Description: pulumi.String("example ASNs for a list"),
/// 			Kind:        pulumi.String("asn"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// ASN List Item
/// 		_, err = cloudflare.NewListItem(ctx, "exampleAsnItem", &cloudflare.ListItemArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			ListId:    exampleAsnList.ID(),
/// 			Comment:   pulumi.String("List Item Comment"),
/// 			Asn:       pulumi.Int(6789),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// Hostname List
/// 		exampleHostnameList, err := cloudflare.NewList(ctx, "exampleHostnameList", &cloudflare.ListArgs{
/// 			AccountId:   pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:        pulumi.String("example_hostname_list"),
/// 			Description: pulumi.String("example Hostnames for a list"),
/// 			Kind:        pulumi.String("hostname"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// Hostname List Item
/// 		_, err = cloudflare.NewListItem(ctx, "exampleHostnameItem", &cloudflare.ListItemArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			ListId:    exampleHostnameList.ID(),
/// 			Comment:   pulumi.String("List Item Comment"),
/// 			Hostname: &cloudflare.ListItemHostnameArgs{
/// 				UrlHostname: pulumi.String("example.com"),
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.List;
/// import com.pulumi.cloudflare.ListArgs;
/// import com.pulumi.cloudflare.ListItem;
/// import com.pulumi.cloudflare.ListItemArgs;
/// import com.pulumi.cloudflare.inputs.ListItemRedirectArgs;
/// import com.pulumi.cloudflare.inputs.ListItemHostnameArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // IP List
///         var exampleIpList = new List("exampleIpList", ListArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("example_list")
///             .description("example IPs for a list")
///             .kind("ip")
///             .build());
///
///         // IP List Item
///         var exampleIpItem = new ListItem("exampleIpItem", ListItemArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .listId(exampleIpList.id())
///             .comment("List Item Comment")
///             .ip("192.0.2.0")
///             .build());
///
///         // Redirect List
///         var exampleRedirectList = new List("exampleRedirectList", ListArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("example_list")
///             .description("example Redirects for a list")
///             .kind("redirect")
///             .build());
///
///         // Redirect List Item
///         var exampleRedirectItem = new ListItem("exampleRedirectItem", ListItemArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .listId(exampleIpList.id())
///             .redirect(ListItemRedirectArgs.builder()
///                 .sourceUrl("https://source.tld/")
///                 .targetUrl("https://target.tld")
///                 .statusCode(302)
///                 .subpathMatching(true)
///                 .build())
///             .build());
///
///         // ASN List
///         var exampleAsnList = new List("exampleAsnList", ListArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("example_asn_list")
///             .description("example ASNs for a list")
///             .kind("asn")
///             .build());
///
///         // ASN List Item
///         var exampleAsnItem = new ListItem("exampleAsnItem", ListItemArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .listId(exampleAsnList.id())
///             .comment("List Item Comment")
///             .asn(6789)
///             .build());
///
///         // Hostname List
///         var exampleHostnameList = new List("exampleHostnameList", ListArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("example_hostname_list")
///             .description("example Hostnames for a list")
///             .kind("hostname")
///             .build());
///
///         // Hostname List Item
///         var exampleHostnameItem = new ListItem("exampleHostnameItem", ListItemArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .listId(exampleHostnameList.id())
///             .comment("List Item Comment")
///             .hostname(ListItemHostnameArgs.builder()
///                 .urlHostname("example.com")
///                 .build())
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # IP List
///   exampleIpList:
///     type: cloudflare:List
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       name: example_list
///       description: example IPs for a list
///       kind: ip
///   # IP List Item
///   exampleIpItem:
///     type: cloudflare:ListItem
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       listId: ${exampleIpList.id}
///       comment: List Item Comment
///       ip: 192.0.2.0
///   # Redirect List
///   exampleRedirectList:
///     type: cloudflare:List
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       name: example_list
///       description: example Redirects for a list
///       kind: redirect
///   # Redirect List Item
///   exampleRedirectItem:
///     type: cloudflare:ListItem
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       listId: ${exampleIpList.id}
///       redirect:
///         sourceUrl: https://source.tld/
///         targetUrl: https://target.tld
///         statusCode: 302
///         subpathMatching: true
///   # ASN List
///   exampleAsnList:
///     type: cloudflare:List
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       name: example_asn_list
///       description: example ASNs for a list
///       kind: asn
///   # ASN List Item
///   exampleAsnItem:
///     type: cloudflare:ListItem
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       listId: ${exampleAsnList.id}
///       comment: List Item Comment
///       asn: 6789
///   # Hostname List
///   exampleHostnameList:
///     type: cloudflare:List
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       name: example_hostname_list
///       description: example Hostnames for a list
///       kind: hostname
///   # Hostname List Item
///   exampleHostnameItem:
///     type: cloudflare:ListItem
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       listId: ${exampleHostnameList.id}
///       comment: List Item Comment
///       hostname:
///         urlHostname: example.com
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/listItem:ListItem example <account_id>/<list_id>/<item_id>
/// ```
///
pub mod list_item {

    pub struct ListItemArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Autonomous system number to include in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.
        pub asn: pulumi_wasm_rust::Output<Option<i32>>,
        /// An optional comment for the item.
        pub comment: pulumi_wasm_rust::Output<Option<String>>,
        /// Hostname to store in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.
        pub hostname: pulumi_wasm_rust::Output<Option<crate::types::ListItemHostname>>,
        /// IP address to include in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.
        pub ip: pulumi_wasm_rust::Output<Option<String>>,
        /// The list identifier to target for the resource.
        pub list_id: pulumi_wasm_rust::Output<String>,
        /// Redirect configuration to store in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.
        pub redirect: pulumi_wasm_rust::Output<Option<crate::types::ListItemRedirect>>,
    }

    pub struct ListItemResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Autonomous system number to include in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.
        pub asn: pulumi_wasm_rust::Output<Option<i32>>,
        /// An optional comment for the item.
        pub comment: pulumi_wasm_rust::Output<Option<String>>,
        /// Hostname to store in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.
        pub hostname: pulumi_wasm_rust::Output<Option<crate::types::ListItemHostname>>,
        /// IP address to include in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.
        pub ip: pulumi_wasm_rust::Output<Option<String>>,
        /// The list identifier to target for the resource.
        pub list_id: pulumi_wasm_rust::Output<String>,
        /// Redirect configuration to store in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.
        pub redirect: pulumi_wasm_rust::Output<Option<crate::types::ListItemRedirect>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn list_item(name: &str, args: ListItemArgs) -> ListItemResult {
        let result = crate::bindings::pulumi::cloudflare::list_item::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::list_item::Args {
                account_id: args.account_id.get_inner(),
                asn: args.asn.get_inner(),
                comment: args.comment.get_inner(),
                hostname: args.hostname.get_inner(),
                ip: args.ip.get_inner(),
                list_id: args.list_id.get_inner(),
                redirect: args.redirect.get_inner(),
            },
        );

        ListItemResult {
            account_id: crate::into_domain(result.account_id),
            asn: crate::into_domain(result.asn),
            comment: crate::into_domain(result.comment),
            hostname: crate::into_domain(result.hostname),
            ip: crate::into_domain(result.ip),
            list_id: crate::into_domain(result.list_id),
            redirect: crate::into_domain(result.redirect),
        }
    }
}

/// Provides a Cloudflare Load Balancer resource. This sits in front of
/// a number of defined pools of origins and provides various options
/// for geographically-aware load balancing. Note that the load balancing
/// feature must be enabled in your Cloudflare account before you can use
/// this resource.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const exampleLoadBalancerPool = new cloudflare.LoadBalancerPool("exampleLoadBalancerPool", {
///     name: "example-lb-pool",
///     origins: [{
///         name: "example-1",
///         address: "192.0.2.1",
///         enabled: false,
///     }],
/// });
/// // Define a load balancer which always points to a pool we define below.
/// // In normal usage, would have different pools set for different pops
/// // (cloudflare points-of-presence) and/or for different regions.
/// // Within each pop or region we can define multiple pools in failover order.
/// const exampleLoadBalancer = new cloudflare.LoadBalancer("exampleLoadBalancer", {
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
///     name: "example-load-balancer.example.com",
///     fallbackPoolId: exampleLoadBalancerPool.id,
///     defaultPoolIds: [exampleLoadBalancerPool.id],
///     description: "example load balancer using geo-balancing",
///     proxied: true,
///     steeringPolicy: "geo",
///     popPools: [{
///         pop: "LAX",
///         poolIds: [exampleLoadBalancerPool.id],
///     }],
///     countryPools: [{
///         country: "US",
///         poolIds: [exampleLoadBalancerPool.id],
///     }],
///     regionPools: [{
///         region: "WNAM",
///         poolIds: [exampleLoadBalancerPool.id],
///     }],
///     rules: [{
///         name: "example rule",
///         condition: "http.request.uri.path contains \"testing\"",
///         fixedResponse: {
///             messageBody: "hello",
///             statusCode: 200,
///             contentType: "html",
///             location: "www.example.com",
///         },
///     }],
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example_load_balancer_pool = cloudflare.LoadBalancerPool("exampleLoadBalancerPool",
///     name="example-lb-pool",
///     origins=[cloudflare.LoadBalancerPoolOriginArgs(
///         name="example-1",
///         address="192.0.2.1",
///         enabled=False,
///     )])
/// # Define a load balancer which always points to a pool we define below.
/// # In normal usage, would have different pools set for different pops
/// # (cloudflare points-of-presence) and/or for different regions.
/// # Within each pop or region we can define multiple pools in failover order.
/// example_load_balancer = cloudflare.LoadBalancer("exampleLoadBalancer",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711",
///     name="example-load-balancer.example.com",
///     fallback_pool_id=example_load_balancer_pool.id,
///     default_pool_ids=[example_load_balancer_pool.id],
///     description="example load balancer using geo-balancing",
///     proxied=True,
///     steering_policy="geo",
///     pop_pools=[cloudflare.LoadBalancerPopPoolArgs(
///         pop="LAX",
///         pool_ids=[example_load_balancer_pool.id],
///     )],
///     country_pools=[cloudflare.LoadBalancerCountryPoolArgs(
///         country="US",
///         pool_ids=[example_load_balancer_pool.id],
///     )],
///     region_pools=[cloudflare.LoadBalancerRegionPoolArgs(
///         region="WNAM",
///         pool_ids=[example_load_balancer_pool.id],
///     )],
///     rules=[cloudflare.LoadBalancerRuleArgs(
///         name="example rule",
///         condition="http.request.uri.path contains \"testing\"",
///         fixed_response=cloudflare.LoadBalancerRuleFixedResponseArgs(
///             message_body="hello",
///             status_code=200,
///             content_type="html",
///             location="www.example.com",
///         ),
///     )])
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var exampleLoadBalancerPool = new Cloudflare.LoadBalancerPool("exampleLoadBalancerPool", new()
///     {
///         Name = "example-lb-pool",
///         Origins = new[]
///         {
///             new Cloudflare.Inputs.LoadBalancerPoolOriginArgs
///             {
///                 Name = "example-1",
///                 Address = "192.0.2.1",
///                 Enabled = false,
///             },
///         },
///     });
///
///     // Define a load balancer which always points to a pool we define below.
///     // In normal usage, would have different pools set for different pops
///     // (cloudflare points-of-presence) and/or for different regions.
///     // Within each pop or region we can define multiple pools in failover order.
///     var exampleLoadBalancer = new Cloudflare.LoadBalancer("exampleLoadBalancer", new()
///     {
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///         Name = "example-load-balancer.example.com",
///         FallbackPoolId = exampleLoadBalancerPool.Id,
///         DefaultPoolIds = new[]
///         {
///             exampleLoadBalancerPool.Id,
///         },
///         Description = "example load balancer using geo-balancing",
///         Proxied = true,
///         SteeringPolicy = "geo",
///         PopPools = new[]
///         {
///             new Cloudflare.Inputs.LoadBalancerPopPoolArgs
///             {
///                 Pop = "LAX",
///                 PoolIds = new[]
///                 {
///                     exampleLoadBalancerPool.Id,
///                 },
///             },
///         },
///         CountryPools = new[]
///         {
///             new Cloudflare.Inputs.LoadBalancerCountryPoolArgs
///             {
///                 Country = "US",
///                 PoolIds = new[]
///                 {
///                     exampleLoadBalancerPool.Id,
///                 },
///             },
///         },
///         RegionPools = new[]
///         {
///             new Cloudflare.Inputs.LoadBalancerRegionPoolArgs
///             {
///                 Region = "WNAM",
///                 PoolIds = new[]
///                 {
///                     exampleLoadBalancerPool.Id,
///                 },
///             },
///         },
///         Rules = new[]
///         {
///             new Cloudflare.Inputs.LoadBalancerRuleArgs
///             {
///                 Name = "example rule",
///                 Condition = "http.request.uri.path contains \"testing\"",
///                 FixedResponse = new Cloudflare.Inputs.LoadBalancerRuleFixedResponseArgs
///                 {
///                     MessageBody = "hello",
///                     StatusCode = 200,
///                     ContentType = "html",
///                     Location = "www.example.com",
///                 },
///             },
///         },
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		exampleLoadBalancerPool, err := cloudflare.NewLoadBalancerPool(ctx, "exampleLoadBalancerPool", &cloudflare.LoadBalancerPoolArgs{
/// 			Name: pulumi.String("example-lb-pool"),
/// 			Origins: cloudflare.LoadBalancerPoolOriginArray{
/// 				&cloudflare.LoadBalancerPoolOriginArgs{
/// 					Name:    pulumi.String("example-1"),
/// 					Address: pulumi.String("192.0.2.1"),
/// 					Enabled: pulumi.Bool(false),
/// 				},
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// Define a load balancer which always points to a pool we define below.
/// 		// In normal usage, would have different pools set for different pops
/// 		// (cloudflare points-of-presence) and/or for different regions.
/// 		// Within each pop or region we can define multiple pools in failover order.
/// 		_, err = cloudflare.NewLoadBalancer(ctx, "exampleLoadBalancer", &cloudflare.LoadBalancerArgs{
/// 			ZoneId:         pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 			Name:           pulumi.String("example-load-balancer.example.com"),
/// 			FallbackPoolId: exampleLoadBalancerPool.ID(),
/// 			DefaultPoolIds: pulumi.StringArray{
/// 				exampleLoadBalancerPool.ID(),
/// 			},
/// 			Description:    pulumi.String("example load balancer using geo-balancing"),
/// 			Proxied:        pulumi.Bool(true),
/// 			SteeringPolicy: pulumi.String("geo"),
/// 			PopPools: cloudflare.LoadBalancerPopPoolArray{
/// 				&cloudflare.LoadBalancerPopPoolArgs{
/// 					Pop: pulumi.String("LAX"),
/// 					PoolIds: pulumi.StringArray{
/// 						exampleLoadBalancerPool.ID(),
/// 					},
/// 				},
/// 			},
/// 			CountryPools: cloudflare.LoadBalancerCountryPoolArray{
/// 				&cloudflare.LoadBalancerCountryPoolArgs{
/// 					Country: pulumi.String("US"),
/// 					PoolIds: pulumi.StringArray{
/// 						exampleLoadBalancerPool.ID(),
/// 					},
/// 				},
/// 			},
/// 			RegionPools: cloudflare.LoadBalancerRegionPoolArray{
/// 				&cloudflare.LoadBalancerRegionPoolArgs{
/// 					Region: pulumi.String("WNAM"),
/// 					PoolIds: pulumi.StringArray{
/// 						exampleLoadBalancerPool.ID(),
/// 					},
/// 				},
/// 			},
/// 			Rules: cloudflare.LoadBalancerRuleArray{
/// 				&cloudflare.LoadBalancerRuleArgs{
/// 					Name:      pulumi.String("example rule"),
/// 					Condition: pulumi.String("http.request.uri.path contains \"testing\""),
/// 					FixedResponse: &cloudflare.LoadBalancerRuleFixedResponseArgs{
/// 						MessageBody: pulumi.String("hello"),
/// 						StatusCode:  pulumi.Int(200),
/// 						ContentType: pulumi.String("html"),
/// 						Location:    pulumi.String("www.example.com"),
/// 					},
/// 				},
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.LoadBalancerPool;
/// import com.pulumi.cloudflare.LoadBalancerPoolArgs;
/// import com.pulumi.cloudflare.inputs.LoadBalancerPoolOriginArgs;
/// import com.pulumi.cloudflare.LoadBalancer;
/// import com.pulumi.cloudflare.LoadBalancerArgs;
/// import com.pulumi.cloudflare.inputs.LoadBalancerPopPoolArgs;
/// import com.pulumi.cloudflare.inputs.LoadBalancerCountryPoolArgs;
/// import com.pulumi.cloudflare.inputs.LoadBalancerRegionPoolArgs;
/// import com.pulumi.cloudflare.inputs.LoadBalancerRuleArgs;
/// import com.pulumi.cloudflare.inputs.LoadBalancerRuleFixedResponseArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var exampleLoadBalancerPool = new LoadBalancerPool("exampleLoadBalancerPool", LoadBalancerPoolArgs.builder()        
///             .name("example-lb-pool")
///             .origins(LoadBalancerPoolOriginArgs.builder()
///                 .name("example-1")
///                 .address("192.0.2.1")
///                 .enabled(false)
///                 .build())
///             .build());
///
///         // Define a load balancer which always points to a pool we define below.
///         // In normal usage, would have different pools set for different pops
///         // (cloudflare points-of-presence) and/or for different regions.
///         // Within each pop or region we can define multiple pools in failover order.
///         var exampleLoadBalancer = new LoadBalancer("exampleLoadBalancer", LoadBalancerArgs.builder()        
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .name("example-load-balancer.example.com")
///             .fallbackPoolId(exampleLoadBalancerPool.id())
///             .defaultPoolIds(exampleLoadBalancerPool.id())
///             .description("example load balancer using geo-balancing")
///             .proxied(true)
///             .steeringPolicy("geo")
///             .popPools(LoadBalancerPopPoolArgs.builder()
///                 .pop("LAX")
///                 .poolIds(exampleLoadBalancerPool.id())
///                 .build())
///             .countryPools(LoadBalancerCountryPoolArgs.builder()
///                 .country("US")
///                 .poolIds(exampleLoadBalancerPool.id())
///                 .build())
///             .regionPools(LoadBalancerRegionPoolArgs.builder()
///                 .region("WNAM")
///                 .poolIds(exampleLoadBalancerPool.id())
///                 .build())
///             .rules(LoadBalancerRuleArgs.builder()
///                 .name("example rule")
///                 .condition("http.request.uri.path contains \"testing\"")
///                 .fixedResponse(LoadBalancerRuleFixedResponseArgs.builder()
///                     .messageBody("hello")
///                     .statusCode(200)
///                     .contentType("html")
///                     .location("www.example.com")
///                     .build())
///                 .build())
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # Define a load balancer which always points to a pool we define below.
///   # In normal usage, would have different pools set for different pops
///   # (cloudflare points-of-presence) and/or for different regions.
///   # Within each pop or region we can define multiple pools in failover order.
///   exampleLoadBalancer:
///     type: cloudflare:LoadBalancer
///     properties:
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///       name: example-load-balancer.example.com
///       fallbackPoolId: ${exampleLoadBalancerPool.id}
///       defaultPoolIds:
///         - ${exampleLoadBalancerPool.id}
///       description: example load balancer using geo-balancing
///       proxied: true
///       steeringPolicy: geo
///       popPools:
///         - pop: LAX
///           poolIds:
///             - ${exampleLoadBalancerPool.id}
///       countryPools:
///         - country: US
///           poolIds:
///             - ${exampleLoadBalancerPool.id}
///       regionPools:
///         - region: WNAM
///           poolIds:
///             - ${exampleLoadBalancerPool.id}
///       rules:
///         - name: example rule
///           condition: http.request.uri.path contains "testing"
///           fixedResponse:
///             messageBody: hello
///             statusCode: 200
///             contentType: html
///             location: www.example.com
///   exampleLoadBalancerPool:
///     type: cloudflare:LoadBalancerPool
///     properties:
///       name: example-lb-pool
///       origins:
///         - name: example-1
///           address: 192.0.2.1
///           enabled: false
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/loadBalancer:LoadBalancer example <zone_id>/<load_balancer_id>
/// ```
///
pub mod load_balancer {

    pub struct LoadBalancerArgs {
        /// Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.
        pub adaptive_routings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::LoadBalancerAdaptiveRouting>>>,
        /// A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.
        pub country_pools:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::LoadBalancerCountryPool>>>,
        /// A list of pool IDs ordered by their failover priority. Used whenever `pop_pools`/`country_pools`/`region_pools` are not defined.
        pub default_pool_ids: pulumi_wasm_rust::Output<Vec<String>>,
        /// Free text description.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Enable or disable the load balancer. Defaults to `true`.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The pool ID to use when all other pools are detected as unhealthy.
        pub fallback_pool_id: pulumi_wasm_rust::Output<String>,
        /// Controls location-based steering for non-proxied requests.
        pub location_strategies:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::LoadBalancerLocationStrategy>>>,
        /// Human readable name for this rule.
        pub name: pulumi_wasm_rust::Output<String>,
        /// A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.
        pub pop_pools: pulumi_wasm_rust::Output<Option<Vec<crate::types::LoadBalancerPopPool>>>,
        /// Whether the hostname gets Cloudflare's origin protection. Defaults to `false`. Conflicts with `ttl`.
        pub proxied: pulumi_wasm_rust::Output<Option<bool>>,
        /// Configures pool weights. When `steering_policy="random"`, a random pool is selected with probability proportional to pool weights. When `steering_policy="least_outstanding_requests"`, pool weights are used to scale each pool's outstanding requests. When `steering_policy="least_connections"`, pool weights are used to scale each pool's open connections.
        pub random_steerings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::LoadBalancerRandomSteering>>>,
        /// A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.
        pub region_pools:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::LoadBalancerRegionPool>>>,
        /// A list of rules for this load balancer to execute.
        pub rules: pulumi_wasm_rust::Output<Option<Vec<crate::types::LoadBalancerRule>>>,
        /// Configure attributes for session affinity.
        pub session_affinity: pulumi_wasm_rust::Output<Option<String>>,
        /// Configure attributes for session affinity. Note that the property `drain_duration` is not currently supported as a rule override.
        pub session_affinity_attributes: pulumi_wasm_rust::Output<
            Option<Vec<crate::types::LoadBalancerSessionAffinityAttribute>>,
        >,
        /// Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.
        pub session_affinity_ttl: pulumi_wasm_rust::Output<Option<i32>>,
        /// The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `least_outstanding_requests` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of outstanding requests. Pools with more pending requests are weighted proportionately less relative to others. Value `least_connections` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of open connections. Pools with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Value `""` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `least_outstanding_requests`, `least_connections`, `""` Defaults to `""`.
        pub steering_policy: pulumi_wasm_rust::Output<Option<String>>,
        /// Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`.
        pub ttl: pulumi_wasm_rust::Output<Option<i32>>,
        /// The zone ID to add the load balancer to. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct LoadBalancerResult {
        /// Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.
        pub adaptive_routings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::LoadBalancerAdaptiveRouting>>>,
        /// A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.
        pub country_pools:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::LoadBalancerCountryPool>>>,
        /// The RFC3339 timestamp of when the load balancer was created.
        pub created_on: pulumi_wasm_rust::Output<String>,
        /// A list of pool IDs ordered by their failover priority. Used whenever `pop_pools`/`country_pools`/`region_pools` are not defined.
        pub default_pool_ids: pulumi_wasm_rust::Output<Vec<String>>,
        /// Free text description.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Enable or disable the load balancer. Defaults to `true`.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The pool ID to use when all other pools are detected as unhealthy.
        pub fallback_pool_id: pulumi_wasm_rust::Output<String>,
        /// Controls location-based steering for non-proxied requests.
        pub location_strategies:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::LoadBalancerLocationStrategy>>>,
        /// The RFC3339 timestamp of when the load balancer was last modified.
        pub modified_on: pulumi_wasm_rust::Output<String>,
        /// Human readable name for this rule.
        pub name: pulumi_wasm_rust::Output<String>,
        /// A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.
        pub pop_pools: pulumi_wasm_rust::Output<Option<Vec<crate::types::LoadBalancerPopPool>>>,
        /// Whether the hostname gets Cloudflare's origin protection. Defaults to `false`. Conflicts with `ttl`.
        pub proxied: pulumi_wasm_rust::Output<Option<bool>>,
        /// Configures pool weights. When `steering_policy="random"`, a random pool is selected with probability proportional to pool weights. When `steering_policy="least_outstanding_requests"`, pool weights are used to scale each pool's outstanding requests. When `steering_policy="least_connections"`, pool weights are used to scale each pool's open connections.
        pub random_steerings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::LoadBalancerRandomSteering>>>,
        /// A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.
        pub region_pools:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::LoadBalancerRegionPool>>>,
        /// A list of rules for this load balancer to execute.
        pub rules: pulumi_wasm_rust::Output<Option<Vec<crate::types::LoadBalancerRule>>>,
        /// Configure attributes for session affinity.
        pub session_affinity: pulumi_wasm_rust::Output<Option<String>>,
        /// Configure attributes for session affinity. Note that the property `drain_duration` is not currently supported as a rule override.
        pub session_affinity_attributes: pulumi_wasm_rust::Output<
            Option<Vec<crate::types::LoadBalancerSessionAffinityAttribute>>,
        >,
        /// Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.
        pub session_affinity_ttl: pulumi_wasm_rust::Output<Option<i32>>,
        /// The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `least_outstanding_requests` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of outstanding requests. Pools with more pending requests are weighted proportionately less relative to others. Value `least_connections` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of open connections. Pools with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Value `""` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `least_outstanding_requests`, `least_connections`, `""` Defaults to `""`.
        pub steering_policy: pulumi_wasm_rust::Output<String>,
        /// Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`.
        pub ttl: pulumi_wasm_rust::Output<i32>,
        /// The zone ID to add the load balancer to. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn load_balancer(name: &str, args: LoadBalancerArgs) -> LoadBalancerResult {
        let result = crate::bindings::pulumi::cloudflare::load_balancer::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::load_balancer::Args {
                adaptive_routings: args.adaptive_routings.get_inner(),
                country_pools: args.country_pools.get_inner(),
                default_pool_ids: args.default_pool_ids.get_inner(),
                description: args.description.get_inner(),
                enabled: args.enabled.get_inner(),
                fallback_pool_id: args.fallback_pool_id.get_inner(),
                location_strategies: args.location_strategies.get_inner(),
                name: args.name.get_inner(),
                pop_pools: args.pop_pools.get_inner(),
                proxied: args.proxied.get_inner(),
                random_steerings: args.random_steerings.get_inner(),
                region_pools: args.region_pools.get_inner(),
                rules: args.rules.get_inner(),
                session_affinity: args.session_affinity.get_inner(),
                session_affinity_attributes: args.session_affinity_attributes.get_inner(),
                session_affinity_ttl: args.session_affinity_ttl.get_inner(),
                steering_policy: args.steering_policy.get_inner(),
                ttl: args.ttl.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        LoadBalancerResult {
            adaptive_routings: crate::into_domain(result.adaptive_routings),
            country_pools: crate::into_domain(result.country_pools),
            created_on: crate::into_domain(result.created_on),
            default_pool_ids: crate::into_domain(result.default_pool_ids),
            description: crate::into_domain(result.description),
            enabled: crate::into_domain(result.enabled),
            fallback_pool_id: crate::into_domain(result.fallback_pool_id),
            location_strategies: crate::into_domain(result.location_strategies),
            modified_on: crate::into_domain(result.modified_on),
            name: crate::into_domain(result.name),
            pop_pools: crate::into_domain(result.pop_pools),
            proxied: crate::into_domain(result.proxied),
            random_steerings: crate::into_domain(result.random_steerings),
            region_pools: crate::into_domain(result.region_pools),
            rules: crate::into_domain(result.rules),
            session_affinity: crate::into_domain(result.session_affinity),
            session_affinity_attributes: crate::into_domain(result.session_affinity_attributes),
            session_affinity_ttl: crate::into_domain(result.session_affinity_ttl),
            steering_policy: crate::into_domain(result.steering_policy),
            ttl: crate::into_domain(result.ttl),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// If Cloudflare's Load Balancing to load-balance across multiple
/// origin servers or data centers, you configure one of these Monitors
/// to actively check the availability of those servers over HTTP(S) or
/// TCP.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// // TCP Monitor
/// const example = new cloudflare.LoadBalancerMonitor("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     description: "example tcp load balancer",
///     interval: 60,
///     method: "connection_established",
///     port: 8080,
///     retries: 5,
///     timeout: 7,
///     type: "tcp",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// # TCP Monitor
/// example = cloudflare.LoadBalancerMonitor("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     description="example tcp load balancer",
///     interval=60,
///     method="connection_established",
///     port=8080,
///     retries=5,
///     timeout=7,
///     type="tcp")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     // TCP Monitor
///     var example = new Cloudflare.LoadBalancerMonitor("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Description = "example tcp load balancer",
///         Interval = 60,
///         Method = "connection_established",
///         Port = 8080,
///         Retries = 5,
///         Timeout = 7,
///         Type = "tcp",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// TCP Monitor
/// 		_, err := cloudflare.NewLoadBalancerMonitor(ctx, "example", &cloudflare.LoadBalancerMonitorArgs{
/// 			AccountId:   pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Description: pulumi.String("example tcp load balancer"),
/// 			Interval:    pulumi.Int(60),
/// 			Method:      pulumi.String("connection_established"),
/// 			Port:        pulumi.Int(8080),
/// 			Retries:     pulumi.Int(5),
/// 			Timeout:     pulumi.Int(7),
/// 			Type:        pulumi.String("tcp"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.LoadBalancerMonitor;
/// import com.pulumi.cloudflare.LoadBalancerMonitorArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // TCP Monitor
///         var example = new LoadBalancerMonitor("example", LoadBalancerMonitorArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .description("example tcp load balancer")
///             .interval(60)
///             .method("connection_established")
///             .port(8080)
///             .retries(5)
///             .timeout(7)
///             .type("tcp")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # TCP Monitor
///   example:
///     type: cloudflare:LoadBalancerMonitor
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       description: example tcp load balancer
///       interval: 60
///       method: connection_established
///       port: 8080
///       retries: 5
///       timeout: 7
///       type: tcp
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/loadBalancerMonitor:LoadBalancerMonitor example <account_id>/<load_balancer_monitor_id>
/// ```
///
pub mod load_balancer_monitor {

    pub struct LoadBalancerMonitorArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Do not validate the certificate when monitor use HTTPS.  Only valid if `type` is "http" or "https".
        pub allow_insecure: pulumi_wasm_rust::Output<Option<bool>>,
        /// To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times. Defaults to `0`.
        pub consecutive_down: pulumi_wasm_rust::Output<Option<i32>>,
        /// To be marked healthy the monitored origin must pass this healthcheck N consecutive times. Defaults to `0`.
        pub consecutive_up: pulumi_wasm_rust::Output<Option<i32>>,
        /// Free text description.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. Only valid if `type` is "http" or "https".
        pub expected_body: pulumi_wasm_rust::Output<Option<String>>,
        /// The expected HTTP response code or code range of the health check. Eg `2xx`. Only valid and required if `type` is "http" or "https".
        pub expected_codes: pulumi_wasm_rust::Output<Option<String>>,
        /// Follow redirects if returned by the origin. Only valid if `type` is "http" or "https".
        pub follow_redirects: pulumi_wasm_rust::Output<Option<bool>>,
        /// The header name.
        pub headers: pulumi_wasm_rust::Output<Option<Vec<crate::types::LoadBalancerMonitorHeader>>>,
        /// The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations. Defaults to `60`.
        pub interval: pulumi_wasm_rust::Output<Option<i32>>,
        /// The method to use for the health check.
        pub method: pulumi_wasm_rust::Output<Option<String>>,
        /// The endpoint path to health check against.
        pub path: pulumi_wasm_rust::Output<Option<String>>,
        /// The port number to use for the healthcheck, required when creating a TCP monitor.
        pub port: pulumi_wasm_rust::Output<Option<i32>>,
        /// Assign this monitor to emulate the specified zone while probing. Only valid if `type` is "http" or "https".
        pub probe_zone: pulumi_wasm_rust::Output<Option<String>>,
        /// The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Defaults to `2`.
        pub retries: pulumi_wasm_rust::Output<Option<i32>>,
        /// The timeout (in seconds) before marking the health check as failed. Defaults to `5`.
        pub timeout: pulumi_wasm_rust::Output<Option<i32>>,
        /// The protocol to use for the healthcheck. Available values: `http`, `https`, `tcp`, `udp_icmp`, `icmp_ping`, `smtp`. Defaults to `http`.
        pub type_: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct LoadBalancerMonitorResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Do not validate the certificate when monitor use HTTPS.  Only valid if `type` is "http" or "https".
        pub allow_insecure: pulumi_wasm_rust::Output<Option<bool>>,
        /// To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times. Defaults to `0`.
        pub consecutive_down: pulumi_wasm_rust::Output<Option<i32>>,
        /// To be marked healthy the monitored origin must pass this healthcheck N consecutive times. Defaults to `0`.
        pub consecutive_up: pulumi_wasm_rust::Output<Option<i32>>,
        /// The RFC3339 timestamp of when the load balancer monitor was created.
        pub created_on: pulumi_wasm_rust::Output<String>,
        /// Free text description.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. Only valid if `type` is "http" or "https".
        pub expected_body: pulumi_wasm_rust::Output<Option<String>>,
        /// The expected HTTP response code or code range of the health check. Eg `2xx`. Only valid and required if `type` is "http" or "https".
        pub expected_codes: pulumi_wasm_rust::Output<Option<String>>,
        /// Follow redirects if returned by the origin. Only valid if `type` is "http" or "https".
        pub follow_redirects: pulumi_wasm_rust::Output<Option<bool>>,
        /// The header name.
        pub headers: pulumi_wasm_rust::Output<Option<Vec<crate::types::LoadBalancerMonitorHeader>>>,
        /// The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations. Defaults to `60`.
        pub interval: pulumi_wasm_rust::Output<Option<i32>>,
        /// The method to use for the health check.
        pub method: pulumi_wasm_rust::Output<String>,
        /// The RFC3339 timestamp of when the load balancer monitor was last modified.
        pub modified_on: pulumi_wasm_rust::Output<String>,
        /// The endpoint path to health check against.
        pub path: pulumi_wasm_rust::Output<String>,
        /// The port number to use for the healthcheck, required when creating a TCP monitor.
        pub port: pulumi_wasm_rust::Output<Option<i32>>,
        /// Assign this monitor to emulate the specified zone while probing. Only valid if `type` is "http" or "https".
        pub probe_zone: pulumi_wasm_rust::Output<Option<String>>,
        /// The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Defaults to `2`.
        pub retries: pulumi_wasm_rust::Output<Option<i32>>,
        /// The timeout (in seconds) before marking the health check as failed. Defaults to `5`.
        pub timeout: pulumi_wasm_rust::Output<Option<i32>>,
        /// The protocol to use for the healthcheck. Available values: `http`, `https`, `tcp`, `udp_icmp`, `icmp_ping`, `smtp`. Defaults to `http`.
        pub type_: pulumi_wasm_rust::Output<Option<String>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn load_balancer_monitor(
        name: &str,
        args: LoadBalancerMonitorArgs,
    ) -> LoadBalancerMonitorResult {
        let result = crate::bindings::pulumi::cloudflare::load_balancer_monitor::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::load_balancer_monitor::Args {
                account_id: args.account_id.get_inner(),
                allow_insecure: args.allow_insecure.get_inner(),
                consecutive_down: args.consecutive_down.get_inner(),
                consecutive_up: args.consecutive_up.get_inner(),
                description: args.description.get_inner(),
                expected_body: args.expected_body.get_inner(),
                expected_codes: args.expected_codes.get_inner(),
                follow_redirects: args.follow_redirects.get_inner(),
                headers: args.headers.get_inner(),
                interval: args.interval.get_inner(),
                method: args.method.get_inner(),
                path: args.path.get_inner(),
                port: args.port.get_inner(),
                probe_zone: args.probe_zone.get_inner(),
                retries: args.retries.get_inner(),
                timeout: args.timeout.get_inner(),
                type_: args.type_.get_inner(),
            },
        );

        LoadBalancerMonitorResult {
            account_id: crate::into_domain(result.account_id),
            allow_insecure: crate::into_domain(result.allow_insecure),
            consecutive_down: crate::into_domain(result.consecutive_down),
            consecutive_up: crate::into_domain(result.consecutive_up),
            created_on: crate::into_domain(result.created_on),
            description: crate::into_domain(result.description),
            expected_body: crate::into_domain(result.expected_body),
            expected_codes: crate::into_domain(result.expected_codes),
            follow_redirects: crate::into_domain(result.follow_redirects),
            headers: crate::into_domain(result.headers),
            interval: crate::into_domain(result.interval),
            method: crate::into_domain(result.method),
            modified_on: crate::into_domain(result.modified_on),
            path: crate::into_domain(result.path),
            port: crate::into_domain(result.port),
            probe_zone: crate::into_domain(result.probe_zone),
            retries: crate::into_domain(result.retries),
            timeout: crate::into_domain(result.timeout),
            type_: crate::into_domain(result.type_),
        }
    }
}

/// Provides a Cloudflare Load Balancer pool resource. This provides a
/// pool of origins that can be used by a Cloudflare Load Balancer.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.LoadBalancerPool("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     description: "example load balancer pool",
///     enabled: false,
///     latitude: 55,
///     loadSheddings: [{
///         defaultPercent: 55,
///         defaultPolicy: "random",
///         sessionPercent: 12,
///         sessionPolicy: "hash",
///     }],
///     longitude: -12,
///     minimumOrigins: 1,
///     name: "example-pool",
///     notificationEmail: "someone@example.com",
///     originSteerings: [{
///         policy: "random",
///     }],
///     origins: [
///         {
///             address: "192.0.2.1",
///             enabled: false,
///             headers: [{
///                 header: "Host",
///                 values: ["example-1"],
///             }],
///             name: "example-1",
///         },
///         {
///             address: "192.0.2.2",
///             headers: [{
///                 header: "Host",
///                 values: ["example-2"],
///             }],
///             name: "example-2",
///         },
///     ],
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.LoadBalancerPool("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     description="example load balancer pool",
///     enabled=False,
///     latitude=55,
///     load_sheddings=[cloudflare.LoadBalancerPoolLoadSheddingArgs(
///         default_percent=55,
///         default_policy="random",
///         session_percent=12,
///         session_policy="hash",
///     )],
///     longitude=-12,
///     minimum_origins=1,
///     name="example-pool",
///     notification_email="someone@example.com",
///     origin_steerings=[cloudflare.LoadBalancerPoolOriginSteeringArgs(
///         policy="random",
///     )],
///     origins=[
///         cloudflare.LoadBalancerPoolOriginArgs(
///             address="192.0.2.1",
///             enabled=False,
///             headers=[cloudflare.LoadBalancerPoolOriginHeaderArgs(
///                 header="Host",
///                 values=["example-1"],
///             )],
///             name="example-1",
///         ),
///         cloudflare.LoadBalancerPoolOriginArgs(
///             address="192.0.2.2",
///             headers=[cloudflare.LoadBalancerPoolOriginHeaderArgs(
///                 header="Host",
///                 values=["example-2"],
///             )],
///             name="example-2",
///         ),
///     ])
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.LoadBalancerPool("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Description = "example load balancer pool",
///         Enabled = false,
///         Latitude = 55,
///         LoadSheddings = new[]
///         {
///             new Cloudflare.Inputs.LoadBalancerPoolLoadSheddingArgs
///             {
///                 DefaultPercent = 55,
///                 DefaultPolicy = "random",
///                 SessionPercent = 12,
///                 SessionPolicy = "hash",
///             },
///         },
///         Longitude = -12,
///         MinimumOrigins = 1,
///         Name = "example-pool",
///         NotificationEmail = "someone@example.com",
///         OriginSteerings = new[]
///         {
///             new Cloudflare.Inputs.LoadBalancerPoolOriginSteeringArgs
///             {
///                 Policy = "random",
///             },
///         },
///         Origins = new[]
///         {
///             new Cloudflare.Inputs.LoadBalancerPoolOriginArgs
///             {
///                 Address = "192.0.2.1",
///                 Enabled = false,
///                 Headers = new[]
///                 {
///                     new Cloudflare.Inputs.LoadBalancerPoolOriginHeaderArgs
///                     {
///                         Header = "Host",
///                         Values = new[]
///                         {
///                             "example-1",
///                         },
///                     },
///                 },
///                 Name = "example-1",
///             },
///             new Cloudflare.Inputs.LoadBalancerPoolOriginArgs
///             {
///                 Address = "192.0.2.2",
///                 Headers = new[]
///                 {
///                     new Cloudflare.Inputs.LoadBalancerPoolOriginHeaderArgs
///                     {
///                         Header = "Host",
///                         Values = new[]
///                         {
///                             "example-2",
///                         },
///                     },
///                 },
///                 Name = "example-2",
///             },
///         },
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewLoadBalancerPool(ctx, "example", &cloudflare.LoadBalancerPoolArgs{
/// 			AccountId:   pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Description: pulumi.String("example load balancer pool"),
/// 			Enabled:     pulumi.Bool(false),
/// 			Latitude:    pulumi.Float64(55),
/// 			LoadSheddings: cloudflare.LoadBalancerPoolLoadSheddingArray{
/// 				&cloudflare.LoadBalancerPoolLoadSheddingArgs{
/// 					DefaultPercent: pulumi.Float64(55),
/// 					DefaultPolicy:  pulumi.String("random"),
/// 					SessionPercent: pulumi.Float64(12),
/// 					SessionPolicy:  pulumi.String("hash"),
/// 				},
/// 			},
/// 			Longitude:         -12,
/// 			MinimumOrigins:    pulumi.Int(1),
/// 			Name:              pulumi.String("example-pool"),
/// 			NotificationEmail: pulumi.String("someone@example.com"),
/// 			OriginSteerings: cloudflare.LoadBalancerPoolOriginSteeringArray{
/// 				&cloudflare.LoadBalancerPoolOriginSteeringArgs{
/// 					Policy: pulumi.String("random"),
/// 				},
/// 			},
/// 			Origins: cloudflare.LoadBalancerPoolOriginArray{
/// 				&cloudflare.LoadBalancerPoolOriginArgs{
/// 					Address: pulumi.String("192.0.2.1"),
/// 					Enabled: pulumi.Bool(false),
/// 					Headers: cloudflare.LoadBalancerPoolOriginHeaderArray{
/// 						&cloudflare.LoadBalancerPoolOriginHeaderArgs{
/// 							Header: pulumi.String("Host"),
/// 							Values: pulumi.StringArray{
/// 								pulumi.String("example-1"),
/// 							},
/// 						},
/// 					},
/// 					Name: pulumi.String("example-1"),
/// 				},
/// 				&cloudflare.LoadBalancerPoolOriginArgs{
/// 					Address: pulumi.String("192.0.2.2"),
/// 					Headers: cloudflare.LoadBalancerPoolOriginHeaderArray{
/// 						&cloudflare.LoadBalancerPoolOriginHeaderArgs{
/// 							Header: pulumi.String("Host"),
/// 							Values: pulumi.StringArray{
/// 								pulumi.String("example-2"),
/// 							},
/// 						},
/// 					},
/// 					Name: pulumi.String("example-2"),
/// 				},
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.LoadBalancerPool;
/// import com.pulumi.cloudflare.LoadBalancerPoolArgs;
/// import com.pulumi.cloudflare.inputs.LoadBalancerPoolLoadSheddingArgs;
/// import com.pulumi.cloudflare.inputs.LoadBalancerPoolOriginSteeringArgs;
/// import com.pulumi.cloudflare.inputs.LoadBalancerPoolOriginArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new LoadBalancerPool("example", LoadBalancerPoolArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .description("example load balancer pool")
///             .enabled(false)
///             .latitude(55)
///             .loadSheddings(LoadBalancerPoolLoadSheddingArgs.builder()
///                 .defaultPercent(55)
///                 .defaultPolicy("random")
///                 .sessionPercent(12)
///                 .sessionPolicy("hash")
///                 .build())
///             .longitude("TODO: GenUnaryOpExpression")
///             .minimumOrigins(1)
///             .name("example-pool")
///             .notificationEmail("someone@example.com")
///             .originSteerings(LoadBalancerPoolOriginSteeringArgs.builder()
///                 .policy("random")
///                 .build())
///             .origins(            
///                 LoadBalancerPoolOriginArgs.builder()
///                     .address("192.0.2.1")
///                     .enabled(false)
///                     .headers(LoadBalancerPoolOriginHeaderArgs.builder()
///                         .header("Host")
///                         .values("example-1")
///                         .build())
///                     .name("example-1")
///                     .build(),
///                 LoadBalancerPoolOriginArgs.builder()
///                     .address("192.0.2.2")
///                     .headers(LoadBalancerPoolOriginHeaderArgs.builder()
///                         .header("Host")
///                         .values("example-2")
///                         .build())
///                     .name("example-2")
///                     .build())
///             .build());
///
///     }
/// }
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/loadBalancerPool:LoadBalancerPool example <account_id>/<load_balancer_pool_id>
/// ```
///
pub mod load_balancer_pool {

    pub struct LoadBalancerPoolArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// A list of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api).
        pub check_regions: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Free text description.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether this origin is enabled. Disabled origins will not receive traffic and are excluded from health checks. Defaults to `true`.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The latitude this pool is physically located at; used for proximity steering.
        pub latitude: pulumi_wasm_rust::Output<Option<f64>>,
        /// Setting for controlling load shedding for this pool.
        pub load_sheddings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::LoadBalancerPoolLoadShedding>>>,
        /// The longitude this pool is physically located at; used for proximity steering.
        pub longitude: pulumi_wasm_rust::Output<Option<f64>>,
        /// The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and we will failover to the next available pool. Defaults to `1`.
        pub minimum_origins: pulumi_wasm_rust::Output<Option<i32>>,
        /// The ID of the Monitor to use for health checking origins within this pool.
        pub monitor: pulumi_wasm_rust::Output<Option<String>>,
        /// A human-identifiable name for the origin.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list.
        pub notification_email: pulumi_wasm_rust::Output<Option<String>>,
        /// Set an origin steering policy to control origin selection within a pool.
        pub origin_steerings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::LoadBalancerPoolOriginSteering>>>,
        /// The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy.
        pub origins: pulumi_wasm_rust::Output<Vec<crate::types::LoadBalancerPoolOrigin>>,
    }

    pub struct LoadBalancerPoolResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// A list of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api).
        pub check_regions: pulumi_wasm_rust::Output<Vec<String>>,
        /// The RFC3339 timestamp of when the load balancer was created.
        pub created_on: pulumi_wasm_rust::Output<String>,
        /// Free text description.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether this origin is enabled. Disabled origins will not receive traffic and are excluded from health checks. Defaults to `true`.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The latitude this pool is physically located at; used for proximity steering.
        pub latitude: pulumi_wasm_rust::Output<Option<f64>>,
        /// Setting for controlling load shedding for this pool.
        pub load_sheddings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::LoadBalancerPoolLoadShedding>>>,
        /// The longitude this pool is physically located at; used for proximity steering.
        pub longitude: pulumi_wasm_rust::Output<Option<f64>>,
        /// The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and we will failover to the next available pool. Defaults to `1`.
        pub minimum_origins: pulumi_wasm_rust::Output<Option<i32>>,
        /// The RFC3339 timestamp of when the load balancer was last modified.
        pub modified_on: pulumi_wasm_rust::Output<String>,
        /// The ID of the Monitor to use for health checking origins within this pool.
        pub monitor: pulumi_wasm_rust::Output<Option<String>>,
        /// A human-identifiable name for the origin.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list.
        pub notification_email: pulumi_wasm_rust::Output<Option<String>>,
        /// Set an origin steering policy to control origin selection within a pool.
        pub origin_steerings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::LoadBalancerPoolOriginSteering>>>,
        /// The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy.
        pub origins: pulumi_wasm_rust::Output<Vec<crate::types::LoadBalancerPoolOrigin>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn load_balancer_pool(name: &str, args: LoadBalancerPoolArgs) -> LoadBalancerPoolResult {
        let result = crate::bindings::pulumi::cloudflare::load_balancer_pool::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::load_balancer_pool::Args {
                account_id: args.account_id.get_inner(),
                check_regions: args.check_regions.get_inner(),
                description: args.description.get_inner(),
                enabled: args.enabled.get_inner(),
                latitude: args.latitude.get_inner(),
                load_sheddings: args.load_sheddings.get_inner(),
                longitude: args.longitude.get_inner(),
                minimum_origins: args.minimum_origins.get_inner(),
                monitor: args.monitor.get_inner(),
                name: args.name.get_inner(),
                notification_email: args.notification_email.get_inner(),
                origin_steerings: args.origin_steerings.get_inner(),
                origins: args.origins.get_inner(),
            },
        );

        LoadBalancerPoolResult {
            account_id: crate::into_domain(result.account_id),
            check_regions: crate::into_domain(result.check_regions),
            created_on: crate::into_domain(result.created_on),
            description: crate::into_domain(result.description),
            enabled: crate::into_domain(result.enabled),
            latitude: crate::into_domain(result.latitude),
            load_sheddings: crate::into_domain(result.load_sheddings),
            longitude: crate::into_domain(result.longitude),
            minimum_origins: crate::into_domain(result.minimum_origins),
            modified_on: crate::into_domain(result.modified_on),
            monitor: crate::into_domain(result.monitor),
            name: crate::into_domain(result.name),
            notification_email: crate::into_domain(result.notification_email),
            origin_steerings: crate::into_domain(result.origin_steerings),
            origins: crate::into_domain(result.origins),
        }
    }
}

/// Allows management of the Logpull Retention settings used to control whether or not to retain HTTP request logs.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.LogpullRetention("example", {
///     enabled: true,
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.LogpullRetention("example",
///     enabled=True,
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.LogpullRetention("example", new()
///     {
///         Enabled = true,
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewLogpullRetention(ctx, "example", &cloudflare.LogpullRetentionArgs{
/// 			Enabled: pulumi.Bool(true),
/// 			ZoneId:  pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.LogpullRetention;
/// import com.pulumi.cloudflare.LogpullRetentionArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new LogpullRetention("example", LogpullRetentionArgs.builder()        
///             .enabled("true")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:LogpullRetention
///     properties:
///       enabled: 'true'
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/logpullRetention:LogpullRetention example <zone_id>
/// ```
///
pub mod logpull_retention {

    pub struct LogpullRetentionArgs {
        /// Whether you wish to retain logs or not.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct LogpullRetentionResult {
        /// Whether you wish to retain logs or not.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn logpull_retention(name: &str, args: LogpullRetentionArgs) -> LogpullRetentionResult {
        let result = crate::bindings::pulumi::cloudflare::logpull_retention::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::logpull_retention::Args {
                enabled: args.enabled.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        LogpullRetentionResult {
            enabled: crate::into_domain(result.enabled),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// ## Example Usage
///
/// ## Import
///
/// Import an account-scoped job.
///
/// ```sh
/// $ pulumi import cloudflare:index/logpushJob:LogpushJob example account/<account_id>/<job_id>
/// ```
///
/// Import a zone-scoped job.
///
/// ```sh
/// $ pulumi import cloudflare:index/logpushJob:LogpushJob example zone/<zone_id>/<job_id>
/// ```
///
pub mod logpush_job {

    pub struct LogpushJobArgs {
        /// The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The kind of the dataset to use with the logpush job. Available values: `access_requests`, `casb_findings`, `firewall_events`, `http_requests`, `spectrum_events`, `nel_reports`, `audit_logs`, `gateway_dns`, `gateway_http`, `gateway_network`, `dns_logs`, `network_analytics_logs`, `workers_trace_events`, `device_posture_results`, `zero_trust_network_sessions`, `magic_ids_detections`.
        pub dataset: pulumi_wasm_rust::Output<String>,
        /// Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/reference/logpush-api-configuration#destination).
        pub destination_conf: pulumi_wasm_rust::Output<String>,
        /// Whether to enable the job.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Use filters to select the events to include and/or remove from your logs. For more information, refer to [Filters](https://developers.cloudflare.com/logs/reference/logpush-api-configuration/filters/).
        pub filter: pulumi_wasm_rust::Output<Option<String>>,
        /// A higher frequency will result in logs being pushed on faster with smaller files. `low` frequency will push logs less often with larger files. Available values: `high`, `low`. Defaults to `high`.
        pub frequency: pulumi_wasm_rust::Output<Option<String>>,
        /// The kind of logpush job to create. Available values: `edge`, `instant-logs`, `""`.
        pub kind: pulumi_wasm_rust::Output<Option<String>>,
        /// Configuration string for the Logshare API. It specifies things like requested fields and timestamp formats. See [Logpush options documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#options).
        pub logpull_options: pulumi_wasm_rust::Output<Option<String>>,
        /// The maximum uncompressed file size of a batch of logs. Value must be between 5MB and 1GB.
        pub max_upload_bytes: pulumi_wasm_rust::Output<Option<i32>>,
        /// The maximum interval in seconds for log batches. Value must be between 30 and 300.
        pub max_upload_interval_seconds: pulumi_wasm_rust::Output<Option<i32>>,
        /// The maximum number of log lines per batch. Value must be between 1000 and 1,000,000.
        pub max_upload_records: pulumi_wasm_rust::Output<Option<i32>>,
        /// The name of the logpush job to create.
        pub name: pulumi_wasm_rust::Output<Option<String>>,
        /// Structured replacement for logpull*options. When including this field, the logpull*option field will be ignored.
        pub output_options: pulumi_wasm_rust::Output<Option<crate::types::LogpushJobOutputOptions>>,
        /// Ownership challenge token to prove destination ownership, required when destination is Amazon S3, Google Cloud Storage, Microsoft Azure or Sumo Logic. See [Developer documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#usage).
        pub ownership_challenge: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct LogpushJobResult {
        /// The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The kind of the dataset to use with the logpush job. Available values: `access_requests`, `casb_findings`, `firewall_events`, `http_requests`, `spectrum_events`, `nel_reports`, `audit_logs`, `gateway_dns`, `gateway_http`, `gateway_network`, `dns_logs`, `network_analytics_logs`, `workers_trace_events`, `device_posture_results`, `zero_trust_network_sessions`, `magic_ids_detections`.
        pub dataset: pulumi_wasm_rust::Output<String>,
        /// Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/reference/logpush-api-configuration#destination).
        pub destination_conf: pulumi_wasm_rust::Output<String>,
        /// Whether to enable the job.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Use filters to select the events to include and/or remove from your logs. For more information, refer to [Filters](https://developers.cloudflare.com/logs/reference/logpush-api-configuration/filters/).
        pub filter: pulumi_wasm_rust::Output<Option<String>>,
        /// A higher frequency will result in logs being pushed on faster with smaller files. `low` frequency will push logs less often with larger files. Available values: `high`, `low`. Defaults to `high`.
        pub frequency: pulumi_wasm_rust::Output<Option<String>>,
        /// The kind of logpush job to create. Available values: `edge`, `instant-logs`, `""`.
        pub kind: pulumi_wasm_rust::Output<Option<String>>,
        /// Configuration string for the Logshare API. It specifies things like requested fields and timestamp formats. See [Logpush options documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#options).
        pub logpull_options: pulumi_wasm_rust::Output<Option<String>>,
        /// The maximum uncompressed file size of a batch of logs. Value must be between 5MB and 1GB.
        pub max_upload_bytes: pulumi_wasm_rust::Output<Option<i32>>,
        /// The maximum interval in seconds for log batches. Value must be between 30 and 300.
        pub max_upload_interval_seconds: pulumi_wasm_rust::Output<Option<i32>>,
        /// The maximum number of log lines per batch. Value must be between 1000 and 1,000,000.
        pub max_upload_records: pulumi_wasm_rust::Output<Option<i32>>,
        /// The name of the logpush job to create.
        pub name: pulumi_wasm_rust::Output<Option<String>>,
        /// Structured replacement for logpull*options. When including this field, the logpull*option field will be ignored.
        pub output_options: pulumi_wasm_rust::Output<Option<crate::types::LogpushJobOutputOptions>>,
        /// Ownership challenge token to prove destination ownership, required when destination is Amazon S3, Google Cloud Storage, Microsoft Azure or Sumo Logic. See [Developer documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#usage).
        pub ownership_challenge: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn logpush_job(name: &str, args: LogpushJobArgs) -> LogpushJobResult {
        let result = crate::bindings::pulumi::cloudflare::logpush_job::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::logpush_job::Args {
                account_id: args.account_id.get_inner(),
                dataset: args.dataset.get_inner(),
                destination_conf: args.destination_conf.get_inner(),
                enabled: args.enabled.get_inner(),
                filter: args.filter.get_inner(),
                frequency: args.frequency.get_inner(),
                kind: args.kind.get_inner(),
                logpull_options: args.logpull_options.get_inner(),
                max_upload_bytes: args.max_upload_bytes.get_inner(),
                max_upload_interval_seconds: args.max_upload_interval_seconds.get_inner(),
                max_upload_records: args.max_upload_records.get_inner(),
                name: args.name.get_inner(),
                output_options: args.output_options.get_inner(),
                ownership_challenge: args.ownership_challenge.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        LogpushJobResult {
            account_id: crate::into_domain(result.account_id),
            dataset: crate::into_domain(result.dataset),
            destination_conf: crate::into_domain(result.destination_conf),
            enabled: crate::into_domain(result.enabled),
            filter: crate::into_domain(result.filter),
            frequency: crate::into_domain(result.frequency),
            kind: crate::into_domain(result.kind),
            logpull_options: crate::into_domain(result.logpull_options),
            max_upload_bytes: crate::into_domain(result.max_upload_bytes),
            max_upload_interval_seconds: crate::into_domain(result.max_upload_interval_seconds),
            max_upload_records: crate::into_domain(result.max_upload_records),
            name: crate::into_domain(result.name),
            output_options: crate::into_domain(result.output_options),
            ownership_challenge: crate::into_domain(result.ownership_challenge),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a resource which manages Cloudflare Logpush ownership
/// challenges to use in a Logpush Job. On it's own, doesn't do much
/// however this resource should be used in conjunction to create
/// Logpush jobs.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.LogpushOwnershipChallenge("example", {
///     destinationConf: "s3://my-bucket-path?region=us-west-2",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.LogpushOwnershipChallenge("example",
///     destination_conf="s3://my-bucket-path?region=us-west-2",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.LogpushOwnershipChallenge("example", new()
///     {
///         DestinationConf = "s3://my-bucket-path?region=us-west-2",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewLogpushOwnershipChallenge(ctx, "example", &cloudflare.LogpushOwnershipChallengeArgs{
/// 			DestinationConf: pulumi.String("s3://my-bucket-path?region=us-west-2"),
/// 			ZoneId:          pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.LogpushOwnershipChallenge;
/// import com.pulumi.cloudflare.LogpushOwnershipChallengeArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new LogpushOwnershipChallenge("example", LogpushOwnershipChallengeArgs.builder()        
///             .destinationConf("s3://my-bucket-path?region=us-west-2")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:LogpushOwnershipChallenge
///     properties:
///       destinationConf: s3://my-bucket-path?region=us-west-2
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
pub mod logpush_ownership_challenge {

    pub struct LogpushOwnershipChallengeArgs {
        /// The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#destination). **Modifying this attribute will force creation of a new resource.**
        pub destination_conf: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct LogpushOwnershipChallengeResult {
        /// The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#destination). **Modifying this attribute will force creation of a new resource.**
        pub destination_conf: pulumi_wasm_rust::Output<String>,
        /// The filename of the ownership challenge which	contains the contents required for Logpush Job creation.
        pub ownership_challenge_filename: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn logpush_ownership_challenge(
        name: &str,
        args: LogpushOwnershipChallengeArgs,
    ) -> LogpushOwnershipChallengeResult {
        let result = crate::bindings::pulumi::cloudflare::logpush_ownership_challenge::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::logpush_ownership_challenge::Args {
                account_id: args.account_id.get_inner(),
                destination_conf: args.destination_conf.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        LogpushOwnershipChallengeResult {
            account_id: crate::into_domain(result.account_id),
            destination_conf: crate::into_domain(result.destination_conf),
            ownership_challenge_filename: crate::into_domain(result.ownership_challenge_filename),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Magic Firewall is a network-level firewall to protect networks that are onboarded to Cloudflare's Magic Transit. This resource
/// creates a root ruleset on the account level and contains one or more rules. Rules can be crafted in Wireshark syntax and
/// are evaluated in order, with the first rule having the highest priority.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.MagicFirewallRuleset("example", {
///     accountId: "d41d8cd98f00b204e9800998ecf8427e",
///     description: "Global mitigations",
///     name: "Magic Transit Ruleset",
///     rules: [
///         {
///             action: "allow",
///             description: "Allow TCP Ephemeral Ports",
///             enabled: "true",
///             expression: "tcp.dstport in { 32768..65535 }",
///         },
///         {
///             action: "block",
///             description: "Block all",
///             enabled: "true",
///             expression: "ip.len >= 0",
///         },
///     ],
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.MagicFirewallRuleset("example",
///     account_id="d41d8cd98f00b204e9800998ecf8427e",
///     description="Global mitigations",
///     name="Magic Transit Ruleset",
///     rules=[
///         {
///             "action": "allow",
///             "description": "Allow TCP Ephemeral Ports",
///             "enabled": "true",
///             "expression": "tcp.dstport in { 32768..65535 }",
///         },
///         {
///             "action": "block",
///             "description": "Block all",
///             "enabled": "true",
///             "expression": "ip.len >= 0",
///         },
///     ])
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.MagicFirewallRuleset("example", new()
///     {
///         AccountId = "d41d8cd98f00b204e9800998ecf8427e",
///         Description = "Global mitigations",
///         Name = "Magic Transit Ruleset",
///         Rules = new[]
///         {
///             
///             {
///                 { "action", "allow" },
///                 { "description", "Allow TCP Ephemeral Ports" },
///                 { "enabled", "true" },
///                 { "expression", "tcp.dstport in { 32768..65535 }" },
///             },
///             
///             {
///                 { "action", "block" },
///                 { "description", "Block all" },
///                 { "enabled", "true" },
///                 { "expression", "ip.len >= 0" },
///             },
///         },
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewMagicFirewallRuleset(ctx, "example", &cloudflare.MagicFirewallRulesetArgs{
/// 			AccountId:   pulumi.String("d41d8cd98f00b204e9800998ecf8427e"),
/// 			Description: pulumi.String("Global mitigations"),
/// 			Name:        pulumi.String("Magic Transit Ruleset"),
/// 			Rules: pulumi.StringMapArray{
/// 				pulumi.StringMap{
/// 					"action":      pulumi.String("allow"),
/// 					"description": pulumi.String("Allow TCP Ephemeral Ports"),
/// 					"enabled":     pulumi.String("true"),
/// 					"expression":  pulumi.String("tcp.dstport in { 32768..65535 }"),
/// 				},
/// 				pulumi.StringMap{
/// 					"action":      pulumi.String("block"),
/// 					"description": pulumi.String("Block all"),
/// 					"enabled":     pulumi.String("true"),
/// 					"expression":  pulumi.String("ip.len >= 0"),
/// 				},
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.MagicFirewallRuleset;
/// import com.pulumi.cloudflare.MagicFirewallRulesetArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new MagicFirewallRuleset("example", MagicFirewallRulesetArgs.builder()        
///             .accountId("d41d8cd98f00b204e9800998ecf8427e")
///             .description("Global mitigations")
///             .name("Magic Transit Ruleset")
///             .rules(            
///                 Map.ofEntries(
///                     Map.entry("action", "allow"),
///                     Map.entry("description", "Allow TCP Ephemeral Ports"),
///                     Map.entry("enabled", "true"),
///                     Map.entry("expression", "tcp.dstport in { 32768..65535 }")
///                 ),
///                 Map.ofEntries(
///                     Map.entry("action", "block"),
///                     Map.entry("description", "Block all"),
///                     Map.entry("enabled", "true"),
///                     Map.entry("expression", "ip.len >= 0")
///                 ))
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:MagicFirewallRuleset
///     properties:
///       accountId: d41d8cd98f00b204e9800998ecf8427e
///       description: Global mitigations
///       name: Magic Transit Ruleset
///       rules:
///         - action: allow
///           description: Allow TCP Ephemeral Ports
///           enabled: 'true'
///           expression: tcp.dstport in { 32768..65535 }
///         - action: block
///           description: Block all
///           enabled: 'true'
///           expression: ip.len >= 0
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// An existing Magic Firewall Ruleset can be imported using the account ID and ruleset ID
///
/// ```sh
/// $ pulumi import cloudflare:index/magicFirewallRuleset:MagicFirewallRuleset example d41d8cd98f00b204e9800998ecf8427e/cb029e245cfdd66dc8d2e570d5dd3322
/// ```
pub mod magic_firewall_ruleset {

    pub struct MagicFirewallRulesetArgs {
        /// The ID of the account where the ruleset is being created.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// A note that can be used to annotate the rule.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The name of the ruleset.
        pub name: pulumi_wasm_rust::Output<String>,
        pub rules: pulumi_wasm_rust::Output<Option<Vec<std::collections::HashMap<String, String>>>>,
    }

    pub struct MagicFirewallRulesetResult {
        /// The ID of the account where the ruleset is being created.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// A note that can be used to annotate the rule.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The name of the ruleset.
        pub name: pulumi_wasm_rust::Output<String>,
        pub rules: pulumi_wasm_rust::Output<Option<Vec<std::collections::HashMap<String, String>>>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn magic_firewall_ruleset(
        name: &str,
        args: MagicFirewallRulesetArgs,
    ) -> MagicFirewallRulesetResult {
        let result = crate::bindings::pulumi::cloudflare::magic_firewall_ruleset::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::magic_firewall_ruleset::Args {
                account_id: args.account_id.get_inner(),
                description: args.description.get_inner(),
                name: args.name.get_inner(),
                rules: args.rules.get_inner(),
            },
        );

        MagicFirewallRulesetResult {
            account_id: crate::into_domain(result.account_id),
            description: crate::into_domain(result.description),
            name: crate::into_domain(result.name),
            rules: crate::into_domain(result.rules),
        }
    }
}

/// The [Cloudflare Managed Headers](https://developers.cloudflare.com/rules/transform/managed-transforms/)
/// allows you to add or remove some predefined headers to one's
/// requests or origin responses.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// // Enable security headers using Managed Meaders
/// const example = new cloudflare.ManagedHeaders("example", {
///     managedRequestHeaders: [{
///         enabled: true,
///         id: "add_true_client_ip_headers",
///     }],
///     managedResponseHeaders: [{
///         enabled: true,
///         id: "remove_x-powered-by_header",
///     }],
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// # Enable security headers using Managed Meaders
/// example = cloudflare.ManagedHeaders("example",
///     managed_request_headers=[cloudflare.ManagedHeadersManagedRequestHeaderArgs(
///         enabled=True,
///         id="add_true_client_ip_headers",
///     )],
///     managed_response_headers=[cloudflare.ManagedHeadersManagedResponseHeaderArgs(
///         enabled=True,
///         id="remove_x-powered-by_header",
///     )],
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     // Enable security headers using Managed Meaders
///     var example = new Cloudflare.ManagedHeaders("example", new()
///     {
///         ManagedRequestHeaders = new[]
///         {
///             new Cloudflare.Inputs.ManagedHeadersManagedRequestHeaderArgs
///             {
///                 Enabled = true,
///                 Id = "add_true_client_ip_headers",
///             },
///         },
///         ManagedResponseHeaders = new[]
///         {
///             new Cloudflare.Inputs.ManagedHeadersManagedResponseHeaderArgs
///             {
///                 Enabled = true,
///                 Id = "remove_x-powered-by_header",
///             },
///         },
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// Enable security headers using Managed Meaders
/// 		_, err := cloudflare.NewManagedHeaders(ctx, "example", &cloudflare.ManagedHeadersArgs{
/// 			ManagedRequestHeaders: cloudflare.ManagedHeadersManagedRequestHeaderArray{
/// 				&cloudflare.ManagedHeadersManagedRequestHeaderArgs{
/// 					Enabled: pulumi.Bool(true),
/// 					Id:      pulumi.String("add_true_client_ip_headers"),
/// 				},
/// 			},
/// 			ManagedResponseHeaders: cloudflare.ManagedHeadersManagedResponseHeaderArray{
/// 				&cloudflare.ManagedHeadersManagedResponseHeaderArgs{
/// 					Enabled: pulumi.Bool(true),
/// 					Id:      pulumi.String("remove_x-powered-by_header"),
/// 				},
/// 			},
/// 			ZoneId: pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.ManagedHeaders;
/// import com.pulumi.cloudflare.ManagedHeadersArgs;
/// import com.pulumi.cloudflare.inputs.ManagedHeadersManagedRequestHeaderArgs;
/// import com.pulumi.cloudflare.inputs.ManagedHeadersManagedResponseHeaderArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // Enable security headers using Managed Meaders
///         var example = new ManagedHeaders("example", ManagedHeadersArgs.builder()        
///             .managedRequestHeaders(ManagedHeadersManagedRequestHeaderArgs.builder()
///                 .enabled(true)
///                 .id("add_true_client_ip_headers")
///                 .build())
///             .managedResponseHeaders(ManagedHeadersManagedResponseHeaderArgs.builder()
///                 .enabled(true)
///                 .id("remove_x-powered-by_header")
///                 .build())
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # Enable security headers using Managed Meaders
///   example:
///     type: cloudflare:ManagedHeaders
///     properties:
///       managedRequestHeaders:
///         - enabled: true
///           id: add_true_client_ip_headers
///       managedResponseHeaders:
///         - enabled: true
///           id: remove_x-powered-by_header
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
pub mod managed_headers {

    pub struct ManagedHeadersArgs {
        /// The list of managed request headers.
        pub managed_request_headers:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::ManagedHeadersManagedRequestHeader>>>,
        /// The list of managed response headers.
        pub managed_response_headers: pulumi_wasm_rust::Output<
            Option<Vec<crate::types::ManagedHeadersManagedResponseHeader>>,
        >,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct ManagedHeadersResult {
        /// The list of managed request headers.
        pub managed_request_headers:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::ManagedHeadersManagedRequestHeader>>>,
        /// The list of managed response headers.
        pub managed_response_headers: pulumi_wasm_rust::Output<
            Option<Vec<crate::types::ManagedHeadersManagedResponseHeader>>,
        >,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn managed_headers(name: &str, args: ManagedHeadersArgs) -> ManagedHeadersResult {
        let result = crate::bindings::pulumi::cloudflare::managed_headers::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::managed_headers::Args {
                managed_request_headers: args.managed_request_headers.get_inner(),
                managed_response_headers: args.managed_response_headers.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        ManagedHeadersResult {
            managed_request_headers: crate::into_domain(result.managed_request_headers),
            managed_response_headers: crate::into_domain(result.managed_response_headers),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare mTLS certificate resource. These certificates may be used with mTLS enabled Cloudflare services.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.MtlsCertificate("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     ca: true,
///     certificates: `-----BEGIN CERTIFICATE-----
/// MIIDmDCCAoCgAwIBAgIUKTOAZNj...i4JhqeoTewsxndhDDE
/// -----END CERTIFICATE-----
/// `,
///     name: "example",
///     privateKey: `-----BEGIN PRIVATE KEY-----
/// MIIEvQIBADANBgkqhkiG9w0BAQE...1IS3EnQRrz6WMYA=
/// -----END PRIVATE KEY-----
/// `,
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.MtlsCertificate("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     ca=True,
///     certificates="""-----BEGIN CERTIFICATE-----
/// MIIDmDCCAoCgAwIBAgIUKTOAZNj...i4JhqeoTewsxndhDDE
/// -----END CERTIFICATE-----
/// """,
///     name="example",
///     private_key="""-----BEGIN PRIVATE KEY-----
/// MIIEvQIBADANBgkqhkiG9w0BAQE...1IS3EnQRrz6WMYA=
/// -----END PRIVATE KEY-----
/// """)
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.MtlsCertificate("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Ca = true,
///         Certificates = @"-----BEGIN CERTIFICATE-----
/// MIIDmDCCAoCgAwIBAgIUKTOAZNj...i4JhqeoTewsxndhDDE
/// -----END CERTIFICATE-----
/// ",
///         Name = "example",
///         PrivateKey = @"-----BEGIN PRIVATE KEY-----
/// MIIEvQIBADANBgkqhkiG9w0BAQE...1IS3EnQRrz6WMYA=
/// -----END PRIVATE KEY-----
/// ",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewMtlsCertificate(ctx, "example", &cloudflare.MtlsCertificateArgs{
/// 			AccountId:    pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Ca:           pulumi.Bool(true),
/// 			Certificates: pulumi.String("-----BEGIN CERTIFICATE-----\nMIIDmDCCAoCgAwIBAgIUKTOAZNj...i4JhqeoTewsxndhDDE\n-----END CERTIFICATE-----\n"),
/// 			Name:         pulumi.String("example"),
/// 			PrivateKey:   pulumi.String("-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQE...1IS3EnQRrz6WMYA=\n-----END PRIVATE KEY-----\n"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.MtlsCertificate;
/// import com.pulumi.cloudflare.MtlsCertificateArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new MtlsCertificate("example", MtlsCertificateArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .ca(true)
///             .certificates("""
/// -----BEGIN CERTIFICATE-----
/// MIIDmDCCAoCgAwIBAgIUKTOAZNj...i4JhqeoTewsxndhDDE
/// -----END CERTIFICATE-----
///             """)
///             .name("example")
///             .privateKey("""
/// -----BEGIN PRIVATE KEY-----
/// MIIEvQIBADANBgkqhkiG9w0BAQE...1IS3EnQRrz6WMYA=
/// -----END PRIVATE KEY-----
///             """)
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:MtlsCertificate
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       ca: true
///       certificates: |
///         -----BEGIN CERTIFICATE-----
///         MIIDmDCCAoCgAwIBAgIUKTOAZNj...i4JhqeoTewsxndhDDE
///         -----END CERTIFICATE-----
///       name: example
///       privateKey: |
///         -----BEGIN PRIVATE KEY-----
///         MIIEvQIBADANBgkqhkiG9w0BAQE...1IS3EnQRrz6WMYA=
///         -----END PRIVATE KEY-----
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/mtlsCertificate:MtlsCertificate example <account_id>/<mtls_certificate_id>
/// ```
///
pub mod mtls_certificate {

    pub struct MtlsCertificateArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether this is a CA or leaf certificate. **Modifying this attribute will force creation of a new resource.**
        pub ca: pulumi_wasm_rust::Output<bool>,
        /// Certificate you intend to use with mTLS-enabled services. **Modifying this attribute will force creation of a new resource.**
        pub certificates: pulumi_wasm_rust::Output<String>,
        /// Optional unique name for the certificate. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<Option<String>>,
        /// The certificate's private key. **Modifying this attribute will force creation of a new resource.**
        pub private_key: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct MtlsCertificateResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether this is a CA or leaf certificate. **Modifying this attribute will force creation of a new resource.**
        pub ca: pulumi_wasm_rust::Output<bool>,
        /// Certificate you intend to use with mTLS-enabled services. **Modifying this attribute will force creation of a new resource.**
        pub certificates: pulumi_wasm_rust::Output<String>,
        /// **Modifying this attribute will force creation of a new resource.**
        pub expires_on: pulumi_wasm_rust::Output<String>,
        /// **Modifying this attribute will force creation of a new resource.**
        pub issuer: pulumi_wasm_rust::Output<String>,
        /// Optional unique name for the certificate. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<Option<String>>,
        /// The certificate's private key. **Modifying this attribute will force creation of a new resource.**
        pub private_key: pulumi_wasm_rust::Output<Option<String>>,
        /// **Modifying this attribute will force creation of a new resource.**
        pub serial_number: pulumi_wasm_rust::Output<String>,
        /// **Modifying this attribute will force creation of a new resource.**
        pub signature: pulumi_wasm_rust::Output<String>,
        /// **Modifying this attribute will force creation of a new resource.**
        pub uploaded_on: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn mtls_certificate(name: &str, args: MtlsCertificateArgs) -> MtlsCertificateResult {
        let result = crate::bindings::pulumi::cloudflare::mtls_certificate::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::mtls_certificate::Args {
                account_id: args.account_id.get_inner(),
                ca: args.ca.get_inner(),
                certificates: args.certificates.get_inner(),
                name: args.name.get_inner(),
                private_key: args.private_key.get_inner(),
            },
        );

        MtlsCertificateResult {
            account_id: crate::into_domain(result.account_id),
            ca: crate::into_domain(result.ca),
            certificates: crate::into_domain(result.certificates),
            expires_on: crate::into_domain(result.expires_on),
            issuer: crate::into_domain(result.issuer),
            name: crate::into_domain(result.name),
            private_key: crate::into_domain(result.private_key),
            serial_number: crate::into_domain(result.serial_number),
            signature: crate::into_domain(result.signature),
            uploaded_on: crate::into_domain(result.uploaded_on),
        }
    }
}

/// Provides a resource, that manages a notification policy for
/// Cloudflare's products. The delivery mechanisms supported are email,
/// webhooks, and PagerDuty.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// //## With Filters
/// const example = new cloudflare.NotificationPolicy("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     alertType: "health_check_status_notification",
///     description: "Notification policy to alert on unhealthy Healthcheck status",
///     emailIntegrations: [{
///         id: "myemail@example.com",
///     }],
///     enabled: true,
///     filters: {
///         healthCheckIds: ["699d98642c564d2e855e9661899b7252"],
///         statuses: ["Unhealthy"],
///     },
///     name: "Policy for Healthcheck notification",
///     pagerdutyIntegrations: [{
///         id: "850129d136459401860572c5d964d27k",
///     }],
///     webhooksIntegrations: [{
///         id: "1860572c5d964d27aa0f379d13645940",
///     }],
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// ### With Filters
/// example = cloudflare.NotificationPolicy("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     alert_type="health_check_status_notification",
///     description="Notification policy to alert on unhealthy Healthcheck status",
///     email_integrations=[cloudflare.NotificationPolicyEmailIntegrationArgs(
///         id="myemail@example.com",
///     )],
///     enabled=True,
///     filters=cloudflare.NotificationPolicyFiltersArgs(
///         health_check_ids=["699d98642c564d2e855e9661899b7252"],
///         statuses=["Unhealthy"],
///     ),
///     name="Policy for Healthcheck notification",
///     pagerduty_integrations=[cloudflare.NotificationPolicyPagerdutyIntegrationArgs(
///         id="850129d136459401860572c5d964d27k",
///     )],
///     webhooks_integrations=[cloudflare.NotificationPolicyWebhooksIntegrationArgs(
///         id="1860572c5d964d27aa0f379d13645940",
///     )])
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     //## With Filters
///     var example = new Cloudflare.NotificationPolicy("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         AlertType = "health_check_status_notification",
///         Description = "Notification policy to alert on unhealthy Healthcheck status",
///         EmailIntegrations = new[]
///         {
///             new Cloudflare.Inputs.NotificationPolicyEmailIntegrationArgs
///             {
///                 Id = "myemail@example.com",
///             },
///         },
///         Enabled = true,
///         Filters = new Cloudflare.Inputs.NotificationPolicyFiltersArgs
///         {
///             HealthCheckIds = new[]
///             {
///                 "699d98642c564d2e855e9661899b7252",
///             },
///             Statuses = new[]
///             {
///                 "Unhealthy",
///             },
///         },
///         Name = "Policy for Healthcheck notification",
///         PagerdutyIntegrations = new[]
///         {
///             new Cloudflare.Inputs.NotificationPolicyPagerdutyIntegrationArgs
///             {
///                 Id = "850129d136459401860572c5d964d27k",
///             },
///         },
///         WebhooksIntegrations = new[]
///         {
///             new Cloudflare.Inputs.NotificationPolicyWebhooksIntegrationArgs
///             {
///                 Id = "1860572c5d964d27aa0f379d13645940",
///             },
///         },
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// ## With Filters
/// 		_, err := cloudflare.NewNotificationPolicy(ctx, "example", &cloudflare.NotificationPolicyArgs{
/// 			AccountId:   pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			AlertType:   pulumi.String("health_check_status_notification"),
/// 			Description: pulumi.String("Notification policy to alert on unhealthy Healthcheck status"),
/// 			EmailIntegrations: cloudflare.NotificationPolicyEmailIntegrationArray{
/// 				&cloudflare.NotificationPolicyEmailIntegrationArgs{
/// 					Id: pulumi.String("myemail@example.com"),
/// 				},
/// 			},
/// 			Enabled: pulumi.Bool(true),
/// 			Filters: &cloudflare.NotificationPolicyFiltersArgs{
/// 				HealthCheckIds: pulumi.StringArray{
/// 					pulumi.String("699d98642c564d2e855e9661899b7252"),
/// 				},
/// 				Statuses: pulumi.StringArray{
/// 					pulumi.String("Unhealthy"),
/// 				},
/// 			},
/// 			Name: pulumi.String("Policy for Healthcheck notification"),
/// 			PagerdutyIntegrations: cloudflare.NotificationPolicyPagerdutyIntegrationArray{
/// 				&cloudflare.NotificationPolicyPagerdutyIntegrationArgs{
/// 					Id: pulumi.String("850129d136459401860572c5d964d27k"),
/// 				},
/// 			},
/// 			WebhooksIntegrations: cloudflare.NotificationPolicyWebhooksIntegrationArray{
/// 				&cloudflare.NotificationPolicyWebhooksIntegrationArgs{
/// 					Id: pulumi.String("1860572c5d964d27aa0f379d13645940"),
/// 				},
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.NotificationPolicy;
/// import com.pulumi.cloudflare.NotificationPolicyArgs;
/// import com.pulumi.cloudflare.inputs.NotificationPolicyEmailIntegrationArgs;
/// import com.pulumi.cloudflare.inputs.NotificationPolicyFiltersArgs;
/// import com.pulumi.cloudflare.inputs.NotificationPolicyPagerdutyIntegrationArgs;
/// import com.pulumi.cloudflare.inputs.NotificationPolicyWebhooksIntegrationArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         //## With Filters
///         var example = new NotificationPolicy("example", NotificationPolicyArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .alertType("health_check_status_notification")
///             .description("Notification policy to alert on unhealthy Healthcheck status")
///             .emailIntegrations(NotificationPolicyEmailIntegrationArgs.builder()
///                 .id("myemail@example.com")
///                 .build())
///             .enabled(true)
///             .filters(NotificationPolicyFiltersArgs.builder()
///                 .healthCheckIds("699d98642c564d2e855e9661899b7252")
///                 .statuses("Unhealthy")
///                 .build())
///             .name("Policy for Healthcheck notification")
///             .pagerdutyIntegrations(NotificationPolicyPagerdutyIntegrationArgs.builder()
///                 .id("850129d136459401860572c5d964d27k")
///                 .build())
///             .webhooksIntegrations(NotificationPolicyWebhooksIntegrationArgs.builder()
///                 .id("1860572c5d964d27aa0f379d13645940")
///                 .build())
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   ## With Filters
///   example:
///     type: cloudflare:NotificationPolicy
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       alertType: health_check_status_notification
///       description: Notification policy to alert on unhealthy Healthcheck status
///       emailIntegrations:
///         - id: myemail@example.com
///       enabled: true
///       filters:
///         healthCheckIds:
///           - 699d98642c564d2e855e9661899b7252
///         statuses:
///           - Unhealthy
///       name: Policy for Healthcheck notification
///       pagerdutyIntegrations:
///         - id: 850129d136459401860572c5d964d27k
///       webhooksIntegrations:
///         - id: 1860572c5d964d27aa0f379d13645940
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/notificationPolicy:NotificationPolicy example <account_id>/<policy_id>
/// ```
///
pub mod notification_policy {

    pub struct NotificationPolicyArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The event type that will trigger the dispatch of a notification. See the developer documentation for descriptions of [available alert types](https://developers.cloudflare.com/fundamentals/notifications/notification-available/). Available values: `advanced_http_alert_error`, `access_custom_certificate_expiration_type`, `advanced_ddos_attack_l4_alert`, `advanced_ddos_attack_l7_alert`, `bgp_hijack_notification`, `billing_usage_alert`, `block_notification_block_removed`, `block_notification_new_block`, `block_notification_review_rejected`, `brand_protection_alert`, `brand_protection_digest`, `clickhouse_alert_fw_anomaly`, `clickhouse_alert_fw_ent_anomaly`, `custom_ssl_certificate_event_type`, `dedicated_ssl_certificate_event_type`, `dos_attack_l4`, `dos_attack_l7`, `expiring_service_token_alert`, `failing_logpush_job_disabled_alert`, `fbm_auto_advertisement`, `fbm_dosd_attack`, `fbm_volumetric_attack`, `health_check_status_notification`, `hostname_aop_custom_certificate_expiration_type`, `http_alert_edge_error`, `http_alert_origin_error`, `incident_alert`, `load_balancing_health_alert`, `load_balancing_pool_enablement_alert`, `logo_match_alert`, `magic_tunnel_health_check_event`, `maintenance_event_notification`, `mtls_certificate_store_certificate_expiration_type`, `pages_event_alert`, `radar_notification`, `real_origin_monitoring`, `scriptmonitor_alert_new_code_change_detections`, `scriptmonitor_alert_new_hosts`, `scriptmonitor_alert_new_malicious_hosts`, `scriptmonitor_alert_new_malicious_scripts`, `scriptmonitor_alert_new_malicious_url`, `scriptmonitor_alert_new_max_length_resource_url`, `scriptmonitor_alert_new_resources`, `secondary_dns_all_primaries_failing`, `secondary_dns_primaries_failing`, `secondary_dns_zone_successfully_updated`, `secondary_dns_zone_validation_warning`, `sentinel_alert`, `stream_live_notifications`, `traffic_anomalies_alert`, `tunnel_health_event`, `tunnel_update_event`, `universal_ssl_event_type`, `web_analytics_metrics_update`, `weekly_account_overview`, `workers_alert`, `zone_aop_custom_certificate_expiration_type`.
        pub alert_type: pulumi_wasm_rust::Output<String>,
        /// Description of the notification policy.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The email ID to which the notification should be dispatched.
        pub email_integrations:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::NotificationPolicyEmailIntegration>>>,
        /// State of the pool to alert on.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// An optional nested block of filters that applies to the selected `alert_type`. A key-value map that specifies the type of filter and the values to match against (refer to the alert type block for available fields).
        pub filters: pulumi_wasm_rust::Output<Option<crate::types::NotificationPolicyFilters>>,
        /// The name of the notification policy.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The unique ID of a configured pagerduty endpoint to which the notification should be dispatched.
        pub pagerduty_integrations: pulumi_wasm_rust::Output<
            Option<Vec<crate::types::NotificationPolicyPagerdutyIntegration>>,
        >,
        /// The unique ID of a configured webhooks endpoint to which the notification should be dispatched.
        pub webhooks_integrations: pulumi_wasm_rust::Output<
            Option<Vec<crate::types::NotificationPolicyWebhooksIntegration>>,
        >,
    }

    pub struct NotificationPolicyResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The event type that will trigger the dispatch of a notification. See the developer documentation for descriptions of [available alert types](https://developers.cloudflare.com/fundamentals/notifications/notification-available/). Available values: `advanced_http_alert_error`, `access_custom_certificate_expiration_type`, `advanced_ddos_attack_l4_alert`, `advanced_ddos_attack_l7_alert`, `bgp_hijack_notification`, `billing_usage_alert`, `block_notification_block_removed`, `block_notification_new_block`, `block_notification_review_rejected`, `brand_protection_alert`, `brand_protection_digest`, `clickhouse_alert_fw_anomaly`, `clickhouse_alert_fw_ent_anomaly`, `custom_ssl_certificate_event_type`, `dedicated_ssl_certificate_event_type`, `dos_attack_l4`, `dos_attack_l7`, `expiring_service_token_alert`, `failing_logpush_job_disabled_alert`, `fbm_auto_advertisement`, `fbm_dosd_attack`, `fbm_volumetric_attack`, `health_check_status_notification`, `hostname_aop_custom_certificate_expiration_type`, `http_alert_edge_error`, `http_alert_origin_error`, `incident_alert`, `load_balancing_health_alert`, `load_balancing_pool_enablement_alert`, `logo_match_alert`, `magic_tunnel_health_check_event`, `maintenance_event_notification`, `mtls_certificate_store_certificate_expiration_type`, `pages_event_alert`, `radar_notification`, `real_origin_monitoring`, `scriptmonitor_alert_new_code_change_detections`, `scriptmonitor_alert_new_hosts`, `scriptmonitor_alert_new_malicious_hosts`, `scriptmonitor_alert_new_malicious_scripts`, `scriptmonitor_alert_new_malicious_url`, `scriptmonitor_alert_new_max_length_resource_url`, `scriptmonitor_alert_new_resources`, `secondary_dns_all_primaries_failing`, `secondary_dns_primaries_failing`, `secondary_dns_zone_successfully_updated`, `secondary_dns_zone_validation_warning`, `sentinel_alert`, `stream_live_notifications`, `traffic_anomalies_alert`, `tunnel_health_event`, `tunnel_update_event`, `universal_ssl_event_type`, `web_analytics_metrics_update`, `weekly_account_overview`, `workers_alert`, `zone_aop_custom_certificate_expiration_type`.
        pub alert_type: pulumi_wasm_rust::Output<String>,
        /// When the notification policy was created.
        pub created: pulumi_wasm_rust::Output<String>,
        /// Description of the notification policy.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The email ID to which the notification should be dispatched.
        pub email_integrations:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::NotificationPolicyEmailIntegration>>>,
        /// State of the pool to alert on.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// An optional nested block of filters that applies to the selected `alert_type`. A key-value map that specifies the type of filter and the values to match against (refer to the alert type block for available fields).
        pub filters: pulumi_wasm_rust::Output<Option<crate::types::NotificationPolicyFilters>>,
        /// When the notification policy was last modified.
        pub modified: pulumi_wasm_rust::Output<String>,
        /// The name of the notification policy.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The unique ID of a configured pagerduty endpoint to which the notification should be dispatched.
        pub pagerduty_integrations: pulumi_wasm_rust::Output<
            Option<Vec<crate::types::NotificationPolicyPagerdutyIntegration>>,
        >,
        /// The unique ID of a configured webhooks endpoint to which the notification should be dispatched.
        pub webhooks_integrations: pulumi_wasm_rust::Output<
            Option<Vec<crate::types::NotificationPolicyWebhooksIntegration>>,
        >,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn notification_policy(
        name: &str,
        args: NotificationPolicyArgs,
    ) -> NotificationPolicyResult {
        let result = crate::bindings::pulumi::cloudflare::notification_policy::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::notification_policy::Args {
                account_id: args.account_id.get_inner(),
                alert_type: args.alert_type.get_inner(),
                description: args.description.get_inner(),
                email_integrations: args.email_integrations.get_inner(),
                enabled: args.enabled.get_inner(),
                filters: args.filters.get_inner(),
                name: args.name.get_inner(),
                pagerduty_integrations: args.pagerduty_integrations.get_inner(),
                webhooks_integrations: args.webhooks_integrations.get_inner(),
            },
        );

        NotificationPolicyResult {
            account_id: crate::into_domain(result.account_id),
            alert_type: crate::into_domain(result.alert_type),
            created: crate::into_domain(result.created),
            description: crate::into_domain(result.description),
            email_integrations: crate::into_domain(result.email_integrations),
            enabled: crate::into_domain(result.enabled),
            filters: crate::into_domain(result.filters),
            modified: crate::into_domain(result.modified),
            name: crate::into_domain(result.name),
            pagerduty_integrations: crate::into_domain(result.pagerduty_integrations),
            webhooks_integrations: crate::into_domain(result.webhooks_integrations),
        }
    }
}

/// Provides a resource, that manages a webhook destination. These destinations can be tied to the notification policies created for Cloudflare's products.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.NotificationPolicyWebhooks("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "Webhooks destination",
///     secret: "my-secret",
///     url: "https://example.com",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.NotificationPolicyWebhooks("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="Webhooks destination",
///     secret="my-secret",
///     url="https://example.com")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.NotificationPolicyWebhooks("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "Webhooks destination",
///         Secret = "my-secret",
///         Url = "https://example.com",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewNotificationPolicyWebhooks(ctx, "example", &cloudflare.NotificationPolicyWebhooksArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:      pulumi.String("Webhooks destination"),
/// 			Secret:    pulumi.String("my-secret"),
/// 			Url:       pulumi.String("https://example.com"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.NotificationPolicyWebhooks;
/// import com.pulumi.cloudflare.NotificationPolicyWebhooksArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new NotificationPolicyWebhooks("example", NotificationPolicyWebhooksArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("Webhooks destination")
///             .secret("my-secret")
///             .url("https://example.com")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:NotificationPolicyWebhooks
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       name: Webhooks destination
///       secret: my-secret
///       url: https://example.com
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/notificationPolicyWebhooks:NotificationPolicyWebhooks example <account_id>/<notification_webhook_id>
/// ```
///
pub mod notification_policy_webhooks {

    pub struct NotificationPolicyWebhooksArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the webhook destination.
        pub name: pulumi_wasm_rust::Output<String>,
        /// An optional secret can be provided that will be passed in the `cf-webhook-auth` header when dispatching a webhook notification. Secrets are not returned in any API response body. Refer to the [documentation](https://api.cloudflare.com/#notification-webhooks-create-webhook) for more details.
        pub secret: pulumi_wasm_rust::Output<Option<String>>,
        /// The URL of the webhook destinations. **Modifying this attribute will force creation of a new resource.**
        pub url: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct NotificationPolicyWebhooksResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Timestamp of when the notification webhook was created.
        pub created_at: pulumi_wasm_rust::Output<String>,
        /// Timestamp of when the notification webhook last faiuled.
        pub last_failure: pulumi_wasm_rust::Output<String>,
        /// Timestamp of when the notification webhook was last successful.
        pub last_success: pulumi_wasm_rust::Output<String>,
        /// The name of the webhook destination.
        pub name: pulumi_wasm_rust::Output<String>,
        /// An optional secret can be provided that will be passed in the `cf-webhook-auth` header when dispatching a webhook notification. Secrets are not returned in any API response body. Refer to the [documentation](https://api.cloudflare.com/#notification-webhooks-create-webhook) for more details.
        pub secret: pulumi_wasm_rust::Output<Option<String>>,
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The URL of the webhook destinations. **Modifying this attribute will force creation of a new resource.**
        pub url: pulumi_wasm_rust::Output<Option<String>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn notification_policy_webhooks(
        name: &str,
        args: NotificationPolicyWebhooksArgs,
    ) -> NotificationPolicyWebhooksResult {
        let result = crate::bindings::pulumi::cloudflare::notification_policy_webhooks::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::notification_policy_webhooks::Args {
                account_id: args.account_id.get_inner(),
                name: args.name.get_inner(),
                secret: args.secret.get_inner(),
                url: args.url.get_inner(),
            },
        );

        NotificationPolicyWebhooksResult {
            account_id: crate::into_domain(result.account_id),
            created_at: crate::into_domain(result.created_at),
            last_failure: crate::into_domain(result.last_failure),
            last_success: crate::into_domain(result.last_success),
            name: crate::into_domain(result.name),
            secret: crate::into_domain(result.secret),
            type_: crate::into_domain(result.type_),
            url: crate::into_domain(result.url),
        }
    }
}

/// Provides a Cloudflare Observatory Scheduled Test resource.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.ObservatoryScheduledTest("example", {
///     frequency: "WEEKLY",
///     region: "us-central1",
///     url: "example.com",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.ObservatoryScheduledTest("example",
///     frequency="WEEKLY",
///     region="us-central1",
///     url="example.com",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.ObservatoryScheduledTest("example", new()
///     {
///         Frequency = "WEEKLY",
///         Region = "us-central1",
///         Url = "example.com",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewObservatoryScheduledTest(ctx, "example", &cloudflare.ObservatoryScheduledTestArgs{
/// 			Frequency: pulumi.String("WEEKLY"),
/// 			Region:    pulumi.String("us-central1"),
/// 			Url:       pulumi.String("example.com"),
/// 			ZoneId:    pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.ObservatoryScheduledTest;
/// import com.pulumi.cloudflare.ObservatoryScheduledTestArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new ObservatoryScheduledTest("example", ObservatoryScheduledTestArgs.builder()        
///             .frequency("WEEKLY")
///             .region("us-central1")
///             .url("example.com")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:ObservatoryScheduledTest
///     properties:
///       frequency: WEEKLY
///       region: us-central1
///       url: example.com
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/observatoryScheduledTest:ObservatoryScheduledTest example <zone_id>:<url>:<region>
/// ```
///
pub mod observatory_scheduled_test {

    pub struct ObservatoryScheduledTestArgs {
        /// The frequency to run the test. Available values: `DAILY`, `WEEKLY`. **Modifying this attribute will force creation of a new resource.**
        pub frequency: pulumi_wasm_rust::Output<String>,
        /// The region to run the test in. Available values: `us-central1`, `us-east1`, `us-east4`, `us-south1`, `us-west1`, `southamerica-east1`, `europe-north1`, `europe-southwest1`, `europe-west1`, `europe-west2`, `europe-west3`, `europe-west4`, `europe-west8`, `europe-west9`, `asia-east1`, `asia-south1`, `asia-southeast1`, `me-west1`, `australia-southeast1`. **Modifying this attribute will force creation of a new resource.**
        pub region: pulumi_wasm_rust::Output<String>,
        /// The page to run the test on. **Modifying this attribute will force creation of a new resource.**
        pub url: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct ObservatoryScheduledTestResult {
        /// The frequency to run the test. Available values: `DAILY`, `WEEKLY`. **Modifying this attribute will force creation of a new resource.**
        pub frequency: pulumi_wasm_rust::Output<String>,
        /// The region to run the test in. Available values: `us-central1`, `us-east1`, `us-east4`, `us-south1`, `us-west1`, `southamerica-east1`, `europe-north1`, `europe-southwest1`, `europe-west1`, `europe-west2`, `europe-west3`, `europe-west4`, `europe-west8`, `europe-west9`, `asia-east1`, `asia-south1`, `asia-southeast1`, `me-west1`, `australia-southeast1`. **Modifying this attribute will force creation of a new resource.**
        pub region: pulumi_wasm_rust::Output<String>,
        /// The page to run the test on. **Modifying this attribute will force creation of a new resource.**
        pub url: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn observatory_scheduled_test(
        name: &str,
        args: ObservatoryScheduledTestArgs,
    ) -> ObservatoryScheduledTestResult {
        let result = crate::bindings::pulumi::cloudflare::observatory_scheduled_test::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::observatory_scheduled_test::Args {
                frequency: args.frequency.get_inner(),
                region: args.region.get_inner(),
                url: args.url.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        ObservatoryScheduledTestResult {
            frequency: crate::into_domain(result.frequency),
            region: crate::into_domain(result.region),
            url: crate::into_domain(result.url),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare Origin CA certificate used to protect traffic to your origin without involving a third party Certificate Authority.
///
/// > Since v3.32.0
///    all authentication schemes are supported for managing Origin CA certificates.
///    Versions prior to v3.32.0 will still need to use `api_user_service_key`.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
/// import * as tls from "@pulumi/tls";
///
/// const examplePrivateKey = new tls.PrivateKey("examplePrivateKey", {algorithm: "RSA"});
/// const exampleCertRequest = new tls.CertRequest("exampleCertRequest", {
///     privateKeyPem: examplePrivateKey.privateKeyPem,
///     subjects: [{
///         commonName: "",
///         organization: "Terraform Test",
///     }],
/// });
/// const exampleOriginCaCertificate = new cloudflare.OriginCaCertificate("exampleOriginCaCertificate", {
///     csr: exampleCertRequest.certRequestPem,
///     hostnames: ["example.com"],
///     requestType: "origin-rsa",
///     requestedValidity: 7,
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
/// import pulumi_tls as tls
///
/// example_private_key = tls.PrivateKey("examplePrivateKey", algorithm="RSA")
/// example_cert_request = tls.CertRequest("exampleCertRequest",
///     private_key_pem=example_private_key.private_key_pem,
///     subjects=[tls.CertRequestSubjectArgs(
///         common_name="",
///         organization="Terraform Test",
///     )])
/// example_origin_ca_certificate = cloudflare.OriginCaCertificate("exampleOriginCaCertificate",
///     csr=example_cert_request.cert_request_pem,
///     hostnames=["example.com"],
///     request_type="origin-rsa",
///     requested_validity=7)
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
/// using Tls = Pulumi.Tls;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var examplePrivateKey = new Tls.PrivateKey("examplePrivateKey", new()
///     {
///         Algorithm = "RSA",
///     });
///
///     var exampleCertRequest = new Tls.CertRequest("exampleCertRequest", new()
///     {
///         PrivateKeyPem = examplePrivateKey.PrivateKeyPem,
///         Subjects = new[]
///         {
///             new Tls.Inputs.CertRequestSubjectArgs
///             {
///                 CommonName = "",
///                 Organization = "Terraform Test",
///             },
///         },
///     });
///
///     var exampleOriginCaCertificate = new Cloudflare.OriginCaCertificate("exampleOriginCaCertificate", new()
///     {
///         Csr = exampleCertRequest.CertRequestPem,
///         Hostnames = new[]
///         {
///             "example.com",
///         },
///         RequestType = "origin-rsa",
///         RequestedValidity = 7,
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi-tls/sdk/v4/go/tls"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		examplePrivateKey, err := tls.NewPrivateKey(ctx, "examplePrivateKey", &tls.PrivateKeyArgs{
/// 			Algorithm: pulumi.String("RSA"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		exampleCertRequest, err := tls.NewCertRequest(ctx, "exampleCertRequest", &tls.CertRequestArgs{
/// 			PrivateKeyPem: examplePrivateKey.PrivateKeyPem,
/// 			Subjects: tls.CertRequestSubjectArray{
/// 				&tls.CertRequestSubjectArgs{
/// 					CommonName:   pulumi.String(""),
/// 					Organization: pulumi.String("Terraform Test"),
/// 				},
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		_, err = cloudflare.NewOriginCaCertificate(ctx, "exampleOriginCaCertificate", &cloudflare.OriginCaCertificateArgs{
/// 			Csr: exampleCertRequest.CertRequestPem,
/// 			Hostnames: pulumi.StringArray{
/// 				pulumi.String("example.com"),
/// 			},
/// 			RequestType:       pulumi.String("origin-rsa"),
/// 			RequestedValidity: pulumi.Int(7),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.tls.PrivateKey;
/// import com.pulumi.tls.PrivateKeyArgs;
/// import com.pulumi.tls.CertRequest;
/// import com.pulumi.tls.CertRequestArgs;
/// import com.pulumi.tls.inputs.CertRequestSubjectArgs;
/// import com.pulumi.cloudflare.OriginCaCertificate;
/// import com.pulumi.cloudflare.OriginCaCertificateArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var examplePrivateKey = new PrivateKey("examplePrivateKey", PrivateKeyArgs.builder()        
///             .algorithm("RSA")
///             .build());
///
///         var exampleCertRequest = new CertRequest("exampleCertRequest", CertRequestArgs.builder()        
///             .privateKeyPem(examplePrivateKey.privateKeyPem())
///             .subjects(CertRequestSubjectArgs.builder()
///                 .commonName("")
///                 .organization("Terraform Test")
///                 .build())
///             .build());
///
///         var exampleOriginCaCertificate = new OriginCaCertificate("exampleOriginCaCertificate", OriginCaCertificateArgs.builder()        
///             .csr(exampleCertRequest.certRequestPem())
///             .hostnames("example.com")
///             .requestType("origin-rsa")
///             .requestedValidity(7)
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   examplePrivateKey:
///     type: tls:PrivateKey
///     properties:
///       algorithm: RSA
///   exampleCertRequest:
///     type: tls:CertRequest
///     properties:
///       privateKeyPem: ${examplePrivateKey.privateKeyPem}
///       subjects:
///         - commonName:
///           organization: Terraform Test
///   exampleOriginCaCertificate:
///     type: cloudflare:OriginCaCertificate
///     properties:
///       csr: ${exampleCertRequest.certRequestPem}
///       hostnames:
///         - example.com
///       requestType: origin-rsa
///       requestedValidity: 7
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/originCaCertificate:OriginCaCertificate example <certificate_id>
/// ```
///
pub mod origin_ca_certificate {

    pub struct OriginCaCertificateArgs {
        /// The Certificate Signing Request. Must be newline-encoded. **Modifying this attribute will force creation of a new resource.**
        pub csr: pulumi_wasm_rust::Output<String>,
        /// A list of hostnames or wildcard names bound to the certificate. **Modifying this attribute will force creation of a new resource.**
        pub hostnames: pulumi_wasm_rust::Output<Vec<String>>,
        /// Number of days prior to the expiry to trigger a renewal of the certificate if a Terraform operation is run.
        pub min_days_for_renewal: pulumi_wasm_rust::Output<Option<i32>>,
        /// The signature type desired on the certificate. Available values: `origin-rsa`, `origin-ecc`, `keyless-certificate`. **Modifying this attribute will force creation of a new resource.**
        pub request_type: pulumi_wasm_rust::Output<String>,
        /// The number of days for which the certificate should be valid. Available values: `7`, `30`, `90`, `365`, `730`, `1095`, `5475`. **Modifying this attribute will force creation of a new resource.**
        pub requested_validity: pulumi_wasm_rust::Output<Option<i32>>,
    }

    pub struct OriginCaCertificateResult {
        /// The Origin CA certificate.
        pub certificate: pulumi_wasm_rust::Output<String>,
        /// The Certificate Signing Request. Must be newline-encoded. **Modifying this attribute will force creation of a new resource.**
        pub csr: pulumi_wasm_rust::Output<String>,
        /// The datetime when the certificate will expire.
        pub expires_on: pulumi_wasm_rust::Output<String>,
        /// A list of hostnames or wildcard names bound to the certificate. **Modifying this attribute will force creation of a new resource.**
        pub hostnames: pulumi_wasm_rust::Output<Vec<String>>,
        /// Number of days prior to the expiry to trigger a renewal of the certificate if a Terraform operation is run.
        pub min_days_for_renewal: pulumi_wasm_rust::Output<Option<i32>>,
        /// The signature type desired on the certificate. Available values: `origin-rsa`, `origin-ecc`, `keyless-certificate`. **Modifying this attribute will force creation of a new resource.**
        pub request_type: pulumi_wasm_rust::Output<String>,
        /// The number of days for which the certificate should be valid. Available values: `7`, `30`, `90`, `365`, `730`, `1095`, `5475`. **Modifying this attribute will force creation of a new resource.**
        pub requested_validity: pulumi_wasm_rust::Output<i32>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn origin_ca_certificate(
        name: &str,
        args: OriginCaCertificateArgs,
    ) -> OriginCaCertificateResult {
        let result = crate::bindings::pulumi::cloudflare::origin_ca_certificate::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::origin_ca_certificate::Args {
                csr: args.csr.get_inner(),
                hostnames: args.hostnames.get_inner(),
                min_days_for_renewal: args.min_days_for_renewal.get_inner(),
                request_type: args.request_type.get_inner(),
                requested_validity: args.requested_validity.get_inner(),
            },
        );

        OriginCaCertificateResult {
            certificate: crate::into_domain(result.certificate),
            csr: crate::into_domain(result.csr),
            expires_on: crate::into_domain(result.expires_on),
            hostnames: crate::into_domain(result.hostnames),
            min_days_for_renewal: crate::into_domain(result.min_days_for_renewal),
            request_type: crate::into_domain(result.request_type),
            requested_validity: crate::into_domain(result.requested_validity),
        }
    }
}

/// Provides a Cloudflare page rule resource.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// // Add a page rule to the domain
/// const foobar = new cloudflare.PageRule("foobar", {
///     zoneId: _var.cloudflare_zone_id,
///     target: `sub.${_var.cloudflare_zone}/page`,
///     priority: 1,
///     actions: {
///         ssl: "flexible",
///         emailObfuscation: "on",
///         minifies: [{
///             html: "off",
///             css: "on",
///             js: "on",
///         }],
///     },
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// # Add a page rule to the domain
/// foobar = cloudflare.PageRule("foobar",
///     zone_id=var["cloudflare_zone_id"],
///     target=f"sub.{var['cloudflare_zone']}/page",
///     priority=1,
///     actions=cloudflare.PageRuleActionsArgs(
///         ssl="flexible",
///         email_obfuscation="on",
///         minifies=[cloudflare.PageRuleActionsMinifyArgs(
///             html="off",
///             css="on",
///             js="on",
///         )],
///     ))
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     // Add a page rule to the domain
///     var foobar = new Cloudflare.PageRule("foobar", new()
///     {
///         ZoneId = @var.Cloudflare_zone_id,
///         Target = $"sub.{@var.Cloudflare_zone}/page",
///         Priority = 1,
///         Actions = new Cloudflare.Inputs.PageRuleActionsArgs
///         {
///             Ssl = "flexible",
///             EmailObfuscation = "on",
///             Minifies = new[]
///             {
///                 new Cloudflare.Inputs.PageRuleActionsMinifyArgs
///                 {
///                     Html = "off",
///                     Css = "on",
///                     Js = "on",
///                 },
///             },
///         },
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"fmt"
///
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// Add a page rule to the domain
/// 		_, err := cloudflare.NewPageRule(ctx, "foobar", &cloudflare.PageRuleArgs{
/// 			ZoneId:   pulumi.Any(_var.Cloudflare_zone_id),
/// 			Target:   pulumi.String(fmt.Sprintf("sub.%v/page", _var.Cloudflare_zone)),
/// 			Priority: pulumi.Int(1),
/// 			Actions: &cloudflare.PageRuleActionsArgs{
/// 				Ssl:              pulumi.String("flexible"),
/// 				EmailObfuscation: pulumi.String("on"),
/// 				Minifies: cloudflare.PageRuleActionsMinifyArray{
/// 					&cloudflare.PageRuleActionsMinifyArgs{
/// 						Html: pulumi.String("off"),
/// 						Css:  pulumi.String("on"),
/// 						Js:   pulumi.String("on"),
/// 					},
/// 				},
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.PageRule;
/// import com.pulumi.cloudflare.PageRuleArgs;
/// import com.pulumi.cloudflare.inputs.PageRuleActionsArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // Add a page rule to the domain
///         var foobar = new PageRule("foobar", PageRuleArgs.builder()        
///             .zoneId(var_.cloudflare_zone_id())
///             .target(String.format("sub.%s/page", var_.cloudflare_zone()))
///             .priority(1)
///             .actions(PageRuleActionsArgs.builder()
///                 .ssl("flexible")
///                 .emailObfuscation("on")
///                 .minifies(PageRuleActionsMinifyArgs.builder()
///                     .html("off")
///                     .css("on")
///                     .js("on")
///                     .build())
///                 .build())
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # Add a page rule to the domain
///   foobar:
///     type: cloudflare:PageRule
///     properties:
///       zoneId: ${var.cloudflare_zone_id}
///       target: sub.${var.cloudflare_zone}/page
///       priority: 1
///       actions:
///         ssl: flexible
///         emailObfuscation: on
///         minifies:
///           - html: off
///             css: on
///             js: on
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// Page rules can be imported using a composite ID formed of zone ID and page rule ID, e.g.
///
/// ```sh
/// $ pulumi import cloudflare:index/pageRule:PageRule default d41d8cd98f00b204e9800998ecf8427e/ch8374ftwdghsif43
/// ```
pub mod page_rule {

    pub struct PageRuleArgs {
        /// The actions taken by the page rule, options given below.
        pub actions: pulumi_wasm_rust::Output<crate::types::PageRuleActions>,
        /// The priority of the page rule among others for this target, the higher the number the higher the priority as per [API documentation](https://api.cloudflare.com/#page-rules-for-a-zone-create-page-rule).
        pub priority: pulumi_wasm_rust::Output<Option<i32>>,
        /// Whether the page rule is active or disabled.
        pub status: pulumi_wasm_rust::Output<Option<String>>,
        /// The URL pattern to target with the page rule.
        pub target: pulumi_wasm_rust::Output<String>,
        /// The DNS zone ID to which the page rule should be added.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct PageRuleResult {
        /// The actions taken by the page rule, options given below.
        pub actions: pulumi_wasm_rust::Output<crate::types::PageRuleActions>,
        /// The priority of the page rule among others for this target, the higher the number the higher the priority as per [API documentation](https://api.cloudflare.com/#page-rules-for-a-zone-create-page-rule).
        pub priority: pulumi_wasm_rust::Output<Option<i32>>,
        /// Whether the page rule is active or disabled.
        pub status: pulumi_wasm_rust::Output<Option<String>>,
        /// The URL pattern to target with the page rule.
        pub target: pulumi_wasm_rust::Output<String>,
        /// The DNS zone ID to which the page rule should be added.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn page_rule(name: &str, args: PageRuleArgs) -> PageRuleResult {
        let result = crate::bindings::pulumi::cloudflare::page_rule::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::page_rule::Args {
                actions: args.actions.get_inner(),
                priority: args.priority.get_inner(),
                status: args.status.get_inner(),
                target: args.target.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        PageRuleResult {
            actions: crate::into_domain(result.actions),
            priority: crate::into_domain(result.priority),
            status: crate::into_domain(result.status),
            target: crate::into_domain(result.target),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a resource for managing Cloudflare Pages domains.
///
/// > A DNS record for the domain is not automatically created. You need to create
///    a `cloudflare.Record` resource for the domain you want to use.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const my_domain = new cloudflare.PagesDomain("my-domain", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     domain: "example.com",
///     projectName: "my-example-project",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// my_domain = cloudflare.PagesDomain("my-domain",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     domain="example.com",
///     project_name="my-example-project")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var my_domain = new Cloudflare.PagesDomain("my-domain", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Domain = "example.com",
///         ProjectName = "my-example-project",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewPagesDomain(ctx, "my-domain", &cloudflare.PagesDomainArgs{
/// 			AccountId:   pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Domain:      pulumi.String("example.com"),
/// 			ProjectName: pulumi.String("my-example-project"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.PagesDomain;
/// import com.pulumi.cloudflare.PagesDomainArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var my_domain = new PagesDomain("my-domain", PagesDomainArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .domain("example.com")
///             .projectName("my-example-project")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   my-domain:
///     type: cloudflare:PagesDomain
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       domain: example.com
///       projectName: my-example-project
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/pagesDomain:PagesDomain example <account_id>/<project_name>/<domain-name>
/// ```
///
pub mod pages_domain {

    pub struct PagesDomainArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Custom domain. **Modifying this attribute will force creation of a new resource.**
        pub domain: pulumi_wasm_rust::Output<String>,
        /// Name of the Pages Project. **Modifying this attribute will force creation of a new resource.**
        pub project_name: pulumi_wasm_rust::Output<String>,
    }

    pub struct PagesDomainResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Custom domain. **Modifying this attribute will force creation of a new resource.**
        pub domain: pulumi_wasm_rust::Output<String>,
        /// Name of the Pages Project. **Modifying this attribute will force creation of a new resource.**
        pub project_name: pulumi_wasm_rust::Output<String>,
        /// Status of the custom domain.
        pub status: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn pages_domain(name: &str, args: PagesDomainArgs) -> PagesDomainResult {
        let result = crate::bindings::pulumi::cloudflare::pages_domain::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::pages_domain::Args {
                account_id: args.account_id.get_inner(),
                domain: args.domain.get_inner(),
                project_name: args.project_name.get_inner(),
            },
        );

        PagesDomainResult {
            account_id: crate::into_domain(result.account_id),
            domain: crate::into_domain(result.domain),
            project_name: crate::into_domain(result.project_name),
            status: crate::into_domain(result.status),
        }
    }
}

/// Provides a resource which manages Cloudflare Pages projects.
///
/// > If you are using a `source` block configuration, you must first have a
///    connected GitHub or GitLab account connected to Cloudflare. See the
///    [Getting Started with Pages] documentation on how to link your accounts.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// // Direct upload Pages project
/// const basicProject = new cloudflare.PagesProject("basicProject", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "this-is-my-project-01",
///     productionBranch: "main",
/// });
/// // Pages project with managing build config
/// const buildConfig = new cloudflare.PagesProject("buildConfig", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     buildConfig: {
///         buildCommand: "npm run build",
///         destinationDir: "build",
///         rootDir: "",
///         webAnalyticsTag: "cee1c73f6e4743d0b5e6bb1a0bcaabcc",
///         webAnalyticsToken: "021e1057c18547eca7b79f2516f06o7x",
///     },
///     name: "this-is-my-project-01",
///     productionBranch: "main",
/// });
/// // Pages project managing project source
/// const sourceConfig = new cloudflare.PagesProject("sourceConfig", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "this-is-my-project-01",
///     productionBranch: "main",
///     source: {
///         config: {
///             deploymentsEnabled: true,
///             owner: "cloudflare",
///             prCommentsEnabled: true,
///             previewBranchExcludes: [
///                 "main",
///                 "prod",
///             ],
///             previewBranchIncludes: [
///                 "dev",
///                 "preview",
///             ],
///             previewDeploymentSetting: "custom",
///             productionBranch: "main",
///             productionDeploymentEnabled: true,
///             repoName: "ninjakittens",
///         },
///         type: "github",
///     },
/// });
/// // Pages project managing all configs
/// const deploymentConfigs = new cloudflare.PagesProject("deploymentConfigs", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     buildConfig: {
///         buildCommand: "npm run build",
///         destinationDir: "build",
///         rootDir: "",
///         webAnalyticsTag: "cee1c73f6e4743d0b5e6bb1a0bcaabcc",
///         webAnalyticsToken: "021e1057c18547eca7b79f2516f06o7x",
///     },
///     deploymentConfigs: {
///         preview: {
///             compatibilityDate: "2022-08-15",
///             compatibilityFlags: ["nodejs_compat"],
///             d1Databases: {
///                 D1BINDING: "445e2955-951a-4358-a35b-a4d0c813f63",
///             },
///             durableObjectNamespaces: {
///                 DOBINDING: "5eb63bbbe01eeed093cb22bb8f5acdc3",
///             },
///             environmentVariables: {
///                 ENVIRONMENT: "preview",
///             },
///             kvNamespaces: {
///                 KVBINDING: "5eb63bbbe01eeed093cb22bb8f5acdc3",
///             },
///             r2Buckets: {
///                 R2BINDING: "some-bucket",
///             },
///             secrets: {
///                 TURNSTILESECRET: "1x0000000000000000000000000000000AA",
///             },
///         },
///         production: {
///             compatibilityDate: "2022-08-16",
///             compatibilityFlags: [
///                 "nodejs_compat",
///                 "streams_enable_constructors",
///             ],
///             d1Databases: {
///                 D1BINDING1: "445e2955-951a-4358-a35b-a4d0c813f63",
///                 D1BINDING2: "a399414b-c697-409a-a688-377db6433cd9",
///             },
///             durableObjectNamespaces: {
///                 DOBINDING1: "5eb63bbbe01eeed093cb22bb8f5acdc3",
///                 DOBINDING2: "3cdca5f8bb22bc390deee10ebbb36be5",
///             },
///             environmentVariables: {
///                 ENVIRONMENT: "production",
///                 OTHERVALUE: "other value",
///             },
///             kvNamespaces: {
///                 KVBINDING1: "5eb63bbbe01eeed093cb22bb8f5acdc3",
///                 KVBINDING2: "3cdca5f8bb22bc390deee10ebbb36be5",
///             },
///             r2Buckets: {
///                 R2BINDING1: "some-bucket",
///                 R2BINDING2: "other-bucket",
///             },
///             secrets: {
///                 TURNSTILEINVISSECRET: "2x0000000000000000000000000000000AA",
///                 TURNSTILESECRET: "1x0000000000000000000000000000000AA",
///             },
///         },
///     },
///     name: "this-is-my-project-01",
///     productionBranch: "main",
///     source: {
///         config: {
///             deploymentsEnabled: true,
///             owner: "cloudflare",
///             prCommentsEnabled: true,
///             previewBranchExcludes: [
///                 "main",
///                 "prod",
///             ],
///             previewBranchIncludes: [
///                 "dev",
///                 "preview",
///             ],
///             previewDeploymentSetting: "custom",
///             productionBranch: "main",
///             productionDeploymentEnabled: true,
///             repoName: "ninjakittens",
///         },
///         type: "github",
///     },
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// # Direct upload Pages project
/// basic_project = cloudflare.PagesProject("basicProject",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="this-is-my-project-01",
///     production_branch="main")
/// # Pages project with managing build config
/// build_config = cloudflare.PagesProject("buildConfig",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     build_config=cloudflare.PagesProjectBuildConfigArgs(
///         build_command="npm run build",
///         destination_dir="build",
///         root_dir="",
///         web_analytics_tag="cee1c73f6e4743d0b5e6bb1a0bcaabcc",
///         web_analytics_token="021e1057c18547eca7b79f2516f06o7x",
///     ),
///     name="this-is-my-project-01",
///     production_branch="main")
/// # Pages project managing project source
/// source_config = cloudflare.PagesProject("sourceConfig",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="this-is-my-project-01",
///     production_branch="main",
///     source=cloudflare.PagesProjectSourceArgs(
///         config=cloudflare.PagesProjectSourceConfigArgs(
///             deployments_enabled=True,
///             owner="cloudflare",
///             pr_comments_enabled=True,
///             preview_branch_excludes=[
///                 "main",
///                 "prod",
///             ],
///             preview_branch_includes=[
///                 "dev",
///                 "preview",
///             ],
///             preview_deployment_setting="custom",
///             production_branch="main",
///             production_deployment_enabled=True,
///             repo_name="ninjakittens",
///         ),
///         type="github",
///     ))
/// # Pages project managing all configs
/// deployment_configs = cloudflare.PagesProject("deploymentConfigs",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     build_config=cloudflare.PagesProjectBuildConfigArgs(
///         build_command="npm run build",
///         destination_dir="build",
///         root_dir="",
///         web_analytics_tag="cee1c73f6e4743d0b5e6bb1a0bcaabcc",
///         web_analytics_token="021e1057c18547eca7b79f2516f06o7x",
///     ),
///     deployment_configs=cloudflare.PagesProjectDeploymentConfigsArgs(
///         preview=cloudflare.PagesProjectDeploymentConfigsPreviewArgs(
///             compatibility_date="2022-08-15",
///             compatibility_flags=["nodejs_compat"],
///             d1_databases={
///                 "D1BINDING": "445e2955-951a-4358-a35b-a4d0c813f63",
///             },
///             durable_object_namespaces={
///                 "DOBINDING": "5eb63bbbe01eeed093cb22bb8f5acdc3",
///             },
///             environment_variables={
///                 "ENVIRONMENT": "preview",
///             },
///             kv_namespaces={
///                 "KVBINDING": "5eb63bbbe01eeed093cb22bb8f5acdc3",
///             },
///             r2_buckets={
///                 "R2BINDING": "some-bucket",
///             },
///             secrets={
///                 "TURNSTILESECRET": "1x0000000000000000000000000000000AA",
///             },
///         ),
///         production=cloudflare.PagesProjectDeploymentConfigsProductionArgs(
///             compatibility_date="2022-08-16",
///             compatibility_flags=[
///                 "nodejs_compat",
///                 "streams_enable_constructors",
///             ],
///             d1_databases={
///                 "D1BINDING1": "445e2955-951a-4358-a35b-a4d0c813f63",
///                 "D1BINDING2": "a399414b-c697-409a-a688-377db6433cd9",
///             },
///             durable_object_namespaces={
///                 "DOBINDING1": "5eb63bbbe01eeed093cb22bb8f5acdc3",
///                 "DOBINDING2": "3cdca5f8bb22bc390deee10ebbb36be5",
///             },
///             environment_variables={
///                 "ENVIRONMENT": "production",
///                 "OTHERVALUE": "other value",
///             },
///             kv_namespaces={
///                 "KVBINDING1": "5eb63bbbe01eeed093cb22bb8f5acdc3",
///                 "KVBINDING2": "3cdca5f8bb22bc390deee10ebbb36be5",
///             },
///             r2_buckets={
///                 "R2BINDING1": "some-bucket",
///                 "R2BINDING2": "other-bucket",
///             },
///             secrets={
///                 "TURNSTILEINVISSECRET": "2x0000000000000000000000000000000AA",
///                 "TURNSTILESECRET": "1x0000000000000000000000000000000AA",
///             },
///         ),
///     ),
///     name="this-is-my-project-01",
///     production_branch="main",
///     source=cloudflare.PagesProjectSourceArgs(
///         config=cloudflare.PagesProjectSourceConfigArgs(
///             deployments_enabled=True,
///             owner="cloudflare",
///             pr_comments_enabled=True,
///             preview_branch_excludes=[
///                 "main",
///                 "prod",
///             ],
///             preview_branch_includes=[
///                 "dev",
///                 "preview",
///             ],
///             preview_deployment_setting="custom",
///             production_branch="main",
///             production_deployment_enabled=True,
///             repo_name="ninjakittens",
///         ),
///         type="github",
///     ))
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     // Direct upload Pages project
///     var basicProject = new Cloudflare.PagesProject("basicProject", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "this-is-my-project-01",
///         ProductionBranch = "main",
///     });
///
///     // Pages project with managing build config
///     var buildConfig = new Cloudflare.PagesProject("buildConfig", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         BuildConfig = new Cloudflare.Inputs.PagesProjectBuildConfigArgs
///         {
///             BuildCommand = "npm run build",
///             DestinationDir = "build",
///             RootDir = "",
///             WebAnalyticsTag = "cee1c73f6e4743d0b5e6bb1a0bcaabcc",
///             WebAnalyticsToken = "021e1057c18547eca7b79f2516f06o7x",
///         },
///         Name = "this-is-my-project-01",
///         ProductionBranch = "main",
///     });
///
///     // Pages project managing project source
///     var sourceConfig = new Cloudflare.PagesProject("sourceConfig", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "this-is-my-project-01",
///         ProductionBranch = "main",
///         Source = new Cloudflare.Inputs.PagesProjectSourceArgs
///         {
///             Config = new Cloudflare.Inputs.PagesProjectSourceConfigArgs
///             {
///                 DeploymentsEnabled = true,
///                 Owner = "cloudflare",
///                 PrCommentsEnabled = true,
///                 PreviewBranchExcludes = new[]
///                 {
///                     "main",
///                     "prod",
///                 },
///                 PreviewBranchIncludes = new[]
///                 {
///                     "dev",
///                     "preview",
///                 },
///                 PreviewDeploymentSetting = "custom",
///                 ProductionBranch = "main",
///                 ProductionDeploymentEnabled = true,
///                 RepoName = "ninjakittens",
///             },
///             Type = "github",
///         },
///     });
///
///     // Pages project managing all configs
///     var deploymentConfigs = new Cloudflare.PagesProject("deploymentConfigs", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         BuildConfig = new Cloudflare.Inputs.PagesProjectBuildConfigArgs
///         {
///             BuildCommand = "npm run build",
///             DestinationDir = "build",
///             RootDir = "",
///             WebAnalyticsTag = "cee1c73f6e4743d0b5e6bb1a0bcaabcc",
///             WebAnalyticsToken = "021e1057c18547eca7b79f2516f06o7x",
///         },
///         DeploymentConfigs = new Cloudflare.Inputs.PagesProjectDeploymentConfigsArgs
///         {
///             Preview = new Cloudflare.Inputs.PagesProjectDeploymentConfigsPreviewArgs
///             {
///                 CompatibilityDate = "2022-08-15",
///                 CompatibilityFlags = new[]
///                 {
///                     "nodejs_compat",
///                 },
///                 D1Databases =
///                 {
///                     { "D1BINDING", "445e2955-951a-4358-a35b-a4d0c813f63" },
///                 },
///                 DurableObjectNamespaces =
///                 {
///                     { "DOBINDING", "5eb63bbbe01eeed093cb22bb8f5acdc3" },
///                 },
///                 EnvironmentVariables =
///                 {
///                     { "ENVIRONMENT", "preview" },
///                 },
///                 KvNamespaces =
///                 {
///                     { "KVBINDING", "5eb63bbbe01eeed093cb22bb8f5acdc3" },
///                 },
///                 R2Buckets =
///                 {
///                     { "R2BINDING", "some-bucket" },
///                 },
///                 Secrets =
///                 {
///                     { "TURNSTILESECRET", "1x0000000000000000000000000000000AA" },
///                 },
///             },
///             Production = new Cloudflare.Inputs.PagesProjectDeploymentConfigsProductionArgs
///             {
///                 CompatibilityDate = "2022-08-16",
///                 CompatibilityFlags = new[]
///                 {
///                     "nodejs_compat",
///                     "streams_enable_constructors",
///                 },
///                 D1Databases =
///                 {
///                     { "D1BINDING1", "445e2955-951a-4358-a35b-a4d0c813f63" },
///                     { "D1BINDING2", "a399414b-c697-409a-a688-377db6433cd9" },
///                 },
///                 DurableObjectNamespaces =
///                 {
///                     { "DOBINDING1", "5eb63bbbe01eeed093cb22bb8f5acdc3" },
///                     { "DOBINDING2", "3cdca5f8bb22bc390deee10ebbb36be5" },
///                 },
///                 EnvironmentVariables =
///                 {
///                     { "ENVIRONMENT", "production" },
///                     { "OTHERVALUE", "other value" },
///                 },
///                 KvNamespaces =
///                 {
///                     { "KVBINDING1", "5eb63bbbe01eeed093cb22bb8f5acdc3" },
///                     { "KVBINDING2", "3cdca5f8bb22bc390deee10ebbb36be5" },
///                 },
///                 R2Buckets =
///                 {
///                     { "R2BINDING1", "some-bucket" },
///                     { "R2BINDING2", "other-bucket" },
///                 },
///                 Secrets =
///                 {
///                     { "TURNSTILEINVISSECRET", "2x0000000000000000000000000000000AA" },
///                     { "TURNSTILESECRET", "1x0000000000000000000000000000000AA" },
///                 },
///             },
///         },
///         Name = "this-is-my-project-01",
///         ProductionBranch = "main",
///         Source = new Cloudflare.Inputs.PagesProjectSourceArgs
///         {
///             Config = new Cloudflare.Inputs.PagesProjectSourceConfigArgs
///             {
///                 DeploymentsEnabled = true,
///                 Owner = "cloudflare",
///                 PrCommentsEnabled = true,
///                 PreviewBranchExcludes = new[]
///                 {
///                     "main",
///                     "prod",
///                 },
///                 PreviewBranchIncludes = new[]
///                 {
///                     "dev",
///                     "preview",
///                 },
///                 PreviewDeploymentSetting = "custom",
///                 ProductionBranch = "main",
///                 ProductionDeploymentEnabled = true,
///                 RepoName = "ninjakittens",
///             },
///             Type = "github",
///         },
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// Direct upload Pages project
/// 		_, err := cloudflare.NewPagesProject(ctx, "basicProject", &cloudflare.PagesProjectArgs{
/// 			AccountId:        pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:             pulumi.String("this-is-my-project-01"),
/// 			ProductionBranch: pulumi.String("main"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// Pages project with managing build config
/// 		_, err = cloudflare.NewPagesProject(ctx, "buildConfig", &cloudflare.PagesProjectArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			BuildConfig: &cloudflare.PagesProjectBuildConfigArgs{
/// 				BuildCommand:      pulumi.String("npm run build"),
/// 				DestinationDir:    pulumi.String("build"),
/// 				RootDir:           pulumi.String(""),
/// 				WebAnalyticsTag:   pulumi.String("cee1c73f6e4743d0b5e6bb1a0bcaabcc"),
/// 				WebAnalyticsToken: pulumi.String("021e1057c18547eca7b79f2516f06o7x"),
/// 			},
/// 			Name:             pulumi.String("this-is-my-project-01"),
/// 			ProductionBranch: pulumi.String("main"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// Pages project managing project source
/// 		_, err = cloudflare.NewPagesProject(ctx, "sourceConfig", &cloudflare.PagesProjectArgs{
/// 			AccountId:        pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:             pulumi.String("this-is-my-project-01"),
/// 			ProductionBranch: pulumi.String("main"),
/// 			Source: &cloudflare.PagesProjectSourceArgs{
/// 				Config: &cloudflare.PagesProjectSourceConfigArgs{
/// 					DeploymentsEnabled: pulumi.Bool(true),
/// 					Owner:              pulumi.String("cloudflare"),
/// 					PrCommentsEnabled:  pulumi.Bool(true),
/// 					PreviewBranchExcludes: pulumi.StringArray{
/// 						pulumi.String("main"),
/// 						pulumi.String("prod"),
/// 					},
/// 					PreviewBranchIncludes: pulumi.StringArray{
/// 						pulumi.String("dev"),
/// 						pulumi.String("preview"),
/// 					},
/// 					PreviewDeploymentSetting:    pulumi.String("custom"),
/// 					ProductionBranch:            pulumi.String("main"),
/// 					ProductionDeploymentEnabled: pulumi.Bool(true),
/// 					RepoName:                    pulumi.String("ninjakittens"),
/// 				},
/// 				Type: pulumi.String("github"),
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// Pages project managing all configs
/// 		_, err = cloudflare.NewPagesProject(ctx, "deploymentConfigs", &cloudflare.PagesProjectArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			BuildConfig: &cloudflare.PagesProjectBuildConfigArgs{
/// 				BuildCommand:      pulumi.String("npm run build"),
/// 				DestinationDir:    pulumi.String("build"),
/// 				RootDir:           pulumi.String(""),
/// 				WebAnalyticsTag:   pulumi.String("cee1c73f6e4743d0b5e6bb1a0bcaabcc"),
/// 				WebAnalyticsToken: pulumi.String("021e1057c18547eca7b79f2516f06o7x"),
/// 			},
/// 			DeploymentConfigs: &cloudflare.PagesProjectDeploymentConfigsArgs{
/// 				Preview: &cloudflare.PagesProjectDeploymentConfigsPreviewArgs{
/// 					CompatibilityDate: pulumi.String("2022-08-15"),
/// 					CompatibilityFlags: pulumi.StringArray{
/// 						pulumi.String("nodejs_compat"),
/// 					},
/// 					D1Databases: pulumi.Map{
/// 						"D1BINDING": pulumi.Any("445e2955-951a-4358-a35b-a4d0c813f63"),
/// 					},
/// 					DurableObjectNamespaces: pulumi.Map{
/// 						"DOBINDING": pulumi.Any("5eb63bbbe01eeed093cb22bb8f5acdc3"),
/// 					},
/// 					EnvironmentVariables: pulumi.Map{
/// 						"ENVIRONMENT": pulumi.Any("preview"),
/// 					},
/// 					KvNamespaces: pulumi.Map{
/// 						"KVBINDING": pulumi.Any("5eb63bbbe01eeed093cb22bb8f5acdc3"),
/// 					},
/// 					R2Buckets: pulumi.Map{
/// 						"R2BINDING": pulumi.Any("some-bucket"),
/// 					},
/// 					Secrets: pulumi.Map{
/// 						"TURNSTILESECRET": pulumi.Any("1x0000000000000000000000000000000AA"),
/// 					},
/// 				},
/// 				Production: &cloudflare.PagesProjectDeploymentConfigsProductionArgs{
/// 					CompatibilityDate: pulumi.String("2022-08-16"),
/// 					CompatibilityFlags: pulumi.StringArray{
/// 						pulumi.String("nodejs_compat"),
/// 						pulumi.String("streams_enable_constructors"),
/// 					},
/// 					D1Databases: pulumi.Map{
/// 						"D1BINDING1": pulumi.Any("445e2955-951a-4358-a35b-a4d0c813f63"),
/// 						"D1BINDING2": pulumi.Any("a399414b-c697-409a-a688-377db6433cd9"),
/// 					},
/// 					DurableObjectNamespaces: pulumi.Map{
/// 						"DOBINDING1": pulumi.Any("5eb63bbbe01eeed093cb22bb8f5acdc3"),
/// 						"DOBINDING2": pulumi.Any("3cdca5f8bb22bc390deee10ebbb36be5"),
/// 					},
/// 					EnvironmentVariables: pulumi.Map{
/// 						"ENVIRONMENT": pulumi.Any("production"),
/// 						"OTHERVALUE":  pulumi.Any("other value"),
/// 					},
/// 					KvNamespaces: pulumi.Map{
/// 						"KVBINDING1": pulumi.Any("5eb63bbbe01eeed093cb22bb8f5acdc3"),
/// 						"KVBINDING2": pulumi.Any("3cdca5f8bb22bc390deee10ebbb36be5"),
/// 					},
/// 					R2Buckets: pulumi.Map{
/// 						"R2BINDING1": pulumi.Any("some-bucket"),
/// 						"R2BINDING2": pulumi.Any("other-bucket"),
/// 					},
/// 					Secrets: pulumi.Map{
/// 						"TURNSTILEINVISSECRET": pulumi.Any("2x0000000000000000000000000000000AA"),
/// 						"TURNSTILESECRET":      pulumi.Any("1x0000000000000000000000000000000AA"),
/// 					},
/// 				},
/// 			},
/// 			Name:             pulumi.String("this-is-my-project-01"),
/// 			ProductionBranch: pulumi.String("main"),
/// 			Source: &cloudflare.PagesProjectSourceArgs{
/// 				Config: &cloudflare.PagesProjectSourceConfigArgs{
/// 					DeploymentsEnabled: pulumi.Bool(true),
/// 					Owner:              pulumi.String("cloudflare"),
/// 					PrCommentsEnabled:  pulumi.Bool(true),
/// 					PreviewBranchExcludes: pulumi.StringArray{
/// 						pulumi.String("main"),
/// 						pulumi.String("prod"),
/// 					},
/// 					PreviewBranchIncludes: pulumi.StringArray{
/// 						pulumi.String("dev"),
/// 						pulumi.String("preview"),
/// 					},
/// 					PreviewDeploymentSetting:    pulumi.String("custom"),
/// 					ProductionBranch:            pulumi.String("main"),
/// 					ProductionDeploymentEnabled: pulumi.Bool(true),
/// 					RepoName:                    pulumi.String("ninjakittens"),
/// 				},
/// 				Type: pulumi.String("github"),
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.PagesProject;
/// import com.pulumi.cloudflare.PagesProjectArgs;
/// import com.pulumi.cloudflare.inputs.PagesProjectBuildConfigArgs;
/// import com.pulumi.cloudflare.inputs.PagesProjectSourceArgs;
/// import com.pulumi.cloudflare.inputs.PagesProjectSourceConfigArgs;
/// import com.pulumi.cloudflare.inputs.PagesProjectDeploymentConfigsArgs;
/// import com.pulumi.cloudflare.inputs.PagesProjectDeploymentConfigsPreviewArgs;
/// import com.pulumi.cloudflare.inputs.PagesProjectDeploymentConfigsProductionArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // Direct upload Pages project
///         var basicProject = new PagesProject("basicProject", PagesProjectArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("this-is-my-project-01")
///             .productionBranch("main")
///             .build());
///
///         // Pages project with managing build config
///         var buildConfig = new PagesProject("buildConfig", PagesProjectArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .buildConfig(PagesProjectBuildConfigArgs.builder()
///                 .buildCommand("npm run build")
///                 .destinationDir("build")
///                 .rootDir("")
///                 .webAnalyticsTag("cee1c73f6e4743d0b5e6bb1a0bcaabcc")
///                 .webAnalyticsToken("021e1057c18547eca7b79f2516f06o7x")
///                 .build())
///             .name("this-is-my-project-01")
///             .productionBranch("main")
///             .build());
///
///         // Pages project managing project source
///         var sourceConfig = new PagesProject("sourceConfig", PagesProjectArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("this-is-my-project-01")
///             .productionBranch("main")
///             .source(PagesProjectSourceArgs.builder()
///                 .config(PagesProjectSourceConfigArgs.builder()
///                     .deploymentsEnabled(true)
///                     .owner("cloudflare")
///                     .prCommentsEnabled(true)
///                     .previewBranchExcludes(                    
///                         "main",
///                         "prod")
///                     .previewBranchIncludes(                    
///                         "dev",
///                         "preview")
///                     .previewDeploymentSetting("custom")
///                     .productionBranch("main")
///                     .productionDeploymentEnabled(true)
///                     .repoName("ninjakittens")
///                     .build())
///                 .type("github")
///                 .build())
///             .build());
///
///         // Pages project managing all configs
///         var deploymentConfigs = new PagesProject("deploymentConfigs", PagesProjectArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .buildConfig(PagesProjectBuildConfigArgs.builder()
///                 .buildCommand("npm run build")
///                 .destinationDir("build")
///                 .rootDir("")
///                 .webAnalyticsTag("cee1c73f6e4743d0b5e6bb1a0bcaabcc")
///                 .webAnalyticsToken("021e1057c18547eca7b79f2516f06o7x")
///                 .build())
///             .deploymentConfigs(PagesProjectDeploymentConfigsArgs.builder()
///                 .preview(PagesProjectDeploymentConfigsPreviewArgs.builder()
///                     .compatibilityDate("2022-08-15")
///                     .compatibilityFlags("nodejs_compat")
///                     .d1Databases(Map.of("D1BINDING", "445e2955-951a-4358-a35b-a4d0c813f63"))
///                     .durableObjectNamespaces(Map.of("DOBINDING", "5eb63bbbe01eeed093cb22bb8f5acdc3"))
///                     .environmentVariables(Map.of("ENVIRONMENT", "preview"))
///                     .kvNamespaces(Map.of("KVBINDING", "5eb63bbbe01eeed093cb22bb8f5acdc3"))
///                     .r2Buckets(Map.of("R2BINDING", "some-bucket"))
///                     .secrets(Map.of("TURNSTILESECRET", "1x0000000000000000000000000000000AA"))
///                     .build())
///                 .production(PagesProjectDeploymentConfigsProductionArgs.builder()
///                     .compatibilityDate("2022-08-16")
///                     .compatibilityFlags(                    
///                         "nodejs_compat",
///                         "streams_enable_constructors")
///                     .d1Databases(Map.ofEntries(
///                         Map.entry("D1BINDING1", "445e2955-951a-4358-a35b-a4d0c813f63"),
///                         Map.entry("D1BINDING2", "a399414b-c697-409a-a688-377db6433cd9")
///                     ))
///                     .durableObjectNamespaces(Map.ofEntries(
///                         Map.entry("DOBINDING1", "5eb63bbbe01eeed093cb22bb8f5acdc3"),
///                         Map.entry("DOBINDING2", "3cdca5f8bb22bc390deee10ebbb36be5")
///                     ))
///                     .environmentVariables(Map.ofEntries(
///                         Map.entry("ENVIRONMENT", "production"),
///                         Map.entry("OTHERVALUE", "other value")
///                     ))
///                     .kvNamespaces(Map.ofEntries(
///                         Map.entry("KVBINDING1", "5eb63bbbe01eeed093cb22bb8f5acdc3"),
///                         Map.entry("KVBINDING2", "3cdca5f8bb22bc390deee10ebbb36be5")
///                     ))
///                     .r2Buckets(Map.ofEntries(
///                         Map.entry("R2BINDING1", "some-bucket"),
///                         Map.entry("R2BINDING2", "other-bucket")
///                     ))
///                     .secrets(Map.ofEntries(
///                         Map.entry("TURNSTILEINVISSECRET", "2x0000000000000000000000000000000AA"),
///                         Map.entry("TURNSTILESECRET", "1x0000000000000000000000000000000AA")
///                     ))
///                     .build())
///                 .build())
///             .name("this-is-my-project-01")
///             .productionBranch("main")
///             .source(PagesProjectSourceArgs.builder()
///                 .config(PagesProjectSourceConfigArgs.builder()
///                     .deploymentsEnabled(true)
///                     .owner("cloudflare")
///                     .prCommentsEnabled(true)
///                     .previewBranchExcludes(                    
///                         "main",
///                         "prod")
///                     .previewBranchIncludes(                    
///                         "dev",
///                         "preview")
///                     .previewDeploymentSetting("custom")
///                     .productionBranch("main")
///                     .productionDeploymentEnabled(true)
///                     .repoName("ninjakittens")
///                     .build())
///                 .type("github")
///                 .build())
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # Direct upload Pages project
///   basicProject:
///     type: cloudflare:PagesProject
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       name: this-is-my-project-01
///       productionBranch: main
///   # Pages project with managing build config
///   buildConfig:
///     type: cloudflare:PagesProject
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       buildConfig:
///         buildCommand: npm run build
///         destinationDir: build
///         rootDir:
///         webAnalyticsTag: cee1c73f6e4743d0b5e6bb1a0bcaabcc
///         webAnalyticsToken: 021e1057c18547eca7b79f2516f06o7x
///       name: this-is-my-project-01
///       productionBranch: main
///   # Pages project managing project source
///   sourceConfig:
///     type: cloudflare:PagesProject
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       name: this-is-my-project-01
///       productionBranch: main
///       source:
///         config:
///           deploymentsEnabled: true
///           owner: cloudflare
///           prCommentsEnabled: true
///           previewBranchExcludes:
///             - main
///             - prod
///           previewBranchIncludes:
///             - dev
///             - preview
///           previewDeploymentSetting: custom
///           productionBranch: main
///           productionDeploymentEnabled: true
///           repoName: ninjakittens
///         type: github
///   # Pages project managing all configs
///   deploymentConfigs:
///     type: cloudflare:PagesProject
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       buildConfig:
///         buildCommand: npm run build
///         destinationDir: build
///         rootDir:
///         webAnalyticsTag: cee1c73f6e4743d0b5e6bb1a0bcaabcc
///         webAnalyticsToken: 021e1057c18547eca7b79f2516f06o7x
///       deploymentConfigs:
///         preview:
///           compatibilityDate: 2022-08-15
///           compatibilityFlags:
///             - nodejs_compat
///           d1Databases:
///             D1BINDING: 445e2955-951a-4358-a35b-a4d0c813f63
///           durableObjectNamespaces:
///             DOBINDING: 5eb63bbbe01eeed093cb22bb8f5acdc3
///           environmentVariables:
///             ENVIRONMENT: preview
///           kvNamespaces:
///             KVBINDING: 5eb63bbbe01eeed093cb22bb8f5acdc3
///           r2Buckets:
///             R2BINDING: some-bucket
///           secrets:
///             TURNSTILESECRET: 1x0000000000000000000000000000000AA
///         production:
///           compatibilityDate: 2022-08-16
///           compatibilityFlags:
///             - nodejs_compat
///             - streams_enable_constructors
///           d1Databases:
///             D1BINDING1: 445e2955-951a-4358-a35b-a4d0c813f63
///             D1BINDING2: a399414b-c697-409a-a688-377db6433cd9
///           durableObjectNamespaces:
///             DOBINDING1: 5eb63bbbe01eeed093cb22bb8f5acdc3
///             DOBINDING2: 3cdca5f8bb22bc390deee10ebbb36be5
///           environmentVariables:
///             ENVIRONMENT: production
///             OTHERVALUE: other value
///           kvNamespaces:
///             KVBINDING1: 5eb63bbbe01eeed093cb22bb8f5acdc3
///             KVBINDING2: 3cdca5f8bb22bc390deee10ebbb36be5
///           r2Buckets:
///             R2BINDING1: some-bucket
///             R2BINDING2: other-bucket
///           secrets:
///             TURNSTILEINVISSECRET: 2x0000000000000000000000000000000AA
///             TURNSTILESECRET: 1x0000000000000000000000000000000AA
///       name: this-is-my-project-01
///       productionBranch: main
///       source:
///         config:
///           deploymentsEnabled: true
///           owner: cloudflare
///           prCommentsEnabled: true
///           previewBranchExcludes:
///             - main
///             - prod
///           previewBranchIncludes:
///             - dev
///             - preview
///           previewDeploymentSetting: custom
///           productionBranch: main
///           productionDeploymentEnabled: true
///           repoName: ninjakittens
///         type: github
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// !> It is not possible to import a pages project with secret environment variables. If you have a secret environment variable, you must remove it from your project before importing it.
///
/// ```sh
/// $ pulumi import cloudflare:index/pagesProject:PagesProject example <account_id>/<project_name>
/// ```
///
pub mod pages_project {

    pub struct PagesProjectArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Configuration for the project build process. Read more about the build configuration in the [developer documentation](https://developers.cloudflare.com/pages/platform/build-configuration).
        pub build_config: pulumi_wasm_rust::Output<Option<crate::types::PagesProjectBuildConfig>>,
        /// Configuration for deployments in a project.
        pub deployment_configs:
            pulumi_wasm_rust::Output<Option<crate::types::PagesProjectDeploymentConfigs>>,
        /// The global variable for the binding in your Worker code.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Project production branch name.
        pub production_branch: pulumi_wasm_rust::Output<String>,
        /// Configuration for the project source. Read more about the source configuration in the [developer documentation](https://developers.cloudflare.com/pages/platform/branch-build-controls/).
        pub source: pulumi_wasm_rust::Output<Option<crate::types::PagesProjectSource>>,
    }

    pub struct PagesProjectResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Configuration for the project build process. Read more about the build configuration in the [developer documentation](https://developers.cloudflare.com/pages/platform/build-configuration).
        pub build_config: pulumi_wasm_rust::Output<Option<crate::types::PagesProjectBuildConfig>>,
        /// When the project was created.
        pub created_on: pulumi_wasm_rust::Output<String>,
        /// Configuration for deployments in a project.
        pub deployment_configs:
            pulumi_wasm_rust::Output<crate::types::PagesProjectDeploymentConfigs>,
        /// A list of associated custom domains for the project.
        pub domains: pulumi_wasm_rust::Output<Vec<String>>,
        /// The global variable for the binding in your Worker code.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Project production branch name.
        pub production_branch: pulumi_wasm_rust::Output<String>,
        /// Configuration for the project source. Read more about the source configuration in the [developer documentation](https://developers.cloudflare.com/pages/platform/branch-build-controls/).
        pub source: pulumi_wasm_rust::Output<Option<crate::types::PagesProjectSource>>,
        /// The Cloudflare subdomain associated with the project.
        pub subdomain: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn pages_project(name: &str, args: PagesProjectArgs) -> PagesProjectResult {
        let result = crate::bindings::pulumi::cloudflare::pages_project::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::pages_project::Args {
                account_id: args.account_id.get_inner(),
                build_config: args.build_config.get_inner(),
                deployment_configs: args.deployment_configs.get_inner(),
                name: args.name.get_inner(),
                production_branch: args.production_branch.get_inner(),
                source: args.source.get_inner(),
            },
        );

        PagesProjectResult {
            account_id: crate::into_domain(result.account_id),
            build_config: crate::into_domain(result.build_config),
            created_on: crate::into_domain(result.created_on),
            deployment_configs: crate::into_domain(result.deployment_configs),
            domains: crate::into_domain(result.domains),
            name: crate::into_domain(result.name),
            production_branch: crate::into_domain(result.production_branch),
            source: crate::into_domain(result.source),
            subdomain: crate::into_domain(result.subdomain),
        }
    }
}

/// Provides the ability to manage Cloudflare Workers Queue features.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.Queue("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "my-queue",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.Queue("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="my-queue")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.Queue("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "my-queue",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewQueue(ctx, "example", &cloudflare.QueueArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:      pulumi.String("my-queue"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.Queue;
/// import com.pulumi.cloudflare.QueueArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new Queue("example", QueueArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("my-queue")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:Queue
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       name: my-queue
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/queue:Queue example <account_id>/<queue_id>
/// ```
///
pub mod queue {

    pub struct QueueArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the queue.
        pub name: pulumi_wasm_rust::Output<String>,
    }

    pub struct QueueResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the queue.
        pub name: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn queue(name: &str, args: QueueArgs) -> QueueResult {
        let result = crate::bindings::pulumi::cloudflare::queue::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::queue::Args {
                account_id: args.account_id.get_inner(),
                name: args.name.get_inner(),
            },
        );

        QueueResult {
            account_id: crate::into_domain(result.account_id),
            name: crate::into_domain(result.name),
        }
    }
}

/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.R2Bucket("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     location: "enam",
///     name: "terraform-bucket",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.R2Bucket("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     location="enam",
///     name="terraform-bucket")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.R2Bucket("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Location = "enam",
///         Name = "terraform-bucket",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewR2Bucket(ctx, "example", &cloudflare.R2BucketArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Location:  pulumi.String("enam"),
/// 			Name:      pulumi.String("terraform-bucket"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.R2Bucket;
/// import com.pulumi.cloudflare.R2BucketArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new R2Bucket("example", R2BucketArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .location("enam")
///             .name("terraform-bucket")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:R2Bucket
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       location: enam
///       name: terraform-bucket
/// ```
/// <!--End PulumiCodeChooser -->
///
/// > Available location values can be found in the [R2 documentation](https://developers.cloudflare.com/r2/reference/data-location/#available-hints).
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/r2Bucket:R2Bucket default <account id>/<bucket name>
/// ```
///
pub mod r2_bucket {

    pub struct R2BucketArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The location hint of the R2 bucket.
        pub location: pulumi_wasm_rust::Output<Option<String>>,
        /// The name of the R2 bucket.
        pub name: pulumi_wasm_rust::Output<String>,
    }

    pub struct R2BucketResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The location hint of the R2 bucket.
        pub location: pulumi_wasm_rust::Output<String>,
        /// The name of the R2 bucket.
        pub name: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn r_2_bucket(name: &str, args: R2BucketArgs) -> R2BucketResult {
        let result = crate::bindings::pulumi::cloudflare::r2_bucket::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::r2_bucket::Args {
                account_id: args.account_id.get_inner(),
                location: args.location.get_inner(),
                name: args.name.get_inner(),
            },
        );

        R2BucketResult {
            account_id: crate::into_domain(result.account_id),
            location: crate::into_domain(result.location),
            name: crate::into_domain(result.name),
        }
    }
}

/// Provides a Cloudflare rate limit resource for a given zone. This can
/// be used to limit the traffic you receive zone-wide, or matching more
/// specific types of requests/responses.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.RateLimit("example", {
///     action: {
///         mode: "simulate",
///         response: {
///             body: "custom response body",
///             contentType: "text/plain",
///         },
///         timeout: 43200,
///     },
///     bypassUrlPatterns: [
///         "example.com/bypass1",
///         "example.com/bypass2",
///     ],
///     correlate: {
///         by: "nat",
///     },
///     description: "example rate limit for a zone",
///     disabled: false,
///     match: {
///         request: {
///             methods: [
///                 "GET",
///                 "POST",
///                 "PUT",
///                 "DELETE",
///                 "PATCH",
///                 "HEAD",
///             ],
///             schemes: [
///                 "HTTP",
///                 "HTTPS",
///             ],
///             urlPattern: `${_var.cloudflare_zone}/*`,
///         },
///         response: {
///             headers: [
///                 {
///                     name: "Host",
///                     op: "eq",
///                     value: "localhost",
///                 },
///                 {
///                     name: "X-Example",
///                     op: "ne",
///                     value: "my-example",
///                 },
///             ],
///             originTraffic: false,
///             statuses: [
///                 200,
///                 201,
///                 202,
///                 301,
///                 429,
///             ],
///         },
///     },
///     period: 2,
///     threshold: 2000,
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.RateLimit("example",
///     action=cloudflare.RateLimitActionArgs(
///         mode="simulate",
///         response=cloudflare.RateLimitActionResponseArgs(
///             body="custom response body",
///             content_type="text/plain",
///         ),
///         timeout=43200,
///     ),
///     bypass_url_patterns=[
///         "example.com/bypass1",
///         "example.com/bypass2",
///     ],
///     correlate=cloudflare.RateLimitCorrelateArgs(
///         by="nat",
///     ),
///     description="example rate limit for a zone",
///     disabled=False,
///     match=cloudflare.RateLimitMatchArgs(
///         request=cloudflare.RateLimitMatchRequestArgs(
///             methods=[
///                 "GET",
///                 "POST",
///                 "PUT",
///                 "DELETE",
///                 "PATCH",
///                 "HEAD",
///             ],
///             schemes=[
///                 "HTTP",
///                 "HTTPS",
///             ],
///             url_pattern=f"{var['cloudflare_zone']}/*",
///         ),
///         response=cloudflare.RateLimitMatchResponseArgs(
///             headers=[
///                 {
///                     "name": "Host",
///                     "op": "eq",
///                     "value": "localhost",
///                 },
///                 {
///                     "name": "X-Example",
///                     "op": "ne",
///                     "value": "my-example",
///                 },
///             ],
///             origin_traffic=False,
///             statuses=[
///                 200,
///                 201,
///                 202,
///                 301,
///                 429,
///             ],
///         ),
///     ),
///     period=2,
///     threshold=2000,
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.RateLimit("example", new()
///     {
///         Action = new Cloudflare.Inputs.RateLimitActionArgs
///         {
///             Mode = "simulate",
///             Response = new Cloudflare.Inputs.RateLimitActionResponseArgs
///             {
///                 Body = "custom response body",
///                 ContentType = "text/plain",
///             },
///             Timeout = 43200,
///         },
///         BypassUrlPatterns = new[]
///         {
///             "example.com/bypass1",
///             "example.com/bypass2",
///         },
///         Correlate = new Cloudflare.Inputs.RateLimitCorrelateArgs
///         {
///             By = "nat",
///         },
///         Description = "example rate limit for a zone",
///         Disabled = false,
///         Match = new Cloudflare.Inputs.RateLimitMatchArgs
///         {
///             Request = new Cloudflare.Inputs.RateLimitMatchRequestArgs
///             {
///                 Methods = new[]
///                 {
///                     "GET",
///                     "POST",
///                     "PUT",
///                     "DELETE",
///                     "PATCH",
///                     "HEAD",
///                 },
///                 Schemes = new[]
///                 {
///                     "HTTP",
///                     "HTTPS",
///                 },
///                 UrlPattern = $"{@var.Cloudflare_zone}/*",
///             },
///             Response = new Cloudflare.Inputs.RateLimitMatchResponseArgs
///             {
///                 Headers = new[]
///                 {
///                     
///                     {
///                         { "name", "Host" },
///                         { "op", "eq" },
///                         { "value", "localhost" },
///                     },
///                     
///                     {
///                         { "name", "X-Example" },
///                         { "op", "ne" },
///                         { "value", "my-example" },
///                     },
///                 },
///                 OriginTraffic = false,
///                 Statuses = new[]
///                 {
///                     200,
///                     201,
///                     202,
///                     301,
///                     429,
///                 },
///             },
///         },
///         Period = 2,
///         Threshold = 2000,
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"fmt"
///
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewRateLimit(ctx, "example", &cloudflare.RateLimitArgs{
/// 			Action: &cloudflare.RateLimitActionArgs{
/// 				Mode: pulumi.String("simulate"),
/// 				Response: &cloudflare.RateLimitActionResponseArgs{
/// 					Body:        pulumi.String("custom response body"),
/// 					ContentType: pulumi.String("text/plain"),
/// 				},
/// 				Timeout: pulumi.Int(43200),
/// 			},
/// 			BypassUrlPatterns: pulumi.StringArray{
/// 				pulumi.String("example.com/bypass1"),
/// 				pulumi.String("example.com/bypass2"),
/// 			},
/// 			Correlate: &cloudflare.RateLimitCorrelateArgs{
/// 				By: pulumi.String("nat"),
/// 			},
/// 			Description: pulumi.String("example rate limit for a zone"),
/// 			Disabled:    pulumi.Bool(false),
/// 			Match: &cloudflare.RateLimitMatchArgs{
/// 				Request: &cloudflare.RateLimitMatchRequestArgs{
/// 					Methods: pulumi.StringArray{
/// 						pulumi.String("GET"),
/// 						pulumi.String("POST"),
/// 						pulumi.String("PUT"),
/// 						pulumi.String("DELETE"),
/// 						pulumi.String("PATCH"),
/// 						pulumi.String("HEAD"),
/// 					},
/// 					Schemes: pulumi.StringArray{
/// 						pulumi.String("HTTP"),
/// 						pulumi.String("HTTPS"),
/// 					},
/// 					UrlPattern: pulumi.String(fmt.Sprintf("%v/*", _var.Cloudflare_zone)),
/// 				},
/// 				Response: &cloudflare.RateLimitMatchResponseArgs{
/// 					Headers: pulumi.StringMapArray{
/// 						pulumi.StringMap{
/// 							"name":  pulumi.String("Host"),
/// 							"op":    pulumi.String("eq"),
/// 							"value": pulumi.String("localhost"),
/// 						},
/// 						pulumi.StringMap{
/// 							"name":  pulumi.String("X-Example"),
/// 							"op":    pulumi.String("ne"),
/// 							"value": pulumi.String("my-example"),
/// 						},
/// 					},
/// 					OriginTraffic: pulumi.Bool(false),
/// 					Statuses: pulumi.IntArray{
/// 						pulumi.Int(200),
/// 						pulumi.Int(201),
/// 						pulumi.Int(202),
/// 						pulumi.Int(301),
/// 						pulumi.Int(429),
/// 					},
/// 				},
/// 			},
/// 			Period:    pulumi.Int(2),
/// 			Threshold: pulumi.Int(2000),
/// 			ZoneId:    pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.RateLimit;
/// import com.pulumi.cloudflare.RateLimitArgs;
/// import com.pulumi.cloudflare.inputs.RateLimitActionArgs;
/// import com.pulumi.cloudflare.inputs.RateLimitActionResponseArgs;
/// import com.pulumi.cloudflare.inputs.RateLimitCorrelateArgs;
/// import com.pulumi.cloudflare.inputs.RateLimitMatchArgs;
/// import com.pulumi.cloudflare.inputs.RateLimitMatchRequestArgs;
/// import com.pulumi.cloudflare.inputs.RateLimitMatchResponseArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new RateLimit("example", RateLimitArgs.builder()        
///             .action(RateLimitActionArgs.builder()
///                 .mode("simulate")
///                 .response(RateLimitActionResponseArgs.builder()
///                     .body("custom response body")
///                     .contentType("text/plain")
///                     .build())
///                 .timeout(43200)
///                 .build())
///             .bypassUrlPatterns(            
///                 "example.com/bypass1",
///                 "example.com/bypass2")
///             .correlate(RateLimitCorrelateArgs.builder()
///                 .by("nat")
///                 .build())
///             .description("example rate limit for a zone")
///             .disabled(false)
///             .match(RateLimitMatchArgs.builder()
///                 .request(RateLimitMatchRequestArgs.builder()
///                     .methods(                    
///                         "GET",
///                         "POST",
///                         "PUT",
///                         "DELETE",
///                         "PATCH",
///                         "HEAD")
///                     .schemes(                    
///                         "HTTP",
///                         "HTTPS")
///                     .urlPattern(String.format("%s/*", var_.cloudflare_zone()))
///                     .build())
///                 .response(RateLimitMatchResponseArgs.builder()
///                     .headers(                    
///                         Map.ofEntries(
///                             Map.entry("name", "Host"),
///                             Map.entry("op", "eq"),
///                             Map.entry("value", "localhost")
///                         ),
///                         Map.ofEntries(
///                             Map.entry("name", "X-Example"),
///                             Map.entry("op", "ne"),
///                             Map.entry("value", "my-example")
///                         ))
///                     .originTraffic(false)
///                     .statuses(                    
///                         200,
///                         201,
///                         202,
///                         301,
///                         429)
///                     .build())
///                 .build())
///             .period(2)
///             .threshold(2000)
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:RateLimit
///     properties:
///       action:
///         mode: simulate
///         response:
///           body: custom response body
///           contentType: text/plain
///         timeout: 43200
///       bypassUrlPatterns:
///         - example.com/bypass1
///         - example.com/bypass2
///       correlate:
///         by: nat
///       description: example rate limit for a zone
///       disabled: false
///       match:
///         request:
///           methods:
///             - GET
///             - POST
///             - PUT
///             - DELETE
///             - PATCH
///             - HEAD
///           schemes:
///             - HTTP
///             - HTTPS
///           urlPattern: ${var.cloudflare_zone}/*
///         response:
///           headers:
///             - name: Host
///               op: eq
///               value: localhost
///             - name: X-Example
///               op: ne
///               value: my-example
///           originTraffic: false
///           statuses:
///             - 200
///             - 201
///             - 202
///             - 301
///             - 429
///       period: 2
///       threshold: 2000
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/rateLimit:RateLimit example <zone_id>/<rate_limit_id>
/// ```
///
pub mod rate_limit {

    pub struct RateLimitArgs {
        /// The action to be performed when the threshold of matched traffic within the period defined is exceeded.
        pub action: pulumi_wasm_rust::Output<crate::types::RateLimitAction>,
        pub bypass_url_patterns: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Determines how rate limiting is applied. By default if not specified, rate limiting applies to the clients IP address.
        pub correlate: pulumi_wasm_rust::Output<Option<crate::types::RateLimitCorrelate>>,
        /// A note that you can use to describe the reason for a rate limit. This value is sanitized and all tags are removed.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether this ratelimit is currently disabled. Defaults to `false`.
        pub disabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Determines which traffic the rate limit counts towards the threshold. By default matches all traffic in the zone.
        pub match_: pulumi_wasm_rust::Output<Option<crate::types::RateLimitMatch>>,
        /// The time in seconds to count matching traffic. If the count exceeds threshold within this period the action will be performed.
        pub period: pulumi_wasm_rust::Output<i32>,
        /// The threshold that triggers the rate limit mitigations, combine with period.
        pub threshold: pulumi_wasm_rust::Output<i32>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct RateLimitResult {
        /// The action to be performed when the threshold of matched traffic within the period defined is exceeded.
        pub action: pulumi_wasm_rust::Output<crate::types::RateLimitAction>,
        pub bypass_url_patterns: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Determines how rate limiting is applied. By default if not specified, rate limiting applies to the clients IP address.
        pub correlate: pulumi_wasm_rust::Output<Option<crate::types::RateLimitCorrelate>>,
        /// A note that you can use to describe the reason for a rate limit. This value is sanitized and all tags are removed.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether this ratelimit is currently disabled. Defaults to `false`.
        pub disabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Determines which traffic the rate limit counts towards the threshold. By default matches all traffic in the zone.
        pub match_: pulumi_wasm_rust::Output<crate::types::RateLimitMatch>,
        /// The time in seconds to count matching traffic. If the count exceeds threshold within this period the action will be performed.
        pub period: pulumi_wasm_rust::Output<i32>,
        /// The threshold that triggers the rate limit mitigations, combine with period.
        pub threshold: pulumi_wasm_rust::Output<i32>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn rate_limit(name: &str, args: RateLimitArgs) -> RateLimitResult {
        let result = crate::bindings::pulumi::cloudflare::rate_limit::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::rate_limit::Args {
                action: args.action.get_inner(),
                bypass_url_patterns: args.bypass_url_patterns.get_inner(),
                correlate: args.correlate.get_inner(),
                description: args.description.get_inner(),
                disabled: args.disabled.get_inner(),
                match_: args.match_.get_inner(),
                period: args.period.get_inner(),
                threshold: args.threshold.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        RateLimitResult {
            action: crate::into_domain(result.action),
            bypass_url_patterns: crate::into_domain(result.bypass_url_patterns),
            correlate: crate::into_domain(result.correlate),
            description: crate::into_domain(result.description),
            disabled: crate::into_domain(result.disabled),
            match_: crate::into_domain(result.match_),
            period: crate::into_domain(result.period),
            threshold: crate::into_domain(result.threshold),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare record resource.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// // Add a record to the domain
/// const example = new cloudflare.Record("example", {
///     zoneId: _var.cloudflare_zone_id,
///     name: "example",
///     value: "192.0.2.1",
///     type: "A",
///     ttl: 3600,
/// });
/// // Add a record requiring a data map
/// const _sipTls = new cloudflare.Record("_sipTls", {
///     zoneId: _var.cloudflare_zone_id,
///     name: "_sip._tls",
///     type: "SRV",
///     data: {
///         service: "_sip",
///         proto: "_tls",
///         name: "example-srv",
///         priority: 0,
///         weight: 0,
///         port: 443,
///         target: "example.com",
///     },
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// # Add a record to the domain
/// example = cloudflare.Record("example",
///     zone_id=var["cloudflare_zone_id"],
///     name="example",
///     value="192.0.2.1",
///     type="A",
///     ttl=3600)
/// # Add a record requiring a data map
/// _sip_tls = cloudflare.Record("_sipTls",
///     zone_id=var["cloudflare_zone_id"],
///     name="_sip._tls",
///     type="SRV",
///     data=cloudflare.RecordDataArgs(
///         service="_sip",
///         proto="_tls",
///         name="example-srv",
///         priority=0,
///         weight=0,
///         port=443,
///         target="example.com",
///     ))
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     // Add a record to the domain
///     var example = new Cloudflare.Record("example", new()
///     {
///         ZoneId = @var.Cloudflare_zone_id,
///         Name = "example",
///         Value = "192.0.2.1",
///         Type = "A",
///         Ttl = 3600,
///     });
///
///     // Add a record requiring a data map
///     var _sipTls = new Cloudflare.Record("_sipTls", new()
///     {
///         ZoneId = @var.Cloudflare_zone_id,
///         Name = "_sip._tls",
///         Type = "SRV",
///         Data = new Cloudflare.Inputs.RecordDataArgs
///         {
///             Service = "_sip",
///             Proto = "_tls",
///             Name = "example-srv",
///             Priority = 0,
///             Weight = 0,
///             Port = 443,
///             Target = "example.com",
///         },
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// Add a record to the domain
/// 		_, err := cloudflare.NewRecord(ctx, "example", &cloudflare.RecordArgs{
/// 			ZoneId: pulumi.Any(_var.Cloudflare_zone_id),
/// 			Name:   pulumi.String("example"),
/// 			Value:  pulumi.String("192.0.2.1"),
/// 			Type:   pulumi.String("A"),
/// 			Ttl:    pulumi.Int(3600),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// Add a record requiring a data map
/// 		_, err = cloudflare.NewRecord(ctx, "_sipTls", &cloudflare.RecordArgs{
/// 			ZoneId: pulumi.Any(_var.Cloudflare_zone_id),
/// 			Name:   pulumi.String("_sip._tls"),
/// 			Type:   pulumi.String("SRV"),
/// 			Data: &cloudflare.RecordDataArgs{
/// 				Service:  pulumi.String("_sip"),
/// 				Proto:    pulumi.String("_tls"),
/// 				Name:     pulumi.String("example-srv"),
/// 				Priority: pulumi.Int(0),
/// 				Weight:   pulumi.Int(0),
/// 				Port:     pulumi.Int(443),
/// 				Target:   pulumi.String("example.com"),
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.Record;
/// import com.pulumi.cloudflare.RecordArgs;
/// import com.pulumi.cloudflare.inputs.RecordDataArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // Add a record to the domain
///         var example = new Record("example", RecordArgs.builder()        
///             .zoneId(var_.cloudflare_zone_id())
///             .name("example")
///             .value("192.0.2.1")
///             .type("A")
///             .ttl(3600)
///             .build());
///
///         // Add a record requiring a data map
///         var _sipTls = new Record("_sipTls", RecordArgs.builder()        
///             .zoneId(var_.cloudflare_zone_id())
///             .name("_sip._tls")
///             .type("SRV")
///             .data(RecordDataArgs.builder()
///                 .service("_sip")
///                 .proto("_tls")
///                 .name("example-srv")
///                 .priority(0)
///                 .weight(0)
///                 .port(443)
///                 .target("example.com")
///                 .build())
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # Add a record to the domain
///   example:
///     type: cloudflare:Record
///     properties:
///       zoneId: ${var.cloudflare_zone_id}
///       name: example
///       value: 192.0.2.1
///       type: A
///       ttl: 3600
///   # Add a record requiring a data map
///   _sipTls:
///     type: cloudflare:Record
///     properties:
///       zoneId: ${var.cloudflare_zone_id}
///       name: _sip._tls
///       type: SRV
///       data:
///         service: _sip
///         proto: _tls
///         name: example-srv
///         priority: 0
///         weight: 0
///         port: 443
///         target: example.com
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/record:Record example <zone_id>/<record_id>
/// ```
///
pub mod record {

    pub struct RecordArgs {
        /// Allow creation of this record in Terraform to overwrite an existing record, if any. This does not affect the ability to
        /// update the record in Terraform and does not prevent other resources within Terraform or manual changes outside Terraform
        /// from overwriting this record. **This configuration is not recommended for most environments**
        pub allow_overwrite: pulumi_wasm_rust::Output<Option<bool>>,
        /// Comments or notes about the DNS record. This field has no effect on DNS responses.
        pub comment: pulumi_wasm_rust::Output<Option<String>>,
        /// Map of attributes that constitute the record value. Conflicts with `value`.
        pub data: pulumi_wasm_rust::Output<Option<crate::types::RecordData>>,
        /// The name of the record.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The priority of the record.
        pub priority: pulumi_wasm_rust::Output<Option<i32>>,
        /// Whether the record gets Cloudflare's origin protection.
        pub proxied: pulumi_wasm_rust::Output<Option<bool>>,
        /// Custom tags for the DNS record.
        pub tags: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The TTL of the record.
        pub ttl: pulumi_wasm_rust::Output<Option<i32>>,
        /// The type of the record. Available values: `A`, `AAAA`, `CAA`, `CNAME`, `TXT`, `SRV`, `LOC`, `MX`, `NS`, `SPF`, `CERT`,
        /// `DNSKEY`, `DS`, `NAPTR`, `SMIMEA`, `SSHFP`, `TLSA`, `URI`, `PTR`, `HTTPS`, `SVCB`
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The value of the record.
        pub value: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct RecordResult {
        /// Allow creation of this record in Terraform to overwrite an existing record, if any. This does not affect the ability to
        /// update the record in Terraform and does not prevent other resources within Terraform or manual changes outside Terraform
        /// from overwriting this record. **This configuration is not recommended for most environments**
        pub allow_overwrite: pulumi_wasm_rust::Output<Option<bool>>,
        /// Comments or notes about the DNS record. This field has no effect on DNS responses.
        pub comment: pulumi_wasm_rust::Output<Option<String>>,
        /// The RFC3339 timestamp of when the record was created.
        pub created_on: pulumi_wasm_rust::Output<String>,
        /// Map of attributes that constitute the record value. Conflicts with `value`.
        pub data: pulumi_wasm_rust::Output<Option<crate::types::RecordData>>,
        /// The FQDN of the record.
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// A key-value map of string metadata Cloudflare associates with the record.
        pub metadata: pulumi_wasm_rust::Output<std::collections::HashMap<String, String>>,
        /// The RFC3339 timestamp of when the record was last modified.
        pub modified_on: pulumi_wasm_rust::Output<String>,
        /// The name of the record.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The priority of the record.
        pub priority: pulumi_wasm_rust::Output<Option<i32>>,
        /// Shows whether this record can be proxied.
        pub proxiable: pulumi_wasm_rust::Output<bool>,
        /// Whether the record gets Cloudflare's origin protection.
        pub proxied: pulumi_wasm_rust::Output<Option<bool>>,
        /// Custom tags for the DNS record.
        pub tags: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The TTL of the record.
        pub ttl: pulumi_wasm_rust::Output<i32>,
        /// The type of the record. Available values: `A`, `AAAA`, `CAA`, `CNAME`, `TXT`, `SRV`, `LOC`, `MX`, `NS`, `SPF`, `CERT`,
        /// `DNSKEY`, `DS`, `NAPTR`, `SMIMEA`, `SSHFP`, `TLSA`, `URI`, `PTR`, `HTTPS`, `SVCB`
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The value of the record.
        pub value: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn record(name: &str, args: RecordArgs) -> RecordResult {
        let result = crate::bindings::pulumi::cloudflare::record::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::record::Args {
                allow_overwrite: args.allow_overwrite.get_inner(),
                comment: args.comment.get_inner(),
                data: args.data.get_inner(),
                name: args.name.get_inner(),
                priority: args.priority.get_inner(),
                proxied: args.proxied.get_inner(),
                tags: args.tags.get_inner(),
                ttl: args.ttl.get_inner(),
                type_: args.type_.get_inner(),
                value: args.value.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        RecordResult {
            allow_overwrite: crate::into_domain(result.allow_overwrite),
            comment: crate::into_domain(result.comment),
            created_on: crate::into_domain(result.created_on),
            data: crate::into_domain(result.data),
            hostname: crate::into_domain(result.hostname),
            metadata: crate::into_domain(result.metadata),
            modified_on: crate::into_domain(result.modified_on),
            name: crate::into_domain(result.name),
            priority: crate::into_domain(result.priority),
            proxiable: crate::into_domain(result.proxiable),
            proxied: crate::into_domain(result.proxied),
            tags: crate::into_domain(result.tags),
            ttl: crate::into_domain(result.ttl),
            type_: crate::into_domain(result.type_),
            value: crate::into_domain(result.value),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Data Localization Suite Regional Hostname.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// // Regionalized hostname record resources are managed independently from the
/// // Regionalized Hostname resources.
/// const exampleRecord = new cloudflare.Record("exampleRecord", {
///     name: "example.com",
///     ttl: 3600,
///     type: "A",
///     value: "192.0.2.1",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// // The cloudflare_regional_hostname resource may exist with or without its
/// // corresponding record resource.
/// const exampleRegionalHostname = new cloudflare.RegionalHostname("exampleRegionalHostname", {
///     hostname: "example.com",
///     regionKey: "eu",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// # Regionalized hostname record resources are managed independently from the
/// # Regionalized Hostname resources.
/// example_record = cloudflare.Record("exampleRecord",
///     name="example.com",
///     ttl=3600,
///     type="A",
///     value="192.0.2.1",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// # The cloudflare_regional_hostname resource may exist with or without its
/// # corresponding record resource.
/// example_regional_hostname = cloudflare.RegionalHostname("exampleRegionalHostname",
///     hostname="example.com",
///     region_key="eu",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     // Regionalized hostname record resources are managed independently from the
///     // Regionalized Hostname resources.
///     var exampleRecord = new Cloudflare.Record("exampleRecord", new()
///     {
///         Name = "example.com",
///         Ttl = 3600,
///         Type = "A",
///         Value = "192.0.2.1",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
///     // The cloudflare_regional_hostname resource may exist with or without its
///     // corresponding record resource.
///     var exampleRegionalHostname = new Cloudflare.RegionalHostname("exampleRegionalHostname", new()
///     {
///         Hostname = "example.com",
///         RegionKey = "eu",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// Regionalized hostname record resources are managed independently from the
/// 		// Regionalized Hostname resources.
/// 		_, err := cloudflare.NewRecord(ctx, "exampleRecord", &cloudflare.RecordArgs{
/// 			Name:   pulumi.String("example.com"),
/// 			Ttl:    pulumi.Int(3600),
/// 			Type:   pulumi.String("A"),
/// 			Value:  pulumi.String("192.0.2.1"),
/// 			ZoneId: pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// The cloudflare_regional_hostname resource may exist with or without its
/// 		// corresponding record resource.
/// 		_, err = cloudflare.NewRegionalHostname(ctx, "exampleRegionalHostname", &cloudflare.RegionalHostnameArgs{
/// 			Hostname:  pulumi.String("example.com"),
/// 			RegionKey: pulumi.String("eu"),
/// 			ZoneId:    pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.Record;
/// import com.pulumi.cloudflare.RecordArgs;
/// import com.pulumi.cloudflare.RegionalHostname;
/// import com.pulumi.cloudflare.RegionalHostnameArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // Regionalized hostname record resources are managed independently from the
///         // Regionalized Hostname resources.
///         var exampleRecord = new Record("exampleRecord", RecordArgs.builder()        
///             .name("example.com")
///             .ttl(3600)
///             .type("A")
///             .value("192.0.2.1")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///         // The cloudflare_regional_hostname resource may exist with or without its
///         // corresponding record resource.
///         var exampleRegionalHostname = new RegionalHostname("exampleRegionalHostname", RegionalHostnameArgs.builder()        
///             .hostname("example.com")
///             .regionKey("eu")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # Regionalized hostname record resources are managed independently from the
///   # // Regionalized Hostname resources.
///   exampleRecord:
///     type: cloudflare:Record
///     properties:
///       name: example.com
///       ttl: 3600
///       type: A
///       value: 192.0.2.1
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///   # The cloudflare_regional_hostname resource may exist with or without its
///   # // corresponding record resource.
///   exampleRegionalHostname:
///     type: cloudflare:RegionalHostname
///     properties:
///       hostname: example.com
///       regionKey: eu
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
pub mod regional_hostname {

    pub struct RegionalHostnameArgs {
        /// The hostname to regionalize.
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// The region key. See [the full region list](https://developers.cloudflare.com/data-localization/regional-services/get-started/).
        pub region_key: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct RegionalHostnameResult {
        /// The RFC3339 timestamp of when the hostname was created.
        pub created_on: pulumi_wasm_rust::Output<String>,
        /// The hostname to regionalize.
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// The region key. See [the full region list](https://developers.cloudflare.com/data-localization/regional-services/get-started/).
        pub region_key: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn regional_hostname(name: &str, args: RegionalHostnameArgs) -> RegionalHostnameResult {
        let result = crate::bindings::pulumi::cloudflare::regional_hostname::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::regional_hostname::Args {
                hostname: args.hostname.get_inner(),
                region_key: args.region_key.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        RegionalHostnameResult {
            created_on: crate::into_domain(result.created_on),
            hostname: crate::into_domain(result.hostname),
            region_key: crate::into_domain(result.region_key),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Instructs Cloudflare to check a regional hub data center on the way to your upper tier.
/// This can help improve performance for smart and custom tiered cache topologies.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.RegionalTieredCache("example", {
///     value: "on",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.RegionalTieredCache("example",
///     value="on",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.RegionalTieredCache("example", new()
///     {
///         Value = "on",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewRegionalTieredCache(ctx, "example", &cloudflare.RegionalTieredCacheArgs{
/// 			Value:  pulumi.String("on"),
/// 			ZoneId: pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.RegionalTieredCache;
/// import com.pulumi.cloudflare.RegionalTieredCacheArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new RegionalTieredCache("example", RegionalTieredCacheArgs.builder()        
///             .value("on")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:RegionalTieredCache
///     properties:
///       value: on
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/regionalTieredCache:RegionalTieredCache example <zone_id>
/// ```
///
pub mod regional_tiered_cache {

    pub struct RegionalTieredCacheArgs {
        /// Value of the Regional Tiered Cache zone setting.
        pub value: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct RegionalTieredCacheResult {
        /// Value of the Regional Tiered Cache zone setting.
        pub value: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn regional_tiered_cache(
        name: &str,
        args: RegionalTieredCacheArgs,
    ) -> RegionalTieredCacheResult {
        let result = crate::bindings::pulumi::cloudflare::regional_tiered_cache::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::regional_tiered_cache::Args {
                value: args.value.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        RegionalTieredCacheResult {
            value: crate::into_domain(result.value),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// The [Cloudflare Ruleset Engine](https://developers.cloudflare.com/firewall/cf-rulesets)
/// allows you to create and deploy rules and rulesets.
///
/// The engine syntax, inspired by the Wireshark Display Filter language, is the
/// same syntax used in custom Firewall Rules. Cloudflare uses the Ruleset Engine
/// in different products, allowing you to configure several products using the same
/// basic syntax.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.Ruleset;
/// import com.pulumi.cloudflare.RulesetArgs;
/// import com.pulumi.cloudflare.inputs.RulesetRuleArgs;
/// import com.pulumi.cloudflare.inputs.RulesetRuleActionParametersArgs;
/// import com.pulumi.cloudflare.inputs.RulesetRuleActionParametersOverridesArgs;
/// import com.pulumi.cloudflare.inputs.RulesetRuleActionParametersUriArgs;
/// import com.pulumi.cloudflare.inputs.RulesetRuleActionParametersUriPathArgs;
/// import com.pulumi.cloudflare.inputs.RulesetRuleActionParametersUriQueryArgs;
/// import com.pulumi.cloudflare.inputs.RulesetRuleRatelimitArgs;
/// import com.pulumi.cloudflare.inputs.RulesetRuleActionParametersOriginArgs;
/// import com.pulumi.cloudflare.inputs.RulesetRuleActionParametersBrowserTtlArgs;
/// import com.pulumi.cloudflare.inputs.RulesetRuleActionParametersCacheKeyArgs;
/// import com.pulumi.cloudflare.inputs.RulesetRuleActionParametersCacheKeyCustomKeyArgs;
/// import com.pulumi.cloudflare.inputs.RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs;
/// import com.pulumi.cloudflare.inputs.RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs;
/// import com.pulumi.cloudflare.inputs.RulesetRuleActionParametersCacheKeyCustomKeyHostArgs;
/// import com.pulumi.cloudflare.inputs.RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs;
/// import com.pulumi.cloudflare.inputs.RulesetRuleActionParametersCacheKeyCustomKeyUserArgs;
/// import com.pulumi.cloudflare.inputs.RulesetRuleActionParametersEdgeTtlArgs;
/// import com.pulumi.cloudflare.inputs.RulesetRuleActionParametersServeStaleArgs;
/// import com.pulumi.cloudflare.inputs.RulesetRuleActionParametersFromListArgs;
/// import com.pulumi.cloudflare.inputs.RulesetRuleActionParametersFromValueArgs;
/// import com.pulumi.cloudflare.inputs.RulesetRuleActionParametersFromValueTargetUrlArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // Magic Transit
///         var magicTransitExample = new Ruleset("magicTransitExample", RulesetArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .description("example magic transit ruleset description")
///             .kind("root")
///             .name("account magic transit")
///             .phase("magic_transit")
///             .rules(RulesetRuleArgs.builder()
///                 .action("allow")
///                 .description("Allow TCP Ephemeral Ports")
///                 .expression("tcp.dstport in { 32768..65535 }")
///                 .build())
///             .build());
///
///         // Zone-level WAF Managed Ruleset
///         var zoneLevelManagedWaf = new Ruleset("zoneLevelManagedWaf", RulesetArgs.builder()        
///             .description("managed WAF ruleset description")
///             .kind("zone")
///             .name("managed WAF")
///             .phase("http_request_firewall_managed")
///             .rules(RulesetRuleArgs.builder()
///                 .action("execute")
///                 .actionParameters(RulesetRuleActionParametersArgs.builder()
///                     .id("efb7b8c949ac4650a09736fc376e9aee")
///                     .build())
///                 .description("Execute Cloudflare Managed Ruleset on my zone-level phase entry point ruleset")
///                 .enabled(true)
///                 .expression("(http.host eq \"example.host.com\")")
///                 .build())
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///         // Zone-level WAF with tag-based overrides
///         var zoneLevelManagedWafWithCategoryBasedOverrides = new Ruleset("zoneLevelManagedWafWithCategoryBasedOverrides", RulesetArgs.builder()        
///             .description("managed WAF with tag-based overrides ruleset description")
///             .kind("zone")
///             .name("managed WAF with tag-based overrides")
///             .phase("http_request_firewall_managed")
///             .rules(RulesetRuleArgs.builder()
///                 .action("execute")
///                 .actionParameters(RulesetRuleActionParametersArgs.builder()
///                     .id("efb7b8c949ac4650a09736fc376e9aee")
///                     .overrides(RulesetRuleActionParametersOverridesArgs.builder()
///                         .categories(                        
///                             RulesetRuleActionParametersOverridesCategoryArgs.builder()
///                                 .action("block")
///                                 .category("wordpress")
///                                 .enabled(true)
///                                 .build(),
///                             RulesetRuleActionParametersOverridesCategoryArgs.builder()
///                                 .action("block")
///                                 .category("joomla")
///                                 .enabled(true)
///                                 .build())
///                         .build())
///                     .build())
///                 .description("overrides to only enable wordpress rules to block")
///                 .enabled(false)
///                 .expression("(http.host eq \"example.host.com\")")
///                 .build())
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///         // Rewrite the URI path component to a static path
///         var transformUriRulePath = new Ruleset("transformUriRulePath", RulesetArgs.builder()        
///             .description("change the URI path to a new static path")
///             .kind("zone")
///             .name("transform rule for URI path")
///             .phase("http_request_transform")
///             .rules(RulesetRuleArgs.builder()
///                 .action("rewrite")
///                 .actionParameters(RulesetRuleActionParametersArgs.builder()
///                     .uri(RulesetRuleActionParametersUriArgs.builder()
///                         .path(RulesetRuleActionParametersUriPathArgs.builder()
///                             .value("/my-new-route")
///                             .build())
///                         .build())
///                     .build())
///                 .description("example URI path transform rule")
///                 .enabled(true)
///                 .expression("(http.host eq \"example.com\" and http.request.uri.path eq \"/old-path\")")
///                 .build())
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///         // Rewrite the URI query component to a static query
///         var transformUriRuleQuery = new Ruleset("transformUriRuleQuery", RulesetArgs.builder()        
///             .description("change the URI query to a new static query")
///             .kind("zone")
///             .name("transform rule for URI query parameter")
///             .phase("http_request_transform")
///             .rules(RulesetRuleArgs.builder()
///                 .action("rewrite")
///                 .actionParameters(RulesetRuleActionParametersArgs.builder()
///                     .uri(RulesetRuleActionParametersUriArgs.builder()
///                         .query(RulesetRuleActionParametersUriQueryArgs.builder()
///                             .value("old=new_again")
///                             .build())
///                         .build())
///                     .build())
///                 .description("URI transformation query example")
///                 .enabled(true)
///                 .expression("(http.host eq \"example.host.com\")")
///                 .build())
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///         // Rewrite HTTP headers to a modified values
///         var transformUriHttpHeaders = new Ruleset("transformUriHttpHeaders", RulesetArgs.builder()        
///             .description("modify HTTP headers before reaching origin")
///             .kind("zone")
///             .name("transform rule for HTTP headers")
///             .phase("http_request_late_transform")
///             .rules(RulesetRuleArgs.builder()
///                 .action("rewrite")
///                 .actionParameters(RulesetRuleActionParametersArgs.builder()
///                     .headers(                    
///                         RulesetRuleActionParametersHeaderArgs.builder()
///                             .name("example-http-header-1")
///                             .operation("set")
///                             .value("my-http-header-value-1")
///                             .build(),
///                         RulesetRuleActionParametersHeaderArgs.builder()
///                             .expression("cf.zone.name")
///                             .name("example-http-header-2")
///                             .operation("set")
///                             .build(),
///                         RulesetRuleActionParametersHeaderArgs.builder()
///                             .name("example-http-header-3-to-remove")
///                             .operation("remove")
///                             .build())
///                     .build())
///                 .description("example request header transform rule")
///                 .enabled(false)
///                 .expression("(http.host eq \"example.host.com\")")
///                 .build())
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///         // HTTP rate limit for an API route
///         var rateLimitingExample = new Ruleset("rateLimitingExample", RulesetArgs.builder()        
///             .description("apply HTTP rate limiting for a route")
///             .kind("zone")
///             .name("restrict API requests count")
///             .phase("http_ratelimit")
///             .rules(RulesetRuleArgs.builder()
///                 .action("block")
///                 .description("rate limit for API")
///                 .enabled(true)
///                 .expression("(http.request.uri.path matches \"^/api/\")")
///                 .ratelimit(RulesetRuleRatelimitArgs.builder()
///                     .characteristics(                    
///                         "cf.colo.id",
///                         "ip.src")
///                     .mitigationTimeout(600)
///                     .period(60)
///                     .requestsPerPeriod(100)
///                     .build())
///                 .build())
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///         // Change origin for an API route
///         var httpOriginExample = new Ruleset("httpOriginExample", RulesetArgs.builder()        
///             .description("Change origin for a route")
///             .kind("zone")
///             .name("Change to some origin")
///             .phase("http_request_origin")
///             .rules(RulesetRuleArgs.builder()
///                 .action("route")
///                 .actionParameters(RulesetRuleActionParametersArgs.builder()
///                     .hostHeader("some.host")
///                     .origin(RulesetRuleActionParametersOriginArgs.builder()
///                         .host("some.host")
///                         .port(80)
///                         .build())
///                     .build())
///                 .description("change origin to some.host")
///                 .enabled(true)
///                 .expression("(http.request.uri.path matches \"^/api/\")")
///                 .build())
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///         // Custom fields logging
///         var customFieldsLoggingExample = new Ruleset("customFieldsLoggingExample", RulesetArgs.builder()        
///             .description("add custom fields to logging")
///             .kind("zone")
///             .name("log custom fields")
///             .phase("http_log_custom_fields")
///             .rules(RulesetRuleArgs.builder()
///                 .action("log_custom_field")
///                 .actionParameters(RulesetRuleActionParametersArgs.builder()
///                     .cookieFields(                    
///                         "__ga",
///                         "accountNumber",
///                         "__cfruid")
///                     .requestFields(                    
///                         "content-type",
///                         "x-forwarded-for",
///                         "host")
///                     .responseFields(                    
///                         "server",
///                         "content-type",
///                         "allow")
///                     .build())
///                 .description("log custom fields rule")
///                 .enabled(true)
///                 .expression("(http.host eq \"example.host.com\")")
///                 .build())
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///         // Custom cache keys + settings
///         var cacheSettingsExample = new Ruleset("cacheSettingsExample", RulesetArgs.builder()        
///             .description("set cache settings for the request")
///             .kind("zone")
///             .name("set cache settings")
///             .phase("http_request_cache_settings")
///             .rules(RulesetRuleArgs.builder()
///                 .action("set_cache_settings")
///                 .actionParameters(RulesetRuleActionParametersArgs.builder()
///                     .browserTtl(RulesetRuleActionParametersBrowserTtlArgs.builder()
///                         .mode("respect_origin")
///                         .build())
///                     .cacheKey(RulesetRuleActionParametersCacheKeyArgs.builder()
///                         .cacheDeceptionArmor(true)
///                         .customKey(RulesetRuleActionParametersCacheKeyCustomKeyArgs.builder()
///                             .cookie(RulesetRuleActionParametersCacheKeyCustomKeyCookieArgs.builder()
///                                 .checkPresence(                                
///                                     "cabc_t",
///                                     "cdef_t")
///                                 .include(                                
///                                     "cabc",
///                                     "cdef")
///                                 .build())
///                             .header(RulesetRuleActionParametersCacheKeyCustomKeyHeaderArgs.builder()
///                                 .checkPresence(                                
///                                     "habc_t",
///                                     "hdef_t")
///                                 .excludeOrigin(true)
///                                 .include(                                
///                                     "habc",
///                                     "hdef")
///                                 .build())
///                             .host(RulesetRuleActionParametersCacheKeyCustomKeyHostArgs.builder()
///                                 .resolved(true)
///                                 .build())
///                             .queryString(RulesetRuleActionParametersCacheKeyCustomKeyQueryStringArgs.builder()
///                                 .exclude("*")
///                                 .build())
///                             .user(RulesetRuleActionParametersCacheKeyCustomKeyUserArgs.builder()
///                                 .deviceType(true)
///                                 .geo(false)
///                                 .build())
///                             .build())
///                         .ignoreQueryStringsOrder(false)
///                         .build())
///                     .edgeTtl(RulesetRuleActionParametersEdgeTtlArgs.builder()
///                         .default_(60)
///                         .mode("override_origin")
///                         .statusCodeTtl(                        
///                             %!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference),
///                             %!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
///                         .build())
///                     .originErrorPagePassthru(false)
///                     .respectStrongEtags(true)
///                     .serveStale(RulesetRuleActionParametersServeStaleArgs.builder()
///                         .disableStaleWhileUpdating(true)
///                         .build())
///                     .build())
///                 .description("set cache settings rule")
///                 .enabled(true)
///                 .expression("(http.host eq \"example.host.com\")")
///                 .build())
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///         // Redirects based on a List resource
///         var redirectFromListExample = new Ruleset("redirectFromListExample", RulesetArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .description("Redirect ruleset")
///             .kind("root")
///             .name("redirects")
///             .phase("http_request_redirect")
///             .rules(RulesetRuleArgs.builder()
///                 .action("redirect")
///                 .actionParameters(RulesetRuleActionParametersArgs.builder()
///                     .fromList(RulesetRuleActionParametersFromListArgs.builder()
///                         .key("http.request.full_uri")
///                         .name("redirect_list")
///                         .build())
///                     .build())
///                 .description("Apply redirects from redirect_list")
///                 .enabled(true)
///                 .expression("http.request.full_uri in $redirect_list")
///                 .build())
///             .build());
///
///         // Dynamic Redirects from value resource
///         var redirectFromValueExample = new Ruleset("redirectFromValueExample", RulesetArgs.builder()        
///             .description("Redirect ruleset")
///             .kind("zone")
///             .name("redirects")
///             .phase("http_request_dynamic_redirect")
///             .rules(RulesetRuleArgs.builder()
///                 .action("redirect")
///                 .actionParameters(RulesetRuleActionParametersArgs.builder()
///                     .fromValue(RulesetRuleActionParametersFromValueArgs.builder()
///                         .preserveQueryString(true)
///                         .statusCode(301)
///                         .targetUrl(RulesetRuleActionParametersFromValueTargetUrlArgs.builder()
///                             .value("some_host.com")
///                             .build())
///                         .build())
///                     .build())
///                 .description("Apply redirect from value")
///                 .enabled(true)
///                 .expression("(http.request.uri.path matches \"^/api/\")")
///                 .build())
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///         // Serve some custom error response
///         var httpCustomErrorExample = new Ruleset("httpCustomErrorExample", RulesetArgs.builder()        
///             .description("Serve some error response")
///             .kind("zone")
///             .name("Serve some error response")
///             .phase("http_custom_errors")
///             .rules(RulesetRuleArgs.builder()
///                 .action("serve_error")
///                 .actionParameters(RulesetRuleActionParametersArgs.builder()
///                     .content("some error html")
///                     .contentType("text/html")
///                     .statusCode("530")
///                     .build())
///                 .description("serve some error response")
///                 .enabled(true)
///                 .expression("(http.request.uri.path matches \"^/api/\")")
///                 .build())
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///         // Set Configuration Rules for an API route
///         var httpConfigRulesExample = new Ruleset("httpConfigRulesExample", RulesetArgs.builder()        
///             .description("set config rules for request")
///             .kind("zone")
///             .name("set config rules")
///             .phase("http_config_settings")
///             .rules(RulesetRuleArgs.builder()
///                 .action("set_config")
///                 .actionParameters(RulesetRuleActionParametersArgs.builder()
///                     .bic(true)
///                     .emailObfuscation(true)
///                     .build())
///                 .description("set config rules for matching request")
///                 .enabled(true)
///                 .expression("(http.request.uri.path matches \"^/api/\")")
///                 .build())
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///         // Set compress algorithm for response.
///         var responseCompressBrotliHtml = new Ruleset("responseCompressBrotliHtml", RulesetArgs.builder()        
///             .description("Response compression ruleset")
///             .kind("zone")
///             .name("Brotli response compression for HTML")
///             .phase("http_response_compression")
///             .rules(RulesetRuleArgs.builder()
///                 .action("compress_response")
///                 .actionParameters(RulesetRuleActionParametersArgs.builder()
///                     .algorithms(                    
///                         RulesetRuleActionParametersAlgorithmArgs.builder()
///                             .name("brotli")
///                             .build(),
///                         RulesetRuleActionParametersAlgorithmArgs.builder()
///                             .name("auto")
///                             .build())
///                     .build())
///                 .description("Prefer brotli compression for HTML")
///                 .enabled(true)
///                 .expression("http.response.content_type.media_type == \"text/html\"")
///                 .build())
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # Magic Transit
///   magicTransitExample:
///     type: cloudflare:Ruleset
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       description: example magic transit ruleset description
///       kind: root
///       name: account magic transit
///       phase: magic_transit
///       rules:
///         - action: allow
///           description: Allow TCP Ephemeral Ports
///           expression: tcp.dstport in { 32768..65535 }
///   # Zone-level WAF Managed Ruleset
///   zoneLevelManagedWaf:
///     type: cloudflare:Ruleset
///     properties:
///       description: managed WAF ruleset description
///       kind: zone
///       name: managed WAF
///       phase: http_request_firewall_managed
///       rules:
///         - action: execute
///           actionParameters:
///             id: efb7b8c949ac4650a09736fc376e9aee
///           description: Execute Cloudflare Managed Ruleset on my zone-level phase entry point ruleset
///           enabled: true
///           expression: (http.host eq "example.host.com")
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///   # Zone-level WAF with tag-based overrides
///   zoneLevelManagedWafWithCategoryBasedOverrides:
///     type: cloudflare:Ruleset
///     properties:
///       description: managed WAF with tag-based overrides ruleset description
///       kind: zone
///       name: managed WAF with tag-based overrides
///       phase: http_request_firewall_managed
///       rules:
///         - action: execute
///           actionParameters:
///             id: efb7b8c949ac4650a09736fc376e9aee
///             overrides:
///               categories:
///                 - action: block
///                   category: wordpress
///                   enabled: true
///                 - action: block
///                   category: joomla
///                   enabled: true
///           description: overrides to only enable wordpress rules to block
///           enabled: false
///           expression: (http.host eq "example.host.com")
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///   # Rewrite the URI path component to a static path
///   transformUriRulePath:
///     type: cloudflare:Ruleset
///     properties:
///       description: change the URI path to a new static path
///       kind: zone
///       name: transform rule for URI path
///       phase: http_request_transform
///       rules:
///         - action: rewrite
///           actionParameters:
///             uri:
///               path:
///                 value: /my-new-route
///           description: example URI path transform rule
///           enabled: true
///           expression: (http.host eq "example.com" and http.request.uri.path eq "/old-path")
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///   # Rewrite the URI query component to a static query
///   transformUriRuleQuery:
///     type: cloudflare:Ruleset
///     properties:
///       description: change the URI query to a new static query
///       kind: zone
///       name: transform rule for URI query parameter
///       phase: http_request_transform
///       rules:
///         - action: rewrite
///           actionParameters:
///             uri:
///               query:
///                 value: old=new_again
///           description: URI transformation query example
///           enabled: true
///           expression: (http.host eq "example.host.com")
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///   # Rewrite HTTP headers to a modified values
///   transformUriHttpHeaders:
///     type: cloudflare:Ruleset
///     properties:
///       description: modify HTTP headers before reaching origin
///       kind: zone
///       name: transform rule for HTTP headers
///       phase: http_request_late_transform
///       rules:
///         - action: rewrite
///           actionParameters:
///             headers:
///               - name: example-http-header-1
///                 operation: set
///                 value: my-http-header-value-1
///               - expression: cf.zone.name
///                 name: example-http-header-2
///                 operation: set
///               - name: example-http-header-3-to-remove
///                 operation: remove
///           description: example request header transform rule
///           enabled: false
///           expression: (http.host eq "example.host.com")
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///   # HTTP rate limit for an API route
///   rateLimitingExample:
///     type: cloudflare:Ruleset
///     properties:
///       description: apply HTTP rate limiting for a route
///       kind: zone
///       name: restrict API requests count
///       phase: http_ratelimit
///       rules:
///         - action: block
///           description: rate limit for API
///           enabled: true
///           expression: (http.request.uri.path matches "^/api/")
///           ratelimit:
///             characteristics:
///               - cf.colo.id
///               - ip.src
///             mitigationTimeout: 600
///             period: 60
///             requestsPerPeriod: 100
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///   # Change origin for an API route
///   httpOriginExample:
///     type: cloudflare:Ruleset
///     properties:
///       description: Change origin for a route
///       kind: zone
///       name: Change to some origin
///       phase: http_request_origin
///       rules:
///         - action: route
///           actionParameters:
///             hostHeader: some.host
///             origin:
///               host: some.host
///               port: 80
///           description: change origin to some.host
///           enabled: true
///           expression: (http.request.uri.path matches "^/api/")
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///   # Custom fields logging
///   customFieldsLoggingExample:
///     type: cloudflare:Ruleset
///     properties:
///       description: add custom fields to logging
///       kind: zone
///       name: log custom fields
///       phase: http_log_custom_fields
///       rules:
///         - action: log_custom_field
///           actionParameters:
///             cookieFields:
///               - __ga
///               - accountNumber
///               - __cfruid
///             requestFields:
///               - content-type
///               - x-forwarded-for
///               - host
///             responseFields:
///               - server
///               - content-type
///               - allow
///           description: log custom fields rule
///           enabled: true
///           expression: (http.host eq "example.host.com")
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///   # Custom cache keys + settings
///   cacheSettingsExample:
///     type: cloudflare:Ruleset
///     properties:
///       description: set cache settings for the request
///       kind: zone
///       name: set cache settings
///       phase: http_request_cache_settings
///       rules:
///         - action: set_cache_settings
///           actionParameters:
///             browserTtl:
///               mode: respect_origin
///             cacheKey:
///               cacheDeceptionArmor: true
///               customKey:
///                 cookie:
///                   checkPresence:
///                     - cabc_t
///                     - cdef_t
///                   include:
///                     - cabc
///                     - cdef
///                 header:
///                   checkPresence:
///                     - habc_t
///                     - hdef_t
///                   excludeOrigin: true
///                   include:
///                     - habc
///                     - hdef
///                 host:
///                   resolved: true
///                 queryString:
///                   exclude:
///                     - '*'
///                 user:
///                   deviceType: true
///                   geo: false
///               ignoreQueryStringsOrder: false
///             edgeTtl:
///               default: 60
///               mode: override_origin
///               statusCodeTtl:
///                 - statusCode: 200
///                   value: 50
///                 - statusCodeRange:
///                     - from: 201
///                       to: 300
///                   value: 30
///             originErrorPagePassthru: false
///             respectStrongEtags: true
///             serveStale:
///               disableStaleWhileUpdating: true
///           description: set cache settings rule
///           enabled: true
///           expression: (http.host eq "example.host.com")
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///   # Redirects based on a List resource
///   redirectFromListExample:
///     type: cloudflare:Ruleset
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       description: Redirect ruleset
///       kind: root
///       name: redirects
///       phase: http_request_redirect
///       rules:
///         - action: redirect
///           actionParameters:
///             fromList:
///               key: http.request.full_uri
///               name: redirect_list
///           description: Apply redirects from redirect_list
///           enabled: true
///           expression: http.request.full_uri in $redirect_list
///   # Dynamic Redirects from value resource
///   redirectFromValueExample:
///     type: cloudflare:Ruleset
///     properties:
///       description: Redirect ruleset
///       kind: zone
///       name: redirects
///       phase: http_request_dynamic_redirect
///       rules:
///         - action: redirect
///           actionParameters:
///             fromValue:
///               preserveQueryString: true
///               statusCode: 301
///               targetUrl:
///                 value: some_host.com
///           description: Apply redirect from value
///           enabled: true
///           expression: (http.request.uri.path matches "^/api/")
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///   # Serve some custom error response
///   httpCustomErrorExample:
///     type: cloudflare:Ruleset
///     properties:
///       description: Serve some error response
///       kind: zone
///       name: Serve some error response
///       phase: http_custom_errors
///       rules:
///         - action: serve_error
///           actionParameters:
///             content: some error html
///             contentType: text/html
///             statusCode: '530'
///           description: serve some error response
///           enabled: true
///           expression: (http.request.uri.path matches "^/api/")
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///   # Set Configuration Rules for an API route
///   httpConfigRulesExample:
///     type: cloudflare:Ruleset
///     properties:
///       description: set config rules for request
///       kind: zone
///       name: set config rules
///       phase: http_config_settings
///       rules:
///         - action: set_config
///           actionParameters:
///             bic: true
///             emailObfuscation: true
///           description: set config rules for matching request
///           enabled: true
///           expression: (http.request.uri.path matches "^/api/")
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///   # Set compress algorithm for response.
///   responseCompressBrotliHtml:
///     type: cloudflare:Ruleset
///     properties:
///       description: Response compression ruleset
///       kind: zone
///       name: Brotli response compression for HTML
///       phase: http_response_compression
///       rules:
///         - action: compress_response
///           actionParameters:
///             algorithms:
///               - name: brotli
///               - name: auto
///           description: Prefer brotli compression for HTML
///           enabled: true
///           expression: http.response.content_type.media_type == "text/html"
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// Import an account scoped Ruleset configuration.
///
/// ```sh
/// $ pulumi import cloudflare:index/ruleset:Ruleset example account/<account_id>/<ruleset_id>
/// ```
///
/// Import a zone scoped Ruleset configuration.
///
/// ```sh
/// $ pulumi import cloudflare:index/ruleset:Ruleset example zone/<zone_id>/<ruleset_id>
/// ```
///
pub mod ruleset {

    pub struct RulesetArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Brief summary of the ruleset rule and its intended use.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `zone`.
        pub kind: pulumi_wasm_rust::Output<String>,
        /// Name of the compression algorithm to use. Available values: `gzip`, `brotli`, `auto`, `default`, `none`
        pub name: pulumi_wasm_rust::Output<String>,
        /// Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_sbfm`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.
        pub phase: pulumi_wasm_rust::Output<String>,
        /// List of rule-based overrides.
        pub rules: pulumi_wasm_rust::Output<Option<Vec<crate::types::RulesetRule>>>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct RulesetResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Brief summary of the ruleset rule and its intended use.
        pub description: pulumi_wasm_rust::Output<String>,
        /// Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `zone`.
        pub kind: pulumi_wasm_rust::Output<String>,
        /// Name of the compression algorithm to use. Available values: `gzip`, `brotli`, `auto`, `default`, `none`
        pub name: pulumi_wasm_rust::Output<String>,
        /// Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_sbfm`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.
        pub phase: pulumi_wasm_rust::Output<String>,
        /// List of rule-based overrides.
        pub rules: pulumi_wasm_rust::Output<Option<Vec<crate::types::RulesetRule>>>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn ruleset(name: &str, args: RulesetArgs) -> RulesetResult {
        let result = crate::bindings::pulumi::cloudflare::ruleset::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::ruleset::Args {
                account_id: args.account_id.get_inner(),
                description: args.description.get_inner(),
                kind: args.kind.get_inner(),
                name: args.name.get_inner(),
                phase: args.phase.get_inner(),
                rules: args.rules.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        RulesetResult {
            account_id: crate::into_domain(result.account_id),
            description: crate::into_domain(result.description),
            kind: crate::into_domain(result.kind),
            name: crate::into_domain(result.name),
            phase: crate::into_domain(result.phase),
            rules: crate::into_domain(result.rules),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare Spectrum Application. You can extend the power
/// of Cloudflare's DDoS, TLS, and IP Firewall to your other TCP-based
/// services.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.SpectrumApplication("example", {
///     dns: {
///         name: "ssh.example.com",
///         type: "CNAME",
///     },
///     edgeIps: {
///         ips: [
///             "203.0.113.1",
///             "203.0.113.2",
///         ],
///         type: "static",
///     },
///     originDirects: ["tcp://192.0.2.1:22"],
///     protocol: "tcp/22",
///     trafficType: "direct",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.SpectrumApplication("example",
///     dns=cloudflare.SpectrumApplicationDnsArgs(
///         name="ssh.example.com",
///         type="CNAME",
///     ),
///     edge_ips=cloudflare.SpectrumApplicationEdgeIpsArgs(
///         ips=[
///             "203.0.113.1",
///             "203.0.113.2",
///         ],
///         type="static",
///     ),
///     origin_directs=["tcp://192.0.2.1:22"],
///     protocol="tcp/22",
///     traffic_type="direct",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.SpectrumApplication("example", new()
///     {
///         Dns = new Cloudflare.Inputs.SpectrumApplicationDnsArgs
///         {
///             Name = "ssh.example.com",
///             Type = "CNAME",
///         },
///         EdgeIps = new Cloudflare.Inputs.SpectrumApplicationEdgeIpsArgs
///         {
///             Ips = new[]
///             {
///                 "203.0.113.1",
///                 "203.0.113.2",
///             },
///             Type = "static",
///         },
///         OriginDirects = new[]
///         {
///             "tcp://192.0.2.1:22",
///         },
///         Protocol = "tcp/22",
///         TrafficType = "direct",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewSpectrumApplication(ctx, "example", &cloudflare.SpectrumApplicationArgs{
/// 			Dns: &cloudflare.SpectrumApplicationDnsArgs{
/// 				Name: pulumi.String("ssh.example.com"),
/// 				Type: pulumi.String("CNAME"),
/// 			},
/// 			EdgeIps: &cloudflare.SpectrumApplicationEdgeIpsArgs{
/// 				Ips: pulumi.StringArray{
/// 					pulumi.String("203.0.113.1"),
/// 					pulumi.String("203.0.113.2"),
/// 				},
/// 				Type: pulumi.String("static"),
/// 			},
/// 			OriginDirects: pulumi.StringArray{
/// 				pulumi.String("tcp://192.0.2.1:22"),
/// 			},
/// 			Protocol:    pulumi.String("tcp/22"),
/// 			TrafficType: pulumi.String("direct"),
/// 			ZoneId:      pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.SpectrumApplication;
/// import com.pulumi.cloudflare.SpectrumApplicationArgs;
/// import com.pulumi.cloudflare.inputs.SpectrumApplicationDnsArgs;
/// import com.pulumi.cloudflare.inputs.SpectrumApplicationEdgeIpsArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new SpectrumApplication("example", SpectrumApplicationArgs.builder()        
///             .dns(SpectrumApplicationDnsArgs.builder()
///                 .name("ssh.example.com")
///                 .type("CNAME")
///                 .build())
///             .edgeIps(SpectrumApplicationEdgeIpsArgs.builder()
///                 .ips(                
///                     "203.0.113.1",
///                     "203.0.113.2")
///                 .type("static")
///                 .build())
///             .originDirects("tcp://192.0.2.1:22")
///             .protocol("tcp/22")
///             .trafficType("direct")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:SpectrumApplication
///     properties:
///       dns:
///         name: ssh.example.com
///         type: CNAME
///       edgeIps:
///         ips:
///           - 203.0.113.1
///           - 203.0.113.2
///         type: static
///       originDirects:
///         - tcp://192.0.2.1:22
///       protocol: tcp/22
///       trafficType: direct
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/spectrumApplication:SpectrumApplication example <zone_id>/<spectrum_application_id>
/// ```
///
pub mod spectrum_application {

    pub struct SpectrumApplicationArgs {
        /// Enables Argo Smart Routing.
        pub argo_smart_routing: pulumi_wasm_rust::Output<Option<bool>>,
        /// The name and type of DNS record for the Spectrum application.
        pub dns: pulumi_wasm_rust::Output<crate::types::SpectrumApplicationDns>,
        /// The anycast edge IP configuration for the hostname of this application.
        pub edge_ips: pulumi_wasm_rust::Output<Option<crate::types::SpectrumApplicationEdgeIps>>,
        /// Enables the IP Firewall for this application.
        pub ip_firewall: pulumi_wasm_rust::Output<Option<bool>>,
        /// A list of destination addresses to the origin. e.g. `tcp://192.0.2.1:22`.
        pub origin_directs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// A destination DNS addresses to the origin.
        pub origin_dns:
            pulumi_wasm_rust::Output<Option<crate::types::SpectrumApplicationOriginDns>>,
        /// Origin port to proxy traffice to. Conflicts with `origin_port_range`.
        pub origin_port: pulumi_wasm_rust::Output<Option<i32>>,
        /// Origin port range to proxy traffice to. When using a range, the protocol field must also specify a range, e.g. `tcp/22-23`. Conflicts with `origin_port`.
        pub origin_port_range:
            pulumi_wasm_rust::Output<Option<crate::types::SpectrumApplicationOriginPortRange>>,
        /// The port configuration at Cloudflare's edge. e.g. `tcp/22`.
        pub protocol: pulumi_wasm_rust::Output<String>,
        /// Enables a proxy protocol to the origin. Available values: `off`, `v1`, `v2`, `simple`.
        pub proxy_protocol: pulumi_wasm_rust::Output<Option<String>>,
        /// TLS configuration option for Cloudflare to connect to your origin. Available values: `off`, `flexible`, `full`, `strict`.
        pub tls: pulumi_wasm_rust::Output<Option<String>>,
        /// Sets application type. Available values: `direct`, `http`, `https`.
        pub traffic_type: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct SpectrumApplicationResult {
        /// Enables Argo Smart Routing.
        pub argo_smart_routing: pulumi_wasm_rust::Output<bool>,
        /// The name and type of DNS record for the Spectrum application.
        pub dns: pulumi_wasm_rust::Output<crate::types::SpectrumApplicationDns>,
        /// The anycast edge IP configuration for the hostname of this application.
        pub edge_ips: pulumi_wasm_rust::Output<crate::types::SpectrumApplicationEdgeIps>,
        /// Enables the IP Firewall for this application.
        pub ip_firewall: pulumi_wasm_rust::Output<bool>,
        /// A list of destination addresses to the origin. e.g. `tcp://192.0.2.1:22`.
        pub origin_directs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// A destination DNS addresses to the origin.
        pub origin_dns:
            pulumi_wasm_rust::Output<Option<crate::types::SpectrumApplicationOriginDns>>,
        /// Origin port to proxy traffice to. Conflicts with `origin_port_range`.
        pub origin_port: pulumi_wasm_rust::Output<Option<i32>>,
        /// Origin port range to proxy traffice to. When using a range, the protocol field must also specify a range, e.g. `tcp/22-23`. Conflicts with `origin_port`.
        pub origin_port_range:
            pulumi_wasm_rust::Output<Option<crate::types::SpectrumApplicationOriginPortRange>>,
        /// The port configuration at Cloudflare's edge. e.g. `tcp/22`.
        pub protocol: pulumi_wasm_rust::Output<String>,
        /// Enables a proxy protocol to the origin. Available values: `off`, `v1`, `v2`, `simple`.
        pub proxy_protocol: pulumi_wasm_rust::Output<String>,
        /// TLS configuration option for Cloudflare to connect to your origin. Available values: `off`, `flexible`, `full`, `strict`.
        pub tls: pulumi_wasm_rust::Output<String>,
        /// Sets application type. Available values: `direct`, `http`, `https`.
        pub traffic_type: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn spectrum_application(
        name: &str,
        args: SpectrumApplicationArgs,
    ) -> SpectrumApplicationResult {
        let result = crate::bindings::pulumi::cloudflare::spectrum_application::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::spectrum_application::Args {
                argo_smart_routing: args.argo_smart_routing.get_inner(),
                dns: args.dns.get_inner(),
                edge_ips: args.edge_ips.get_inner(),
                ip_firewall: args.ip_firewall.get_inner(),
                origin_directs: args.origin_directs.get_inner(),
                origin_dns: args.origin_dns.get_inner(),
                origin_port: args.origin_port.get_inner(),
                origin_port_range: args.origin_port_range.get_inner(),
                protocol: args.protocol.get_inner(),
                proxy_protocol: args.proxy_protocol.get_inner(),
                tls: args.tls.get_inner(),
                traffic_type: args.traffic_type.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        SpectrumApplicationResult {
            argo_smart_routing: crate::into_domain(result.argo_smart_routing),
            dns: crate::into_domain(result.dns),
            edge_ips: crate::into_domain(result.edge_ips),
            ip_firewall: crate::into_domain(result.ip_firewall),
            origin_directs: crate::into_domain(result.origin_directs),
            origin_dns: crate::into_domain(result.origin_dns),
            origin_port: crate::into_domain(result.origin_port),
            origin_port_range: crate::into_domain(result.origin_port_range),
            protocol: crate::into_domain(result.protocol),
            proxy_protocol: crate::into_domain(result.proxy_protocol),
            tls: crate::into_domain(result.tls),
            traffic_type: crate::into_domain(result.traffic_type),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare Split Tunnel resource. Split tunnels are used to either
/// include or exclude lists of routes from the WARP client's tunnel.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// // Excluding *.example.com from WARP routes
/// const exampleSplitTunnelExclude = new cloudflare.SplitTunnel("exampleSplitTunnelExclude", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     mode: "exclude",
///     tunnels: [{
///         host: "*.example.com",
///         description: "example domain",
///     }],
/// });
/// // Including *.example.com in WARP routes
/// const exampleSplitTunnelIncludeSplitTunnel = new cloudflare.SplitTunnel("exampleSplitTunnelIncludeSplitTunnel", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     mode: "include",
///     tunnels: [{
///         host: "*.example.com",
///         description: "example domain",
///     }],
/// });
/// // Create a device policy
/// const developerWarpPolicy = new cloudflare.DeviceSettingsPolicy("developerWarpPolicy", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "Developers",
///     precedence: 10,
///     match: "any(identity.groups.name[*] in {\"Developers\"})",
///     switchLocked: true,
/// });
/// // Excluding *.example.com from WARP routes for a particular device policy
/// const exampleDeviceSettingsPolicySplitTunnelExclude = new cloudflare.SplitTunnel("exampleDeviceSettingsPolicySplitTunnelExclude", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     policyId: developerWarpPolicy.id,
///     mode: "exclude",
///     tunnels: [{
///         host: "*.example.com",
///         description: "example domain",
///     }],
/// });
/// // Including *.example.com in WARP routes for a particular device policy
/// const exampleSplitTunnelIncludeIndex_splitTunnelSplitTunnel = new cloudflare.SplitTunnel("exampleSplitTunnelIncludeIndex/splitTunnelSplitTunnel", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     policyId: cloudflare_device_policy.developer_warp_policy.id,
///     mode: "include",
///     tunnels: [{
///         host: "*.example.com",
///         description: "example domain",
///     }],
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// # Excluding *.example.com from WARP routes
/// example_split_tunnel_exclude = cloudflare.SplitTunnel("exampleSplitTunnelExclude",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     mode="exclude",
///     tunnels=[cloudflare.SplitTunnelTunnelArgs(
///         host="*.example.com",
///         description="example domain",
///     )])
/// # Including *.example.com in WARP routes
/// example_split_tunnel_include_split_tunnel = cloudflare.SplitTunnel("exampleSplitTunnelIncludeSplitTunnel",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     mode="include",
///     tunnels=[cloudflare.SplitTunnelTunnelArgs(
///         host="*.example.com",
///         description="example domain",
///     )])
/// # Create a device policy
/// developer_warp_policy = cloudflare.DeviceSettingsPolicy("developerWarpPolicy",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="Developers",
///     precedence=10,
///     match="any(identity.groups.name[*] in {\"Developers\"})",
///     switch_locked=True)
/// # Excluding *.example.com from WARP routes for a particular device policy
/// example_device_settings_policy_split_tunnel_exclude = cloudflare.SplitTunnel("exampleDeviceSettingsPolicySplitTunnelExclude",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     policy_id=developer_warp_policy.id,
///     mode="exclude",
///     tunnels=[cloudflare.SplitTunnelTunnelArgs(
///         host="*.example.com",
///         description="example domain",
///     )])
/// # Including *.example.com in WARP routes for a particular device policy
/// example_split_tunnel_include_index_split_tunnel_split_tunnel = cloudflare.SplitTunnel("exampleSplitTunnelIncludeIndex/splitTunnelSplitTunnel",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     policy_id=cloudflare_device_policy["developer_warp_policy"]["id"],
///     mode="include",
///     tunnels=[cloudflare.SplitTunnelTunnelArgs(
///         host="*.example.com",
///         description="example domain",
///     )])
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     // Excluding *.example.com from WARP routes
///     var exampleSplitTunnelExclude = new Cloudflare.SplitTunnel("exampleSplitTunnelExclude", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Mode = "exclude",
///         Tunnels = new[]
///         {
///             new Cloudflare.Inputs.SplitTunnelTunnelArgs
///             {
///                 Host = "*.example.com",
///                 Description = "example domain",
///             },
///         },
///     });
///
///     // Including *.example.com in WARP routes
///     var exampleSplitTunnelIncludeSplitTunnel = new Cloudflare.SplitTunnel("exampleSplitTunnelIncludeSplitTunnel", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Mode = "include",
///         Tunnels = new[]
///         {
///             new Cloudflare.Inputs.SplitTunnelTunnelArgs
///             {
///                 Host = "*.example.com",
///                 Description = "example domain",
///             },
///         },
///     });
///
///     // Create a device policy
///     var developerWarpPolicy = new Cloudflare.DeviceSettingsPolicy("developerWarpPolicy", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "Developers",
///         Precedence = 10,
///         Match = "any(identity.groups.name[*] in {\"Developers\"})",
///         SwitchLocked = true,
///     });
///
///     // Excluding *.example.com from WARP routes for a particular device policy
///     var exampleDeviceSettingsPolicySplitTunnelExclude = new Cloudflare.SplitTunnel("exampleDeviceSettingsPolicySplitTunnelExclude", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         PolicyId = developerWarpPolicy.Id,
///         Mode = "exclude",
///         Tunnels = new[]
///         {
///             new Cloudflare.Inputs.SplitTunnelTunnelArgs
///             {
///                 Host = "*.example.com",
///                 Description = "example domain",
///             },
///         },
///     });
///
///     // Including *.example.com in WARP routes for a particular device policy
///     var exampleSplitTunnelIncludeIndex_splitTunnelSplitTunnel = new Cloudflare.SplitTunnel("exampleSplitTunnelIncludeIndex/splitTunnelSplitTunnel", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         PolicyId = cloudflare_device_policy.Developer_warp_policy.Id,
///         Mode = "include",
///         Tunnels = new[]
///         {
///             new Cloudflare.Inputs.SplitTunnelTunnelArgs
///             {
///                 Host = "*.example.com",
///                 Description = "example domain",
///             },
///         },
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// Excluding *.example.com from WARP routes
/// 		_, err := cloudflare.NewSplitTunnel(ctx, "exampleSplitTunnelExclude", &cloudflare.SplitTunnelArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Mode:      pulumi.String("exclude"),
/// 			Tunnels: cloudflare.SplitTunnelTunnelArray{
/// 				&cloudflare.SplitTunnelTunnelArgs{
/// 					Host:        pulumi.String("*.example.com"),
/// 					Description: pulumi.String("example domain"),
/// 				},
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// Including *.example.com in WARP routes
/// 		_, err = cloudflare.NewSplitTunnel(ctx, "exampleSplitTunnelIncludeSplitTunnel", &cloudflare.SplitTunnelArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Mode:      pulumi.String("include"),
/// 			Tunnels: cloudflare.SplitTunnelTunnelArray{
/// 				&cloudflare.SplitTunnelTunnelArgs{
/// 					Host:        pulumi.String("*.example.com"),
/// 					Description: pulumi.String("example domain"),
/// 				},
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// Create a device policy
/// 		developerWarpPolicy, err := cloudflare.NewDeviceSettingsPolicy(ctx, "developerWarpPolicy", &cloudflare.DeviceSettingsPolicyArgs{
/// 			AccountId:    pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:         pulumi.String("Developers"),
/// 			Precedence:   pulumi.Int(10),
/// 			Match:        pulumi.String("any(identity.groups.name[*] in {\"Developers\"})"),
/// 			SwitchLocked: pulumi.Bool(true),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// Excluding *.example.com from WARP routes for a particular device policy
/// 		_, err = cloudflare.NewSplitTunnel(ctx, "exampleDeviceSettingsPolicySplitTunnelExclude", &cloudflare.SplitTunnelArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			PolicyId:  developerWarpPolicy.ID(),
/// 			Mode:      pulumi.String("exclude"),
/// 			Tunnels: cloudflare.SplitTunnelTunnelArray{
/// 				&cloudflare.SplitTunnelTunnelArgs{
/// 					Host:        pulumi.String("*.example.com"),
/// 					Description: pulumi.String("example domain"),
/// 				},
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// Including *.example.com in WARP routes for a particular device policy
/// 		_, err = cloudflare.NewSplitTunnel(ctx, "exampleSplitTunnelIncludeIndex/splitTunnelSplitTunnel", &cloudflare.SplitTunnelArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			PolicyId:  pulumi.Any(cloudflare_device_policy.Developer_warp_policy.Id),
/// 			Mode:      pulumi.String("include"),
/// 			Tunnels: cloudflare.SplitTunnelTunnelArray{
/// 				&cloudflare.SplitTunnelTunnelArgs{
/// 					Host:        pulumi.String("*.example.com"),
/// 					Description: pulumi.String("example domain"),
/// 				},
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.SplitTunnel;
/// import com.pulumi.cloudflare.SplitTunnelArgs;
/// import com.pulumi.cloudflare.inputs.SplitTunnelTunnelArgs;
/// import com.pulumi.cloudflare.DeviceSettingsPolicy;
/// import com.pulumi.cloudflare.DeviceSettingsPolicyArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // Excluding *.example.com from WARP routes
///         var exampleSplitTunnelExclude = new SplitTunnel("exampleSplitTunnelExclude", SplitTunnelArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .mode("exclude")
///             .tunnels(SplitTunnelTunnelArgs.builder()
///                 .host("*.example.com")
///                 .description("example domain")
///                 .build())
///             .build());
///
///         // Including *.example.com in WARP routes
///         var exampleSplitTunnelIncludeSplitTunnel = new SplitTunnel("exampleSplitTunnelIncludeSplitTunnel", SplitTunnelArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .mode("include")
///             .tunnels(SplitTunnelTunnelArgs.builder()
///                 .host("*.example.com")
///                 .description("example domain")
///                 .build())
///             .build());
///
///         // Create a device policy
///         var developerWarpPolicy = new DeviceSettingsPolicy("developerWarpPolicy", DeviceSettingsPolicyArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("Developers")
///             .precedence(10)
///             .match("any(identity.groups.name[*] in {\"Developers\"})")
///             .switchLocked(true)
///             .build());
///
///         // Excluding *.example.com from WARP routes for a particular device policy
///         var exampleDeviceSettingsPolicySplitTunnelExclude = new SplitTunnel("exampleDeviceSettingsPolicySplitTunnelExclude", SplitTunnelArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .policyId(developerWarpPolicy.id())
///             .mode("exclude")
///             .tunnels(SplitTunnelTunnelArgs.builder()
///                 .host("*.example.com")
///                 .description("example domain")
///                 .build())
///             .build());
///
///         // Including *.example.com in WARP routes for a particular device policy
///         var exampleSplitTunnelIncludeIndex_splitTunnelSplitTunnel = new SplitTunnel("exampleSplitTunnelIncludeIndex/splitTunnelSplitTunnel", SplitTunnelArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .policyId(cloudflare_device_policy.developer_warp_policy().id())
///             .mode("include")
///             .tunnels(SplitTunnelTunnelArgs.builder()
///                 .host("*.example.com")
///                 .description("example domain")
///                 .build())
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # Excluding *.example.com from WARP routes
///   exampleSplitTunnelExclude:
///     type: cloudflare:SplitTunnel
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       mode: exclude
///       tunnels:
///         - host: '*.example.com'
///           description: example domain
///   # Including *.example.com in WARP routes
///   exampleSplitTunnelIncludeSplitTunnel:
///     type: cloudflare:SplitTunnel
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       mode: include
///       tunnels:
///         - host: '*.example.com'
///           description: example domain
///   # Create a device policy
///   developerWarpPolicy:
///     type: cloudflare:DeviceSettingsPolicy
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       name: Developers
///       precedence: 10
///       match: any(identity.groups.name[*] in {"Developers"})
///       switchLocked: true
///   # Excluding *.example.com from WARP routes for a particular device policy
///   exampleDeviceSettingsPolicySplitTunnelExclude:
///     type: cloudflare:SplitTunnel
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       policyId: ${developerWarpPolicy.id}
///       mode: exclude
///       tunnels:
///         - host: '*.example.com'
///           description: example domain
///   # Including *.example.com in WARP routes for a particular device policy
///   exampleSplitTunnelIncludeIndex/splitTunnelSplitTunnel:
///     type: cloudflare:SplitTunnel
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       policyId: ${cloudflare_device_policy.developer_warp_policy.id}
///       mode: include
///       tunnels:
///         - host: '*.example.com'
///           description: example domain
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// Split Tunnels for default device policies must use "default" as the policy ID.
///
/// ```sh
/// $ pulumi import cloudflare:index/splitTunnel:SplitTunnel example <account_id>/<policy_id>/<mode>
/// ```
///
pub mod split_tunnel {

    pub struct SplitTunnelArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The mode of the split tunnel policy. Available values: `include`, `exclude`.
        pub mode: pulumi_wasm_rust::Output<String>,
        /// The settings policy for which to configure this split tunnel policy.
        pub policy_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The value of the tunnel attributes.
        pub tunnels: pulumi_wasm_rust::Output<Vec<crate::types::SplitTunnelTunnel>>,
    }

    pub struct SplitTunnelResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The mode of the split tunnel policy. Available values: `include`, `exclude`.
        pub mode: pulumi_wasm_rust::Output<String>,
        /// The settings policy for which to configure this split tunnel policy.
        pub policy_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The value of the tunnel attributes.
        pub tunnels: pulumi_wasm_rust::Output<Vec<crate::types::SplitTunnelTunnel>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn split_tunnel(name: &str, args: SplitTunnelArgs) -> SplitTunnelResult {
        let result = crate::bindings::pulumi::cloudflare::split_tunnel::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::split_tunnel::Args {
                account_id: args.account_id.get_inner(),
                mode: args.mode.get_inner(),
                policy_id: args.policy_id.get_inner(),
                tunnels: args.tunnels.get_inner(),
            },
        );

        SplitTunnelResult {
            account_id: crate::into_domain(result.account_id),
            mode: crate::into_domain(result.mode),
            policy_id: crate::into_domain(result.policy_id),
            tunnels: crate::into_domain(result.tunnels),
        }
    }
}

/// Provides a resource, that manages Cloudflare static routes for Magic
/// Transit or Magic WAN. Static routes are used to route traffic
/// through GRE tunnels.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.StaticRoute("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     coloNames: ["den01"],
///     coloRegions: ["APAC"],
///     description: "New route for new prefix 192.0.2.0/24",
///     nexthop: "10.0.0.0",
///     prefix: "192.0.2.0/24",
///     priority: 100,
///     weight: 10,
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.StaticRoute("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     colo_names=["den01"],
///     colo_regions=["APAC"],
///     description="New route for new prefix 192.0.2.0/24",
///     nexthop="10.0.0.0",
///     prefix="192.0.2.0/24",
///     priority=100,
///     weight=10)
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.StaticRoute("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         ColoNames = new[]
///         {
///             "den01",
///         },
///         ColoRegions = new[]
///         {
///             "APAC",
///         },
///         Description = "New route for new prefix 192.0.2.0/24",
///         Nexthop = "10.0.0.0",
///         Prefix = "192.0.2.0/24",
///         Priority = 100,
///         Weight = 10,
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewStaticRoute(ctx, "example", &cloudflare.StaticRouteArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			ColoNames: pulumi.StringArray{
/// 				pulumi.String("den01"),
/// 			},
/// 			ColoRegions: pulumi.StringArray{
/// 				pulumi.String("APAC"),
/// 			},
/// 			Description: pulumi.String("New route for new prefix 192.0.2.0/24"),
/// 			Nexthop:     pulumi.String("10.0.0.0"),
/// 			Prefix:      pulumi.String("192.0.2.0/24"),
/// 			Priority:    pulumi.Int(100),
/// 			Weight:      pulumi.Int(10),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.StaticRoute;
/// import com.pulumi.cloudflare.StaticRouteArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new StaticRoute("example", StaticRouteArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .coloNames("den01")
///             .coloRegions("APAC")
///             .description("New route for new prefix 192.0.2.0/24")
///             .nexthop("10.0.0.0")
///             .prefix("192.0.2.0/24")
///             .priority(100)
///             .weight(10)
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:StaticRoute
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       coloNames:
///         - den01
///       coloRegions:
///         - APAC
///       description: New route for new prefix 192.0.2.0/24
///       nexthop: 10.0.0.0
///       prefix: 192.0.2.0/24
///       priority: 100
///       weight: 10
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/staticRoute:StaticRoute example <account_id>/<static_route_id>
/// ```
///
pub mod static_route {

    pub struct StaticRouteArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// List of Cloudflare colocation regions for this static route.
        pub colo_names: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of Cloudflare colocation names for this static route.
        pub colo_regions: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Description of the static route.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The nexthop IP address where traffic will be routed to.
        pub nexthop: pulumi_wasm_rust::Output<String>,
        /// Your network prefix using CIDR notation.
        pub prefix: pulumi_wasm_rust::Output<String>,
        /// The priority for the static route.
        pub priority: pulumi_wasm_rust::Output<i32>,
        /// The optional weight for ECMP routes. **Modifying this attribute will force creation of a new resource.**
        pub weight: pulumi_wasm_rust::Output<Option<i32>>,
    }

    pub struct StaticRouteResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// List of Cloudflare colocation regions for this static route.
        pub colo_names: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of Cloudflare colocation names for this static route.
        pub colo_regions: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Description of the static route.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The nexthop IP address where traffic will be routed to.
        pub nexthop: pulumi_wasm_rust::Output<String>,
        /// Your network prefix using CIDR notation.
        pub prefix: pulumi_wasm_rust::Output<String>,
        /// The priority for the static route.
        pub priority: pulumi_wasm_rust::Output<i32>,
        /// The optional weight for ECMP routes. **Modifying this attribute will force creation of a new resource.**
        pub weight: pulumi_wasm_rust::Output<Option<i32>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn static_route(name: &str, args: StaticRouteArgs) -> StaticRouteResult {
        let result = crate::bindings::pulumi::cloudflare::static_route::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::static_route::Args {
                account_id: args.account_id.get_inner(),
                colo_names: args.colo_names.get_inner(),
                colo_regions: args.colo_regions.get_inner(),
                description: args.description.get_inner(),
                nexthop: args.nexthop.get_inner(),
                prefix: args.prefix.get_inner(),
                priority: args.priority.get_inner(),
                weight: args.weight.get_inner(),
            },
        );

        StaticRouteResult {
            account_id: crate::into_domain(result.account_id),
            colo_names: crate::into_domain(result.colo_names),
            colo_regions: crate::into_domain(result.colo_regions),
            description: crate::into_domain(result.description),
            nexthop: crate::into_domain(result.nexthop),
            prefix: crate::into_domain(result.prefix),
            priority: crate::into_domain(result.priority),
            weight: crate::into_domain(result.weight),
        }
    }
}

/// Provides a Cloudflare Teams Account resource. The Teams Account
/// resource defines configuration for secure web gateway.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.TeamsAccount("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     antivirus: {
///         enabledDownloadPhase: true,
///         enabledUploadPhase: false,
///         failClosed: true,
///         notificationSettings: {
///             enabled: true,
///             message: "you are blocked",
///             supportUrl: "https://example.com/blocked",
///         },
///     },
///     blockPage: {
///         backgroundColor: "#000000",
///         footerText: "hello",
///         headerText: "hello",
///         logoPath: "https://example.com/logo.jpg",
///     },
///     bodyScanning: {
///         inspectionMode: "deep",
///     },
///     extendedEmailMatching: {
///         enabled: true,
///     },
///     fips: {
///         tls: true,
///     },
///     logging: {
///         redactPii: true,
///         settingsByRuleType: {
///             dns: {
///                 logAll: false,
///                 logBlocks: true,
///             },
///             http: {
///                 logAll: true,
///                 logBlocks: true,
///             },
///             l4: {
///                 logAll: false,
///                 logBlocks: true,
///             },
///         },
///     },
///     protocolDetectionEnabled: true,
///     proxy: {
///         rootCa: true,
///         tcp: true,
///         udp: true,
///     },
///     tlsDecryptEnabled: true,
///     urlBrowserIsolationEnabled: true,
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.TeamsAccount("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     antivirus=cloudflare.TeamsAccountAntivirusArgs(
///         enabled_download_phase=True,
///         enabled_upload_phase=False,
///         fail_closed=True,
///         notification_settings=cloudflare.TeamsAccountAntivirusNotificationSettingsArgs(
///             enabled=True,
///             message="you are blocked",
///             support_url="https://example.com/blocked",
///         ),
///     ),
///     block_page=cloudflare.TeamsAccountBlockPageArgs(
///         background_color="#000000",
///         footer_text="hello",
///         header_text="hello",
///         logo_path="https://example.com/logo.jpg",
///     ),
///     body_scanning=cloudflare.TeamsAccountBodyScanningArgs(
///         inspection_mode="deep",
///     ),
///     extended_email_matching=cloudflare.TeamsAccountExtendedEmailMatchingArgs(
///         enabled=True,
///     ),
///     fips=cloudflare.TeamsAccountFipsArgs(
///         tls=True,
///     ),
///     logging=cloudflare.TeamsAccountLoggingArgs(
///         redact_pii=True,
///         settings_by_rule_type=cloudflare.TeamsAccountLoggingSettingsByRuleTypeArgs(
///             dns=cloudflare.TeamsAccountLoggingSettingsByRuleTypeDnsArgs(
///                 log_all=False,
///                 log_blocks=True,
///             ),
///             http=cloudflare.TeamsAccountLoggingSettingsByRuleTypeHttpArgs(
///                 log_all=True,
///                 log_blocks=True,
///             ),
///             l4=cloudflare.TeamsAccountLoggingSettingsByRuleTypeL4Args(
///                 log_all=False,
///                 log_blocks=True,
///             ),
///         ),
///     ),
///     protocol_detection_enabled=True,
///     proxy=cloudflare.TeamsAccountProxyArgs(
///         root_ca=True,
///         tcp=True,
///         udp=True,
///     ),
///     tls_decrypt_enabled=True,
///     url_browser_isolation_enabled=True)
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.TeamsAccount("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Antivirus = new Cloudflare.Inputs.TeamsAccountAntivirusArgs
///         {
///             EnabledDownloadPhase = true,
///             EnabledUploadPhase = false,
///             FailClosed = true,
///             NotificationSettings = new Cloudflare.Inputs.TeamsAccountAntivirusNotificationSettingsArgs
///             {
///                 Enabled = true,
///                 Message = "you are blocked",
///                 SupportUrl = "https://example.com/blocked",
///             },
///         },
///         BlockPage = new Cloudflare.Inputs.TeamsAccountBlockPageArgs
///         {
///             BackgroundColor = "#000000",
///             FooterText = "hello",
///             HeaderText = "hello",
///             LogoPath = "https://example.com/logo.jpg",
///         },
///         BodyScanning = new Cloudflare.Inputs.TeamsAccountBodyScanningArgs
///         {
///             InspectionMode = "deep",
///         },
///         ExtendedEmailMatching = new Cloudflare.Inputs.TeamsAccountExtendedEmailMatchingArgs
///         {
///             Enabled = true,
///         },
///         Fips = new Cloudflare.Inputs.TeamsAccountFipsArgs
///         {
///             Tls = true,
///         },
///         Logging = new Cloudflare.Inputs.TeamsAccountLoggingArgs
///         {
///             RedactPii = true,
///             SettingsByRuleType = new Cloudflare.Inputs.TeamsAccountLoggingSettingsByRuleTypeArgs
///             {
///                 Dns = new Cloudflare.Inputs.TeamsAccountLoggingSettingsByRuleTypeDnsArgs
///                 {
///                     LogAll = false,
///                     LogBlocks = true,
///                 },
///                 Http = new Cloudflare.Inputs.TeamsAccountLoggingSettingsByRuleTypeHttpArgs
///                 {
///                     LogAll = true,
///                     LogBlocks = true,
///                 },
///                 L4 = new Cloudflare.Inputs.TeamsAccountLoggingSettingsByRuleTypeL4Args
///                 {
///                     LogAll = false,
///                     LogBlocks = true,
///                 },
///             },
///         },
///         ProtocolDetectionEnabled = true,
///         Proxy = new Cloudflare.Inputs.TeamsAccountProxyArgs
///         {
///             RootCa = true,
///             Tcp = true,
///             Udp = true,
///         },
///         TlsDecryptEnabled = true,
///         UrlBrowserIsolationEnabled = true,
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewTeamsAccount(ctx, "example", &cloudflare.TeamsAccountArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Antivirus: &cloudflare.TeamsAccountAntivirusArgs{
/// 				EnabledDownloadPhase: pulumi.Bool(true),
/// 				EnabledUploadPhase:   pulumi.Bool(false),
/// 				FailClosed:           pulumi.Bool(true),
/// 				NotificationSettings: &cloudflare.TeamsAccountAntivirusNotificationSettingsArgs{
/// 					Enabled:    pulumi.Bool(true),
/// 					Message:    pulumi.String("you are blocked"),
/// 					SupportUrl: pulumi.String("https://example.com/blocked"),
/// 				},
/// 			},
/// 			BlockPage: &cloudflare.TeamsAccountBlockPageArgs{
/// 				BackgroundColor: pulumi.String("#000000"),
/// 				FooterText:      pulumi.String("hello"),
/// 				HeaderText:      pulumi.String("hello"),
/// 				LogoPath:        pulumi.String("https://example.com/logo.jpg"),
/// 			},
/// 			BodyScanning: &cloudflare.TeamsAccountBodyScanningArgs{
/// 				InspectionMode: pulumi.String("deep"),
/// 			},
/// 			ExtendedEmailMatching: &cloudflare.TeamsAccountExtendedEmailMatchingArgs{
/// 				Enabled: pulumi.Bool(true),
/// 			},
/// 			Fips: &cloudflare.TeamsAccountFipsArgs{
/// 				Tls: pulumi.Bool(true),
/// 			},
/// 			Logging: &cloudflare.TeamsAccountLoggingArgs{
/// 				RedactPii: pulumi.Bool(true),
/// 				SettingsByRuleType: &cloudflare.TeamsAccountLoggingSettingsByRuleTypeArgs{
/// 					Dns: &cloudflare.TeamsAccountLoggingSettingsByRuleTypeDnsArgs{
/// 						LogAll:    pulumi.Bool(false),
/// 						LogBlocks: pulumi.Bool(true),
/// 					},
/// 					Http: &cloudflare.TeamsAccountLoggingSettingsByRuleTypeHttpArgs{
/// 						LogAll:    pulumi.Bool(true),
/// 						LogBlocks: pulumi.Bool(true),
/// 					},
/// 					L4: &cloudflare.TeamsAccountLoggingSettingsByRuleTypeL4Args{
/// 						LogAll:    pulumi.Bool(false),
/// 						LogBlocks: pulumi.Bool(true),
/// 					},
/// 				},
/// 			},
/// 			ProtocolDetectionEnabled: pulumi.Bool(true),
/// 			Proxy: &cloudflare.TeamsAccountProxyArgs{
/// 				RootCa: pulumi.Bool(true),
/// 				Tcp:    pulumi.Bool(true),
/// 				Udp:    pulumi.Bool(true),
/// 			},
/// 			TlsDecryptEnabled:          pulumi.Bool(true),
/// 			UrlBrowserIsolationEnabled: pulumi.Bool(true),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.TeamsAccount;
/// import com.pulumi.cloudflare.TeamsAccountArgs;
/// import com.pulumi.cloudflare.inputs.TeamsAccountAntivirusArgs;
/// import com.pulumi.cloudflare.inputs.TeamsAccountAntivirusNotificationSettingsArgs;
/// import com.pulumi.cloudflare.inputs.TeamsAccountBlockPageArgs;
/// import com.pulumi.cloudflare.inputs.TeamsAccountBodyScanningArgs;
/// import com.pulumi.cloudflare.inputs.TeamsAccountExtendedEmailMatchingArgs;
/// import com.pulumi.cloudflare.inputs.TeamsAccountFipsArgs;
/// import com.pulumi.cloudflare.inputs.TeamsAccountLoggingArgs;
/// import com.pulumi.cloudflare.inputs.TeamsAccountLoggingSettingsByRuleTypeArgs;
/// import com.pulumi.cloudflare.inputs.TeamsAccountLoggingSettingsByRuleTypeDnsArgs;
/// import com.pulumi.cloudflare.inputs.TeamsAccountLoggingSettingsByRuleTypeHttpArgs;
/// import com.pulumi.cloudflare.inputs.TeamsAccountLoggingSettingsByRuleTypeL4Args;
/// import com.pulumi.cloudflare.inputs.TeamsAccountProxyArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new TeamsAccount("example", TeamsAccountArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .antivirus(TeamsAccountAntivirusArgs.builder()
///                 .enabledDownloadPhase(true)
///                 .enabledUploadPhase(false)
///                 .failClosed(true)
///                 .notificationSettings(TeamsAccountAntivirusNotificationSettingsArgs.builder()
///                     .enabled(true)
///                     .message("you are blocked")
///                     .supportUrl("https://example.com/blocked")
///                     .build())
///                 .build())
///             .blockPage(TeamsAccountBlockPageArgs.builder()
///                 .backgroundColor("#000000")
///                 .footerText("hello")
///                 .headerText("hello")
///                 .logoPath("https://example.com/logo.jpg")
///                 .build())
///             .bodyScanning(TeamsAccountBodyScanningArgs.builder()
///                 .inspectionMode("deep")
///                 .build())
///             .extendedEmailMatching(TeamsAccountExtendedEmailMatchingArgs.builder()
///                 .enabled(true)
///                 .build())
///             .fips(TeamsAccountFipsArgs.builder()
///                 .tls(true)
///                 .build())
///             .logging(TeamsAccountLoggingArgs.builder()
///                 .redactPii(true)
///                 .settingsByRuleType(TeamsAccountLoggingSettingsByRuleTypeArgs.builder()
///                     .dns(TeamsAccountLoggingSettingsByRuleTypeDnsArgs.builder()
///                         .logAll(false)
///                         .logBlocks(true)
///                         .build())
///                     .http(TeamsAccountLoggingSettingsByRuleTypeHttpArgs.builder()
///                         .logAll(true)
///                         .logBlocks(true)
///                         .build())
///                     .l4(TeamsAccountLoggingSettingsByRuleTypeL4Args.builder()
///                         .logAll(false)
///                         .logBlocks(true)
///                         .build())
///                     .build())
///                 .build())
///             .protocolDetectionEnabled(true)
///             .proxy(TeamsAccountProxyArgs.builder()
///                 .rootCa(true)
///                 .tcp(true)
///                 .udp(true)
///                 .build())
///             .tlsDecryptEnabled(true)
///             .urlBrowserIsolationEnabled(true)
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:TeamsAccount
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       antivirus:
///         enabledDownloadPhase: true
///         enabledUploadPhase: false
///         failClosed: true
///         notificationSettings:
///           enabled: true
///           message: you are blocked
///           supportUrl: https://example.com/blocked
///       blockPage:
///         backgroundColor: '#000000'
///         footerText: hello
///         headerText: hello
///         logoPath: https://example.com/logo.jpg
///       bodyScanning:
///         inspectionMode: deep
///       extendedEmailMatching:
///         enabled: true
///       fips:
///         tls: true
///       logging:
///         redactPii: true
///         settingsByRuleType:
///           dns:
///             logAll: false
///             logBlocks: true
///           http:
///             logAll: true
///             logBlocks: true
///           l4:
///             logAll: false
///             logBlocks: true
///       protocolDetectionEnabled: true
///       proxy:
///         rootCa: true
///         tcp: true
///         udp: true
///       tlsDecryptEnabled: true
///       urlBrowserIsolationEnabled: true
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/teamsAccount:TeamsAccount example <account_id>
/// ```
///
pub mod teams_account {

    pub struct TeamsAccountArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether to enable the activity log.
        pub activity_log_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Configuration block for antivirus traffic scanning.
        pub antivirus: pulumi_wasm_rust::Output<Option<crate::types::TeamsAccountAntivirus>>,
        /// Configuration for a custom block page.
        pub block_page: pulumi_wasm_rust::Output<Option<crate::types::TeamsAccountBlockPage>>,
        /// Configuration for body scanning.
        pub body_scanning: pulumi_wasm_rust::Output<Option<crate::types::TeamsAccountBodyScanning>>,
        /// Configuration for extended e-mail matching.
        pub extended_email_matching:
            pulumi_wasm_rust::Output<Option<crate::types::TeamsAccountExtendedEmailMatching>>,
        /// Configure compliance with Federal Information Processing Standards.
        pub fips: pulumi_wasm_rust::Output<Option<crate::types::TeamsAccountFips>>,
        pub logging: pulumi_wasm_rust::Output<Option<crate::types::TeamsAccountLogging>>,
        /// Enable non-identity onramp for Browser Isolation. Defaults to `false`.
        pub non_identity_browser_isolation_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Configuration for DLP Payload Logging.
        pub payload_log: pulumi_wasm_rust::Output<Option<crate::types::TeamsAccountPayloadLog>>,
        /// Indicator that protocol detection is enabled.
        pub protocol_detection_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Configuration block for specifying which protocols are proxied.
        pub proxy: pulumi_wasm_rust::Output<Option<crate::types::TeamsAccountProxy>>,
        /// Configuration for SSH Session Logging.
        pub ssh_session_log:
            pulumi_wasm_rust::Output<Option<crate::types::TeamsAccountSshSessionLog>>,
        /// Indicator that decryption of TLS traffic is enabled.
        pub tls_decrypt_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Safely browse websites in Browser Isolation through a URL. Defaults to `false`.
        pub url_browser_isolation_enabled: pulumi_wasm_rust::Output<Option<bool>>,
    }

    pub struct TeamsAccountResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether to enable the activity log.
        pub activity_log_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Configuration block for antivirus traffic scanning.
        pub antivirus: pulumi_wasm_rust::Output<Option<crate::types::TeamsAccountAntivirus>>,
        /// Configuration for a custom block page.
        pub block_page: pulumi_wasm_rust::Output<Option<crate::types::TeamsAccountBlockPage>>,
        /// Configuration for body scanning.
        pub body_scanning: pulumi_wasm_rust::Output<Option<crate::types::TeamsAccountBodyScanning>>,
        /// Configuration for extended e-mail matching.
        pub extended_email_matching:
            pulumi_wasm_rust::Output<Option<crate::types::TeamsAccountExtendedEmailMatching>>,
        /// Configure compliance with Federal Information Processing Standards.
        pub fips: pulumi_wasm_rust::Output<Option<crate::types::TeamsAccountFips>>,
        pub logging: pulumi_wasm_rust::Output<Option<crate::types::TeamsAccountLogging>>,
        /// Enable non-identity onramp for Browser Isolation. Defaults to `false`.
        pub non_identity_browser_isolation_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Configuration for DLP Payload Logging.
        pub payload_log: pulumi_wasm_rust::Output<Option<crate::types::TeamsAccountPayloadLog>>,
        /// Indicator that protocol detection is enabled.
        pub protocol_detection_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Configuration block for specifying which protocols are proxied.
        pub proxy: pulumi_wasm_rust::Output<Option<crate::types::TeamsAccountProxy>>,
        /// Configuration for SSH Session Logging.
        pub ssh_session_log:
            pulumi_wasm_rust::Output<Option<crate::types::TeamsAccountSshSessionLog>>,
        /// Indicator that decryption of TLS traffic is enabled.
        pub tls_decrypt_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Safely browse websites in Browser Isolation through a URL. Defaults to `false`.
        pub url_browser_isolation_enabled: pulumi_wasm_rust::Output<Option<bool>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn teams_account(name: &str, args: TeamsAccountArgs) -> TeamsAccountResult {
        let result = crate::bindings::pulumi::cloudflare::teams_account::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::teams_account::Args {
                account_id: args.account_id.get_inner(),
                activity_log_enabled: args.activity_log_enabled.get_inner(),
                antivirus: args.antivirus.get_inner(),
                block_page: args.block_page.get_inner(),
                body_scanning: args.body_scanning.get_inner(),
                extended_email_matching: args.extended_email_matching.get_inner(),
                fips: args.fips.get_inner(),
                logging: args.logging.get_inner(),
                non_identity_browser_isolation_enabled: args
                    .non_identity_browser_isolation_enabled
                    .get_inner(),
                payload_log: args.payload_log.get_inner(),
                protocol_detection_enabled: args.protocol_detection_enabled.get_inner(),
                proxy: args.proxy.get_inner(),
                ssh_session_log: args.ssh_session_log.get_inner(),
                tls_decrypt_enabled: args.tls_decrypt_enabled.get_inner(),
                url_browser_isolation_enabled: args.url_browser_isolation_enabled.get_inner(),
            },
        );

        TeamsAccountResult {
            account_id: crate::into_domain(result.account_id),
            activity_log_enabled: crate::into_domain(result.activity_log_enabled),
            antivirus: crate::into_domain(result.antivirus),
            block_page: crate::into_domain(result.block_page),
            body_scanning: crate::into_domain(result.body_scanning),
            extended_email_matching: crate::into_domain(result.extended_email_matching),
            fips: crate::into_domain(result.fips),
            logging: crate::into_domain(result.logging),
            non_identity_browser_isolation_enabled: crate::into_domain(
                result.non_identity_browser_isolation_enabled,
            ),
            payload_log: crate::into_domain(result.payload_log),
            protocol_detection_enabled: crate::into_domain(result.protocol_detection_enabled),
            proxy: crate::into_domain(result.proxy),
            ssh_session_log: crate::into_domain(result.ssh_session_log),
            tls_decrypt_enabled: crate::into_domain(result.tls_decrypt_enabled),
            url_browser_isolation_enabled: crate::into_domain(result.url_browser_isolation_enabled),
        }
    }
}

/// Provides a Cloudflare Teams List resource. Teams lists are
/// referenced when creating secure web gateway policies or device
/// posture rules.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.TeamsList("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     description: "Serial numbers for all corporate devices.",
///     items: [
///         "8GE8721REF",
///         "5RE8543EGG",
///         "1YE2880LNP",
///     ],
///     name: "Corporate devices",
///     type: "SERIAL",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.TeamsList("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     description="Serial numbers for all corporate devices.",
///     items=[
///         "8GE8721REF",
///         "5RE8543EGG",
///         "1YE2880LNP",
///     ],
///     name="Corporate devices",
///     type="SERIAL")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.TeamsList("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Description = "Serial numbers for all corporate devices.",
///         Items = new[]
///         {
///             "8GE8721REF",
///             "5RE8543EGG",
///             "1YE2880LNP",
///         },
///         Name = "Corporate devices",
///         Type = "SERIAL",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewTeamsList(ctx, "example", &cloudflare.TeamsListArgs{
/// 			AccountId:   pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Description: pulumi.String("Serial numbers for all corporate devices."),
/// 			Items: pulumi.StringArray{
/// 				pulumi.String("8GE8721REF"),
/// 				pulumi.String("5RE8543EGG"),
/// 				pulumi.String("1YE2880LNP"),
/// 			},
/// 			Name: pulumi.String("Corporate devices"),
/// 			Type: pulumi.String("SERIAL"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.TeamsList;
/// import com.pulumi.cloudflare.TeamsListArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new TeamsList("example", TeamsListArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .description("Serial numbers for all corporate devices.")
///             .items(            
///                 "8GE8721REF",
///                 "5RE8543EGG",
///                 "1YE2880LNP")
///             .name("Corporate devices")
///             .type("SERIAL")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:TeamsList
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       description: Serial numbers for all corporate devices.
///       items:
///         - 8GE8721REF
///         - 5RE8543EGG
///         - 1YE2880LNP
///       name: Corporate devices
///       type: SERIAL
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/teamsList:TeamsList example <account_id>/<teams_list_id>
/// ```
///
pub mod teams_list {

    pub struct TeamsListArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The description of the teams list.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The items of the teams list.
        pub items: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Name of the teams list.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The teams list type. Available values: `IP`, `SERIAL`, `URL`, `DOMAIN`, `EMAIL`.
        pub type_: pulumi_wasm_rust::Output<String>,
    }

    pub struct TeamsListResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The description of the teams list.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The items of the teams list.
        pub items: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Name of the teams list.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The teams list type. Available values: `IP`, `SERIAL`, `URL`, `DOMAIN`, `EMAIL`.
        pub type_: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn teams_list(name: &str, args: TeamsListArgs) -> TeamsListResult {
        let result = crate::bindings::pulumi::cloudflare::teams_list::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::teams_list::Args {
                account_id: args.account_id.get_inner(),
                description: args.description.get_inner(),
                items: args.items.get_inner(),
                name: args.name.get_inner(),
                type_: args.type_.get_inner(),
            },
        );

        TeamsListResult {
            account_id: crate::into_domain(result.account_id),
            description: crate::into_domain(result.description),
            items: crate::into_domain(result.items),
            name: crate::into_domain(result.name),
            type_: crate::into_domain(result.type_),
        }
    }
}

/// Provides a Cloudflare Teams Location resource. Teams Locations are
/// referenced when creating secure web gateway policies.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.TeamsLocation("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     clientDefault: true,
///     name: "office",
///     networks: [
///         {
///             network: "203.0.113.1/32",
///         },
///         {
///             network: "203.0.113.2/32",
///         },
///     ],
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.TeamsLocation("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     client_default=True,
///     name="office",
///     networks=[
///         cloudflare.TeamsLocationNetworkArgs(
///             network="203.0.113.1/32",
///         ),
///         cloudflare.TeamsLocationNetworkArgs(
///             network="203.0.113.2/32",
///         ),
///     ])
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.TeamsLocation("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         ClientDefault = true,
///         Name = "office",
///         Networks = new[]
///         {
///             new Cloudflare.Inputs.TeamsLocationNetworkArgs
///             {
///                 Network = "203.0.113.1/32",
///             },
///             new Cloudflare.Inputs.TeamsLocationNetworkArgs
///             {
///                 Network = "203.0.113.2/32",
///             },
///         },
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewTeamsLocation(ctx, "example", &cloudflare.TeamsLocationArgs{
/// 			AccountId:     pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			ClientDefault: pulumi.Bool(true),
/// 			Name:          pulumi.String("office"),
/// 			Networks: cloudflare.TeamsLocationNetworkArray{
/// 				&cloudflare.TeamsLocationNetworkArgs{
/// 					Network: pulumi.String("203.0.113.1/32"),
/// 				},
/// 				&cloudflare.TeamsLocationNetworkArgs{
/// 					Network: pulumi.String("203.0.113.2/32"),
/// 				},
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.TeamsLocation;
/// import com.pulumi.cloudflare.TeamsLocationArgs;
/// import com.pulumi.cloudflare.inputs.TeamsLocationNetworkArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new TeamsLocation("example", TeamsLocationArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .clientDefault(true)
///             .name("office")
///             .networks(            
///                 TeamsLocationNetworkArgs.builder()
///                     .network("203.0.113.1/32")
///                     .build(),
///                 TeamsLocationNetworkArgs.builder()
///                     .network("203.0.113.2/32")
///                     .build())
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:TeamsLocation
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       clientDefault: true
///       name: office
///       networks:
///         - network: 203.0.113.1/32
///         - network: 203.0.113.2/32
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/teamsLocation:TeamsLocation example <account_id>/<teams_location_id>
/// ```
///
pub mod teams_location {

    pub struct TeamsLocationArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Indicator that this is the default location.
        pub client_default: pulumi_wasm_rust::Output<Option<bool>>,
        /// Name of the teams location.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The networks CIDRs that comprise the location.
        pub networks: pulumi_wasm_rust::Output<Option<Vec<crate::types::TeamsLocationNetwork>>>,
    }

    pub struct TeamsLocationResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Indicator that anonymized logs are enabled.
        pub anonymized_logs_enabled: pulumi_wasm_rust::Output<bool>,
        /// Indicator that this is the default location.
        pub client_default: pulumi_wasm_rust::Output<Option<bool>>,
        /// The FQDN that DoH clients should be pointed at.
        pub doh_subdomain: pulumi_wasm_rust::Output<String>,
        /// Client IP address.
        pub ip: pulumi_wasm_rust::Output<String>,
        /// IP to direct all IPv4 DNS queries to.
        pub ipv4_destination: pulumi_wasm_rust::Output<String>,
        /// Name of the teams location.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The networks CIDRs that comprise the location.
        pub networks: pulumi_wasm_rust::Output<Option<Vec<crate::types::TeamsLocationNetwork>>>,
        pub policy_ids: pulumi_wasm_rust::Output<Vec<String>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn teams_location(name: &str, args: TeamsLocationArgs) -> TeamsLocationResult {
        let result = crate::bindings::pulumi::cloudflare::teams_location::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::teams_location::Args {
                account_id: args.account_id.get_inner(),
                client_default: args.client_default.get_inner(),
                name: args.name.get_inner(),
                networks: args.networks.get_inner(),
            },
        );

        TeamsLocationResult {
            account_id: crate::into_domain(result.account_id),
            anonymized_logs_enabled: crate::into_domain(result.anonymized_logs_enabled),
            client_default: crate::into_domain(result.client_default),
            doh_subdomain: crate::into_domain(result.doh_subdomain),
            ip: crate::into_domain(result.ip),
            ipv4_destination: crate::into_domain(result.ipv4_destination),
            name: crate::into_domain(result.name),
            networks: crate::into_domain(result.networks),
            policy_ids: crate::into_domain(result.policy_ids),
        }
    }
}

/// Provides a Cloudflare Teams Proxy Endpoint resource. Teams Proxy
/// Endpoints are used for pointing proxy clients at Cloudflare Secure
/// Gateway.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.TeamsProxyEndpoint("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     ips: ["192.0.2.0/24"],
///     name: "office",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.TeamsProxyEndpoint("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     ips=["192.0.2.0/24"],
///     name="office")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.TeamsProxyEndpoint("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Ips = new[]
///         {
///             "192.0.2.0/24",
///         },
///         Name = "office",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewTeamsProxyEndpoint(ctx, "example", &cloudflare.TeamsProxyEndpointArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Ips: pulumi.StringArray{
/// 				pulumi.String("192.0.2.0/24"),
/// 			},
/// 			Name: pulumi.String("office"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.TeamsProxyEndpoint;
/// import com.pulumi.cloudflare.TeamsProxyEndpointArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new TeamsProxyEndpoint("example", TeamsProxyEndpointArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .ips("192.0.2.0/24")
///             .name("office")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:TeamsProxyEndpoint
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       ips:
///         - 192.0.2.0/24
///       name: office
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/teamsProxyEndpoint:TeamsProxyEndpoint example <account_id>/<proxy_endpoint_id>
/// ```
///
pub mod teams_proxy_endpoint {

    pub struct TeamsProxyEndpointArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The networks CIDRs that will be allowed to initiate proxy connections.
        pub ips: pulumi_wasm_rust::Output<Vec<String>>,
        /// Name of the teams proxy endpoint.
        pub name: pulumi_wasm_rust::Output<String>,
    }

    pub struct TeamsProxyEndpointResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The networks CIDRs that will be allowed to initiate proxy connections.
        pub ips: pulumi_wasm_rust::Output<Vec<String>>,
        /// Name of the teams proxy endpoint.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The FQDN that proxy clients should be pointed at.
        pub subdomain: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn teams_proxy_endpoint(
        name: &str,
        args: TeamsProxyEndpointArgs,
    ) -> TeamsProxyEndpointResult {
        let result = crate::bindings::pulumi::cloudflare::teams_proxy_endpoint::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::teams_proxy_endpoint::Args {
                account_id: args.account_id.get_inner(),
                ips: args.ips.get_inner(),
                name: args.name.get_inner(),
            },
        );

        TeamsProxyEndpointResult {
            account_id: crate::into_domain(result.account_id),
            ips: crate::into_domain(result.ips),
            name: crate::into_domain(result.name),
            subdomain: crate::into_domain(result.subdomain),
        }
    }
}

/// Provides a Cloudflare Teams rule resource. Teams rules comprise secure web gateway policies.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.TeamsRule("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     action: "block",
///     description: "desc",
///     filters: ["http"],
///     name: "office",
///     precedence: 1,
///     ruleSettings: {
///         blockPageEnabled: true,
///         blockPageReason: "access not permitted",
///     },
///     traffic: "http.request.uri == \"https://www.example.com/malicious\"",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.TeamsRule("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     action="block",
///     description="desc",
///     filters=["http"],
///     name="office",
///     precedence=1,
///     rule_settings=cloudflare.TeamsRuleRuleSettingsArgs(
///         block_page_enabled=True,
///         block_page_reason="access not permitted",
///     ),
///     traffic="http.request.uri == \"https://www.example.com/malicious\"")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.TeamsRule("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Action = "block",
///         Description = "desc",
///         Filters = new[]
///         {
///             "http",
///         },
///         Name = "office",
///         Precedence = 1,
///         RuleSettings = new Cloudflare.Inputs.TeamsRuleRuleSettingsArgs
///         {
///             BlockPageEnabled = true,
///             BlockPageReason = "access not permitted",
///         },
///         Traffic = "http.request.uri == \"https://www.example.com/malicious\"",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewTeamsRule(ctx, "example", &cloudflare.TeamsRuleArgs{
/// 			AccountId:   pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Action:      pulumi.String("block"),
/// 			Description: pulumi.String("desc"),
/// 			Filters: pulumi.StringArray{
/// 				pulumi.String("http"),
/// 			},
/// 			Name:       pulumi.String("office"),
/// 			Precedence: pulumi.Int(1),
/// 			RuleSettings: &cloudflare.TeamsRuleRuleSettingsArgs{
/// 				BlockPageEnabled: pulumi.Bool(true),
/// 				BlockPageReason:  pulumi.String("access not permitted"),
/// 			},
/// 			Traffic: pulumi.String("http.request.uri == \"https://www.example.com/malicious\""),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.TeamsRule;
/// import com.pulumi.cloudflare.TeamsRuleArgs;
/// import com.pulumi.cloudflare.inputs.TeamsRuleRuleSettingsArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new TeamsRule("example", TeamsRuleArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .action("block")
///             .description("desc")
///             .filters("http")
///             .name("office")
///             .precedence(1)
///             .ruleSettings(TeamsRuleRuleSettingsArgs.builder()
///                 .blockPageEnabled(true)
///                 .blockPageReason("access not permitted")
///                 .build())
///             .traffic("http.request.uri == \"https://www.example.com/malicious\"")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:TeamsRule
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       action: block
///       description: desc
///       filters:
///         - http
///       name: office
///       precedence: 1
///       ruleSettings:
///         blockPageEnabled: true
///         blockPageReason: access not permitted
///       traffic: http.request.uri == "https://www.example.com/malicious"
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/teamsRule:TeamsRule example <account_id>/<teams_rule_id>
/// ```
///
pub mod teams_rule {

    pub struct TeamsRuleArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Action to be taken when the SSL certificate of upstream is invalid. Available values: `pass_through`, `block`, `error`.
        pub action: pulumi_wasm_rust::Output<String>,
        /// The description of the teams rule.
        pub description: pulumi_wasm_rust::Output<String>,
        /// The wirefilter expression to be used for device_posture check matching.
        pub device_posture: pulumi_wasm_rust::Output<Option<String>>,
        /// Enable notification settings.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The protocol or layer to evaluate the traffic and identity expressions.
        pub filters: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The wirefilter expression to be used for identity matching.
        pub identity: pulumi_wasm_rust::Output<Option<String>>,
        /// The name of the teams rule.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The evaluation precedence of the teams rule.
        pub precedence: pulumi_wasm_rust::Output<i32>,
        /// Additional rule settings.
        pub rule_settings: pulumi_wasm_rust::Output<Option<crate::types::TeamsRuleRuleSettings>>,
        /// The wirefilter expression to be used for traffic matching.
        pub traffic: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct TeamsRuleResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Action to be taken when the SSL certificate of upstream is invalid. Available values: `pass_through`, `block`, `error`.
        pub action: pulumi_wasm_rust::Output<String>,
        /// The description of the teams rule.
        pub description: pulumi_wasm_rust::Output<String>,
        /// The wirefilter expression to be used for device_posture check matching.
        pub device_posture: pulumi_wasm_rust::Output<Option<String>>,
        /// Enable notification settings.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The protocol or layer to evaluate the traffic and identity expressions.
        pub filters: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The wirefilter expression to be used for identity matching.
        pub identity: pulumi_wasm_rust::Output<Option<String>>,
        /// The name of the teams rule.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The evaluation precedence of the teams rule.
        pub precedence: pulumi_wasm_rust::Output<i32>,
        /// Additional rule settings.
        pub rule_settings: pulumi_wasm_rust::Output<Option<crate::types::TeamsRuleRuleSettings>>,
        /// The wirefilter expression to be used for traffic matching.
        pub traffic: pulumi_wasm_rust::Output<Option<String>>,
        pub version: pulumi_wasm_rust::Output<i32>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn teams_rule(name: &str, args: TeamsRuleArgs) -> TeamsRuleResult {
        let result = crate::bindings::pulumi::cloudflare::teams_rule::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::teams_rule::Args {
                account_id: args.account_id.get_inner(),
                action: args.action.get_inner(),
                description: args.description.get_inner(),
                device_posture: args.device_posture.get_inner(),
                enabled: args.enabled.get_inner(),
                filters: args.filters.get_inner(),
                identity: args.identity.get_inner(),
                name: args.name.get_inner(),
                precedence: args.precedence.get_inner(),
                rule_settings: args.rule_settings.get_inner(),
                traffic: args.traffic.get_inner(),
            },
        );

        TeamsRuleResult {
            account_id: crate::into_domain(result.account_id),
            action: crate::into_domain(result.action),
            description: crate::into_domain(result.description),
            device_posture: crate::into_domain(result.device_posture),
            enabled: crate::into_domain(result.enabled),
            filters: crate::into_domain(result.filters),
            identity: crate::into_domain(result.identity),
            name: crate::into_domain(result.name),
            precedence: crate::into_domain(result.precedence),
            rule_settings: crate::into_domain(result.rule_settings),
            traffic: crate::into_domain(result.traffic),
            version: crate::into_domain(result.version),
        }
    }
}

/// Provides a resource, that manages Cloudflare Tiered Cache settings.
/// This allows you to adjust topologies for your zone.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.TieredCache("example", {
///     cacheType: "smart",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.TieredCache("example",
///     cache_type="smart",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.TieredCache("example", new()
///     {
///         CacheType = "smart",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewTieredCache(ctx, "example", &cloudflare.TieredCacheArgs{
/// 			CacheType: pulumi.String("smart"),
/// 			ZoneId:    pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.TieredCache;
/// import com.pulumi.cloudflare.TieredCacheArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new TieredCache("example", TieredCacheArgs.builder()        
///             .cacheType("smart")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:TieredCache
///     properties:
///       cacheType: smart
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
pub mod tiered_cache {

    pub struct TieredCacheArgs {
        /// The typed of tiered cache to utilize on the zone. Available values: `generic`, `smart`, `off`.
        pub cache_type: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct TieredCacheResult {
        /// The typed of tiered cache to utilize on the zone. Available values: `generic`, `smart`, `off`.
        pub cache_type: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn tiered_cache(name: &str, args: TieredCacheArgs) -> TieredCacheResult {
        let result = crate::bindings::pulumi::cloudflare::tiered_cache::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::tiered_cache::Args {
                cache_type: args.cache_type.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        TieredCacheResult {
            cache_type: crate::into_domain(result.cache_type),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a resource which manages Total TLS for a zone.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.TotalTls("example", {
///     certificateAuthority: "lets_encrypt",
///     enabled: true,
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.TotalTls("example",
///     certificate_authority="lets_encrypt",
///     enabled=True,
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.TotalTls("example", new()
///     {
///         CertificateAuthority = "lets_encrypt",
///         Enabled = true,
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewTotalTls(ctx, "example", &cloudflare.TotalTlsArgs{
/// 			CertificateAuthority: pulumi.String("lets_encrypt"),
/// 			Enabled:              pulumi.Bool(true),
/// 			ZoneId:               pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.TotalTls;
/// import com.pulumi.cloudflare.TotalTlsArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new TotalTls("example", TotalTlsArgs.builder()        
///             .certificateAuthority("lets_encrypt")
///             .enabled(true)
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:TotalTls
///     properties:
///       certificateAuthority: lets_encrypt
///       enabled: true
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/totalTls:TotalTls example <zone_id>
/// ```
///
pub mod total_tls {

    pub struct TotalTlsArgs {
        /// The Certificate Authority that Total TLS certificates will be issued through. Available values: `google`, `lets_encrypt`.
        pub certificate_authority: pulumi_wasm_rust::Output<Option<String>>,
        /// Enable Total TLS for the zone.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct TotalTlsResult {
        /// The Certificate Authority that Total TLS certificates will be issued through. Available values: `google`, `lets_encrypt`.
        pub certificate_authority: pulumi_wasm_rust::Output<Option<String>>,
        /// Enable Total TLS for the zone.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn total_tls(name: &str, args: TotalTlsArgs) -> TotalTlsResult {
        let result = crate::bindings::pulumi::cloudflare::total_tls::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::total_tls::Args {
                certificate_authority: args.certificate_authority.get_inner(),
                enabled: args.enabled.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        TotalTlsResult {
            certificate_authority: crate::into_domain(result.certificate_authority),
            enabled: crate::into_domain(result.enabled),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Tunnel exposes applications running on your local web server on any
/// network with an internet connection without manually adding DNS
/// records or configuring a firewall or router.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.Tunnel("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "my-tunnel",
///     secret: "AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.Tunnel("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="my-tunnel",
///     secret="AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.Tunnel("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "my-tunnel",
///         Secret = "AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewTunnel(ctx, "example", &cloudflare.TunnelArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:      pulumi.String("my-tunnel"),
/// 			Secret:    pulumi.String("AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg="),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.Tunnel;
/// import com.pulumi.cloudflare.TunnelArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new Tunnel("example", TunnelArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("my-tunnel")
///             .secret("AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:Tunnel
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       name: my-tunnel
///       secret: AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/tunnel:Tunnel example <account_id>/<tunnel_id>
/// ```
///
pub mod tunnel {

    pub struct TunnelArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel on the Zero Trust dashboard or using tunnel*config, tunnel*route or tunnel*virtual*network resources. Available values: `local`, `cloudflare`. **Modifying this attribute will force creation of a new resource.**
        pub config_src: pulumi_wasm_rust::Output<Option<String>>,
        /// A user-friendly name chosen when the tunnel is created. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
        /// 32 or more bytes, encoded as a base64 string. The Create Argo Tunnel endpoint sets this as the tunnel's password. Anyone wishing to run the tunnel needs this password. **Modifying this attribute will force creation of a new resource.**
        pub secret: pulumi_wasm_rust::Output<String>,
    }

    pub struct TunnelResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Usable CNAME for accessing the Tunnel.
        pub cname: pulumi_wasm_rust::Output<String>,
        /// Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel on the Zero Trust dashboard or using tunnel*config, tunnel*route or tunnel*virtual*network resources. Available values: `local`, `cloudflare`. **Modifying this attribute will force creation of a new resource.**
        pub config_src: pulumi_wasm_rust::Output<Option<String>>,
        /// A user-friendly name chosen when the tunnel is created. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
        /// 32 or more bytes, encoded as a base64 string. The Create Argo Tunnel endpoint sets this as the tunnel's password. Anyone wishing to run the tunnel needs this password. **Modifying this attribute will force creation of a new resource.**
        pub secret: pulumi_wasm_rust::Output<String>,
        /// Token used by a connector to authenticate and run the tunnel.
        pub tunnel_token: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn tunnel(name: &str, args: TunnelArgs) -> TunnelResult {
        let result = crate::bindings::pulumi::cloudflare::tunnel::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::tunnel::Args {
                account_id: args.account_id.get_inner(),
                config_src: args.config_src.get_inner(),
                name: args.name.get_inner(),
                secret: args.secret.get_inner(),
            },
        );

        TunnelResult {
            account_id: crate::into_domain(result.account_id),
            cname: crate::into_domain(result.cname),
            config_src: crate::into_domain(result.config_src),
            name: crate::into_domain(result.name),
            secret: crate::into_domain(result.secret),
            tunnel_token: crate::into_domain(result.tunnel_token),
        }
    }
}

/// Provides a Cloudflare Tunnel configuration resource.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const exampleTunnel = new cloudflare.Tunnel("exampleTunnel", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "example_tunnel",
///     secret: "<32 character secret>",
/// });
/// const exampleConfig = new cloudflare.TunnelConfig("exampleConfig", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     tunnelId: exampleTunnel.id,
///     config: {
///         warpRouting: {
///             enabled: true,
///         },
///         originRequest: {
///             connectTimeout: "1m0s",
///             tlsTimeout: "1m0s",
///             tcpKeepAlive: "1m0s",
///             noHappyEyeballs: false,
///             keepAliveConnections: 1024,
///             keepAliveTimeout: "1m0s",
///             httpHostHeader: "baz",
///             originServerName: "foobar",
///             caPool: "/path/to/unsigned/ca/pool",
///             noTlsVerify: false,
///             disableChunkedEncoding: false,
///             bastionMode: false,
///             proxyAddress: "10.0.0.1",
///             proxyPort: 8123,
///             proxyType: "socks",
///             ipRules: [{
///                 prefix: "/web",
///                 ports: [
///                     80,
///                     443,
///                 ],
///                 allow: false,
///             }],
///         },
///         ingressRules: [
///             {
///                 hostname: "foo",
///                 path: "/bar",
///                 service: "http://10.0.0.2:8080",
///                 originRequest: {
///                     connectTimeout: "2m0s",
///                     access: {
///                         required: true,
///                         teamName: "terraform",
///                         audTags: ["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"],
///                     },
///                 },
///             },
///             {
///                 service: "https://10.0.0.3:8081",
///             },
///         ],
///     },
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example_tunnel = cloudflare.Tunnel("exampleTunnel",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="example_tunnel",
///     secret="<32 character secret>")
/// example_config = cloudflare.TunnelConfig("exampleConfig",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     tunnel_id=example_tunnel.id,
///     config=cloudflare.TunnelConfigConfigArgs(
///         warp_routing=cloudflare.TunnelConfigConfigWarpRoutingArgs(
///             enabled=True,
///         ),
///         origin_request=cloudflare.TunnelConfigConfigOriginRequestArgs(
///             connect_timeout="1m0s",
///             tls_timeout="1m0s",
///             tcp_keep_alive="1m0s",
///             no_happy_eyeballs=False,
///             keep_alive_connections=1024,
///             keep_alive_timeout="1m0s",
///             http_host_header="baz",
///             origin_server_name="foobar",
///             ca_pool="/path/to/unsigned/ca/pool",
///             no_tls_verify=False,
///             disable_chunked_encoding=False,
///             bastion_mode=False,
///             proxy_address="10.0.0.1",
///             proxy_port=8123,
///             proxy_type="socks",
///             ip_rules=[cloudflare.TunnelConfigConfigOriginRequestIpRuleArgs(
///                 prefix="/web",
///                 ports=[
///                     80,
///                     443,
///                 ],
///                 allow=False,
///             )],
///         ),
///         ingress_rules=[
///             cloudflare.TunnelConfigConfigIngressRuleArgs(
///                 hostname="foo",
///                 path="/bar",
///                 service="http://10.0.0.2:8080",
///                 origin_request=cloudflare.TunnelConfigConfigIngressRuleOriginRequestArgs(
///                     connect_timeout="2m0s",
///                     access=cloudflare.TunnelConfigConfigIngressRuleOriginRequestAccessArgs(
///                         required=True,
///                         team_name="terraform",
///                         aud_tags=["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"],
///                     ),
///                 ),
///             ),
///             cloudflare.TunnelConfigConfigIngressRuleArgs(
///                 service="https://10.0.0.3:8081",
///             ),
///         ],
///     ))
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var exampleTunnel = new Cloudflare.Tunnel("exampleTunnel", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "example_tunnel",
///         Secret = "<32 character secret>",
///     });
///
///     var exampleConfig = new Cloudflare.TunnelConfig("exampleConfig", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         TunnelId = exampleTunnel.Id,
///         Config = new Cloudflare.Inputs.TunnelConfigConfigArgs
///         {
///             WarpRouting = new Cloudflare.Inputs.TunnelConfigConfigWarpRoutingArgs
///             {
///                 Enabled = true,
///             },
///             OriginRequest = new Cloudflare.Inputs.TunnelConfigConfigOriginRequestArgs
///             {
///                 ConnectTimeout = "1m0s",
///                 TlsTimeout = "1m0s",
///                 TcpKeepAlive = "1m0s",
///                 NoHappyEyeballs = false,
///                 KeepAliveConnections = 1024,
///                 KeepAliveTimeout = "1m0s",
///                 HttpHostHeader = "baz",
///                 OriginServerName = "foobar",
///                 CaPool = "/path/to/unsigned/ca/pool",
///                 NoTlsVerify = false,
///                 DisableChunkedEncoding = false,
///                 BastionMode = false,
///                 ProxyAddress = "10.0.0.1",
///                 ProxyPort = 8123,
///                 ProxyType = "socks",
///                 IpRules = new[]
///                 {
///                     new Cloudflare.Inputs.TunnelConfigConfigOriginRequestIpRuleArgs
///                     {
///                         Prefix = "/web",
///                         Ports = new[]
///                         {
///                             80,
///                             443,
///                         },
///                         Allow = false,
///                     },
///                 },
///             },
///             IngressRules = new[]
///             {
///                 new Cloudflare.Inputs.TunnelConfigConfigIngressRuleArgs
///                 {
///                     Hostname = "foo",
///                     Path = "/bar",
///                     Service = "http://10.0.0.2:8080",
///                     OriginRequest = new Cloudflare.Inputs.TunnelConfigConfigIngressRuleOriginRequestArgs
///                     {
///                         ConnectTimeout = "2m0s",
///                         Access = new Cloudflare.Inputs.TunnelConfigConfigIngressRuleOriginRequestAccessArgs
///                         {
///                             Required = true,
///                             TeamName = "terraform",
///                             AudTags = new[]
///                             {
///                                 "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
///                             },
///                         },
///                     },
///                 },
///                 new Cloudflare.Inputs.TunnelConfigConfigIngressRuleArgs
///                 {
///                     Service = "https://10.0.0.3:8081",
///                 },
///             },
///         },
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		exampleTunnel, err := cloudflare.NewTunnel(ctx, "exampleTunnel", &cloudflare.TunnelArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:      pulumi.String("example_tunnel"),
/// 			Secret:    pulumi.String("<32 character secret>"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		_, err = cloudflare.NewTunnelConfig(ctx, "exampleConfig", &cloudflare.TunnelConfigArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			TunnelId:  exampleTunnel.ID(),
/// 			Config: &cloudflare.TunnelConfigConfigArgs{
/// 				WarpRouting: &cloudflare.TunnelConfigConfigWarpRoutingArgs{
/// 					Enabled: pulumi.Bool(true),
/// 				},
/// 				OriginRequest: &cloudflare.TunnelConfigConfigOriginRequestArgs{
/// 					ConnectTimeout:         pulumi.String("1m0s"),
/// 					TlsTimeout:             pulumi.String("1m0s"),
/// 					TcpKeepAlive:           pulumi.String("1m0s"),
/// 					NoHappyEyeballs:        pulumi.Bool(false),
/// 					KeepAliveConnections:   pulumi.Int(1024),
/// 					KeepAliveTimeout:       pulumi.String("1m0s"),
/// 					HttpHostHeader:         pulumi.String("baz"),
/// 					OriginServerName:       pulumi.String("foobar"),
/// 					CaPool:                 pulumi.String("/path/to/unsigned/ca/pool"),
/// 					NoTlsVerify:            pulumi.Bool(false),
/// 					DisableChunkedEncoding: pulumi.Bool(false),
/// 					BastionMode:            pulumi.Bool(false),
/// 					ProxyAddress:           pulumi.String("10.0.0.1"),
/// 					ProxyPort:              pulumi.Int(8123),
/// 					ProxyType:              pulumi.String("socks"),
/// 					IpRules: cloudflare.TunnelConfigConfigOriginRequestIpRuleArray{
/// 						&cloudflare.TunnelConfigConfigOriginRequestIpRuleArgs{
/// 							Prefix: pulumi.String("/web"),
/// 							Ports: pulumi.IntArray{
/// 								pulumi.Int(80),
/// 								pulumi.Int(443),
/// 							},
/// 							Allow: pulumi.Bool(false),
/// 						},
/// 					},
/// 				},
/// 				IngressRules: cloudflare.TunnelConfigConfigIngressRuleArray{
/// 					&cloudflare.TunnelConfigConfigIngressRuleArgs{
/// 						Hostname: pulumi.String("foo"),
/// 						Path:     pulumi.String("/bar"),
/// 						Service:  pulumi.String("http://10.0.0.2:8080"),
/// 						OriginRequest: &cloudflare.TunnelConfigConfigIngressRuleOriginRequestArgs{
/// 							ConnectTimeout: pulumi.String("2m0s"),
/// 							Access: &cloudflare.TunnelConfigConfigIngressRuleOriginRequestAccessArgs{
/// 								Required: pulumi.Bool(true),
/// 								TeamName: pulumi.String("terraform"),
/// 								AudTags: pulumi.StringArray{
/// 									pulumi.String("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"),
/// 								},
/// 							},
/// 						},
/// 					},
/// 					&cloudflare.TunnelConfigConfigIngressRuleArgs{
/// 						Service: pulumi.String("https://10.0.0.3:8081"),
/// 					},
/// 				},
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.Tunnel;
/// import com.pulumi.cloudflare.TunnelArgs;
/// import com.pulumi.cloudflare.TunnelConfig;
/// import com.pulumi.cloudflare.TunnelConfigArgs;
/// import com.pulumi.cloudflare.inputs.TunnelConfigConfigArgs;
/// import com.pulumi.cloudflare.inputs.TunnelConfigConfigWarpRoutingArgs;
/// import com.pulumi.cloudflare.inputs.TunnelConfigConfigOriginRequestArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var exampleTunnel = new Tunnel("exampleTunnel", TunnelArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("example_tunnel")
///             .secret("<32 character secret>")
///             .build());
///
///         var exampleConfig = new TunnelConfig("exampleConfig", TunnelConfigArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .tunnelId(exampleTunnel.id())
///             .config(TunnelConfigConfigArgs.builder()
///                 .warpRouting(TunnelConfigConfigWarpRoutingArgs.builder()
///                     .enabled(true)
///                     .build())
///                 .originRequest(TunnelConfigConfigOriginRequestArgs.builder()
///                     .connectTimeout("1m0s")
///                     .tlsTimeout("1m0s")
///                     .tcpKeepAlive("1m0s")
///                     .noHappyEyeballs(false)
///                     .keepAliveConnections(1024)
///                     .keepAliveTimeout("1m0s")
///                     .httpHostHeader("baz")
///                     .originServerName("foobar")
///                     .caPool("/path/to/unsigned/ca/pool")
///                     .noTlsVerify(false)
///                     .disableChunkedEncoding(false)
///                     .bastionMode(false)
///                     .proxyAddress("10.0.0.1")
///                     .proxyPort("8123")
///                     .proxyType("socks")
///                     .ipRules(TunnelConfigConfigOriginRequestIpRuleArgs.builder()
///                         .prefix("/web")
///                         .ports(                        
///                             80,
///                             443)
///                         .allow(false)
///                         .build())
///                     .build())
///                 .ingressRules(                
///                     TunnelConfigConfigIngressRuleArgs.builder()
///                         .hostname("foo")
///                         .path("/bar")
///                         .service("http://10.0.0.2:8080")
///                         .originRequest(TunnelConfigConfigIngressRuleOriginRequestArgs.builder()
///                             .connectTimeout("2m0s")
///                             .access(TunnelConfigConfigIngressRuleOriginRequestAccessArgs.builder()
///                                 .required(true)
///                                 .teamName("terraform")
///                                 .audTags("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
///                                 .build())
///                             .build())
///                         .build(),
///                     TunnelConfigConfigIngressRuleArgs.builder()
///                         .service("https://10.0.0.3:8081")
///                         .build())
///                 .build())
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   exampleTunnel:
///     type: cloudflare:Tunnel
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       name: example_tunnel
///       secret: <32 character secret>
///   exampleConfig:
///     type: cloudflare:TunnelConfig
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       tunnelId: ${exampleTunnel.id}
///       config:
///         warpRouting:
///           enabled: true
///         originRequest:
///           connectTimeout: 1m0s
///           tlsTimeout: 1m0s
///           tcpKeepAlive: 1m0s
///           noHappyEyeballs: false
///           keepAliveConnections: 1024
///           keepAliveTimeout: 1m0s
///           httpHostHeader: baz
///           originServerName: foobar
///           caPool: /path/to/unsigned/ca/pool
///           noTlsVerify: false
///           disableChunkedEncoding: false
///           bastionMode: false
///           proxyAddress: 10.0.0.1
///           proxyPort: '8123'
///           proxyType: socks
///           ipRules:
///             - prefix: /web
///               ports:
///                 - 80
///                 - 443
///               allow: false
///         ingressRules:
///           - hostname: foo
///             path: /bar
///             service: http://10.0.0.2:8080
///             originRequest:
///               connectTimeout: 2m0s
///               access:
///                 required: true
///                 teamName: terraform
///                 audTags:
///                   - AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
///           - service: https://10.0.0.3:8081
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/tunnelConfig:TunnelConfig example <account_id>/<tunnel_id>
/// ```
///
pub mod tunnel_config {

    pub struct TunnelConfigArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Configuration block for Tunnel Configuration.
        pub config: pulumi_wasm_rust::Output<crate::types::TunnelConfigConfig>,
        /// Identifier of the Tunnel to target for this configuration.
        pub tunnel_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct TunnelConfigResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Configuration block for Tunnel Configuration.
        pub config: pulumi_wasm_rust::Output<crate::types::TunnelConfigConfig>,
        /// Identifier of the Tunnel to target for this configuration.
        pub tunnel_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn tunnel_config(name: &str, args: TunnelConfigArgs) -> TunnelConfigResult {
        let result = crate::bindings::pulumi::cloudflare::tunnel_config::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::tunnel_config::Args {
                account_id: args.account_id.get_inner(),
                config: args.config.get_inner(),
                tunnel_id: args.tunnel_id.get_inner(),
            },
        );

        TunnelConfigResult {
            account_id: crate::into_domain(result.account_id),
            config: crate::into_domain(result.config),
            tunnel_id: crate::into_domain(result.tunnel_id),
        }
    }
}

/// Provides a resource, that manages Cloudflare tunnel routes for Zero
/// Trust. Tunnel routes are used to direct IP traffic through
/// Cloudflare Tunnels.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// // Tunnel route
/// const exampleTunnelRoute = new cloudflare.TunnelRoute("exampleTunnelRoute", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     tunnelId: "f70ff985-a4ef-4643-bbbc-4a0ed4fc8415",
///     network: "192.0.2.24/32",
///     comment: "New tunnel route for documentation",
///     virtualNetworkId: "bdc39a3c-3104-4c23-8ac0-9f455dda691a",
/// });
/// // Tunnel with tunnel route
/// const tunnel = new cloudflare.Tunnel("tunnel", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "my_tunnel",
///     secret: "AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=",
/// });
/// const exampleIndex_tunnelRouteTunnelRoute = new cloudflare.TunnelRoute("exampleIndex/tunnelRouteTunnelRoute", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     tunnelId: tunnel.id,
///     network: "192.0.2.24/32",
///     comment: "New tunnel route for documentation",
///     virtualNetworkId: "bdc39a3c-3104-4c23-8ac0-9f455dda691a",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// # Tunnel route
/// example_tunnel_route = cloudflare.TunnelRoute("exampleTunnelRoute",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     tunnel_id="f70ff985-a4ef-4643-bbbc-4a0ed4fc8415",
///     network="192.0.2.24/32",
///     comment="New tunnel route for documentation",
///     virtual_network_id="bdc39a3c-3104-4c23-8ac0-9f455dda691a")
/// # Tunnel with tunnel route
/// tunnel = cloudflare.Tunnel("tunnel",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="my_tunnel",
///     secret="AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=")
/// example_index_tunnel_route_tunnel_route = cloudflare.TunnelRoute("exampleIndex/tunnelRouteTunnelRoute",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     tunnel_id=tunnel.id,
///     network="192.0.2.24/32",
///     comment="New tunnel route for documentation",
///     virtual_network_id="bdc39a3c-3104-4c23-8ac0-9f455dda691a")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     // Tunnel route
///     var exampleTunnelRoute = new Cloudflare.TunnelRoute("exampleTunnelRoute", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         TunnelId = "f70ff985-a4ef-4643-bbbc-4a0ed4fc8415",
///         Network = "192.0.2.24/32",
///         Comment = "New tunnel route for documentation",
///         VirtualNetworkId = "bdc39a3c-3104-4c23-8ac0-9f455dda691a",
///     });
///
///     // Tunnel with tunnel route
///     var tunnel = new Cloudflare.Tunnel("tunnel", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "my_tunnel",
///         Secret = "AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=",
///     });
///
///     var exampleIndex_tunnelRouteTunnelRoute = new Cloudflare.TunnelRoute("exampleIndex/tunnelRouteTunnelRoute", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         TunnelId = tunnel.Id,
///         Network = "192.0.2.24/32",
///         Comment = "New tunnel route for documentation",
///         VirtualNetworkId = "bdc39a3c-3104-4c23-8ac0-9f455dda691a",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// Tunnel route
/// 		_, err := cloudflare.NewTunnelRoute(ctx, "exampleTunnelRoute", &cloudflare.TunnelRouteArgs{
/// 			AccountId:        pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			TunnelId:         pulumi.String("f70ff985-a4ef-4643-bbbc-4a0ed4fc8415"),
/// 			Network:          pulumi.String("192.0.2.24/32"),
/// 			Comment:          pulumi.String("New tunnel route for documentation"),
/// 			VirtualNetworkId: pulumi.String("bdc39a3c-3104-4c23-8ac0-9f455dda691a"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// Tunnel with tunnel route
/// 		tunnel, err := cloudflare.NewTunnel(ctx, "tunnel", &cloudflare.TunnelArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:      pulumi.String("my_tunnel"),
/// 			Secret:    pulumi.String("AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg="),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		_, err = cloudflare.NewTunnelRoute(ctx, "exampleIndex/tunnelRouteTunnelRoute", &cloudflare.TunnelRouteArgs{
/// 			AccountId:        pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			TunnelId:         tunnel.ID(),
/// 			Network:          pulumi.String("192.0.2.24/32"),
/// 			Comment:          pulumi.String("New tunnel route for documentation"),
/// 			VirtualNetworkId: pulumi.String("bdc39a3c-3104-4c23-8ac0-9f455dda691a"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.TunnelRoute;
/// import com.pulumi.cloudflare.TunnelRouteArgs;
/// import com.pulumi.cloudflare.Tunnel;
/// import com.pulumi.cloudflare.TunnelArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // Tunnel route
///         var exampleTunnelRoute = new TunnelRoute("exampleTunnelRoute", TunnelRouteArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .tunnelId("f70ff985-a4ef-4643-bbbc-4a0ed4fc8415")
///             .network("192.0.2.24/32")
///             .comment("New tunnel route for documentation")
///             .virtualNetworkId("bdc39a3c-3104-4c23-8ac0-9f455dda691a")
///             .build());
///
///         // Tunnel with tunnel route
///         var tunnel = new Tunnel("tunnel", TunnelArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("my_tunnel")
///             .secret("AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=")
///             .build());
///
///         var exampleIndex_tunnelRouteTunnelRoute = new TunnelRoute("exampleIndex/tunnelRouteTunnelRoute", TunnelRouteArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .tunnelId(tunnel.id())
///             .network("192.0.2.24/32")
///             .comment("New tunnel route for documentation")
///             .virtualNetworkId("bdc39a3c-3104-4c23-8ac0-9f455dda691a")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # Tunnel route
///   exampleTunnelRoute:
///     type: cloudflare:TunnelRoute
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       tunnelId: f70ff985-a4ef-4643-bbbc-4a0ed4fc8415
///       network: 192.0.2.24/32
///       comment: New tunnel route for documentation
///       virtualNetworkId: bdc39a3c-3104-4c23-8ac0-9f455dda691a
///   # Tunnel with tunnel route
///   tunnel:
///     type: cloudflare:Tunnel
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       name: my_tunnel
///       secret: AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=
///   exampleIndex/tunnelRouteTunnelRoute:
///     type: cloudflare:TunnelRoute
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       tunnelId: ${tunnel.id}
///       network: 192.0.2.24/32
///       comment: New tunnel route for documentation
///       virtualNetworkId: bdc39a3c-3104-4c23-8ac0-9f455dda691a
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/tunnelRoute:TunnelRoute example <account_id>/<network_cidr>/<virtual_network_id>
/// ```
///
pub mod tunnel_route {

    pub struct TunnelRouteArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Description of the tunnel route.
        pub comment: pulumi_wasm_rust::Output<Option<String>>,
        /// The IPv4 or IPv6 network that should use this tunnel route, in CIDR notation.
        pub network: pulumi_wasm_rust::Output<String>,
        /// The ID of the tunnel that will service the tunnel route.
        pub tunnel_id: pulumi_wasm_rust::Output<String>,
        /// The ID of the virtual network for which this route is being added; uses the default virtual network of the account if none is provided. **Modifying this attribute will force creation of a new resource.**
        pub virtual_network_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct TunnelRouteResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Description of the tunnel route.
        pub comment: pulumi_wasm_rust::Output<Option<String>>,
        /// The IPv4 or IPv6 network that should use this tunnel route, in CIDR notation.
        pub network: pulumi_wasm_rust::Output<String>,
        /// The ID of the tunnel that will service the tunnel route.
        pub tunnel_id: pulumi_wasm_rust::Output<String>,
        /// The ID of the virtual network for which this route is being added; uses the default virtual network of the account if none is provided. **Modifying this attribute will force creation of a new resource.**
        pub virtual_network_id: pulumi_wasm_rust::Output<Option<String>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn tunnel_route(name: &str, args: TunnelRouteArgs) -> TunnelRouteResult {
        let result = crate::bindings::pulumi::cloudflare::tunnel_route::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::tunnel_route::Args {
                account_id: args.account_id.get_inner(),
                comment: args.comment.get_inner(),
                network: args.network.get_inner(),
                tunnel_id: args.tunnel_id.get_inner(),
                virtual_network_id: args.virtual_network_id.get_inner(),
            },
        );

        TunnelRouteResult {
            account_id: crate::into_domain(result.account_id),
            comment: crate::into_domain(result.comment),
            network: crate::into_domain(result.network),
            tunnel_id: crate::into_domain(result.tunnel_id),
            virtual_network_id: crate::into_domain(result.virtual_network_id),
        }
    }
}

/// Provides a resource, that manages Cloudflare tunnel virtual networks
/// for Zero Trust. Tunnel virtual networks are used for segregation of
/// Tunnel IP Routes via Virtualized Networks to handle overlapping
/// private IPs in your origins.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.TunnelVirtualNetwork("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     comment: "New tunnel virtual network for documentation",
///     name: "vnet-for-documentation",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.TunnelVirtualNetwork("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     comment="New tunnel virtual network for documentation",
///     name="vnet-for-documentation")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.TunnelVirtualNetwork("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Comment = "New tunnel virtual network for documentation",
///         Name = "vnet-for-documentation",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewTunnelVirtualNetwork(ctx, "example", &cloudflare.TunnelVirtualNetworkArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Comment:   pulumi.String("New tunnel virtual network for documentation"),
/// 			Name:      pulumi.String("vnet-for-documentation"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.TunnelVirtualNetwork;
/// import com.pulumi.cloudflare.TunnelVirtualNetworkArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new TunnelVirtualNetwork("example", TunnelVirtualNetworkArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .comment("New tunnel virtual network for documentation")
///             .name("vnet-for-documentation")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:TunnelVirtualNetwork
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       comment: New tunnel virtual network for documentation
///       name: vnet-for-documentation
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/tunnelVirtualNetwork:TunnelVirtualNetwork example <account_id>/<vnet_id>
/// ```
///
pub mod tunnel_virtual_network {

    pub struct TunnelVirtualNetworkArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Description of the tunnel virtual network.
        pub comment: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether this virtual network is the default one for the account. This means IP Routes belong to this virtual network and Teams Clients in the account route through this virtual network, unless specified otherwise for each case.
        pub is_default_network: pulumi_wasm_rust::Output<Option<bool>>,
        /// A user-friendly name chosen when the virtual network is created.
        pub name: pulumi_wasm_rust::Output<String>,
    }

    pub struct TunnelVirtualNetworkResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Description of the tunnel virtual network.
        pub comment: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether this virtual network is the default one for the account. This means IP Routes belong to this virtual network and Teams Clients in the account route through this virtual network, unless specified otherwise for each case.
        pub is_default_network: pulumi_wasm_rust::Output<Option<bool>>,
        /// A user-friendly name chosen when the virtual network is created.
        pub name: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn tunnel_virtual_network(
        name: &str,
        args: TunnelVirtualNetworkArgs,
    ) -> TunnelVirtualNetworkResult {
        let result = crate::bindings::pulumi::cloudflare::tunnel_virtual_network::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::tunnel_virtual_network::Args {
                account_id: args.account_id.get_inner(),
                comment: args.comment.get_inner(),
                is_default_network: args.is_default_network.get_inner(),
                name: args.name.get_inner(),
            },
        );

        TunnelVirtualNetworkResult {
            account_id: crate::into_domain(result.account_id),
            comment: crate::into_domain(result.comment),
            is_default_network: crate::into_domain(result.is_default_network),
            name: crate::into_domain(result.name),
        }
    }
}

/// The [Turnstile Widget](https://developers.cloudflare.com/turnstile/) resource allows you to manage Cloudflare Turnstile Widgets.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.TurnstileWidget("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     botFightMode: false,
///     domains: ["example.com"],
///     mode: "invisible",
///     name: "example widget",
///     region: "world",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.TurnstileWidget("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     bot_fight_mode=False,
///     domains=["example.com"],
///     mode="invisible",
///     name="example widget",
///     region="world")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.TurnstileWidget("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         BotFightMode = false,
///         Domains = new[]
///         {
///             "example.com",
///         },
///         Mode = "invisible",
///         Name = "example widget",
///         Region = "world",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewTurnstileWidget(ctx, "example", &cloudflare.TurnstileWidgetArgs{
/// 			AccountId:    pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			BotFightMode: pulumi.Bool(false),
/// 			Domains: pulumi.StringArray{
/// 				pulumi.String("example.com"),
/// 			},
/// 			Mode:   pulumi.String("invisible"),
/// 			Name:   pulumi.String("example widget"),
/// 			Region: pulumi.String("world"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.TurnstileWidget;
/// import com.pulumi.cloudflare.TurnstileWidgetArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new TurnstileWidget("example", TurnstileWidgetArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .botFightMode(false)
///             .domains("example.com")
///             .mode("invisible")
///             .name("example widget")
///             .region("world")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:TurnstileWidget
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       botFightMode: false
///       domains:
///         - example.com
///       mode: invisible
///       name: example widget
///       region: world
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/turnstileWidget:TurnstileWidget example <account_id>/<site_key>
/// ```
///
pub mod turnstile_widget {

    pub struct TurnstileWidgetArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// If bot*fight*mode is set to true, Cloudflare issues computationally expensive challenges in response to malicious bots (Enterprise only).
        pub bot_fight_mode: pulumi_wasm_rust::Output<Option<bool>>,
        /// Domains where the widget is deployed
        pub domains: pulumi_wasm_rust::Output<Vec<String>>,
        /// Widget Mode. Available values: `non-interactive`, `invisible`, `managed`
        pub mode: pulumi_wasm_rust::Output<String>,
        /// Human readable widget name.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Do not show any Cloudflare branding on the widget (Enterprise only).
        pub offlabel: pulumi_wasm_rust::Output<Option<bool>>,
        /// Region where this widget can be used.
        pub region: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct TurnstileWidgetResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// If bot*fight*mode is set to true, Cloudflare issues computationally expensive challenges in response to malicious bots (Enterprise only).
        pub bot_fight_mode: pulumi_wasm_rust::Output<bool>,
        /// Domains where the widget is deployed
        pub domains: pulumi_wasm_rust::Output<Vec<String>>,
        /// Widget Mode. Available values: `non-interactive`, `invisible`, `managed`
        pub mode: pulumi_wasm_rust::Output<String>,
        /// Human readable widget name.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Do not show any Cloudflare branding on the widget (Enterprise only).
        pub offlabel: pulumi_wasm_rust::Output<bool>,
        /// Region where this widget can be used.
        pub region: pulumi_wasm_rust::Output<String>,
        /// Secret key for this widget.
        pub secret: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn turnstile_widget(name: &str, args: TurnstileWidgetArgs) -> TurnstileWidgetResult {
        let result = crate::bindings::pulumi::cloudflare::turnstile_widget::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::turnstile_widget::Args {
                account_id: args.account_id.get_inner(),
                bot_fight_mode: args.bot_fight_mode.get_inner(),
                domains: args.domains.get_inner(),
                mode: args.mode.get_inner(),
                name: args.name.get_inner(),
                offlabel: args.offlabel.get_inner(),
                region: args.region.get_inner(),
            },
        );

        TurnstileWidgetResult {
            account_id: crate::into_domain(result.account_id),
            bot_fight_mode: crate::into_domain(result.bot_fight_mode),
            domains: crate::into_domain(result.domains),
            mode: crate::into_domain(result.mode),
            name: crate::into_domain(result.name),
            offlabel: crate::into_domain(result.offlabel),
            region: crate::into_domain(result.region),
            secret: crate::into_domain(result.secret),
        }
    }
}

/// Provides a resource to manage URL Normalization Settings.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.UrlNormalizationSettings("example", {
///     scope: "incoming",
///     type: "cloudflare",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.UrlNormalizationSettings("example",
///     scope="incoming",
///     type="cloudflare",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.UrlNormalizationSettings("example", new()
///     {
///         Scope = "incoming",
///         Type = "cloudflare",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewUrlNormalizationSettings(ctx, "example", &cloudflare.UrlNormalizationSettingsArgs{
/// 			Scope:  pulumi.String("incoming"),
/// 			Type:   pulumi.String("cloudflare"),
/// 			ZoneId: pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.UrlNormalizationSettings;
/// import com.pulumi.cloudflare.UrlNormalizationSettingsArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new UrlNormalizationSettings("example", UrlNormalizationSettingsArgs.builder()        
///             .scope("incoming")
///             .type("cloudflare")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:UrlNormalizationSettings
///     properties:
///       scope: incoming
///       type: cloudflare
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
pub mod url_normalization_settings {

    pub struct UrlNormalizationSettingsArgs {
        /// The scope of the URL normalization.
        pub scope: pulumi_wasm_rust::Output<String>,
        /// The type of URL normalization performed by Cloudflare.
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct UrlNormalizationSettingsResult {
        /// The scope of the URL normalization.
        pub scope: pulumi_wasm_rust::Output<String>,
        /// The type of URL normalization performed by Cloudflare.
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn url_normalization_settings(
        name: &str,
        args: UrlNormalizationSettingsArgs,
    ) -> UrlNormalizationSettingsResult {
        let result = crate::bindings::pulumi::cloudflare::url_normalization_settings::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::url_normalization_settings::Args {
                scope: args.scope.get_inner(),
                type_: args.type_.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        UrlNormalizationSettingsResult {
            scope: crate::into_domain(result.scope),
            type_: crate::into_domain(result.type_),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a resource to manage User Agent Blocking Rules.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example1 = new cloudflare.UserAgentBlockingRule("example1", {
///     configuration: {
///         target: "ua",
///         value: "Chrome",
///     },
///     description: "My description 1",
///     mode: "js_challenge",
///     paused: false,
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// const example2 = new cloudflare.UserAgentBlockingRule("example2", {
///     configuration: {
///         target: "ua",
///         value: "Mozilla",
///     },
///     description: "My description 22",
///     mode: "challenge",
///     paused: true,
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example1 = cloudflare.UserAgentBlockingRule("example1",
///     configuration=cloudflare.UserAgentBlockingRuleConfigurationArgs(
///         target="ua",
///         value="Chrome",
///     ),
///     description="My description 1",
///     mode="js_challenge",
///     paused=False,
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// example2 = cloudflare.UserAgentBlockingRule("example2",
///     configuration=cloudflare.UserAgentBlockingRuleConfigurationArgs(
///         target="ua",
///         value="Mozilla",
///     ),
///     description="My description 22",
///     mode="challenge",
///     paused=True,
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example1 = new Cloudflare.UserAgentBlockingRule("example1", new()
///     {
///         Configuration = new Cloudflare.Inputs.UserAgentBlockingRuleConfigurationArgs
///         {
///             Target = "ua",
///             Value = "Chrome",
///         },
///         Description = "My description 1",
///         Mode = "js_challenge",
///         Paused = false,
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
///     var example2 = new Cloudflare.UserAgentBlockingRule("example2", new()
///     {
///         Configuration = new Cloudflare.Inputs.UserAgentBlockingRuleConfigurationArgs
///         {
///             Target = "ua",
///             Value = "Mozilla",
///         },
///         Description = "My description 22",
///         Mode = "challenge",
///         Paused = true,
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewUserAgentBlockingRule(ctx, "example1", &cloudflare.UserAgentBlockingRuleArgs{
/// 			Configuration: &cloudflare.UserAgentBlockingRuleConfigurationArgs{
/// 				Target: pulumi.String("ua"),
/// 				Value:  pulumi.String("Chrome"),
/// 			},
/// 			Description: pulumi.String("My description 1"),
/// 			Mode:        pulumi.String("js_challenge"),
/// 			Paused:      pulumi.Bool(false),
/// 			ZoneId:      pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		_, err = cloudflare.NewUserAgentBlockingRule(ctx, "example2", &cloudflare.UserAgentBlockingRuleArgs{
/// 			Configuration: &cloudflare.UserAgentBlockingRuleConfigurationArgs{
/// 				Target: pulumi.String("ua"),
/// 				Value:  pulumi.String("Mozilla"),
/// 			},
/// 			Description: pulumi.String("My description 22"),
/// 			Mode:        pulumi.String("challenge"),
/// 			Paused:      pulumi.Bool(true),
/// 			ZoneId:      pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.UserAgentBlockingRule;
/// import com.pulumi.cloudflare.UserAgentBlockingRuleArgs;
/// import com.pulumi.cloudflare.inputs.UserAgentBlockingRuleConfigurationArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example1 = new UserAgentBlockingRule("example1", UserAgentBlockingRuleArgs.builder()        
///             .configuration(UserAgentBlockingRuleConfigurationArgs.builder()
///                 .target("ua")
///                 .value("Chrome")
///                 .build())
///             .description("My description 1")
///             .mode("js_challenge")
///             .paused(false)
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///         var example2 = new UserAgentBlockingRule("example2", UserAgentBlockingRuleArgs.builder()        
///             .configuration(UserAgentBlockingRuleConfigurationArgs.builder()
///                 .target("ua")
///                 .value("Mozilla")
///                 .build())
///             .description("My description 22")
///             .mode("challenge")
///             .paused(true)
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example1:
///     type: cloudflare:UserAgentBlockingRule
///     properties:
///       configuration:
///         target: ua
///         value: Chrome
///       description: My description 1
///       mode: js_challenge
///       paused: false
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///   example2:
///     type: cloudflare:UserAgentBlockingRule
///     properties:
///       configuration:
///         target: ua
///         value: Mozilla
///       description: My description 22
///       mode: challenge
///       paused: true
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/userAgentBlockingRule:UserAgentBlockingRule example <zone_id>/<user_agent_blocking_rule_id>
/// ```
///
pub mod user_agent_blocking_rule {

    pub struct UserAgentBlockingRuleArgs {
        /// The configuration object for the current rule.
        pub configuration:
            pulumi_wasm_rust::Output<crate::types::UserAgentBlockingRuleConfiguration>,
        /// An informative summary of the rule.
        pub description: pulumi_wasm_rust::Output<String>,
        /// The action to apply to a matched request. Available values: `block`, `challenge`, `js_challenge`, `managed_challenge`.
        pub mode: pulumi_wasm_rust::Output<String>,
        /// When true, indicates that the rule is currently paused.
        pub paused: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct UserAgentBlockingRuleResult {
        /// The configuration object for the current rule.
        pub configuration:
            pulumi_wasm_rust::Output<crate::types::UserAgentBlockingRuleConfiguration>,
        /// An informative summary of the rule.
        pub description: pulumi_wasm_rust::Output<String>,
        /// The action to apply to a matched request. Available values: `block`, `challenge`, `js_challenge`, `managed_challenge`.
        pub mode: pulumi_wasm_rust::Output<String>,
        /// When true, indicates that the rule is currently paused.
        pub paused: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn user_agent_blocking_rule(
        name: &str,
        args: UserAgentBlockingRuleArgs,
    ) -> UserAgentBlockingRuleResult {
        let result = crate::bindings::pulumi::cloudflare::user_agent_blocking_rule::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::user_agent_blocking_rule::Args {
                configuration: args.configuration.get_inner(),
                description: args.description.get_inner(),
                mode: args.mode.get_inner(),
                paused: args.paused.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        UserAgentBlockingRuleResult {
            configuration: crate::into_domain(result.configuration),
            description: crate::into_domain(result.description),
            mode: crate::into_domain(result.mode),
            paused: crate::into_domain(result.paused),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare Waiting Room resource.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// // Waiting Room
/// const example = new cloudflare.WaitingRoom("example", {
///     additionalRoutes: [
///         {
///             host: "shop1.example.com",
///             path: "/example-path",
///         },
///         {
///             host: "shop2.example.com",
///         },
///     ],
///     cookieSuffix: "queue1",
///     host: "foo.example.com",
///     name: "foo",
///     newUsersPerMinute: 200,
///     path: "/",
///     queueingStatusCode: 200,
///     totalActiveUsers: 200,
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// # Waiting Room
/// example = cloudflare.WaitingRoom("example",
///     additional_routes=[
///         cloudflare.WaitingRoomAdditionalRouteArgs(
///             host="shop1.example.com",
///             path="/example-path",
///         ),
///         cloudflare.WaitingRoomAdditionalRouteArgs(
///             host="shop2.example.com",
///         ),
///     ],
///     cookie_suffix="queue1",
///     host="foo.example.com",
///     name="foo",
///     new_users_per_minute=200,
///     path="/",
///     queueing_status_code=200,
///     total_active_users=200,
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     // Waiting Room
///     var example = new Cloudflare.WaitingRoom("example", new()
///     {
///         AdditionalRoutes = new[]
///         {
///             new Cloudflare.Inputs.WaitingRoomAdditionalRouteArgs
///             {
///                 Host = "shop1.example.com",
///                 Path = "/example-path",
///             },
///             new Cloudflare.Inputs.WaitingRoomAdditionalRouteArgs
///             {
///                 Host = "shop2.example.com",
///             },
///         },
///         CookieSuffix = "queue1",
///         Host = "foo.example.com",
///         Name = "foo",
///         NewUsersPerMinute = 200,
///         Path = "/",
///         QueueingStatusCode = 200,
///         TotalActiveUsers = 200,
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// Waiting Room
/// 		_, err := cloudflare.NewWaitingRoom(ctx, "example", &cloudflare.WaitingRoomArgs{
/// 			AdditionalRoutes: cloudflare.WaitingRoomAdditionalRouteArray{
/// 				&cloudflare.WaitingRoomAdditionalRouteArgs{
/// 					Host: pulumi.String("shop1.example.com"),
/// 					Path: pulumi.String("/example-path"),
/// 				},
/// 				&cloudflare.WaitingRoomAdditionalRouteArgs{
/// 					Host: pulumi.String("shop2.example.com"),
/// 				},
/// 			},
/// 			CookieSuffix:       pulumi.String("queue1"),
/// 			Host:               pulumi.String("foo.example.com"),
/// 			Name:               pulumi.String("foo"),
/// 			NewUsersPerMinute:  pulumi.Int(200),
/// 			Path:               pulumi.String("/"),
/// 			QueueingStatusCode: pulumi.Int(200),
/// 			TotalActiveUsers:   pulumi.Int(200),
/// 			ZoneId:             pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.WaitingRoom;
/// import com.pulumi.cloudflare.WaitingRoomArgs;
/// import com.pulumi.cloudflare.inputs.WaitingRoomAdditionalRouteArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // Waiting Room
///         var example = new WaitingRoom("example", WaitingRoomArgs.builder()        
///             .additionalRoutes(            
///                 WaitingRoomAdditionalRouteArgs.builder()
///                     .host("shop1.example.com")
///                     .path("/example-path")
///                     .build(),
///                 WaitingRoomAdditionalRouteArgs.builder()
///                     .host("shop2.example.com")
///                     .build())
///             .cookieSuffix("queue1")
///             .host("foo.example.com")
///             .name("foo")
///             .newUsersPerMinute(200)
///             .path("/")
///             .queueingStatusCode(200)
///             .totalActiveUsers(200)
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # Waiting Room
///   example:
///     type: cloudflare:WaitingRoom
///     properties:
///       additionalRoutes:
///         - host: shop1.example.com
///           path: /example-path
///         - host: shop2.example.com
///       cookieSuffix: queue1
///       host: foo.example.com
///       name: foo
///       newUsersPerMinute: 200
///       path: /
///       queueingStatusCode: 200
///       totalActiveUsers: 200
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// Use the Zone ID and Waiting Room ID to import.
///
/// ```sh
/// $ pulumi import cloudflare:index/waitingRoom:WaitingRoom default <zone_id>/<waiting_room_id>
/// ```
///
pub mod waiting_room {

    pub struct WaitingRoomArgs {
        /// A list of additional hostname and paths combination to be applied on the waiting room.
        pub additional_routes:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::WaitingRoomAdditionalRoute>>>,
        /// A cookie suffix to be appended to the Cloudflare waiting room cookie name.
        pub cookie_suffix: pulumi_wasm_rust::Output<Option<String>>,
        /// This is a templated html file that will be rendered at the edge.
        pub custom_page_html: pulumi_wasm_rust::Output<Option<String>>,
        /// The language to use for the default waiting room page. Available values: `de-DE`, `es-ES`, `en-US`, `fr-FR`, `id-ID`, `it-IT`, `ja-JP`, `ko-KR`, `nl-NL`, `pl-PL`, `pt-BR`, `tr-TR`, `zh-CN`, `zh-TW`, `ru-RU`, `fa-IR`. Defaults to `en-US`.
        pub default_template_language: pulumi_wasm_rust::Output<Option<String>>,
        /// A description to add more details about the waiting room.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Disables automatic renewal of session cookies.
        pub disable_session_renewal: pulumi_wasm_rust::Output<Option<bool>>,
        /// The additional host name for which the waiting room to be applied on (no wildcards).
        pub host: pulumi_wasm_rust::Output<String>,
        /// If true, requests to the waiting room with the header `Accept: application/json` will receive a JSON response object.
        pub json_response_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// A unique name to identify the waiting room. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
        /// The number of new users that will be let into the route every minute.
        pub new_users_per_minute: pulumi_wasm_rust::Output<i32>,
        /// The path within the additional host to enable the waiting room on. Defaults to `/`.
        pub path: pulumi_wasm_rust::Output<Option<String>>,
        /// If queue_all is true, then all traffic will be sent to the waiting room.
        pub queue_all: pulumi_wasm_rust::Output<Option<bool>>,
        /// The queueing method used by the waiting room. Available values: `fifo`, `random`, `passthrough`, `reject`. Defaults to `fifo`.
        pub queueing_method: pulumi_wasm_rust::Output<Option<String>>,
        /// HTTP status code returned to a user while in the queue. Defaults to `200`.
        pub queueing_status_code: pulumi_wasm_rust::Output<Option<i32>>,
        /// Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the origin. Defaults to `5`.
        pub session_duration: pulumi_wasm_rust::Output<Option<i32>>,
        /// Suspends the waiting room.
        pub suspended: pulumi_wasm_rust::Output<Option<bool>>,
        /// The total number of active user sessions on the route at a point in time.
        pub total_active_users: pulumi_wasm_rust::Output<i32>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct WaitingRoomResult {
        /// A list of additional hostname and paths combination to be applied on the waiting room.
        pub additional_routes:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::WaitingRoomAdditionalRoute>>>,
        /// A cookie suffix to be appended to the Cloudflare waiting room cookie name.
        pub cookie_suffix: pulumi_wasm_rust::Output<Option<String>>,
        /// This is a templated html file that will be rendered at the edge.
        pub custom_page_html: pulumi_wasm_rust::Output<Option<String>>,
        /// The language to use for the default waiting room page. Available values: `de-DE`, `es-ES`, `en-US`, `fr-FR`, `id-ID`, `it-IT`, `ja-JP`, `ko-KR`, `nl-NL`, `pl-PL`, `pt-BR`, `tr-TR`, `zh-CN`, `zh-TW`, `ru-RU`, `fa-IR`. Defaults to `en-US`.
        pub default_template_language: pulumi_wasm_rust::Output<Option<String>>,
        /// A description to add more details about the waiting room.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Disables automatic renewal of session cookies.
        pub disable_session_renewal: pulumi_wasm_rust::Output<Option<bool>>,
        /// The additional host name for which the waiting room to be applied on (no wildcards).
        pub host: pulumi_wasm_rust::Output<String>,
        /// If true, requests to the waiting room with the header `Accept: application/json` will receive a JSON response object.
        pub json_response_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// A unique name to identify the waiting room. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
        /// The number of new users that will be let into the route every minute.
        pub new_users_per_minute: pulumi_wasm_rust::Output<i32>,
        /// The path within the additional host to enable the waiting room on. Defaults to `/`.
        pub path: pulumi_wasm_rust::Output<Option<String>>,
        /// If queue_all is true, then all traffic will be sent to the waiting room.
        pub queue_all: pulumi_wasm_rust::Output<Option<bool>>,
        /// The queueing method used by the waiting room. Available values: `fifo`, `random`, `passthrough`, `reject`. Defaults to `fifo`.
        pub queueing_method: pulumi_wasm_rust::Output<Option<String>>,
        /// HTTP status code returned to a user while in the queue. Defaults to `200`.
        pub queueing_status_code: pulumi_wasm_rust::Output<Option<i32>>,
        /// Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the origin. Defaults to `5`.
        pub session_duration: pulumi_wasm_rust::Output<Option<i32>>,
        /// Suspends the waiting room.
        pub suspended: pulumi_wasm_rust::Output<Option<bool>>,
        /// The total number of active user sessions on the route at a point in time.
        pub total_active_users: pulumi_wasm_rust::Output<i32>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn waiting_room(name: &str, args: WaitingRoomArgs) -> WaitingRoomResult {
        let result = crate::bindings::pulumi::cloudflare::waiting_room::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::waiting_room::Args {
                additional_routes: args.additional_routes.get_inner(),
                cookie_suffix: args.cookie_suffix.get_inner(),
                custom_page_html: args.custom_page_html.get_inner(),
                default_template_language: args.default_template_language.get_inner(),
                description: args.description.get_inner(),
                disable_session_renewal: args.disable_session_renewal.get_inner(),
                host: args.host.get_inner(),
                json_response_enabled: args.json_response_enabled.get_inner(),
                name: args.name.get_inner(),
                new_users_per_minute: args.new_users_per_minute.get_inner(),
                path: args.path.get_inner(),
                queue_all: args.queue_all.get_inner(),
                queueing_method: args.queueing_method.get_inner(),
                queueing_status_code: args.queueing_status_code.get_inner(),
                session_duration: args.session_duration.get_inner(),
                suspended: args.suspended.get_inner(),
                total_active_users: args.total_active_users.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        WaitingRoomResult {
            additional_routes: crate::into_domain(result.additional_routes),
            cookie_suffix: crate::into_domain(result.cookie_suffix),
            custom_page_html: crate::into_domain(result.custom_page_html),
            default_template_language: crate::into_domain(result.default_template_language),
            description: crate::into_domain(result.description),
            disable_session_renewal: crate::into_domain(result.disable_session_renewal),
            host: crate::into_domain(result.host),
            json_response_enabled: crate::into_domain(result.json_response_enabled),
            name: crate::into_domain(result.name),
            new_users_per_minute: crate::into_domain(result.new_users_per_minute),
            path: crate::into_domain(result.path),
            queue_all: crate::into_domain(result.queue_all),
            queueing_method: crate::into_domain(result.queueing_method),
            queueing_status_code: crate::into_domain(result.queueing_status_code),
            session_duration: crate::into_domain(result.session_duration),
            suspended: crate::into_domain(result.suspended),
            total_active_users: crate::into_domain(result.total_active_users),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare Waiting Room Event resource.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// // Waiting Room Event
/// const example = new cloudflare.WaitingRoomEvent("example", {
///     eventEndTime: "2006-01-02T20:04:05Z",
///     eventStartTime: "2006-01-02T15:04:05Z",
///     name: "foo",
///     waitingRoomId: "d41d8cd98f00b204e9800998ecf8427e",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// # Waiting Room Event
/// example = cloudflare.WaitingRoomEvent("example",
///     event_end_time="2006-01-02T20:04:05Z",
///     event_start_time="2006-01-02T15:04:05Z",
///     name="foo",
///     waiting_room_id="d41d8cd98f00b204e9800998ecf8427e",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     // Waiting Room Event
///     var example = new Cloudflare.WaitingRoomEvent("example", new()
///     {
///         EventEndTime = "2006-01-02T20:04:05Z",
///         EventStartTime = "2006-01-02T15:04:05Z",
///         Name = "foo",
///         WaitingRoomId = "d41d8cd98f00b204e9800998ecf8427e",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// Waiting Room Event
/// 		_, err := cloudflare.NewWaitingRoomEvent(ctx, "example", &cloudflare.WaitingRoomEventArgs{
/// 			EventEndTime:   pulumi.String("2006-01-02T20:04:05Z"),
/// 			EventStartTime: pulumi.String("2006-01-02T15:04:05Z"),
/// 			Name:           pulumi.String("foo"),
/// 			WaitingRoomId:  pulumi.String("d41d8cd98f00b204e9800998ecf8427e"),
/// 			ZoneId:         pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.WaitingRoomEvent;
/// import com.pulumi.cloudflare.WaitingRoomEventArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // Waiting Room Event
///         var example = new WaitingRoomEvent("example", WaitingRoomEventArgs.builder()        
///             .eventEndTime("2006-01-02T20:04:05Z")
///             .eventStartTime("2006-01-02T15:04:05Z")
///             .name("foo")
///             .waitingRoomId("d41d8cd98f00b204e9800998ecf8427e")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # Waiting Room Event
///   example:
///     type: cloudflare:WaitingRoomEvent
///     properties:
///       eventEndTime: 2006-01-02T20:04:05Z
///       eventStartTime: 2006-01-02T15:04:05Z
///       name: foo
///       waitingRoomId: d41d8cd98f00b204e9800998ecf8427e
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// Use the Zone ID, Waiting Room ID, and Event ID to import.
///
/// ```sh
/// $ pulumi import cloudflare:index/waitingRoomEvent:WaitingRoomEvent default <zone_id>/<waiting_room_id>/<waiting_room_event_id>
/// ```
///
pub mod waiting_room_event {

    pub struct WaitingRoomEventArgs {
        /// This is a templated html file that will be rendered at the edge.
        pub custom_page_html: pulumi_wasm_rust::Output<Option<String>>,
        /// A description to let users add more details about the event.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Disables automatic renewal of session cookies.
        pub disable_session_renewal: pulumi_wasm_rust::Output<Option<bool>>,
        /// ISO 8601 timestamp that marks the end of the event. **Modifying this attribute will force creation of a new resource.**
        pub event_end_time: pulumi_wasm_rust::Output<String>,
        /// ISO 8601 timestamp that marks the start of the event. Must occur at least 1 minute before `event_end_time`. **Modifying this attribute will force creation of a new resource.**
        pub event_start_time: pulumi_wasm_rust::Output<String>,
        /// A unique name to identify the event. Only alphanumeric characters, hyphens, and underscores are allowed. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
        /// The number of new users that will be let into the route every minute.
        pub new_users_per_minute: pulumi_wasm_rust::Output<Option<i32>>,
        /// ISO 8601 timestamp that marks when to begin queueing all users before the event starts. Must occur at least 5 minutes before `event_start_time`.
        pub prequeue_start_time: pulumi_wasm_rust::Output<Option<String>>,
        /// The queueing method used by the waiting room. Available values: `fifo`, `random`, `passthrough`, `reject`.
        pub queueing_method: pulumi_wasm_rust::Output<Option<String>>,
        /// Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the origin.
        pub session_duration: pulumi_wasm_rust::Output<Option<i32>>,
        /// Users in the prequeue will be shuffled randomly at the `event_start_time`. Requires that `prequeue_start_time` is not null. Defaults to `false`.
        pub shuffle_at_event_start: pulumi_wasm_rust::Output<Option<bool>>,
        /// If suspended, the event is ignored and traffic will be handled based on the waiting room configuration.
        pub suspended: pulumi_wasm_rust::Output<Option<bool>>,
        /// The total number of active user sessions on the route at a point in time.
        pub total_active_users: pulumi_wasm_rust::Output<Option<i32>>,
        /// The Waiting Room ID the event should apply to. **Modifying this attribute will force creation of a new resource.**
        pub waiting_room_id: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct WaitingRoomEventResult {
        /// Creation time.
        pub created_on: pulumi_wasm_rust::Output<String>,
        /// This is a templated html file that will be rendered at the edge.
        pub custom_page_html: pulumi_wasm_rust::Output<Option<String>>,
        /// A description to let users add more details about the event.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Disables automatic renewal of session cookies.
        pub disable_session_renewal: pulumi_wasm_rust::Output<Option<bool>>,
        /// ISO 8601 timestamp that marks the end of the event. **Modifying this attribute will force creation of a new resource.**
        pub event_end_time: pulumi_wasm_rust::Output<String>,
        /// ISO 8601 timestamp that marks the start of the event. Must occur at least 1 minute before `event_end_time`. **Modifying this attribute will force creation of a new resource.**
        pub event_start_time: pulumi_wasm_rust::Output<String>,
        /// Last modified time.
        pub modified_on: pulumi_wasm_rust::Output<String>,
        /// A unique name to identify the event. Only alphanumeric characters, hyphens, and underscores are allowed. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
        /// The number of new users that will be let into the route every minute.
        pub new_users_per_minute: pulumi_wasm_rust::Output<Option<i32>>,
        /// ISO 8601 timestamp that marks when to begin queueing all users before the event starts. Must occur at least 5 minutes before `event_start_time`.
        pub prequeue_start_time: pulumi_wasm_rust::Output<Option<String>>,
        /// The queueing method used by the waiting room. Available values: `fifo`, `random`, `passthrough`, `reject`.
        pub queueing_method: pulumi_wasm_rust::Output<Option<String>>,
        /// Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the origin.
        pub session_duration: pulumi_wasm_rust::Output<Option<i32>>,
        /// Users in the prequeue will be shuffled randomly at the `event_start_time`. Requires that `prequeue_start_time` is not null. Defaults to `false`.
        pub shuffle_at_event_start: pulumi_wasm_rust::Output<Option<bool>>,
        /// If suspended, the event is ignored and traffic will be handled based on the waiting room configuration.
        pub suspended: pulumi_wasm_rust::Output<Option<bool>>,
        /// The total number of active user sessions on the route at a point in time.
        pub total_active_users: pulumi_wasm_rust::Output<Option<i32>>,
        /// The Waiting Room ID the event should apply to. **Modifying this attribute will force creation of a new resource.**
        pub waiting_room_id: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn waiting_room_event(name: &str, args: WaitingRoomEventArgs) -> WaitingRoomEventResult {
        let result = crate::bindings::pulumi::cloudflare::waiting_room_event::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::waiting_room_event::Args {
                custom_page_html: args.custom_page_html.get_inner(),
                description: args.description.get_inner(),
                disable_session_renewal: args.disable_session_renewal.get_inner(),
                event_end_time: args.event_end_time.get_inner(),
                event_start_time: args.event_start_time.get_inner(),
                name: args.name.get_inner(),
                new_users_per_minute: args.new_users_per_minute.get_inner(),
                prequeue_start_time: args.prequeue_start_time.get_inner(),
                queueing_method: args.queueing_method.get_inner(),
                session_duration: args.session_duration.get_inner(),
                shuffle_at_event_start: args.shuffle_at_event_start.get_inner(),
                suspended: args.suspended.get_inner(),
                total_active_users: args.total_active_users.get_inner(),
                waiting_room_id: args.waiting_room_id.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        WaitingRoomEventResult {
            created_on: crate::into_domain(result.created_on),
            custom_page_html: crate::into_domain(result.custom_page_html),
            description: crate::into_domain(result.description),
            disable_session_renewal: crate::into_domain(result.disable_session_renewal),
            event_end_time: crate::into_domain(result.event_end_time),
            event_start_time: crate::into_domain(result.event_start_time),
            modified_on: crate::into_domain(result.modified_on),
            name: crate::into_domain(result.name),
            new_users_per_minute: crate::into_domain(result.new_users_per_minute),
            prequeue_start_time: crate::into_domain(result.prequeue_start_time),
            queueing_method: crate::into_domain(result.queueing_method),
            session_duration: crate::into_domain(result.session_duration),
            shuffle_at_event_start: crate::into_domain(result.shuffle_at_event_start),
            suspended: crate::into_domain(result.suspended),
            total_active_users: crate::into_domain(result.total_active_users),
            waiting_room_id: crate::into_domain(result.waiting_room_id),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare Waiting Room Rules resource.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.WaitingRoomRules("example", {
///     rules: [
///         {
///             action: "bypass_waiting_room",
///             description: "bypass ip list",
///             expression: "src.ip in {192.0.2.0 192.0.2.1}",
///             status: "enabled",
///         },
///         {
///             action: "bypass_waiting_room",
///             description: "bypass query string",
///             expression: "http.request.uri.query contains \"bypass=true\"",
///             status: "enabled",
///         },
///     ],
///     waitingRoomId: "d41d8cd98f00b204e9800998ecf8427e",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.WaitingRoomRules("example",
///     rules=[
///         cloudflare.WaitingRoomRulesRuleArgs(
///             action="bypass_waiting_room",
///             description="bypass ip list",
///             expression="src.ip in {192.0.2.0 192.0.2.1}",
///             status="enabled",
///         ),
///         cloudflare.WaitingRoomRulesRuleArgs(
///             action="bypass_waiting_room",
///             description="bypass query string",
///             expression="http.request.uri.query contains \"bypass=true\"",
///             status="enabled",
///         ),
///     ],
///     waiting_room_id="d41d8cd98f00b204e9800998ecf8427e",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.WaitingRoomRules("example", new()
///     {
///         Rules = new[]
///         {
///             new Cloudflare.Inputs.WaitingRoomRulesRuleArgs
///             {
///                 Action = "bypass_waiting_room",
///                 Description = "bypass ip list",
///                 Expression = "src.ip in {192.0.2.0 192.0.2.1}",
///                 Status = "enabled",
///             },
///             new Cloudflare.Inputs.WaitingRoomRulesRuleArgs
///             {
///                 Action = "bypass_waiting_room",
///                 Description = "bypass query string",
///                 Expression = "http.request.uri.query contains \"bypass=true\"",
///                 Status = "enabled",
///             },
///         },
///         WaitingRoomId = "d41d8cd98f00b204e9800998ecf8427e",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewWaitingRoomRules(ctx, "example", &cloudflare.WaitingRoomRulesArgs{
/// 			Rules: cloudflare.WaitingRoomRulesRuleArray{
/// 				&cloudflare.WaitingRoomRulesRuleArgs{
/// 					Action:      pulumi.String("bypass_waiting_room"),
/// 					Description: pulumi.String("bypass ip list"),
/// 					Expression:  pulumi.String("src.ip in {192.0.2.0 192.0.2.1}"),
/// 					Status:      pulumi.String("enabled"),
/// 				},
/// 				&cloudflare.WaitingRoomRulesRuleArgs{
/// 					Action:      pulumi.String("bypass_waiting_room"),
/// 					Description: pulumi.String("bypass query string"),
/// 					Expression:  pulumi.String("http.request.uri.query contains \"bypass=true\""),
/// 					Status:      pulumi.String("enabled"),
/// 				},
/// 			},
/// 			WaitingRoomId: pulumi.String("d41d8cd98f00b204e9800998ecf8427e"),
/// 			ZoneId:        pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.WaitingRoomRules;
/// import com.pulumi.cloudflare.WaitingRoomRulesArgs;
/// import com.pulumi.cloudflare.inputs.WaitingRoomRulesRuleArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new WaitingRoomRules("example", WaitingRoomRulesArgs.builder()        
///             .rules(            
///                 WaitingRoomRulesRuleArgs.builder()
///                     .action("bypass_waiting_room")
///                     .description("bypass ip list")
///                     .expression("src.ip in {192.0.2.0 192.0.2.1}")
///                     .status("enabled")
///                     .build(),
///                 WaitingRoomRulesRuleArgs.builder()
///                     .action("bypass_waiting_room")
///                     .description("bypass query string")
///                     .expression("http.request.uri.query contains \"bypass=true\"")
///                     .status("enabled")
///                     .build())
///             .waitingRoomId("d41d8cd98f00b204e9800998ecf8427e")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:WaitingRoomRules
///     properties:
///       rules:
///         - action: bypass_waiting_room
///           description: bypass ip list
///           expression: src.ip in {192.0.2.0 192.0.2.1}
///           status: enabled
///         - action: bypass_waiting_room
///           description: bypass query string
///           expression: http.request.uri.query contains "bypass=true"
///           status: enabled
///       waitingRoomId: d41d8cd98f00b204e9800998ecf8427e
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/waitingRoomRules:WaitingRoomRules default <zone_id>/<waiting_room_id>
/// ```
///
pub mod waiting_room_rules {

    pub struct WaitingRoomRulesArgs {
        /// List of rules to apply to the ruleset.
        pub rules: pulumi_wasm_rust::Output<Option<Vec<crate::types::WaitingRoomRulesRule>>>,
        /// The Waiting Room ID the rules should apply to. **Modifying this attribute will force creation of a new resource.**
        pub waiting_room_id: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct WaitingRoomRulesResult {
        /// List of rules to apply to the ruleset.
        pub rules: pulumi_wasm_rust::Output<Option<Vec<crate::types::WaitingRoomRulesRule>>>,
        /// The Waiting Room ID the rules should apply to. **Modifying this attribute will force creation of a new resource.**
        pub waiting_room_id: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn waiting_room_rules(name: &str, args: WaitingRoomRulesArgs) -> WaitingRoomRulesResult {
        let result = crate::bindings::pulumi::cloudflare::waiting_room_rules::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::waiting_room_rules::Args {
                rules: args.rules.get_inner(),
                waiting_room_id: args.waiting_room_id.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        WaitingRoomRulesResult {
            rules: crate::into_domain(result.rules),
            waiting_room_id: crate::into_domain(result.waiting_room_id),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Configure zone-wide settings for Cloudflare waiting rooms.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.WaitingRoomSettings("example", {
///     searchEngineCrawlerBypass: true,
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.WaitingRoomSettings("example",
///     search_engine_crawler_bypass=True,
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.WaitingRoomSettings("example", new()
///     {
///         SearchEngineCrawlerBypass = true,
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewWaitingRoomSettings(ctx, "example", &cloudflare.WaitingRoomSettingsArgs{
/// 			SearchEngineCrawlerBypass: pulumi.Bool(true),
/// 			ZoneId:                    pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.WaitingRoomSettings;
/// import com.pulumi.cloudflare.WaitingRoomSettingsArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new WaitingRoomSettings("example", WaitingRoomSettingsArgs.builder()        
///             .searchEngineCrawlerBypass(true)
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:WaitingRoomSettings
///     properties:
///       searchEngineCrawlerBypass: true
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/waitingRoomSettings:WaitingRoomSettings example <zone_id>
/// ```
///
pub mod waiting_room_settings {

    pub struct WaitingRoomSettingsArgs {
        /// Whether to allow verified search engine crawlers to bypass all waiting rooms on this zone. Defaults to `false`.
        pub search_engine_crawler_bypass: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct WaitingRoomSettingsResult {
        /// Whether to allow verified search engine crawlers to bypass all waiting rooms on this zone. Defaults to `false`.
        pub search_engine_crawler_bypass: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn waiting_room_settings(
        name: &str,
        args: WaitingRoomSettingsArgs,
    ) -> WaitingRoomSettingsResult {
        let result = crate::bindings::pulumi::cloudflare::waiting_room_settings::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::waiting_room_settings::Args {
                search_engine_crawler_bypass: args.search_engine_crawler_bypass.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        WaitingRoomSettingsResult {
            search_engine_crawler_bypass: crate::into_domain(result.search_engine_crawler_bypass),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Manages Web3 hostnames for IPFS and Ethereum gateways.
pub mod web3_hostname {

    pub struct Web3HostnameArgs {
        /// An optional description of the hostname.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// DNSLink value used if the target is ipfs.
        pub dnslink: pulumi_wasm_rust::Output<Option<String>>,
        /// The hostname that will point to the target gateway via CNAME.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Target gateway of the hostname.
        pub target: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct Web3HostnameResult {
        /// Creation time.
        pub created_on: pulumi_wasm_rust::Output<String>,
        /// An optional description of the hostname.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// DNSLink value used if the target is ipfs.
        pub dnslink: pulumi_wasm_rust::Output<Option<String>>,
        /// Last modification time.
        pub modified_on: pulumi_wasm_rust::Output<String>,
        /// The hostname that will point to the target gateway via CNAME.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Status of the hostname's activation.
        pub status: pulumi_wasm_rust::Output<String>,
        /// Target gateway of the hostname.
        pub target: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn web_3_hostname(name: &str, args: Web3HostnameArgs) -> Web3HostnameResult {
        let result = crate::bindings::pulumi::cloudflare::web3_hostname::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::web3_hostname::Args {
                description: args.description.get_inner(),
                dnslink: args.dnslink.get_inner(),
                name: args.name.get_inner(),
                target: args.target.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        Web3HostnameResult {
            created_on: crate::into_domain(result.created_on),
            description: crate::into_domain(result.description),
            dnslink: crate::into_domain(result.dnslink),
            modified_on: crate::into_domain(result.modified_on),
            name: crate::into_domain(result.name),
            status: crate::into_domain(result.status),
            target: crate::into_domain(result.target),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare Web Analytics Rule resource.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const exampleWebAnalyticsSite = new cloudflare.WebAnalyticsSite("exampleWebAnalyticsSite", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     zoneTag: "0da42c8d2132a9ddaf714f9e7c920711",
///     autoInstall: true,
/// });
/// const exampleWebAnalyticsRule = new cloudflare.WebAnalyticsRule("exampleWebAnalyticsRule", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     rulesetId: exampleWebAnalyticsSite.rulesetId,
///     host: "*",
///     paths: ["/excluded"],
///     inclusive: false,
///     isPaused: false,
/// }, {
///     dependsOn: [exampleWebAnalyticsSite],
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example_web_analytics_site = cloudflare.WebAnalyticsSite("exampleWebAnalyticsSite",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     zone_tag="0da42c8d2132a9ddaf714f9e7c920711",
///     auto_install=True)
/// example_web_analytics_rule = cloudflare.WebAnalyticsRule("exampleWebAnalyticsRule",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     ruleset_id=example_web_analytics_site.ruleset_id,
///     host="*",
///     paths=["/excluded"],
///     inclusive=False,
///     is_paused=False,
///     opts=pulumi.ResourceOptions(depends_on=[example_web_analytics_site]))
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var exampleWebAnalyticsSite = new Cloudflare.WebAnalyticsSite("exampleWebAnalyticsSite", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         ZoneTag = "0da42c8d2132a9ddaf714f9e7c920711",
///         AutoInstall = true,
///     });
///
///     var exampleWebAnalyticsRule = new Cloudflare.WebAnalyticsRule("exampleWebAnalyticsRule", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         RulesetId = exampleWebAnalyticsSite.RulesetId,
///         Host = "*",
///         Paths = new[]
///         {
///             "/excluded",
///         },
///         Inclusive = false,
///         IsPaused = false,
///     }, new CustomResourceOptions
///     {
///         DependsOn =
///         {
///             exampleWebAnalyticsSite,
///         },
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		exampleWebAnalyticsSite, err := cloudflare.NewWebAnalyticsSite(ctx, "exampleWebAnalyticsSite", &cloudflare.WebAnalyticsSiteArgs{
/// 			AccountId:   pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			ZoneTag:     pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 			AutoInstall: pulumi.Bool(true),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		_, err = cloudflare.NewWebAnalyticsRule(ctx, "exampleWebAnalyticsRule", &cloudflare.WebAnalyticsRuleArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			RulesetId: exampleWebAnalyticsSite.RulesetId,
/// 			Host:      pulumi.String("*"),
/// 			Paths: pulumi.StringArray{
/// 				pulumi.String("/excluded"),
/// 			},
/// 			Inclusive: pulumi.Bool(false),
/// 			IsPaused:  pulumi.Bool(false),
/// 		}, pulumi.DependsOn([]pulumi.Resource{
/// 			exampleWebAnalyticsSite,
/// 		}))
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.WebAnalyticsSite;
/// import com.pulumi.cloudflare.WebAnalyticsSiteArgs;
/// import com.pulumi.cloudflare.WebAnalyticsRule;
/// import com.pulumi.cloudflare.WebAnalyticsRuleArgs;
/// import com.pulumi.resources.CustomResourceOptions;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var exampleWebAnalyticsSite = new WebAnalyticsSite("exampleWebAnalyticsSite", WebAnalyticsSiteArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .zoneTag("0da42c8d2132a9ddaf714f9e7c920711")
///             .autoInstall(true)
///             .build());
///
///         var exampleWebAnalyticsRule = new WebAnalyticsRule("exampleWebAnalyticsRule", WebAnalyticsRuleArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .rulesetId(exampleWebAnalyticsSite.rulesetId())
///             .host("*")
///             .paths("/excluded")
///             .inclusive(false)
///             .isPaused(false)
///             .build(), CustomResourceOptions.builder()
///                 .dependsOn(exampleWebAnalyticsSite)
///                 .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   exampleWebAnalyticsSite:
///     type: cloudflare:WebAnalyticsSite
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       zoneTag: 0da42c8d2132a9ddaf714f9e7c920711
///       autoInstall: true
///   exampleWebAnalyticsRule:
///     type: cloudflare:WebAnalyticsRule
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       rulesetId: ${exampleWebAnalyticsSite.rulesetId}
///       host: '*'
///       paths:
///         - /excluded
///       inclusive: false
///       isPaused: false
///     options:
///       dependson:
///         - ${exampleWebAnalyticsSite}
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/webAnalyticsRule:WebAnalyticsRule example <account_id>/<ruleset_id>/<rule_id>
/// ```
///
pub mod web_analytics_rule {

    pub struct WebAnalyticsRuleArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The host to apply the rule to.
        pub host: pulumi_wasm_rust::Output<String>,
        /// Whether the rule includes or excludes the matched traffic from being measured in Web Analytics.
        pub inclusive: pulumi_wasm_rust::Output<bool>,
        /// Whether the rule is paused or not.
        pub is_paused: pulumi_wasm_rust::Output<bool>,
        /// A list of paths to apply the rule to.
        pub paths: pulumi_wasm_rust::Output<Vec<String>>,
        /// The Web Analytics ruleset id. **Modifying this attribute will force creation of a new resource.**
        pub ruleset_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct WebAnalyticsRuleResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The host to apply the rule to.
        pub host: pulumi_wasm_rust::Output<String>,
        /// Whether the rule includes or excludes the matched traffic from being measured in Web Analytics.
        pub inclusive: pulumi_wasm_rust::Output<bool>,
        /// Whether the rule is paused or not.
        pub is_paused: pulumi_wasm_rust::Output<bool>,
        /// A list of paths to apply the rule to.
        pub paths: pulumi_wasm_rust::Output<Vec<String>>,
        /// The Web Analytics ruleset id. **Modifying this attribute will force creation of a new resource.**
        pub ruleset_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn web_analytics_rule(name: &str, args: WebAnalyticsRuleArgs) -> WebAnalyticsRuleResult {
        let result = crate::bindings::pulumi::cloudflare::web_analytics_rule::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::web_analytics_rule::Args {
                account_id: args.account_id.get_inner(),
                host: args.host.get_inner(),
                inclusive: args.inclusive.get_inner(),
                is_paused: args.is_paused.get_inner(),
                paths: args.paths.get_inner(),
                ruleset_id: args.ruleset_id.get_inner(),
            },
        );

        WebAnalyticsRuleResult {
            account_id: crate::into_domain(result.account_id),
            host: crate::into_domain(result.host),
            inclusive: crate::into_domain(result.inclusive),
            is_paused: crate::into_domain(result.is_paused),
            paths: crate::into_domain(result.paths),
            ruleset_id: crate::into_domain(result.ruleset_id),
        }
    }
}

/// Provides a Cloudflare Web Analytics Site resource.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.WebAnalyticsSite("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     autoInstall: true,
///     zoneTag: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.WebAnalyticsSite("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     auto_install=True,
///     zone_tag="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.WebAnalyticsSite("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         AutoInstall = true,
///         ZoneTag = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewWebAnalyticsSite(ctx, "example", &cloudflare.WebAnalyticsSiteArgs{
/// 			AccountId:   pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			AutoInstall: pulumi.Bool(true),
/// 			ZoneTag:     pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.WebAnalyticsSite;
/// import com.pulumi.cloudflare.WebAnalyticsSiteArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new WebAnalyticsSite("example", WebAnalyticsSiteArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .autoInstall(true)
///             .zoneTag("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:WebAnalyticsSite
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       autoInstall: true
///       zoneTag: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/webAnalyticsSite:WebAnalyticsSite example <account_id>/<site_tag>
/// ```
///
pub mod web_analytics_site {

    pub struct WebAnalyticsSiteArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether Cloudflare will automatically inject the JavaScript snippet for orange-clouded sites. **Modifying this attribute will force creation of a new resource.**
        pub auto_install: pulumi_wasm_rust::Output<bool>,
        /// The hostname to use for gray-clouded sites. Must provide only one of `zone_tag`. **Modifying this attribute will force creation of a new resource.**
        pub host: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier for orange-clouded sites. Must provide only one of `host`. **Modifying this attribute will force creation of a new resource.**
        pub zone_tag: pulumi_wasm_rust::Output<Option<String>>,
    }

    pub struct WebAnalyticsSiteResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether Cloudflare will automatically inject the JavaScript snippet for orange-clouded sites. **Modifying this attribute will force creation of a new resource.**
        pub auto_install: pulumi_wasm_rust::Output<bool>,
        /// The hostname to use for gray-clouded sites. Must provide only one of `zone_tag`. **Modifying this attribute will force creation of a new resource.**
        pub host: pulumi_wasm_rust::Output<Option<String>>,
        /// The ID for the ruleset associated to this Web Analytics Site.
        pub ruleset_id: pulumi_wasm_rust::Output<String>,
        /// The Web Analytics site tag.
        pub site_tag: pulumi_wasm_rust::Output<String>,
        /// The token for the Web Analytics site.
        pub site_token: pulumi_wasm_rust::Output<String>,
        /// The encoded JS snippet to add to your site's HTML page if auto_install is false.
        pub snippet: pulumi_wasm_rust::Output<String>,
        /// The zone identifier for orange-clouded sites. Must provide only one of `host`. **Modifying this attribute will force creation of a new resource.**
        pub zone_tag: pulumi_wasm_rust::Output<Option<String>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn web_analytics_site(name: &str, args: WebAnalyticsSiteArgs) -> WebAnalyticsSiteResult {
        let result = crate::bindings::pulumi::cloudflare::web_analytics_site::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::web_analytics_site::Args {
                account_id: args.account_id.get_inner(),
                auto_install: args.auto_install.get_inner(),
                host: args.host.get_inner(),
                zone_tag: args.zone_tag.get_inner(),
            },
        );

        WebAnalyticsSiteResult {
            account_id: crate::into_domain(result.account_id),
            auto_install: crate::into_domain(result.auto_install),
            host: crate::into_domain(result.host),
            ruleset_id: crate::into_domain(result.ruleset_id),
            site_tag: crate::into_domain(result.site_tag),
            site_token: crate::into_domain(result.site_token),
            snippet: crate::into_domain(result.snippet),
            zone_tag: crate::into_domain(result.zone_tag),
        }
    }
}

/// Worker Cron Triggers allow users to map a cron expression to a Worker script
/// using a `ScheduledEvent` listener that enables Workers to be executed on a
/// schedule. Worker Cron Triggers are ideal for running periodic jobs for
/// maintenance or calling third-party APIs to collect up-to-date data.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
/// import * as fs from "fs";
///
/// const exampleScript = new cloudflare.WorkerScript("exampleScript", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "example-script",
///     content: fs.readFileSync("path/to/my.js", "utf8"),
/// });
/// const exampleTrigger = new cloudflare.WorkerCronTrigger("exampleTrigger", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     scriptName: exampleScript.name,
///     schedules: [
///         "*/5 * * * *",
///         "10 7 * * mon-fri",
///     ],
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example_script = cloudflare.WorkerScript("exampleScript",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="example-script",
///     content=(lambda path: open(path).read())("path/to/my.js"))
/// example_trigger = cloudflare.WorkerCronTrigger("exampleTrigger",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     script_name=example_script.name,
///     schedules=[
///         "*/5 * * * *",
///         "10 7 * * mon-fri",
///     ])
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.IO;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var exampleScript = new Cloudflare.WorkerScript("exampleScript", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "example-script",
///         Content = File.ReadAllText("path/to/my.js"),
///     });
///
///     var exampleTrigger = new Cloudflare.WorkerCronTrigger("exampleTrigger", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         ScriptName = exampleScript.Name,
///         Schedules = new[]
///         {
///             "*/5 * * * *",
///             "10 7 * * mon-fri",
///         },
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"os"
///
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func readFileOrPanic(path string) pulumi.StringPtrInput {
/// 	data, err := os.ReadFile(path)
/// 	if err != nil {
/// 		panic(err.Error())
/// 	}
/// 	return pulumi.String(string(data))
/// }
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		exampleScript, err := cloudflare.NewWorkerScript(ctx, "exampleScript", &cloudflare.WorkerScriptArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:      pulumi.String("example-script"),
/// 			Content:   readFileOrPanic("path/to/my.js"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		_, err = cloudflare.NewWorkerCronTrigger(ctx, "exampleTrigger", &cloudflare.WorkerCronTriggerArgs{
/// 			AccountId:  pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			ScriptName: exampleScript.Name,
/// 			Schedules: pulumi.StringArray{
/// 				pulumi.String("*/5 * * * *"),
/// 				pulumi.String("10 7 * * mon-fri"),
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.WorkerScript;
/// import com.pulumi.cloudflare.WorkerScriptArgs;
/// import com.pulumi.cloudflare.WorkerCronTrigger;
/// import com.pulumi.cloudflare.WorkerCronTriggerArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var exampleScript = new WorkerScript("exampleScript", WorkerScriptArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("example-script")
///             .content(Files.readString(Paths.get("path/to/my.js")))
///             .build());
///
///         var exampleTrigger = new WorkerCronTrigger("exampleTrigger", WorkerCronTriggerArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .scriptName(exampleScript.name())
///             .schedules(            
///                 "*/5 * * * *",
///                 "10 7 * * mon-fri")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   exampleScript:
///     type: cloudflare:WorkerScript
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       name: example-script
///       content:
///         fn::readFile: path/to/my.js
///   exampleTrigger:
///     type: cloudflare:WorkerCronTrigger
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       scriptName: ${exampleScript.name}
///       schedules:
///         - '*/5 * * * *'
///         - 10 7 * * mon-fri
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/workerCronTrigger:WorkerCronTrigger example <account_id>/<script_name>
/// ```
///
pub mod worker_cron_trigger {

    pub struct WorkerCronTriggerArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Cron expressions to execute the Worker script.
        pub schedules: pulumi_wasm_rust::Output<Vec<String>>,
        /// Worker script to target for the schedules.
        pub script_name: pulumi_wasm_rust::Output<String>,
    }

    pub struct WorkerCronTriggerResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Cron expressions to execute the Worker script.
        pub schedules: pulumi_wasm_rust::Output<Vec<String>>,
        /// Worker script to target for the schedules.
        pub script_name: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn worker_cron_trigger(name: &str, args: WorkerCronTriggerArgs) -> WorkerCronTriggerResult {
        let result = crate::bindings::pulumi::cloudflare::worker_cron_trigger::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::worker_cron_trigger::Args {
                account_id: args.account_id.get_inner(),
                schedules: args.schedules.get_inner(),
                script_name: args.script_name.get_inner(),
            },
        );

        WorkerCronTriggerResult {
            account_id: crate::into_domain(result.account_id),
            schedules: crate::into_domain(result.schedules),
            script_name: crate::into_domain(result.script_name),
        }
    }
}

/// Creates a Worker Custom Domain.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.WorkerDomain("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     hostname: "subdomain.example.com",
///     service: "my-service",
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.WorkerDomain("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     hostname="subdomain.example.com",
///     service="my-service",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.WorkerDomain("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Hostname = "subdomain.example.com",
///         Service = "my-service",
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewWorkerDomain(ctx, "example", &cloudflare.WorkerDomainArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Hostname:  pulumi.String("subdomain.example.com"),
/// 			Service:   pulumi.String("my-service"),
/// 			ZoneId:    pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.WorkerDomain;
/// import com.pulumi.cloudflare.WorkerDomainArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new WorkerDomain("example", WorkerDomainArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .hostname("subdomain.example.com")
///             .service("my-service")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:WorkerDomain
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       hostname: subdomain.example.com
///       service: my-service
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/workerDomain:WorkerDomain example <account_id>/<worker_domain_id>
/// ```
///
pub mod worker_domain {

    pub struct WorkerDomainArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the Worker environment. Defaults to `production`.
        pub environment: pulumi_wasm_rust::Output<Option<String>>,
        /// Hostname of the Worker Domain.
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// Name of worker script to attach the domain to.
        pub service: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct WorkerDomainResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the Worker environment. Defaults to `production`.
        pub environment: pulumi_wasm_rust::Output<Option<String>>,
        /// Hostname of the Worker Domain.
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// Name of worker script to attach the domain to.
        pub service: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn worker_domain(name: &str, args: WorkerDomainArgs) -> WorkerDomainResult {
        let result = crate::bindings::pulumi::cloudflare::worker_domain::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::worker_domain::Args {
                account_id: args.account_id.get_inner(),
                environment: args.environment.get_inner(),
                hostname: args.hostname.get_inner(),
                service: args.service.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        WorkerDomainResult {
            account_id: crate::into_domain(result.account_id),
            environment: crate::into_domain(result.environment),
            hostname: crate::into_domain(result.hostname),
            service: crate::into_domain(result.service),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare worker route resource. A route will also require a `cloudflare.WorkerScript`.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const myScript = new cloudflare.WorkerScript("myScript", {});
/// // see "cloudflare_worker_script" documentation ...
/// // Runs the specified worker script for all URLs that match `example.com/*`
/// const myRoute = new cloudflare.WorkerRoute("myRoute", {
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
///     pattern: "example.com/*",
///     scriptName: myScript.name,
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// my_script = cloudflare.WorkerScript("myScript")
/// # see "cloudflare_worker_script" documentation ...
/// # Runs the specified worker script for all URLs that match `example.com/*`
/// my_route = cloudflare.WorkerRoute("myRoute",
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711",
///     pattern="example.com/*",
///     script_name=my_script.name)
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var myScript = new Cloudflare.WorkerScript("myScript");
///
///     // see "cloudflare_worker_script" documentation ...
///     // Runs the specified worker script for all URLs that match `example.com/*`
///     var myRoute = new Cloudflare.WorkerRoute("myRoute", new()
///     {
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///         Pattern = "example.com/*",
///         ScriptName = myScript.Name,
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		myScript, err := cloudflare.NewWorkerScript(ctx, "myScript", nil)
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// Runs the specified worker script for all URLs that match `example.com/*`
/// 		_, err = cloudflare.NewWorkerRoute(ctx, "myRoute", &cloudflare.WorkerRouteArgs{
/// 			ZoneId:     pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 			Pattern:    pulumi.String("example.com/*"),
/// 			ScriptName: myScript.Name,
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.WorkerScript;
/// import com.pulumi.cloudflare.WorkerRoute;
/// import com.pulumi.cloudflare.WorkerRouteArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var myScript = new WorkerScript("myScript");
///
///         // see "cloudflare_worker_script" documentation ...
///         // Runs the specified worker script for all URLs that match `example.com/*`
///         var myRoute = new WorkerRoute("myRoute", WorkerRouteArgs.builder()        
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .pattern("example.com/*")
///             .scriptName(myScript.name())
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # Runs the specified worker script for all URLs that match `example.com/*`
///   myRoute:
///     type: cloudflare:WorkerRoute
///     properties:
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
///       pattern: example.com/*
///       scriptName: ${myScript.name}
///   myScript:
///     type: cloudflare:WorkerScript
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/workerRoute:WorkerRoute example <zone_id>/<route_id>
/// ```
///
pub mod worker_route {

    pub struct WorkerRouteArgs {
        /// The [route pattern](https://developers.cloudflare.com/workers/about/routes/) to associate the Worker with.
        pub pattern: pulumi_wasm_rust::Output<String>,
        /// Worker script name to invoke for requests that match the route pattern.
        pub script_name: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct WorkerRouteResult {
        /// The [route pattern](https://developers.cloudflare.com/workers/about/routes/) to associate the Worker with.
        pub pattern: pulumi_wasm_rust::Output<String>,
        /// Worker script name to invoke for requests that match the route pattern.
        pub script_name: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn worker_route(name: &str, args: WorkerRouteArgs) -> WorkerRouteResult {
        let result = crate::bindings::pulumi::cloudflare::worker_route::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::worker_route::Args {
                pattern: args.pattern.get_inner(),
                script_name: args.script_name.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        WorkerRouteResult {
            pattern: crate::into_domain(result.pattern),
            script_name: crate::into_domain(result.script_name),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare worker script resource. In order for a script to be active, you'll also need to setup a `cloudflare.WorkerRoute`.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
/// import * as fs from "fs";
///
/// const myNamespace = new cloudflare.WorkersKvNamespace("myNamespace", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     title: "example",
/// });
/// // Sets the script with the name "script_1"
/// const myScript = new cloudflare.WorkerScript("myScript", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "script_1",
///     content: fs.readFileSync("script.js", "utf8"),
///     kvNamespaceBindings: [{
///         name: "MY_EXAMPLE_KV_NAMESPACE",
///         namespaceId: myNamespace.id,
///     }],
///     plainTextBindings: [{
///         name: "MY_EXAMPLE_PLAIN_TEXT",
///         text: "foobar",
///     }],
///     secretTextBindings: [{
///         name: "MY_EXAMPLE_SECRET_TEXT",
///         text: _var.secret_foo_value,
///     }],
///     webassemblyBindings: [{
///         name: "MY_EXAMPLE_WASM",
///         module: fs.readFileSync("example.wasm", { encoding: "base64" }),
///     }],
///     serviceBindings: [{
///         name: "MY_SERVICE_BINDING",
///         service: "MY_SERVICE",
///         environment: "production",
///     }],
///     r2BucketBindings: [{
///         name: "MY_BUCKET",
///         bucketName: "MY_BUCKET_NAME",
///     }],
///     analyticsEngineBindings: [{
///         name: "MY_DATASET",
///         dataset: "dataset1",
///     }],
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import base64
/// import pulumi_cloudflare as cloudflare
///
/// my_namespace = cloudflare.WorkersKvNamespace("myNamespace",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     title="example")
/// # Sets the script with the name "script_1"
/// my_script = cloudflare.WorkerScript("myScript",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="script_1",
///     content=(lambda path: open(path).read())("script.js"),
///     kv_namespace_bindings=[cloudflare.WorkerScriptKvNamespaceBindingArgs(
///         name="MY_EXAMPLE_KV_NAMESPACE",
///         namespace_id=my_namespace.id,
///     )],
///     plain_text_bindings=[cloudflare.WorkerScriptPlainTextBindingArgs(
///         name="MY_EXAMPLE_PLAIN_TEXT",
///         text="foobar",
///     )],
///     secret_text_bindings=[cloudflare.WorkerScriptSecretTextBindingArgs(
///         name="MY_EXAMPLE_SECRET_TEXT",
///         text=var["secret_foo_value"],
///     )],
///     webassembly_bindings=[cloudflare.WorkerScriptWebassemblyBindingArgs(
///         name="MY_EXAMPLE_WASM",
///         module=(lambda path: base64.b64encode(open(path).read().encode()).decode())("example.wasm"),
///     )],
///     service_bindings=[cloudflare.WorkerScriptServiceBindingArgs(
///         name="MY_SERVICE_BINDING",
///         service="MY_SERVICE",
///         environment="production",
///     )],
///     r2_bucket_bindings=[cloudflare.WorkerScriptR2BucketBindingArgs(
///         name="MY_BUCKET",
///         bucket_name="MY_BUCKET_NAME",
///     )],
///     analytics_engine_bindings=[cloudflare.WorkerScriptAnalyticsEngineBindingArgs(
///         name="MY_DATASET",
///         dataset="dataset1",
///     )])
/// ```
/// ### C#
/// ```csharp
/// using System;
/// using System.Collections.Generic;
/// using System.IO;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
///
/// string ReadFileBase64(string path)
/// {
///     return Convert.ToBase64String(Encoding.UTF8.GetBytes(File.ReadAllText(path)));
/// }
///
/// return await Deployment.RunAsync(() =>
/// {
///     var myNamespace = new Cloudflare.WorkersKvNamespace("myNamespace", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Title = "example",
///     });
///
///     // Sets the script with the name "script_1"
///     var myScript = new Cloudflare.WorkerScript("myScript", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "script_1",
///         Content = File.ReadAllText("script.js"),
///         KvNamespaceBindings = new[]
///         {
///             new Cloudflare.Inputs.WorkerScriptKvNamespaceBindingArgs
///             {
///                 Name = "MY_EXAMPLE_KV_NAMESPACE",
///                 NamespaceId = myNamespace.Id,
///             },
///         },
///         PlainTextBindings = new[]
///         {
///             new Cloudflare.Inputs.WorkerScriptPlainTextBindingArgs
///             {
///                 Name = "MY_EXAMPLE_PLAIN_TEXT",
///                 Text = "foobar",
///             },
///         },
///         SecretTextBindings = new[]
///         {
///             new Cloudflare.Inputs.WorkerScriptSecretTextBindingArgs
///             {
///                 Name = "MY_EXAMPLE_SECRET_TEXT",
///                 Text = @var.Secret_foo_value,
///             },
///         },
///         WebassemblyBindings = new[]
///         {
///             new Cloudflare.Inputs.WorkerScriptWebassemblyBindingArgs
///             {
///                 Name = "MY_EXAMPLE_WASM",
///                 Module = ReadFileBase64("example.wasm"),
///             },
///         },
///         ServiceBindings = new[]
///         {
///             new Cloudflare.Inputs.WorkerScriptServiceBindingArgs
///             {
///                 Name = "MY_SERVICE_BINDING",
///                 Service = "MY_SERVICE",
///                 Environment = "production",
///             },
///         },
///         R2BucketBindings = new[]
///         {
///             new Cloudflare.Inputs.WorkerScriptR2BucketBindingArgs
///             {
///                 Name = "MY_BUCKET",
///                 BucketName = "MY_BUCKET_NAME",
///             },
///         },
///         AnalyticsEngineBindings = new[]
///         {
///             new Cloudflare.Inputs.WorkerScriptAnalyticsEngineBindingArgs
///             {
///                 Name = "MY_DATASET",
///                 Dataset = "dataset1",
///             },
///         },
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"encoding/base64"
/// 	"os"
///
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func filebase64OrPanic(path string) string {
/// 	if fileData, err := os.ReadFile(path); err == nil {
/// 		return base64.StdEncoding.EncodeToString(fileData[:])
/// 	} else {
/// 		panic(err.Error())
/// 	}
/// }
///
/// func readFileOrPanic(path string) pulumi.StringPtrInput {
/// 	data, err := os.ReadFile(path)
/// 	if err != nil {
/// 		panic(err.Error())
/// 	}
/// 	return pulumi.String(string(data))
/// }
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		myNamespace, err := cloudflare.NewWorkersKvNamespace(ctx, "myNamespace", &cloudflare.WorkersKvNamespaceArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Title:     pulumi.String("example"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		// Sets the script with the name "script_1"
/// 		_, err = cloudflare.NewWorkerScript(ctx, "myScript", &cloudflare.WorkerScriptArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:      pulumi.String("script_1"),
/// 			Content:   readFileOrPanic("script.js"),
/// 			KvNamespaceBindings: cloudflare.WorkerScriptKvNamespaceBindingArray{
/// 				&cloudflare.WorkerScriptKvNamespaceBindingArgs{
/// 					Name:        pulumi.String("MY_EXAMPLE_KV_NAMESPACE"),
/// 					NamespaceId: myNamespace.ID(),
/// 				},
/// 			},
/// 			PlainTextBindings: cloudflare.WorkerScriptPlainTextBindingArray{
/// 				&cloudflare.WorkerScriptPlainTextBindingArgs{
/// 					Name: pulumi.String("MY_EXAMPLE_PLAIN_TEXT"),
/// 					Text: pulumi.String("foobar"),
/// 				},
/// 			},
/// 			SecretTextBindings: cloudflare.WorkerScriptSecretTextBindingArray{
/// 				&cloudflare.WorkerScriptSecretTextBindingArgs{
/// 					Name: pulumi.String("MY_EXAMPLE_SECRET_TEXT"),
/// 					Text: pulumi.Any(_var.Secret_foo_value),
/// 				},
/// 			},
/// 			WebassemblyBindings: cloudflare.WorkerScriptWebassemblyBindingArray{
/// 				&cloudflare.WorkerScriptWebassemblyBindingArgs{
/// 					Name:   pulumi.String("MY_EXAMPLE_WASM"),
/// 					Module: filebase64OrPanic("example.wasm"),
/// 				},
/// 			},
/// 			ServiceBindings: cloudflare.WorkerScriptServiceBindingArray{
/// 				&cloudflare.WorkerScriptServiceBindingArgs{
/// 					Name:        pulumi.String("MY_SERVICE_BINDING"),
/// 					Service:     pulumi.String("MY_SERVICE"),
/// 					Environment: pulumi.String("production"),
/// 				},
/// 			},
/// 			R2BucketBindings: cloudflare.WorkerScriptR2BucketBindingArray{
/// 				&cloudflare.WorkerScriptR2BucketBindingArgs{
/// 					Name:       pulumi.String("MY_BUCKET"),
/// 					BucketName: pulumi.String("MY_BUCKET_NAME"),
/// 				},
/// 			},
/// 			AnalyticsEngineBindings: cloudflare.WorkerScriptAnalyticsEngineBindingArray{
/// 				&cloudflare.WorkerScriptAnalyticsEngineBindingArgs{
/// 					Name:    pulumi.String("MY_DATASET"),
/// 					Dataset: pulumi.String("dataset1"),
/// 				},
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.WorkersKvNamespace;
/// import com.pulumi.cloudflare.WorkersKvNamespaceArgs;
/// import com.pulumi.cloudflare.WorkerScript;
/// import com.pulumi.cloudflare.WorkerScriptArgs;
/// import com.pulumi.cloudflare.inputs.WorkerScriptKvNamespaceBindingArgs;
/// import com.pulumi.cloudflare.inputs.WorkerScriptPlainTextBindingArgs;
/// import com.pulumi.cloudflare.inputs.WorkerScriptSecretTextBindingArgs;
/// import com.pulumi.cloudflare.inputs.WorkerScriptWebassemblyBindingArgs;
/// import com.pulumi.cloudflare.inputs.WorkerScriptServiceBindingArgs;
/// import com.pulumi.cloudflare.inputs.WorkerScriptR2BucketBindingArgs;
/// import com.pulumi.cloudflare.inputs.WorkerScriptAnalyticsEngineBindingArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var myNamespace = new WorkersKvNamespace("myNamespace", WorkersKvNamespaceArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .title("example")
///             .build());
///
///         // Sets the script with the name "script_1"
///         var myScript = new WorkerScript("myScript", WorkerScriptArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("script_1")
///             .content(Files.readString(Paths.get("script.js")))
///             .kvNamespaceBindings(WorkerScriptKvNamespaceBindingArgs.builder()
///                 .name("MY_EXAMPLE_KV_NAMESPACE")
///                 .namespaceId(myNamespace.id())
///                 .build())
///             .plainTextBindings(WorkerScriptPlainTextBindingArgs.builder()
///                 .name("MY_EXAMPLE_PLAIN_TEXT")
///                 .text("foobar")
///                 .build())
///             .secretTextBindings(WorkerScriptSecretTextBindingArgs.builder()
///                 .name("MY_EXAMPLE_SECRET_TEXT")
///                 .text(var_.secret_foo_value())
///                 .build())
///             .webassemblyBindings(WorkerScriptWebassemblyBindingArgs.builder()
///                 .name("MY_EXAMPLE_WASM")
///                 .module(Base64.getEncoder().encodeToString(Files.readAllBytes(Paths.get("example.wasm"))))
///                 .build())
///             .serviceBindings(WorkerScriptServiceBindingArgs.builder()
///                 .name("MY_SERVICE_BINDING")
///                 .service("MY_SERVICE")
///                 .environment("production")
///                 .build())
///             .r2BucketBindings(WorkerScriptR2BucketBindingArgs.builder()
///                 .name("MY_BUCKET")
///                 .bucketName("MY_BUCKET_NAME")
///                 .build())
///             .analyticsEngineBindings(WorkerScriptAnalyticsEngineBindingArgs.builder()
///                 .name("MY_DATASET")
///                 .dataset("dataset1")
///                 .build())
///             .build());
///
///     }
/// }
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/workerScript:WorkerScript example <account_id>/<script_name>
/// ```
///
pub mod worker_script {

    pub struct WorkerScriptArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        pub analytics_engine_bindings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::WorkerScriptAnalyticsEngineBinding>>>,
        /// The date to use for the compatibility flag.
        pub compatibility_date: pulumi_wasm_rust::Output<Option<String>>,
        /// Compatibility flags used for Worker Scripts.
        pub compatibility_flags: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The script content.
        pub content: pulumi_wasm_rust::Output<String>,
        pub d1_database_bindings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::WorkerScriptD1DatabaseBinding>>>,
        /// Name of the Workers for Platforms dispatch namespace.
        pub dispatch_namespace: pulumi_wasm_rust::Output<Option<String>>,
        pub kv_namespace_bindings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::WorkerScriptKvNamespaceBinding>>>,
        /// Enabling allows Worker events to be sent to a defined Logpush destination.
        pub logpush: pulumi_wasm_rust::Output<Option<bool>>,
        /// The base64 encoded wasm module you want to store.
        pub module: pulumi_wasm_rust::Output<Option<bool>>,
        /// The global variable for the binding in your Worker code.
        pub name: pulumi_wasm_rust::Output<String>,
        pub placements: pulumi_wasm_rust::Output<Option<Vec<crate::types::WorkerScriptPlacement>>>,
        pub plain_text_bindings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::WorkerScriptPlainTextBinding>>>,
        pub queue_bindings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::WorkerScriptQueueBinding>>>,
        pub r2_bucket_bindings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::WorkerScriptR2BucketBinding>>>,
        pub secret_text_bindings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::WorkerScriptSecretTextBinding>>>,
        pub service_bindings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::WorkerScriptServiceBinding>>>,
        pub tags: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        pub webassembly_bindings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::WorkerScriptWebassemblyBinding>>>,
    }

    pub struct WorkerScriptResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        pub analytics_engine_bindings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::WorkerScriptAnalyticsEngineBinding>>>,
        /// The date to use for the compatibility flag.
        pub compatibility_date: pulumi_wasm_rust::Output<Option<String>>,
        /// Compatibility flags used for Worker Scripts.
        pub compatibility_flags: pulumi_wasm_rust::Output<Vec<String>>,
        /// The script content.
        pub content: pulumi_wasm_rust::Output<String>,
        pub d1_database_bindings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::WorkerScriptD1DatabaseBinding>>>,
        /// Name of the Workers for Platforms dispatch namespace.
        pub dispatch_namespace: pulumi_wasm_rust::Output<Option<String>>,
        pub kv_namespace_bindings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::WorkerScriptKvNamespaceBinding>>>,
        /// Enabling allows Worker events to be sent to a defined Logpush destination.
        pub logpush: pulumi_wasm_rust::Output<Option<bool>>,
        /// The base64 encoded wasm module you want to store.
        pub module: pulumi_wasm_rust::Output<Option<bool>>,
        /// The global variable for the binding in your Worker code.
        pub name: pulumi_wasm_rust::Output<String>,
        pub placements: pulumi_wasm_rust::Output<Option<Vec<crate::types::WorkerScriptPlacement>>>,
        pub plain_text_bindings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::WorkerScriptPlainTextBinding>>>,
        pub queue_bindings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::WorkerScriptQueueBinding>>>,
        pub r2_bucket_bindings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::WorkerScriptR2BucketBinding>>>,
        pub secret_text_bindings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::WorkerScriptSecretTextBinding>>>,
        pub service_bindings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::WorkerScriptServiceBinding>>>,
        pub tags: pulumi_wasm_rust::Output<Vec<String>>,
        pub webassembly_bindings:
            pulumi_wasm_rust::Output<Option<Vec<crate::types::WorkerScriptWebassemblyBinding>>>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn worker_script(name: &str, args: WorkerScriptArgs) -> WorkerScriptResult {
        let result = crate::bindings::pulumi::cloudflare::worker_script::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::worker_script::Args {
                account_id: args.account_id.get_inner(),
                analytics_engine_bindings: args.analytics_engine_bindings.get_inner(),
                compatibility_date: args.compatibility_date.get_inner(),
                compatibility_flags: args.compatibility_flags.get_inner(),
                content: args.content.get_inner(),
                d1_database_bindings: args.d1_database_bindings.get_inner(),
                dispatch_namespace: args.dispatch_namespace.get_inner(),
                kv_namespace_bindings: args.kv_namespace_bindings.get_inner(),
                logpush: args.logpush.get_inner(),
                module: args.module.get_inner(),
                name: args.name.get_inner(),
                placements: args.placements.get_inner(),
                plain_text_bindings: args.plain_text_bindings.get_inner(),
                queue_bindings: args.queue_bindings.get_inner(),
                r2_bucket_bindings: args.r2_bucket_bindings.get_inner(),
                secret_text_bindings: args.secret_text_bindings.get_inner(),
                service_bindings: args.service_bindings.get_inner(),
                tags: args.tags.get_inner(),
                webassembly_bindings: args.webassembly_bindings.get_inner(),
            },
        );

        WorkerScriptResult {
            account_id: crate::into_domain(result.account_id),
            analytics_engine_bindings: crate::into_domain(result.analytics_engine_bindings),
            compatibility_date: crate::into_domain(result.compatibility_date),
            compatibility_flags: crate::into_domain(result.compatibility_flags),
            content: crate::into_domain(result.content),
            d1_database_bindings: crate::into_domain(result.d1_database_bindings),
            dispatch_namespace: crate::into_domain(result.dispatch_namespace),
            kv_namespace_bindings: crate::into_domain(result.kv_namespace_bindings),
            logpush: crate::into_domain(result.logpush),
            module: crate::into_domain(result.module),
            name: crate::into_domain(result.name),
            placements: crate::into_domain(result.placements),
            plain_text_bindings: crate::into_domain(result.plain_text_bindings),
            queue_bindings: crate::into_domain(result.queue_bindings),
            r2_bucket_bindings: crate::into_domain(result.r2_bucket_bindings),
            secret_text_bindings: crate::into_domain(result.secret_text_bindings),
            service_bindings: crate::into_domain(result.service_bindings),
            tags: crate::into_domain(result.tags),
            webassembly_bindings: crate::into_domain(result.webassembly_bindings),
        }
    }
}

/// Provides a Cloudflare Worker secret resource.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const mySecret = new cloudflare.WorkerSecret("mySecret", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "MY_EXAMPLE_SECRET_TEXT",
///     scriptName: "script_1",
///     secretText: "my_secret_value",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// my_secret = cloudflare.WorkerSecret("mySecret",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="MY_EXAMPLE_SECRET_TEXT",
///     script_name="script_1",
///     secret_text="my_secret_value")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var mySecret = new Cloudflare.WorkerSecret("mySecret", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "MY_EXAMPLE_SECRET_TEXT",
///         ScriptName = "script_1",
///         SecretText = "my_secret_value",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewWorkerSecret(ctx, "mySecret", &cloudflare.WorkerSecretArgs{
/// 			AccountId:  pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:       pulumi.String("MY_EXAMPLE_SECRET_TEXT"),
/// 			ScriptName: pulumi.String("script_1"),
/// 			SecretText: pulumi.String("my_secret_value"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.WorkerSecret;
/// import com.pulumi.cloudflare.WorkerSecretArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var mySecret = new WorkerSecret("mySecret", WorkerSecretArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("MY_EXAMPLE_SECRET_TEXT")
///             .scriptName("script_1")
///             .secretText("my_secret_value")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   mySecret:
///     type: cloudflare:WorkerSecret
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       name: MY_EXAMPLE_SECRET_TEXT
///       scriptName: script_1
///       secretText: my_secret_value
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/workerSecret:WorkerSecret example <account_id>/<script_name>/<secret_name>
/// ```
///
pub mod worker_secret {

    pub struct WorkerSecretArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the Worker secret. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
        /// The name of the Worker script to associate the secret with. **Modifying this attribute will force creation of a new resource.**
        pub script_name: pulumi_wasm_rust::Output<String>,
        /// The text of the Worker secret. **Modifying this attribute will force creation of a new resource.**
        pub secret_text: pulumi_wasm_rust::Output<String>,
    }

    pub struct WorkerSecretResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the Worker secret. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
        /// The name of the Worker script to associate the secret with. **Modifying this attribute will force creation of a new resource.**
        pub script_name: pulumi_wasm_rust::Output<String>,
        /// The text of the Worker secret. **Modifying this attribute will force creation of a new resource.**
        pub secret_text: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn worker_secret(name: &str, args: WorkerSecretArgs) -> WorkerSecretResult {
        let result = crate::bindings::pulumi::cloudflare::worker_secret::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::worker_secret::Args {
                account_id: args.account_id.get_inner(),
                name: args.name.get_inner(),
                script_name: args.script_name.get_inner(),
                secret_text: args.secret_text.get_inner(),
            },
        );

        WorkerSecretResult {
            account_id: crate::into_domain(result.account_id),
            name: crate::into_domain(result.name),
            script_name: crate::into_domain(result.script_name),
            secret_text: crate::into_domain(result.secret_text),
        }
    }
}

/// The [Workers for Platforms](https://developers.cloudflare.com/cloudflare-for-platforms/workers-for-platforms/) resource allows you
/// to manage Cloudflare Workers for Platforms namespaces.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
/// import * as fs from "fs";
///
/// const example = new cloudflare.WorkersForPlatformsNamespace("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "example-namespace",
/// });
/// const customerWorker1 = new cloudflare.WorkerScript("customerWorker1", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     name: "customer-worker-1",
///     content: fs.readFileSync("script.js", "utf8"),
///     dispatchNamespace: example.name,
///     tags: ["free"],
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.WorkersForPlatformsNamespace("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="example-namespace")
/// customer_worker1 = cloudflare.WorkerScript("customerWorker1",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     name="customer-worker-1",
///     content=(lambda path: open(path).read())("script.js"),
///     dispatch_namespace=example.name,
///     tags=["free"])
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.IO;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.WorkersForPlatformsNamespace("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "example-namespace",
///     });
///
///     var customerWorker1 = new Cloudflare.WorkerScript("customerWorker1", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Name = "customer-worker-1",
///         Content = File.ReadAllText("script.js"),
///         DispatchNamespace = example.Name,
///         Tags = new[]
///         {
///             "free",
///         },
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"os"
///
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func readFileOrPanic(path string) pulumi.StringPtrInput {
/// 	data, err := os.ReadFile(path)
/// 	if err != nil {
/// 		panic(err.Error())
/// 	}
/// 	return pulumi.String(string(data))
/// }
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		example, err := cloudflare.NewWorkersForPlatformsNamespace(ctx, "example", &cloudflare.WorkersForPlatformsNamespaceArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:      pulumi.String("example-namespace"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		_, err = cloudflare.NewWorkerScript(ctx, "customerWorker1", &cloudflare.WorkerScriptArgs{
/// 			AccountId:         pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Name:              pulumi.String("customer-worker-1"),
/// 			Content:           readFileOrPanic("script.js"),
/// 			DispatchNamespace: example.Name,
/// 			Tags: pulumi.StringArray{
/// 				pulumi.String("free"),
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.WorkersForPlatformsNamespace;
/// import com.pulumi.cloudflare.WorkersForPlatformsNamespaceArgs;
/// import com.pulumi.cloudflare.WorkerScript;
/// import com.pulumi.cloudflare.WorkerScriptArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new WorkersForPlatformsNamespace("example", WorkersForPlatformsNamespaceArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("example-namespace")
///             .build());
///
///         var customerWorker1 = new WorkerScript("customerWorker1", WorkerScriptArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .name("customer-worker-1")
///             .content(Files.readString(Paths.get("script.js")))
///             .dispatchNamespace(example.name())
///             .tags("free")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:WorkersForPlatformsNamespace
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       name: example-namespace
///   customerWorker1:
///     type: cloudflare:WorkerScript
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       name: customer-worker-1
///       content:
///         fn::readFile: script.js
///       dispatchNamespace: ${example.name}
///       tags:
///         - free
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/workersForPlatformsNamespace:WorkersForPlatformsNamespace example <account_id>/<namespace_name>
/// ```
///
pub mod workers_for_platforms_namespace {

    pub struct WorkersForPlatformsNamespaceArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the Workers for Platforms namespace.
        pub name: pulumi_wasm_rust::Output<String>,
    }

    pub struct WorkersForPlatformsNamespaceResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the Workers for Platforms namespace.
        pub name: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn workers_for_platforms_namespace(
        name: &str,
        args: WorkersForPlatformsNamespaceArgs,
    ) -> WorkersForPlatformsNamespaceResult {
        let result = crate::bindings::pulumi::cloudflare::workers_for_platforms_namespace::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::workers_for_platforms_namespace::Args {
                account_id: args.account_id.get_inner(),
                name: args.name.get_inner(),
            },
        );

        WorkersForPlatformsNamespaceResult {
            account_id: crate::into_domain(result.account_id),
            name: crate::into_domain(result.name),
        }
    }
}

/// Provides a resource to manage a Cloudflare Workers KV Pair.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const exampleNs = new cloudflare.WorkersKvNamespace("exampleNs", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     title: "test-namespace",
/// });
/// const example = new cloudflare.WorkersKv("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     namespaceId: exampleNs.id,
///     key: "test-key",
///     value: "test value",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example_ns = cloudflare.WorkersKvNamespace("exampleNs",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     title="test-namespace")
/// example = cloudflare.WorkersKv("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     namespace_id=example_ns.id,
///     key="test-key",
///     value="test value")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var exampleNs = new Cloudflare.WorkersKvNamespace("exampleNs", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Title = "test-namespace",
///     });
///
///     var example = new Cloudflare.WorkersKv("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         NamespaceId = exampleNs.Id,
///         Key = "test-key",
///         Value = "test value",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		exampleNs, err := cloudflare.NewWorkersKvNamespace(ctx, "exampleNs", &cloudflare.WorkersKvNamespaceArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Title:     pulumi.String("test-namespace"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		_, err = cloudflare.NewWorkersKv(ctx, "example", &cloudflare.WorkersKvArgs{
/// 			AccountId:   pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			NamespaceId: exampleNs.ID(),
/// 			Key:         pulumi.String("test-key"),
/// 			Value:       pulumi.String("test value"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.WorkersKvNamespace;
/// import com.pulumi.cloudflare.WorkersKvNamespaceArgs;
/// import com.pulumi.cloudflare.WorkersKv;
/// import com.pulumi.cloudflare.WorkersKvArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var exampleNs = new WorkersKvNamespace("exampleNs", WorkersKvNamespaceArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .title("test-namespace")
///             .build());
///
///         var example = new WorkersKv("example", WorkersKvArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .namespaceId(exampleNs.id())
///             .key("test-key")
///             .value("test value")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   exampleNs:
///     type: cloudflare:WorkersKvNamespace
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       title: test-namespace
///   example:
///     type: cloudflare:WorkersKv
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       namespaceId: ${exampleNs.id}
///       key: test-key
///       value: test value
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/workersKv:WorkersKv example <account_id>/<namespace_id>/<key_name>
/// ```
///
pub mod workers_kv {

    pub struct WorkersKvArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Name of the KV pair. **Modifying this attribute will force creation of a new resource.**
        pub key: pulumi_wasm_rust::Output<String>,
        /// The ID of the Workers KV namespace in which you want to create the KV pair. **Modifying this attribute will force creation of a new resource.**
        pub namespace_id: pulumi_wasm_rust::Output<String>,
        /// Value of the KV pair.
        pub value: pulumi_wasm_rust::Output<String>,
    }

    pub struct WorkersKvResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Name of the KV pair. **Modifying this attribute will force creation of a new resource.**
        pub key: pulumi_wasm_rust::Output<String>,
        /// The ID of the Workers KV namespace in which you want to create the KV pair. **Modifying this attribute will force creation of a new resource.**
        pub namespace_id: pulumi_wasm_rust::Output<String>,
        /// Value of the KV pair.
        pub value: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn workers_kv(name: &str, args: WorkersKvArgs) -> WorkersKvResult {
        let result = crate::bindings::pulumi::cloudflare::workers_kv::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::workers_kv::Args {
                account_id: args.account_id.get_inner(),
                key: args.key.get_inner(),
                namespace_id: args.namespace_id.get_inner(),
                value: args.value.get_inner(),
            },
        );

        WorkersKvResult {
            account_id: crate::into_domain(result.account_id),
            key: crate::into_domain(result.key),
            namespace_id: crate::into_domain(result.namespace_id),
            value: crate::into_domain(result.value),
        }
    }
}

/// Provides the ability to manage Cloudflare Workers KV Namespace features.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.WorkersKvNamespace("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     title: "test-namespace",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.WorkersKvNamespace("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     title="test-namespace")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.WorkersKvNamespace("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         Title = "test-namespace",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewWorkersKvNamespace(ctx, "example", &cloudflare.WorkersKvNamespaceArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Title:     pulumi.String("test-namespace"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.WorkersKvNamespace;
/// import com.pulumi.cloudflare.WorkersKvNamespaceArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new WorkersKvNamespace("example", WorkersKvNamespaceArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .title("test-namespace")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:WorkersKvNamespace
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       title: test-namespace
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/workersKvNamespace:WorkersKvNamespace example <account_id>/<namespace_id>
/// ```
///
pub mod workers_kv_namespace {

    pub struct WorkersKvNamespaceArgs {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Title value of the Worker KV Namespace.
        pub title: pulumi_wasm_rust::Output<String>,
    }

    pub struct WorkersKvNamespaceResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Title value of the Worker KV Namespace.
        pub title: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn workers_kv_namespace(
        name: &str,
        args: WorkersKvNamespaceArgs,
    ) -> WorkersKvNamespaceResult {
        let result = crate::bindings::pulumi::cloudflare::workers_kv_namespace::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::workers_kv_namespace::Args {
                account_id: args.account_id.get_inner(),
                title: args.title.get_inner(),
            },
        );

        WorkersKvNamespaceResult {
            account_id: crate::into_domain(result.account_id),
            title: crate::into_domain(result.title),
        }
    }
}

/// Provides a Cloudflare Zone resource. Zone is the basic resource for
/// working with Cloudflare and is roughly equivalent to a domain name
/// that the user purchases.
///
/// > If you are attempting to sign up a subdomain of a zone you must first have Subdomain Support entitlement for your account.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.Zone("example", {
///     accountId: "f037e56e89293a057740de681ac9abbe",
///     zone: "example.com",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.Zone("example",
///     account_id="f037e56e89293a057740de681ac9abbe",
///     zone="example.com")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.Zone("example", new()
///     {
///         AccountId = "f037e56e89293a057740de681ac9abbe",
///         ZoneName = "example.com",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewZone(ctx, "example", &cloudflare.ZoneArgs{
/// 			AccountId: pulumi.String("f037e56e89293a057740de681ac9abbe"),
/// 			Zone:      pulumi.String("example.com"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.Zone;
/// import com.pulumi.cloudflare.ZoneArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new Zone("example", ZoneArgs.builder()        
///             .accountId("f037e56e89293a057740de681ac9abbe")
///             .zone("example.com")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:Zone
///     properties:
///       accountId: f037e56e89293a057740de681ac9abbe
///       zone: example.com
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/zone:Zone example <zone_id>
/// ```
///
pub mod zone {

    pub struct ZoneArgs {
        /// Account ID to manage the zone resource in.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether to scan for DNS records on creation. Ignored after zone is created.
        pub jump_start: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether this zone is paused (traffic bypasses Cloudflare). Defaults to `false`.
        pub paused: pulumi_wasm_rust::Output<Option<bool>>,
        /// The name of the commercial plan to apply to the zone. Available values: `free`, `lite`, `pro`, `pro_plus`, `business`, `enterprise`, `partners_free`, `partners_pro`, `partners_business`, `partners_enterprise`.
        pub plan: pulumi_wasm_rust::Output<Option<String>>,
        /// A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup. Available values: `full`, `partial`, `secondary`. Defaults to `full`.
        pub type_: pulumi_wasm_rust::Output<Option<String>>,
        /// The DNS zone name which will be added. **Modifying this attribute will force creation of a new resource.**
        pub zone: pulumi_wasm_rust::Output<String>,
    }

    pub struct ZoneResult {
        /// Account ID to manage the zone resource in.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether to scan for DNS records on creation. Ignored after zone is created.
        pub jump_start: pulumi_wasm_rust::Output<Option<bool>>,
        pub meta: pulumi_wasm_rust::Output<std::collections::HashMap<String, bool>>,
        /// Cloudflare-assigned name servers. This is only populated for zones that use Cloudflare DNS.
        pub name_servers: pulumi_wasm_rust::Output<Vec<String>>,
        /// Whether this zone is paused (traffic bypasses Cloudflare). Defaults to `false`.
        pub paused: pulumi_wasm_rust::Output<Option<bool>>,
        /// The name of the commercial plan to apply to the zone. Available values: `free`, `lite`, `pro`, `pro_plus`, `business`, `enterprise`, `partners_free`, `partners_pro`, `partners_business`, `partners_enterprise`.
        pub plan: pulumi_wasm_rust::Output<String>,
        /// Status of the zone. Available values: `active`, `pending`, `initializing`, `moved`, `deleted`, `deactivated`.
        pub status: pulumi_wasm_rust::Output<String>,
        /// A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup. Available values: `full`, `partial`, `secondary`. Defaults to `full`.
        pub type_: pulumi_wasm_rust::Output<Option<String>>,
        /// List of Vanity Nameservers (if set).
        pub vanity_name_servers: pulumi_wasm_rust::Output<Vec<String>>,
        /// Contains the TXT record value to validate domain ownership. This is only populated for zones of type `partial`.
        pub verification_key: pulumi_wasm_rust::Output<String>,
        /// The DNS zone name which will be added. **Modifying this attribute will force creation of a new resource.**
        pub zone: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn zone(name: &str, args: ZoneArgs) -> ZoneResult {
        let result = crate::bindings::pulumi::cloudflare::zone::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::zone::Args {
                account_id: args.account_id.get_inner(),
                jump_start: args.jump_start.get_inner(),
                paused: args.paused.get_inner(),
                plan: args.plan.get_inner(),
                type_: args.type_.get_inner(),
                zone: args.zone.get_inner(),
            },
        );

        ZoneResult {
            account_id: crate::into_domain(result.account_id),
            jump_start: crate::into_domain(result.jump_start),
            meta: crate::into_domain(result.meta),
            name_servers: crate::into_domain(result.name_servers),
            paused: crate::into_domain(result.paused),
            plan: crate::into_domain(result.plan),
            status: crate::into_domain(result.status),
            type_: crate::into_domain(result.type_),
            vanity_name_servers: crate::into_domain(result.vanity_name_servers),
            verification_key: crate::into_domain(result.verification_key),
            zone: crate::into_domain(result.zone),
        }
    }
}

/// Provides a Cloudflare Cache Reserve resource. Cache Reserve can
/// increase cache lifetimes by automatically storing all cacheable
/// files in Cloudflare's persistent object storage buckets.
///
/// Note: Using Cache Reserve without Tiered Cache is not recommended.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.ZoneCacheReserve("example", {
///     enabled: true,
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.ZoneCacheReserve("example",
///     enabled=True,
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.ZoneCacheReserve("example", new()
///     {
///         Enabled = true,
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewZoneCacheReserve(ctx, "example", &cloudflare.ZoneCacheReserveArgs{
/// 			Enabled: pulumi.Bool(true),
/// 			ZoneId:  pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.ZoneCacheReserve;
/// import com.pulumi.cloudflare.ZoneCacheReserveArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new ZoneCacheReserve("example", ZoneCacheReserveArgs.builder()        
///             .enabled(true)
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:ZoneCacheReserve
///     properties:
///       enabled: true
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/zoneCacheReserve:ZoneCacheReserve example <zone_id>
/// ```
///
pub mod zone_cache_reserve {

    pub struct ZoneCacheReserveArgs {
        /// Whether to enable or disable Cache Reserve support for a given zone.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct ZoneCacheReserveResult {
        /// Whether to enable or disable Cache Reserve support for a given zone.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn zone_cache_reserve(name: &str, args: ZoneCacheReserveArgs) -> ZoneCacheReserveResult {
        let result = crate::bindings::pulumi::cloudflare::zone_cache_reserve::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::zone_cache_reserve::Args {
                enabled: args.enabled.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        ZoneCacheReserveResult {
            enabled: crate::into_domain(result.enabled),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a resource which customizes Cloudflare zone cache variants.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.ZoneCacheVariants("example", {
///     avifs: [
///         "image/avif",
///         "image/webp",
///     ],
///     bmps: [
///         "image/bmp",
///         "image/webp",
///     ],
///     gifs: [
///         "image/gif",
///         "image/webp",
///     ],
///     jp2s: [
///         "image/jp2",
///         "image/webp",
///     ],
///     jpegs: [
///         "image/jpeg",
///         "image/webp",
///     ],
///     jpgs: [
///         "image/jpg",
///         "image/webp",
///     ],
///     jpg2s: [
///         "image/jpg2",
///         "image/webp",
///     ],
///     pngs: [
///         "image/png",
///         "image/webp",
///     ],
///     tifs: [
///         "image/tif",
///         "image/webp",
///     ],
///     tiffs: [
///         "image/tiff",
///         "image/webp",
///     ],
///     webps: [
///         "image/jpeg",
///         "image/webp",
///     ],
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.ZoneCacheVariants("example",
///     avifs=[
///         "image/avif",
///         "image/webp",
///     ],
///     bmps=[
///         "image/bmp",
///         "image/webp",
///     ],
///     gifs=[
///         "image/gif",
///         "image/webp",
///     ],
///     jp2s=[
///         "image/jp2",
///         "image/webp",
///     ],
///     jpegs=[
///         "image/jpeg",
///         "image/webp",
///     ],
///     jpgs=[
///         "image/jpg",
///         "image/webp",
///     ],
///     jpg2s=[
///         "image/jpg2",
///         "image/webp",
///     ],
///     pngs=[
///         "image/png",
///         "image/webp",
///     ],
///     tifs=[
///         "image/tif",
///         "image/webp",
///     ],
///     tiffs=[
///         "image/tiff",
///         "image/webp",
///     ],
///     webps=[
///         "image/jpeg",
///         "image/webp",
///     ],
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.ZoneCacheVariants("example", new()
///     {
///         Avifs = new[]
///         {
///             "image/avif",
///             "image/webp",
///         },
///         Bmps = new[]
///         {
///             "image/bmp",
///             "image/webp",
///         },
///         Gifs = new[]
///         {
///             "image/gif",
///             "image/webp",
///         },
///         Jp2s = new[]
///         {
///             "image/jp2",
///             "image/webp",
///         },
///         Jpegs = new[]
///         {
///             "image/jpeg",
///             "image/webp",
///         },
///         Jpgs = new[]
///         {
///             "image/jpg",
///             "image/webp",
///         },
///         Jpg2s = new[]
///         {
///             "image/jpg2",
///             "image/webp",
///         },
///         Pngs = new[]
///         {
///             "image/png",
///             "image/webp",
///         },
///         Tifs = new[]
///         {
///             "image/tif",
///             "image/webp",
///         },
///         Tiffs = new[]
///         {
///             "image/tiff",
///             "image/webp",
///         },
///         Webps = new[]
///         {
///             "image/jpeg",
///             "image/webp",
///         },
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewZoneCacheVariants(ctx, "example", &cloudflare.ZoneCacheVariantsArgs{
/// 			Avifs: pulumi.StringArray{
/// 				pulumi.String("image/avif"),
/// 				pulumi.String("image/webp"),
/// 			},
/// 			Bmps: pulumi.StringArray{
/// 				pulumi.String("image/bmp"),
/// 				pulumi.String("image/webp"),
/// 			},
/// 			Gifs: pulumi.StringArray{
/// 				pulumi.String("image/gif"),
/// 				pulumi.String("image/webp"),
/// 			},
/// 			Jp2s: pulumi.StringArray{
/// 				pulumi.String("image/jp2"),
/// 				pulumi.String("image/webp"),
/// 			},
/// 			Jpegs: pulumi.StringArray{
/// 				pulumi.String("image/jpeg"),
/// 				pulumi.String("image/webp"),
/// 			},
/// 			Jpgs: pulumi.StringArray{
/// 				pulumi.String("image/jpg"),
/// 				pulumi.String("image/webp"),
/// 			},
/// 			Jpg2s: pulumi.StringArray{
/// 				pulumi.String("image/jpg2"),
/// 				pulumi.String("image/webp"),
/// 			},
/// 			Pngs: pulumi.StringArray{
/// 				pulumi.String("image/png"),
/// 				pulumi.String("image/webp"),
/// 			},
/// 			Tifs: pulumi.StringArray{
/// 				pulumi.String("image/tif"),
/// 				pulumi.String("image/webp"),
/// 			},
/// 			Tiffs: pulumi.StringArray{
/// 				pulumi.String("image/tiff"),
/// 				pulumi.String("image/webp"),
/// 			},
/// 			Webps: pulumi.StringArray{
/// 				pulumi.String("image/jpeg"),
/// 				pulumi.String("image/webp"),
/// 			},
/// 			ZoneId: pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.ZoneCacheVariants;
/// import com.pulumi.cloudflare.ZoneCacheVariantsArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new ZoneCacheVariants("example", ZoneCacheVariantsArgs.builder()        
///             .avifs(            
///                 "image/avif",
///                 "image/webp")
///             .bmps(            
///                 "image/bmp",
///                 "image/webp")
///             .gifs(            
///                 "image/gif",
///                 "image/webp")
///             .jp2s(            
///                 "image/jp2",
///                 "image/webp")
///             .jpegs(            
///                 "image/jpeg",
///                 "image/webp")
///             .jpgs(            
///                 "image/jpg",
///                 "image/webp")
///             .jpg2s(            
///                 "image/jpg2",
///                 "image/webp")
///             .pngs(            
///                 "image/png",
///                 "image/webp")
///             .tifs(            
///                 "image/tif",
///                 "image/webp")
///             .tiffs(            
///                 "image/tiff",
///                 "image/webp")
///             .webps(            
///                 "image/jpeg",
///                 "image/webp")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:ZoneCacheVariants
///     properties:
///       avifs:
///         - image/avif
///         - image/webp
///       bmps:
///         - image/bmp
///         - image/webp
///       gifs:
///         - image/gif
///         - image/webp
///       jp2s:
///         - image/jp2
///         - image/webp
///       jpegs:
///         - image/jpeg
///         - image/webp
///       jpgs:
///         - image/jpg
///         - image/webp
///       jpg2s:
///         - image/jpg2
///         - image/webp
///       pngs:
///         - image/png
///         - image/webp
///       tifs:
///         - image/tif
///         - image/webp
///       tiffs:
///         - image/tiff
///         - image/webp
///       webps:
///         - image/jpeg
///         - image/webp
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
pub mod zone_cache_variants {

    pub struct ZoneCacheVariantsArgs {
        /// List of strings with the MIME types of all the variants that should be served for avif.
        pub avifs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for bmp.
        pub bmps: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for gif.
        pub gifs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for jp2.
        pub jp2s: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for jpeg.
        pub jpegs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for jpg2.
        pub jpg2s: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for jpg.
        pub jpgs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for png.
        pub pngs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for tiff.
        pub tiffs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for tif.
        pub tifs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for webp.
        pub webps: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct ZoneCacheVariantsResult {
        /// List of strings with the MIME types of all the variants that should be served for avif.
        pub avifs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for bmp.
        pub bmps: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for gif.
        pub gifs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for jp2.
        pub jp2s: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for jpeg.
        pub jpegs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for jpg2.
        pub jpg2s: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for jpg.
        pub jpgs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for png.
        pub pngs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for tiff.
        pub tiffs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for tif.
        pub tifs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for webp.
        pub webps: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn zone_cache_variants(name: &str, args: ZoneCacheVariantsArgs) -> ZoneCacheVariantsResult {
        let result = crate::bindings::pulumi::cloudflare::zone_cache_variants::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::zone_cache_variants::Args {
                avifs: args.avifs.get_inner(),
                bmps: args.bmps.get_inner(),
                gifs: args.gifs.get_inner(),
                jp2s: args.jp2s.get_inner(),
                jpegs: args.jpegs.get_inner(),
                jpg2s: args.jpg2s.get_inner(),
                jpgs: args.jpgs.get_inner(),
                pngs: args.pngs.get_inner(),
                tiffs: args.tiffs.get_inner(),
                tifs: args.tifs.get_inner(),
                webps: args.webps.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        ZoneCacheVariantsResult {
            avifs: crate::into_domain(result.avifs),
            bmps: crate::into_domain(result.bmps),
            gifs: crate::into_domain(result.gifs),
            jp2s: crate::into_domain(result.jp2s),
            jpegs: crate::into_domain(result.jpegs),
            jpg2s: crate::into_domain(result.jpg2s),
            jpgs: crate::into_domain(result.jpgs),
            pngs: crate::into_domain(result.pngs),
            tiffs: crate::into_domain(result.tiffs),
            tifs: crate::into_domain(result.tifs),
            webps: crate::into_domain(result.webps),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare resource to create and modify zone DNSSEC settings.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const exampleZone = new cloudflare.Zone("exampleZone", {zone: "example.com"});
/// const exampleZoneDnssec = new cloudflare.ZoneDnssec("exampleZoneDnssec", {zoneId: exampleZone.id});
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example_zone = cloudflare.Zone("exampleZone", zone="example.com")
/// example_zone_dnssec = cloudflare.ZoneDnssec("exampleZoneDnssec", zone_id=example_zone.id)
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var exampleZone = new Cloudflare.Zone("exampleZone", new()
///     {
///         ZoneName = "example.com",
///     });
///
///     var exampleZoneDnssec = new Cloudflare.ZoneDnssec("exampleZoneDnssec", new()
///     {
///         ZoneId = exampleZone.Id,
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		exampleZone, err := cloudflare.NewZone(ctx, "exampleZone", &cloudflare.ZoneArgs{
/// 			Zone: pulumi.String("example.com"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		_, err = cloudflare.NewZoneDnssec(ctx, "exampleZoneDnssec", &cloudflare.ZoneDnssecArgs{
/// 			ZoneId: exampleZone.ID(),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.Zone;
/// import com.pulumi.cloudflare.ZoneArgs;
/// import com.pulumi.cloudflare.ZoneDnssec;
/// import com.pulumi.cloudflare.ZoneDnssecArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var exampleZone = new Zone("exampleZone", ZoneArgs.builder()        
///             .zone("example.com")
///             .build());
///
///         var exampleZoneDnssec = new ZoneDnssec("exampleZoneDnssec", ZoneDnssecArgs.builder()        
///             .zoneId(exampleZone.id())
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   exampleZone:
///     type: cloudflare:Zone
///     properties:
///       zone: example.com
///   exampleZoneDnssec:
///     type: cloudflare:ZoneDnssec
///     properties:
///       zoneId: ${exampleZone.id}
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/zoneDnssec:ZoneDnssec example <zone_id>
/// ```
///
pub mod zone_dnssec {

    pub struct ZoneDnssecArgs {
        /// Zone DNSSEC updated time.
        pub modified_on: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct ZoneDnssecResult {
        /// Zone DNSSEC algorithm.
        pub algorithm: pulumi_wasm_rust::Output<String>,
        /// Zone DNSSEC digest.
        pub digest: pulumi_wasm_rust::Output<String>,
        /// Digest algorithm use for Zone DNSSEC.
        pub digest_algorithm: pulumi_wasm_rust::Output<String>,
        /// Digest Type for Zone DNSSEC.
        pub digest_type: pulumi_wasm_rust::Output<String>,
        /// DS for the Zone DNSSEC.
        pub ds: pulumi_wasm_rust::Output<String>,
        /// Zone DNSSEC flags.
        pub flags: pulumi_wasm_rust::Output<i32>,
        /// Key Tag for the Zone DNSSEC.
        pub key_tag: pulumi_wasm_rust::Output<i32>,
        /// Key type used for Zone DNSSEC.
        pub key_type: pulumi_wasm_rust::Output<String>,
        /// Zone DNSSEC updated time.
        pub modified_on: pulumi_wasm_rust::Output<String>,
        /// Public Key for the Zone DNSSEC.
        pub public_key: pulumi_wasm_rust::Output<String>,
        /// The status of the Zone DNSSEC.
        pub status: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn zone_dnssec(name: &str, args: ZoneDnssecArgs) -> ZoneDnssecResult {
        let result = crate::bindings::pulumi::cloudflare::zone_dnssec::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::zone_dnssec::Args {
                modified_on: args.modified_on.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        ZoneDnssecResult {
            algorithm: crate::into_domain(result.algorithm),
            digest: crate::into_domain(result.digest),
            digest_algorithm: crate::into_domain(result.digest_algorithm),
            digest_type: crate::into_domain(result.digest_type),
            ds: crate::into_domain(result.ds),
            flags: crate::into_domain(result.flags),
            key_tag: crate::into_domain(result.key_tag),
            key_type: crate::into_domain(result.key_type),
            modified_on: crate::into_domain(result.modified_on),
            public_key: crate::into_domain(result.public_key),
            status: crate::into_domain(result.status),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare Zone Hold resource that prevents adding
/// the hostname to another account for use.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const example = new cloudflare.ZoneHold("example", {
///     hold: true,
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// example = cloudflare.ZoneHold("example",
///     hold=True,
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var example = new Cloudflare.ZoneHold("example", new()
///     {
///         Hold = true,
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewZoneHold(ctx, "example", &cloudflare.ZoneHoldArgs{
/// 			Hold:   pulumi.Bool(true),
/// 			ZoneId: pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.ZoneHold;
/// import com.pulumi.cloudflare.ZoneHoldArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var example = new ZoneHold("example", ZoneHoldArgs.builder()        
///             .hold(true)
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   example:
///     type: cloudflare:ZoneHold
///     properties:
///       hold: true
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/zoneHold:ZoneHold example <zone_id>
/// ```
///
pub mod zone_hold {

    pub struct ZoneHoldArgs {
        /// Enablement status of the zone hold.
        pub hold: pulumi_wasm_rust::Output<bool>,
        /// The RFC3339 compatible timestamp when to automatically re-enable the zone hold.
        pub hold_after: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether to extend to block any subdomain of the given zone.
        pub include_subdomains: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct ZoneHoldResult {
        /// Enablement status of the zone hold.
        pub hold: pulumi_wasm_rust::Output<bool>,
        /// The RFC3339 compatible timestamp when to automatically re-enable the zone hold.
        pub hold_after: pulumi_wasm_rust::Output<String>,
        /// Whether to extend to block any subdomain of the given zone.
        pub include_subdomains: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn zone_hold(name: &str, args: ZoneHoldArgs) -> ZoneHoldResult {
        let result = crate::bindings::pulumi::cloudflare::zone_hold::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::zone_hold::Args {
                hold: args.hold.get_inner(),
                hold_after: args.hold_after.get_inner(),
                include_subdomains: args.include_subdomains.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        ZoneHoldResult {
            hold: crate::into_domain(result.hold),
            hold_after: crate::into_domain(result.hold_after),
            include_subdomains: crate::into_domain(result.include_subdomains),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a Cloudflare Zone Lockdown resource. Zone Lockdown allows
/// you to define one or more URLs (with wildcard matching on the domain
/// or path) that will only permit access if the request originates
/// from an IP address that matches a safelist of one or more IP
/// addresses and/or IP ranges.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// // Restrict access to these endpoints to requests from a known IP address range.
/// const example = new cloudflare.ZoneLockdown("example", {
///     configurations: [{
///         target: "ip_range",
///         value: "192.0.2.0/24",
///     }],
///     description: "Restrict access to these endpoints to requests from a known IP address range",
///     paused: false,
///     urls: ["api.mysite.com/some/endpoint*"],
///     zoneId: "0da42c8d2132a9ddaf714f9e7c920711",
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// # Restrict access to these endpoints to requests from a known IP address range.
/// example = cloudflare.ZoneLockdown("example",
///     configurations=[cloudflare.ZoneLockdownConfigurationArgs(
///         target="ip_range",
///         value="192.0.2.0/24",
///     )],
///     description="Restrict access to these endpoints to requests from a known IP address range",
///     paused=False,
///     urls=["api.mysite.com/some/endpoint*"],
///     zone_id="0da42c8d2132a9ddaf714f9e7c920711")
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     // Restrict access to these endpoints to requests from a known IP address range.
///     var example = new Cloudflare.ZoneLockdown("example", new()
///     {
///         Configurations = new[]
///         {
///             new Cloudflare.Inputs.ZoneLockdownConfigurationArgs
///             {
///                 Target = "ip_range",
///                 Value = "192.0.2.0/24",
///             },
///         },
///         Description = "Restrict access to these endpoints to requests from a known IP address range",
///         Paused = false,
///         Urls = new[]
///         {
///             "api.mysite.com/some/endpoint*",
///         },
///         ZoneId = "0da42c8d2132a9ddaf714f9e7c920711",
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		// Restrict access to these endpoints to requests from a known IP address range.
/// 		_, err := cloudflare.NewZoneLockdown(ctx, "example", &cloudflare.ZoneLockdownArgs{
/// 			Configurations: cloudflare.ZoneLockdownConfigurationArray{
/// 				&cloudflare.ZoneLockdownConfigurationArgs{
/// 					Target: pulumi.String("ip_range"),
/// 					Value:  pulumi.String("192.0.2.0/24"),
/// 				},
/// 			},
/// 			Description: pulumi.String("Restrict access to these endpoints to requests from a known IP address range"),
/// 			Paused:      pulumi.Bool(false),
/// 			Urls: pulumi.StringArray{
/// 				pulumi.String("api.mysite.com/some/endpoint*"),
/// 			},
/// 			ZoneId: pulumi.String("0da42c8d2132a9ddaf714f9e7c920711"),
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.ZoneLockdown;
/// import com.pulumi.cloudflare.ZoneLockdownArgs;
/// import com.pulumi.cloudflare.inputs.ZoneLockdownConfigurationArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         // Restrict access to these endpoints to requests from a known IP address range.
///         var example = new ZoneLockdown("example", ZoneLockdownArgs.builder()        
///             .configurations(ZoneLockdownConfigurationArgs.builder()
///                 .target("ip_range")
///                 .value("192.0.2.0/24")
///                 .build())
///             .description("Restrict access to these endpoints to requests from a known IP address range")
///             .paused("false")
///             .urls("api.mysite.com/some/endpoint*")
///             .zoneId("0da42c8d2132a9ddaf714f9e7c920711")
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   # Restrict access to these endpoints to requests from a known IP address range.
///   example:
///     type: cloudflare:ZoneLockdown
///     properties:
///       configurations:
///         - target: ip_range
///           value: 192.0.2.0/24
///       description: Restrict access to these endpoints to requests from a known IP address range
///       paused: 'false'
///       urls:
///         - api.mysite.com/some/endpoint*
///       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
/// ```
/// <!--End PulumiCodeChooser -->
///
/// ## Import
///
/// ```sh
/// $ pulumi import cloudflare:index/zoneLockdown:ZoneLockdown example <zone_id>/<lockdown_id>
/// ```
///
pub mod zone_lockdown {

    pub struct ZoneLockdownArgs {
        /// A list of IP addresses or IP ranges to match the request against specified in target, value pairs.
        pub configurations: pulumi_wasm_rust::Output<Vec<crate::types::ZoneLockdownConfiguration>>,
        /// A description about the lockdown entry. Typically used as a reminder or explanation for the lockdown.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Boolean of whether this zone lockdown is currently paused. Defaults to `false`.
        pub paused: pulumi_wasm_rust::Output<Option<bool>>,
        pub priority: pulumi_wasm_rust::Output<Option<i32>>,
        /// A list of simple wildcard patterns to match requests against. The order of the urls is unimportant.
        pub urls: pulumi_wasm_rust::Output<Vec<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct ZoneLockdownResult {
        /// A list of IP addresses or IP ranges to match the request against specified in target, value pairs.
        pub configurations: pulumi_wasm_rust::Output<Vec<crate::types::ZoneLockdownConfiguration>>,
        /// A description about the lockdown entry. Typically used as a reminder or explanation for the lockdown.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Boolean of whether this zone lockdown is currently paused. Defaults to `false`.
        pub paused: pulumi_wasm_rust::Output<Option<bool>>,
        pub priority: pulumi_wasm_rust::Output<Option<i32>>,
        /// A list of simple wildcard patterns to match requests against. The order of the urls is unimportant.
        pub urls: pulumi_wasm_rust::Output<Vec<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn zone_lockdown(name: &str, args: ZoneLockdownArgs) -> ZoneLockdownResult {
        let result = crate::bindings::pulumi::cloudflare::zone_lockdown::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::zone_lockdown::Args {
                configurations: args.configurations.get_inner(),
                description: args.description.get_inner(),
                paused: args.paused.get_inner(),
                priority: args.priority.get_inner(),
                urls: args.urls.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        ZoneLockdownResult {
            configurations: crate::into_domain(result.configurations),
            description: crate::into_domain(result.description),
            paused: crate::into_domain(result.paused),
            priority: crate::into_domain(result.priority),
            urls: crate::into_domain(result.urls),
            zone_id: crate::into_domain(result.zone_id),
        }
    }
}

/// Provides a resource which customizes Cloudflare zone settings.
///
/// > You **should not** use this resource to manage every zone setting. This
///   resource is only intended to override those which you do not want the default.
///   Attempting to manage all settings will result in problems with the resource
///   applying in a consistent manner.
///
/// ## Example Usage
///
/// <!--Start PulumiCodeChooser -->
/// ### Typescript
/// ```typescript
/// import * as pulumi from "@pulumi/pulumi";
/// import * as cloudflare from "@pulumi/cloudflare";
///
/// const test = new cloudflare.ZoneSettingsOverride("test", {
///     zoneId: d41d8cd98f00b204e9800998ecf8427e,
///     settings: {
///         brotli: "on",
///         challengeTtl: 2700,
///         securityLevel: "high",
///         opportunisticEncryption: "on",
///         automaticHttpsRewrites: "on",
///         mirage: "on",
///         waf: "on",
///         minify: {
///             css: "on",
///             js: "off",
///             html: "off",
///         },
///         securityHeader: {
///             enabled: true,
///         },
///     },
/// });
/// ```
/// ### Python
/// ```python
/// import pulumi
/// import pulumi_cloudflare as cloudflare
///
/// test = cloudflare.ZoneSettingsOverride("test",
///     zone_id=d41d8cd98f00b204e9800998ecf8427e,
///     settings=cloudflare.ZoneSettingsOverrideSettingsArgs(
///         brotli="on",
///         challenge_ttl=2700,
///         security_level="high",
///         opportunistic_encryption="on",
///         automatic_https_rewrites="on",
///         mirage="on",
///         waf="on",
///         minify=cloudflare.ZoneSettingsOverrideSettingsMinifyArgs(
///             css="on",
///             js="off",
///             html="off",
///         ),
///         security_header=cloudflare.ZoneSettingsOverrideSettingsSecurityHeaderArgs(
///             enabled=True,
///         ),
///     ))
/// ```
/// ### C#
/// ```csharp
/// using System.Collections.Generic;
/// using System.Linq;
/// using Pulumi;
/// using Cloudflare = Pulumi.Cloudflare;
///
/// return await Deployment.RunAsync(() =>
/// {
///     var test = new Cloudflare.ZoneSettingsOverride("test", new()
///     {
///         ZoneId = d41d8cd98f00b204e9800998ecf8427e,
///         Settings = new Cloudflare.Inputs.ZoneSettingsOverrideSettingsArgs
///         {
///             Brotli = "on",
///             ChallengeTtl = 2700,
///             SecurityLevel = "high",
///             OpportunisticEncryption = "on",
///             AutomaticHttpsRewrites = "on",
///             Mirage = "on",
///             Waf = "on",
///             Minify = new Cloudflare.Inputs.ZoneSettingsOverrideSettingsMinifyArgs
///             {
///                 Css = "on",
///                 Js = "off",
///                 Html = "off",
///             },
///             SecurityHeader = new Cloudflare.Inputs.ZoneSettingsOverrideSettingsSecurityHeaderArgs
///             {
///                 Enabled = true,
///             },
///         },
///     });
///
/// });
/// ```
/// ### Go
/// ```go
/// package main
///
/// import (
/// 	"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare"
/// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
/// )
///
/// func main() {
/// 	pulumi.Run(func(ctx *pulumi.Context) error {
/// 		_, err := cloudflare.NewZoneSettingsOverride(ctx, "test", &cloudflare.ZoneSettingsOverrideArgs{
/// 			ZoneId: pulumi.Any(d41d8cd98f00b204e9800998ecf8427e),
/// 			Settings: &cloudflare.ZoneSettingsOverrideSettingsArgs{
/// 				Brotli:                  pulumi.String("on"),
/// 				ChallengeTtl:            pulumi.Int(2700),
/// 				SecurityLevel:           pulumi.String("high"),
/// 				OpportunisticEncryption: pulumi.String("on"),
/// 				AutomaticHttpsRewrites:  pulumi.String("on"),
/// 				Mirage:                  pulumi.String("on"),
/// 				Waf:                     pulumi.String("on"),
/// 				Minify: &cloudflare.ZoneSettingsOverrideSettingsMinifyArgs{
/// 					Css:  pulumi.String("on"),
/// 					Js:   pulumi.String("off"),
/// 					Html: pulumi.String("off"),
/// 				},
/// 				SecurityHeader: &cloudflare.ZoneSettingsOverrideSettingsSecurityHeaderArgs{
/// 					Enabled: pulumi.Bool(true),
/// 				},
/// 			},
/// 		})
/// 		if err != nil {
/// 			return err
/// 		}
/// 		return nil
/// 	})
/// }
/// ```
/// ### Java
/// ```java
/// package generated_program;
///
/// import com.pulumi.Context;
/// import com.pulumi.Pulumi;
/// import com.pulumi.core.Output;
/// import com.pulumi.cloudflare.ZoneSettingsOverride;
/// import com.pulumi.cloudflare.ZoneSettingsOverrideArgs;
/// import com.pulumi.cloudflare.inputs.ZoneSettingsOverrideSettingsArgs;
/// import com.pulumi.cloudflare.inputs.ZoneSettingsOverrideSettingsMinifyArgs;
/// import com.pulumi.cloudflare.inputs.ZoneSettingsOverrideSettingsSecurityHeaderArgs;
/// import java.util.List;
/// import java.util.ArrayList;
/// import java.util.Map;
/// import java.io.File;
/// import java.nio.file.Files;
/// import java.nio.file.Paths;
///
/// public class App {
///     public static void main(String[] args) {
///         Pulumi.run(App::stack);
///     }
///
///     public static void stack(Context ctx) {
///         var test = new ZoneSettingsOverride("test", ZoneSettingsOverrideArgs.builder()        
///             .zoneId(d41d8cd98f00b204e9800998ecf8427e)
///             .settings(ZoneSettingsOverrideSettingsArgs.builder()
///                 .brotli("on")
///                 .challengeTtl(2700)
///                 .securityLevel("high")
///                 .opportunisticEncryption("on")
///                 .automaticHttpsRewrites("on")
///                 .mirage("on")
///                 .waf("on")
///                 .minify(ZoneSettingsOverrideSettingsMinifyArgs.builder()
///                     .css("on")
///                     .js("off")
///                     .html("off")
///                     .build())
///                 .securityHeader(ZoneSettingsOverrideSettingsSecurityHeaderArgs.builder()
///                     .enabled(true)
///                     .build())
///                 .build())
///             .build());
///
///     }
/// }
/// ```
/// ### YAML
/// ```yaml
/// resources:
///   test:
///     type: cloudflare:ZoneSettingsOverride
///     properties:
///       zoneId: ${d41d8cd98f00b204e9800998ecf8427e}
///       settings:
///         brotli: on
///         challengeTtl: 2700
///         securityLevel: high
///         opportunisticEncryption: on
///         automaticHttpsRewrites: on
///         mirage: on
///         waf: on
///         minify:
///           css: on
///           js: off
///           html: off
///         securityHeader:
///           enabled: true
/// ```
/// <!--End PulumiCodeChooser -->
pub mod zone_settings_override {

    pub struct ZoneSettingsOverrideArgs {
        pub settings: pulumi_wasm_rust::Output<Option<crate::types::ZoneSettingsOverrideSettings>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }

    pub struct ZoneSettingsOverrideResult {
        pub initial_settings:
            pulumi_wasm_rust::Output<Vec<crate::types::ZoneSettingsOverrideInitialSetting>>,
        pub initial_settings_read_at: pulumi_wasm_rust::Output<String>,
        pub readonly_settings: pulumi_wasm_rust::Output<Vec<String>>,
        pub settings: pulumi_wasm_rust::Output<crate::types::ZoneSettingsOverrideSettings>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
        pub zone_status: pulumi_wasm_rust::Output<String>,
        pub zone_type: pulumi_wasm_rust::Output<String>,
    }

    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    pub fn zone_settings_override(
        name: &str,
        args: ZoneSettingsOverrideArgs,
    ) -> ZoneSettingsOverrideResult {
        let result = crate::bindings::pulumi::cloudflare::zone_settings_override::invoke(
            name,
            &crate::bindings::pulumi::cloudflare::zone_settings_override::Args {
                settings: args.settings.get_inner(),
                zone_id: args.zone_id.get_inner(),
            },
        );

        ZoneSettingsOverrideResult {
            initial_settings: crate::into_domain(result.initial_settings),
            initial_settings_read_at: crate::into_domain(result.initial_settings_read_at),
            readonly_settings: crate::into_domain(result.readonly_settings),
            settings: crate::into_domain(result.settings),
            zone_id: crate::into_domain(result.zone_id),
            zone_status: crate::into_domain(result.zone_status),
            zone_type: crate::into_domain(result.zone_type),
        }
    }
}
