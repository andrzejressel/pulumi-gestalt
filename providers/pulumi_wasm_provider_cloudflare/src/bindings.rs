// Generated by `wit-bindgen` 0.25.0. DO NOT EDIT!
// Options used:
#[allow(dead_code)]
pub mod component {
    #[allow(dead_code)]
    pub mod pulumi_wasm {
        #[allow(dead_code, clippy::all)]
        pub mod output_interface {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;

            #[derive(Debug)]
            #[repr(transparent)]
            pub struct Output {
                handle: _rt::Resource<Output>,
            }

            impl Output {
                #[doc(hidden)]
                pub unsafe fn from_handle(handle: u32) -> Self {
                    Self {
                        handle: _rt::Resource::from_handle(handle),
                    }
                }

                #[doc(hidden)]
                pub fn take_handle(&self) -> u32 {
                    _rt::Resource::take_handle(&self.handle)
                }

                #[doc(hidden)]
                pub fn handle(&self) -> u32 {
                    _rt::Resource::handle(&self.handle)
                }
            }

            unsafe impl _rt::WasmResource for Output {
                #[inline]
                unsafe fn drop(_handle: u32) {
                    #[cfg(not(target_arch = "wasm32"))]
                    unreachable!();

                    #[cfg(target_arch = "wasm32")]
                    {
                        #[link(
                            wasm_import_module = "component:pulumi-wasm/output-interface@0.0.0-DEV"
                        )]
                        extern "C" {
                            #[link_name = "[resource-drop]output"]
                            fn drop(_: u32);
                        }

                        drop(_handle);
                    }
                }
            }

            impl Output {
                #[allow(unused_unsafe, clippy::all)]
                pub fn new(value: &str) -> Self {
                    unsafe {
                        let vec0 = value;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();

                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "component:pulumi-wasm/output-interface@0.0.0-DEV"
                        )]
                        extern "C" {
                            #[link_name = "[constructor]output"]
                            fn wit_import(_: *mut u8, _: usize) -> i32;
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: *mut u8, _: usize) -> i32 {
                            unreachable!()
                        }
                        let ret = wit_import(ptr0.cast_mut(), len0);
                        Output::from_handle(ret as u32)
                    }
                }
            }
            impl Output {
                #[allow(unused_unsafe, clippy::all)]
                pub fn map(&self, function_name: &str) -> Output {
                    unsafe {
                        let vec0 = function_name;
                        let ptr0 = vec0.as_ptr().cast::<u8>();
                        let len0 = vec0.len();

                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "component:pulumi-wasm/output-interface@0.0.0-DEV"
                        )]
                        extern "C" {
                            #[link_name = "[method]output.map"]
                            fn wit_import(_: i32, _: *mut u8, _: usize) -> i32;
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: i32, _: *mut u8, _: usize) -> i32 {
                            unreachable!()
                        }
                        let ret = wit_import((self).handle() as i32, ptr0.cast_mut(), len0);
                        Output::from_handle(ret as u32)
                    }
                }
            }
            impl Output {
                #[allow(unused_unsafe, clippy::all)]
                pub fn duplicate(&self) -> Output {
                    unsafe {
                        #[cfg(target_arch = "wasm32")]
                        #[link(
                            wasm_import_module = "component:pulumi-wasm/output-interface@0.0.0-DEV"
                        )]
                        extern "C" {
                            #[link_name = "[method]output.duplicate"]
                            fn wit_import(_: i32) -> i32;
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        fn wit_import(_: i32) -> i32 {
                            unreachable!()
                        }
                        let ret = wit_import((self).handle() as i32);
                        Output::from_handle(ret as u32)
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn combine(outputs: _rt::Vec<Output>) -> Output {
                unsafe {
                    let vec0 = &outputs;
                    let len0 = vec0.len();
                    let layout0 = _rt::alloc::Layout::from_size_align_unchecked(vec0.len() * 4, 4);
                    let result0 = if layout0.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout0).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout0);
                        }
                        ptr
                    } else {
                        {
                            ::core::ptr::null_mut()
                        }
                    };
                    for (i, e) in vec0.into_iter().enumerate() {
                        let base = result0.add(i * 4);
                        {
                            *base.add(0).cast::<i32>() = (e).take_handle() as i32;
                        }
                    }

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "component:pulumi-wasm/output-interface@0.0.0-DEV")]
                    extern "C" {
                        #[link_name = "combine"]
                        fn wit_import(_: *mut u8, _: usize) -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(result0, len0);
                    if layout0.size() != 0 {
                        _rt::alloc::dealloc(result0.cast(), layout0);
                    }
                    Output::from_handle(ret as u32)
                }
            }
        }

        #[allow(dead_code, clippy::all)]
        pub mod register_interface {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Output = super::super::super::component::pulumi_wasm::output_interface::Output;
            pub struct ObjectField<'a> {
                pub name: _rt::String,
                pub value: &'a Output,
            }
            impl<'a> ::core::fmt::Debug for ObjectField<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("ObjectField")
                        .field("name", &self.name)
                        .field("value", &self.value)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct ResultField {
                pub name: _rt::String,
            }
            impl ::core::fmt::Debug for ResultField {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("ResultField")
                        .field("name", &self.name)
                        .finish()
                }
            }
            pub struct RegisterResourceResultField {
                pub name: _rt::String,
                pub output: Output,
            }
            impl ::core::fmt::Debug for RegisterResourceResultField {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("RegisterResourceResultField")
                        .field("name", &self.name)
                        .field("output", &self.output)
                        .finish()
                }
            }
            pub struct RegisterResourceRequest<'a> {
                pub type_: _rt::String,
                pub name: _rt::String,
                pub object: _rt::Vec<ObjectField<'a>>,
                pub results: _rt::Vec<ResultField>,
            }
            impl<'a> ::core::fmt::Debug for RegisterResourceRequest<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("RegisterResourceRequest")
                        .field("type", &self.type_)
                        .field("name", &self.name)
                        .field("object", &self.object)
                        .field("results", &self.results)
                        .finish()
                }
            }
            pub struct RegisterResourceResult {
                pub fields: _rt::Vec<RegisterResourceResultField>,
            }
            impl ::core::fmt::Debug for RegisterResourceResult {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("RegisterResourceResult")
                        .field("fields", &self.fields)
                        .finish()
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn register(request: &RegisterResourceRequest<'_>) -> RegisterResourceResult {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let RegisterResourceRequest {
                        type_: type_0,
                        name: name0,
                        object: object0,
                        results: results0,
                    } = request;
                    let vec1 = type_0;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let vec2 = name0;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    let vec5 = object0;
                    let len5 = vec5.len();
                    let layout5 = _rt::alloc::Layout::from_size_align_unchecked(vec5.len() * 12, 4);
                    let result5 = if layout5.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout5);
                        }
                        ptr
                    } else {
                        {
                            ::core::ptr::null_mut()
                        }
                    };
                    for (i, e) in vec5.into_iter().enumerate() {
                        let base = result5.add(i * 12);
                        {
                            let ObjectField {
                                name: name3,
                                value: value3,
                            } = e;
                            let vec4 = name3;
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            *base.add(4).cast::<usize>() = len4;
                            *base.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                            *base.add(8).cast::<i32>() = (value3).handle() as i32;
                        }
                    }
                    let vec8 = results0;
                    let len8 = vec8.len();
                    let layout8 = _rt::alloc::Layout::from_size_align_unchecked(vec8.len() * 8, 4);
                    let result8 = if layout8.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout8).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout8);
                        }
                        ptr
                    } else {
                        {
                            ::core::ptr::null_mut()
                        }
                    };
                    for (i, e) in vec8.into_iter().enumerate() {
                        let base = result8.add(i * 8);
                        {
                            let ResultField { name: name6 } = e;
                            let vec7 = name6;
                            let ptr7 = vec7.as_ptr().cast::<u8>();
                            let len7 = vec7.len();
                            *base.add(4).cast::<usize>() = len7;
                            *base.add(0).cast::<*mut u8>() = ptr7.cast_mut();
                        }
                    }
                    let ptr9 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(
                        wasm_import_module = "component:pulumi-wasm/register-interface@0.0.0-DEV"
                    )]
                    extern "C" {
                        #[link_name = "register"]
                        fn wit_import(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    wit_import(
                        ptr1.cast_mut(),
                        len1,
                        ptr2.cast_mut(),
                        len2,
                        result5,
                        len5,
                        result8,
                        len8,
                        ptr9,
                    );
                    let l10 = *ptr9.add(0).cast::<*mut u8>();
                    let l11 = *ptr9.add(4).cast::<usize>();
                    let base16 = l10;
                    let len16 = l11;
                    let mut result16 = _rt::Vec::with_capacity(len16);
                    for i in 0..len16 {
                        let base = base16.add(i * 12);
                        let e16 = {
                            let l12 = *base.add(0).cast::<*mut u8>();
                            let l13 = *base.add(4).cast::<usize>();
                            let len14 = l13;
                            let bytes14 = _rt::Vec::from_raw_parts(l12.cast(), len14, len14);
                            let l15 = *base.add(8).cast::<i32>();

                            RegisterResourceResultField{
                name: _rt::string_lift(bytes14),
                output: super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l15 as u32),
              }
                        };
                        result16.push(e16);
                    }
                    _rt::cabi_dealloc(base16, len16 * 12, 4);
                    if layout5.size() != 0 {
                        _rt::alloc::dealloc(result5.cast(), layout5);
                    }
                    if layout8.size() != 0 {
                        _rt::alloc::dealloc(result8.cast(), layout8);
                    }
                    RegisterResourceResult { fields: result16 }
                }
            }
        }
    }
}
#[allow(dead_code)]
pub mod exports {
    #[allow(dead_code)]
    pub mod pulumi {
        #[allow(dead_code)]
        pub mod cloudflare {
            #[allow(dead_code, clippy::all)]
            pub mod access_application {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub allow_authenticate_via_warp: &'a Output,
                    pub allowed_idps: &'a Output,
                    pub app_launcher_logo_url: &'a Output,
                    pub app_launcher_visible: &'a Output,
                    pub auto_redirect_to_identity: &'a Output,
                    pub bg_color: &'a Output,
                    pub cors_headers: &'a Output,
                    pub custom_deny_message: &'a Output,
                    pub custom_deny_url: &'a Output,
                    pub custom_non_identity_deny_url: &'a Output,
                    pub custom_pages: &'a Output,
                    pub domain: &'a Output,
                    pub enable_binding_cookie: &'a Output,
                    pub footer_links: &'a Output,
                    pub header_bg_color: &'a Output,
                    pub http_only_cookie_attribute: &'a Output,
                    pub landing_page_design: &'a Output,
                    pub logo_url: &'a Output,
                    pub name: &'a Output,
                    pub saas_app: &'a Output,
                    pub same_site_cookie_attribute: &'a Output,
                    pub self_hosted_domains: &'a Output,
                    pub service_auth401_redirect: &'a Output,
                    pub session_duration: &'a Output,
                    pub skip_interstitial: &'a Output,
                    pub tags: &'a Output,
                    pub type_: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field(
                                "allow-authenticate-via-warp",
                                &self.allow_authenticate_via_warp,
                            )
                            .field("allowed-idps", &self.allowed_idps)
                            .field("app-launcher-logo-url", &self.app_launcher_logo_url)
                            .field("app-launcher-visible", &self.app_launcher_visible)
                            .field("auto-redirect-to-identity", &self.auto_redirect_to_identity)
                            .field("bg-color", &self.bg_color)
                            .field("cors-headers", &self.cors_headers)
                            .field("custom-deny-message", &self.custom_deny_message)
                            .field("custom-deny-url", &self.custom_deny_url)
                            .field(
                                "custom-non-identity-deny-url",
                                &self.custom_non_identity_deny_url,
                            )
                            .field("custom-pages", &self.custom_pages)
                            .field("domain", &self.domain)
                            .field("enable-binding-cookie", &self.enable_binding_cookie)
                            .field("footer-links", &self.footer_links)
                            .field("header-bg-color", &self.header_bg_color)
                            .field(
                                "http-only-cookie-attribute",
                                &self.http_only_cookie_attribute,
                            )
                            .field("landing-page-design", &self.landing_page_design)
                            .field("logo-url", &self.logo_url)
                            .field("name", &self.name)
                            .field("saas-app", &self.saas_app)
                            .field(
                                "same-site-cookie-attribute",
                                &self.same_site_cookie_attribute,
                            )
                            .field("self-hosted-domains", &self.self_hosted_domains)
                            .field("service-auth401-redirect", &self.service_auth401_redirect)
                            .field("session-duration", &self.session_duration)
                            .field("skip-interstitial", &self.skip_interstitial)
                            .field("tags", &self.tags)
                            .field("type", &self.type_)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub allow_authenticate_via_warp: Output,
                    pub allowed_idps: Output,
                    pub app_launcher_logo_url: Output,
                    pub app_launcher_visible: Output,
                    pub aud: Output,
                    pub auto_redirect_to_identity: Output,
                    pub bg_color: Output,
                    pub cors_headers: Output,
                    pub custom_deny_message: Output,
                    pub custom_deny_url: Output,
                    pub custom_non_identity_deny_url: Output,
                    pub custom_pages: Output,
                    pub domain: Output,
                    pub enable_binding_cookie: Output,
                    pub footer_links: Output,
                    pub header_bg_color: Output,
                    pub http_only_cookie_attribute: Output,
                    pub landing_page_design: Output,
                    pub logo_url: Output,
                    pub name: Output,
                    pub saas_app: Output,
                    pub same_site_cookie_attribute: Output,
                    pub self_hosted_domains: Output,
                    pub service_auth401_redirect: Output,
                    pub session_duration: Output,
                    pub skip_interstitial: Output,
                    pub tags: Output,
                    pub type_: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field(
                                "allow-authenticate-via-warp",
                                &self.allow_authenticate_via_warp,
                            )
                            .field("allowed-idps", &self.allowed_idps)
                            .field("app-launcher-logo-url", &self.app_launcher_logo_url)
                            .field("app-launcher-visible", &self.app_launcher_visible)
                            .field("aud", &self.aud)
                            .field("auto-redirect-to-identity", &self.auto_redirect_to_identity)
                            .field("bg-color", &self.bg_color)
                            .field("cors-headers", &self.cors_headers)
                            .field("custom-deny-message", &self.custom_deny_message)
                            .field("custom-deny-url", &self.custom_deny_url)
                            .field(
                                "custom-non-identity-deny-url",
                                &self.custom_non_identity_deny_url,
                            )
                            .field("custom-pages", &self.custom_pages)
                            .field("domain", &self.domain)
                            .field("enable-binding-cookie", &self.enable_binding_cookie)
                            .field("footer-links", &self.footer_links)
                            .field("header-bg-color", &self.header_bg_color)
                            .field(
                                "http-only-cookie-attribute",
                                &self.http_only_cookie_attribute,
                            )
                            .field("landing-page-design", &self.landing_page_design)
                            .field("logo-url", &self.logo_url)
                            .field("name", &self.name)
                            .field("saas-app", &self.saas_app)
                            .field(
                                "same-site-cookie-attribute",
                                &self.same_site_cookie_attribute,
                            )
                            .field("self-hosted-domains", &self.self_hosted_domains)
                            .field("service-auth401-redirect", &self.service_auth401_redirect)
                            .field("session-duration", &self.session_duration)
                            .field("skip-interstitial", &self.skip_interstitial)
                            .field("tags", &self.tags)
                            .field("type", &self.type_)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle4;
                    let handle6;
                    let handle8;
                    let handle10;
                    let handle12;
                    let handle14;
                    let handle16;
                    let handle18;
                    let handle20;
                    let handle22;
                    let handle24;
                    let handle26;
                    let handle28;
                    let handle30;
                    let handle32;
                    let handle34;
                    let handle36;
                    let handle38;
                    let handle40;
                    let handle42;
                    let handle44;
                    let handle46;
                    let handle48;
                    let handle50;
                    let handle52;
                    let handle54;
                    let handle56;
                    let handle58;
                    let handle60;
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let len2 = l1;
                    let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                    let l3 = *arg0.add(8).cast::<i32>();
                    let l5 = *arg0.add(12).cast::<i32>();
                    let l7 = *arg0.add(16).cast::<i32>();
                    let l9 = *arg0.add(20).cast::<i32>();
                    let l11 = *arg0.add(24).cast::<i32>();
                    let l13 = *arg0.add(28).cast::<i32>();
                    let l15 = *arg0.add(32).cast::<i32>();
                    let l17 = *arg0.add(36).cast::<i32>();
                    let l19 = *arg0.add(40).cast::<i32>();
                    let l21 = *arg0.add(44).cast::<i32>();
                    let l23 = *arg0.add(48).cast::<i32>();
                    let l25 = *arg0.add(52).cast::<i32>();
                    let l27 = *arg0.add(56).cast::<i32>();
                    let l29 = *arg0.add(60).cast::<i32>();
                    let l31 = *arg0.add(64).cast::<i32>();
                    let l33 = *arg0.add(68).cast::<i32>();
                    let l35 = *arg0.add(72).cast::<i32>();
                    let l37 = *arg0.add(76).cast::<i32>();
                    let l39 = *arg0.add(80).cast::<i32>();
                    let l41 = *arg0.add(84).cast::<i32>();
                    let l43 = *arg0.add(88).cast::<i32>();
                    let l45 = *arg0.add(92).cast::<i32>();
                    let l47 = *arg0.add(96).cast::<i32>();
                    let l49 = *arg0.add(100).cast::<i32>();
                    let l51 = *arg0.add(104).cast::<i32>();
                    let l53 = *arg0.add(108).cast::<i32>();
                    let l55 = *arg0.add(112).cast::<i32>();
                    let l57 = *arg0.add(116).cast::<i32>();
                    let l59 = *arg0.add(120).cast::<i32>();
                    let result61 = T::invoke(
                        _rt::string_lift(bytes2),
                        Args {
                            account_id: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l3 as u32);
                                &handle4
                            },
                            allow_authenticate_via_warp: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l5 as u32);
                                &handle6
                            },
                            allowed_idps: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l7 as u32);
                                &handle8
                            },
                            app_launcher_logo_url: {
                                handle10 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l9 as u32);
                                &handle10
                            },
                            app_launcher_visible: {
                                handle12 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l11 as u32);
                                &handle12
                            },
                            auto_redirect_to_identity: {
                                handle14 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l13 as u32);
                                &handle14
                            },
                            bg_color: {
                                handle16 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l15 as u32);
                                &handle16
                            },
                            cors_headers: {
                                handle18 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l17 as u32);
                                &handle18
                            },
                            custom_deny_message: {
                                handle20 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l19 as u32);
                                &handle20
                            },
                            custom_deny_url: {
                                handle22 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l21 as u32);
                                &handle22
                            },
                            custom_non_identity_deny_url: {
                                handle24 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l23 as u32);
                                &handle24
                            },
                            custom_pages: {
                                handle26 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l25 as u32);
                                &handle26
                            },
                            domain: {
                                handle28 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l27 as u32);
                                &handle28
                            },
                            enable_binding_cookie: {
                                handle30 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l29 as u32);
                                &handle30
                            },
                            footer_links: {
                                handle32 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l31 as u32);
                                &handle32
                            },
                            header_bg_color: {
                                handle34 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l33 as u32);
                                &handle34
                            },
                            http_only_cookie_attribute: {
                                handle36 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l35 as u32);
                                &handle36
                            },
                            landing_page_design: {
                                handle38 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l37 as u32);
                                &handle38
                            },
                            logo_url: {
                                handle40 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l39 as u32);
                                &handle40
                            },
                            name: {
                                handle42 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l41 as u32);
                                &handle42
                            },
                            saas_app: {
                                handle44 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l43 as u32);
                                &handle44
                            },
                            same_site_cookie_attribute: {
                                handle46 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l45 as u32);
                                &handle46
                            },
                            self_hosted_domains: {
                                handle48 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l47 as u32);
                                &handle48
                            },
                            service_auth401_redirect: {
                                handle50 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l49 as u32);
                                &handle50
                            },
                            session_duration: {
                                handle52 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l51 as u32);
                                &handle52
                            },
                            skip_interstitial: {
                                handle54 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l53 as u32);
                                &handle54
                            },
                            tags: {
                                handle56 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l55 as u32);
                                &handle56
                            },
                            type_: {
                                handle58 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l57 as u32);
                                &handle58
                            },
                            zone_id: {
                                handle60 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l59 as u32);
                                &handle60
                            },
                        },
                    );
                    _rt::cabi_dealloc(arg0, 124, 4);
                    let ptr62 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id63,
                        allow_authenticate_via_warp: allow_authenticate_via_warp63,
                        allowed_idps: allowed_idps63,
                        app_launcher_logo_url: app_launcher_logo_url63,
                        app_launcher_visible: app_launcher_visible63,
                        aud: aud63,
                        auto_redirect_to_identity: auto_redirect_to_identity63,
                        bg_color: bg_color63,
                        cors_headers: cors_headers63,
                        custom_deny_message: custom_deny_message63,
                        custom_deny_url: custom_deny_url63,
                        custom_non_identity_deny_url: custom_non_identity_deny_url63,
                        custom_pages: custom_pages63,
                        domain: domain63,
                        enable_binding_cookie: enable_binding_cookie63,
                        footer_links: footer_links63,
                        header_bg_color: header_bg_color63,
                        http_only_cookie_attribute: http_only_cookie_attribute63,
                        landing_page_design: landing_page_design63,
                        logo_url: logo_url63,
                        name: name63,
                        saas_app: saas_app63,
                        same_site_cookie_attribute: same_site_cookie_attribute63,
                        self_hosted_domains: self_hosted_domains63,
                        service_auth401_redirect: service_auth401_redirect63,
                        session_duration: session_duration63,
                        skip_interstitial: skip_interstitial63,
                        tags: tags63,
                        type_: type_63,
                        zone_id: zone_id63,
                    } = result61;
                    *ptr62.add(0).cast::<i32>() = (account_id63).take_handle() as i32;
                    *ptr62.add(4).cast::<i32>() =
                        (allow_authenticate_via_warp63).take_handle() as i32;
                    *ptr62.add(8).cast::<i32>() = (allowed_idps63).take_handle() as i32;
                    *ptr62.add(12).cast::<i32>() = (app_launcher_logo_url63).take_handle() as i32;
                    *ptr62.add(16).cast::<i32>() = (app_launcher_visible63).take_handle() as i32;
                    *ptr62.add(20).cast::<i32>() = (aud63).take_handle() as i32;
                    *ptr62.add(24).cast::<i32>() =
                        (auto_redirect_to_identity63).take_handle() as i32;
                    *ptr62.add(28).cast::<i32>() = (bg_color63).take_handle() as i32;
                    *ptr62.add(32).cast::<i32>() = (cors_headers63).take_handle() as i32;
                    *ptr62.add(36).cast::<i32>() = (custom_deny_message63).take_handle() as i32;
                    *ptr62.add(40).cast::<i32>() = (custom_deny_url63).take_handle() as i32;
                    *ptr62.add(44).cast::<i32>() =
                        (custom_non_identity_deny_url63).take_handle() as i32;
                    *ptr62.add(48).cast::<i32>() = (custom_pages63).take_handle() as i32;
                    *ptr62.add(52).cast::<i32>() = (domain63).take_handle() as i32;
                    *ptr62.add(56).cast::<i32>() = (enable_binding_cookie63).take_handle() as i32;
                    *ptr62.add(60).cast::<i32>() = (footer_links63).take_handle() as i32;
                    *ptr62.add(64).cast::<i32>() = (header_bg_color63).take_handle() as i32;
                    *ptr62.add(68).cast::<i32>() =
                        (http_only_cookie_attribute63).take_handle() as i32;
                    *ptr62.add(72).cast::<i32>() = (landing_page_design63).take_handle() as i32;
                    *ptr62.add(76).cast::<i32>() = (logo_url63).take_handle() as i32;
                    *ptr62.add(80).cast::<i32>() = (name63).take_handle() as i32;
                    *ptr62.add(84).cast::<i32>() = (saas_app63).take_handle() as i32;
                    *ptr62.add(88).cast::<i32>() =
                        (same_site_cookie_attribute63).take_handle() as i32;
                    *ptr62.add(92).cast::<i32>() = (self_hosted_domains63).take_handle() as i32;
                    *ptr62.add(96).cast::<i32>() =
                        (service_auth401_redirect63).take_handle() as i32;
                    *ptr62.add(100).cast::<i32>() = (session_duration63).take_handle() as i32;
                    *ptr62.add(104).cast::<i32>() = (skip_interstitial63).take_handle() as i32;
                    *ptr62.add(108).cast::<i32>() = (tags63).take_handle() as i32;
                    *ptr62.add(112).cast::<i32>() = (type_63).take_handle() as i32;
                    *ptr62.add(116).cast::<i32>() = (zone_id63).take_handle() as i32;
                    ptr62
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_access_application_5_24_1_zero_zero_zero_dev_cabi{
        ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

          #[export_name = "pulumi:cloudflare/access-application@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
          unsafe extern "C" fn export_invoke(arg0: *mut u8,) -> *mut u8 {
            $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0)
          }
        };);
      }
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_access_application_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 120]);
                static mut _RET_AREA: _RetArea =
                    _RetArea([::core::mem::MaybeUninit::uninit(); 120]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod access_ca_certificate {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub application_id: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("application-id", &self.application_id)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub application_id: Output,
                    pub aud: Output,
                    pub public_key: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("application-id", &self.application_id)
                            .field("aud", &self.aud)
                            .field("public-key", &self.public_key)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result4 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            application_id: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            zone_id: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                        },
                    );
                    let ptr5 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id6,
                        application_id: application_id6,
                        aud: aud6,
                        public_key: public_key6,
                        zone_id: zone_id6,
                    } = result4;
                    *ptr5.add(0).cast::<i32>() = (account_id6).take_handle() as i32;
                    *ptr5.add(4).cast::<i32>() = (application_id6).take_handle() as i32;
                    *ptr5.add(8).cast::<i32>() = (aud6).take_handle() as i32;
                    *ptr5.add(12).cast::<i32>() = (public_key6).take_handle() as i32;
                    *ptr5.add(16).cast::<i32>() = (zone_id6).take_handle() as i32;
                    ptr5
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_access_ca_certificate_5_24_1_zero_zero_zero_dev_cabi{
      ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

        #[export_name = "pulumi:cloudflare/access-ca-certificate@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
        unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,) -> *mut u8 {
          $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
        }
      };);
    }
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_access_ca_certificate_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 20]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 20]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod access_custom_page {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub app_count: &'a Output,
                    pub custom_html: &'a Output,
                    pub name: &'a Output,
                    pub type_: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("app-count", &self.app_count)
                            .field("custom-html", &self.custom_html)
                            .field("name", &self.name)
                            .field("type", &self.type_)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub app_count: Output,
                    pub custom_html: Output,
                    pub name: Output,
                    pub type_: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("app-count", &self.app_count)
                            .field("custom-html", &self.custom_html)
                            .field("name", &self.name)
                            .field("type", &self.type_)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result7 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            app_count: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            custom_html: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            name: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            type_: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            zone_id: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                        },
                    );
                    let ptr8 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id9,
                        app_count: app_count9,
                        custom_html: custom_html9,
                        name: name9,
                        type_: type_9,
                        zone_id: zone_id9,
                    } = result7;
                    *ptr8.add(0).cast::<i32>() = (account_id9).take_handle() as i32;
                    *ptr8.add(4).cast::<i32>() = (app_count9).take_handle() as i32;
                    *ptr8.add(8).cast::<i32>() = (custom_html9).take_handle() as i32;
                    *ptr8.add(12).cast::<i32>() = (name9).take_handle() as i32;
                    *ptr8.add(16).cast::<i32>() = (type_9).take_handle() as i32;
                    *ptr8.add(20).cast::<i32>() = (zone_id9).take_handle() as i32;
                    ptr8
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_access_custom_page_5_24_1_zero_zero_zero_dev_cabi{
    ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

      #[export_name = "pulumi:cloudflare/access-custom-page@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
      unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,) -> *mut u8 {
        $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
      }
    };);
  }
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_access_custom_page_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 24]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 24]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod access_group {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub excludes: &'a Output,
                    pub includes: &'a Output,
                    pub name: &'a Output,
                    pub requires: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("excludes", &self.excludes)
                            .field("includes", &self.includes)
                            .field("name", &self.name)
                            .field("requires", &self.requires)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub excludes: Output,
                    pub includes: Output,
                    pub name: Output,
                    pub requires: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("excludes", &self.excludes)
                            .field("includes", &self.includes)
                            .field("name", &self.name)
                            .field("requires", &self.requires)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result7 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            excludes: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            includes: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            name: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            requires: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            zone_id: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                        },
                    );
                    let ptr8 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id9,
                        excludes: excludes9,
                        includes: includes9,
                        name: name9,
                        requires: requires9,
                        zone_id: zone_id9,
                    } = result7;
                    *ptr8.add(0).cast::<i32>() = (account_id9).take_handle() as i32;
                    *ptr8.add(4).cast::<i32>() = (excludes9).take_handle() as i32;
                    *ptr8.add(8).cast::<i32>() = (includes9).take_handle() as i32;
                    *ptr8.add(12).cast::<i32>() = (name9).take_handle() as i32;
                    *ptr8.add(16).cast::<i32>() = (requires9).take_handle() as i32;
                    *ptr8.add(20).cast::<i32>() = (zone_id9).take_handle() as i32;
                    ptr8
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_access_group_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/access-group@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_access_group_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 24]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 24]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod access_identity_provider {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub configs: &'a Output,
                    pub name: &'a Output,
                    pub scim_configs: &'a Output,
                    pub type_: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("configs", &self.configs)
                            .field("name", &self.name)
                            .field("scim-configs", &self.scim_configs)
                            .field("type", &self.type_)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub configs: Output,
                    pub name: Output,
                    pub scim_configs: Output,
                    pub type_: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("configs", &self.configs)
                            .field("name", &self.name)
                            .field("scim-configs", &self.scim_configs)
                            .field("type", &self.type_)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result7 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            configs: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            name: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            scim_configs: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            type_: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            zone_id: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                        },
                    );
                    let ptr8 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id9,
                        configs: configs9,
                        name: name9,
                        scim_configs: scim_configs9,
                        type_: type_9,
                        zone_id: zone_id9,
                    } = result7;
                    *ptr8.add(0).cast::<i32>() = (account_id9).take_handle() as i32;
                    *ptr8.add(4).cast::<i32>() = (configs9).take_handle() as i32;
                    *ptr8.add(8).cast::<i32>() = (name9).take_handle() as i32;
                    *ptr8.add(12).cast::<i32>() = (scim_configs9).take_handle() as i32;
                    *ptr8.add(16).cast::<i32>() = (type_9).take_handle() as i32;
                    *ptr8.add(20).cast::<i32>() = (zone_id9).take_handle() as i32;
                    ptr8
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_access_identity_provider_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/access-identity-provider@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_access_identity_provider_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 24]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 24]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod access_keys_configuration {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub key_rotation_interval_days: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field(
                                "key-rotation-interval-days",
                                &self.key_rotation_interval_days,
                            )
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub key_rotation_interval_days: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field(
                                "key-rotation-interval-days",
                                &self.key_rotation_interval_days,
                            )
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result3 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            key_rotation_interval_days: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                        },
                    );
                    let ptr4 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id5,
                        key_rotation_interval_days: key_rotation_interval_days5,
                    } = result3;
                    *ptr4.add(0).cast::<i32>() = (account_id5).take_handle() as i32;
                    *ptr4.add(4).cast::<i32>() = (key_rotation_interval_days5).take_handle() as i32;
                    ptr4
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_access_keys_configuration_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/access-keys-configuration@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_access_keys_configuration_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 8]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod access_mutual_tls_certificate {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub associated_hostnames: &'a Output,
                    pub certificate: &'a Output,
                    pub name: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("associated-hostnames", &self.associated_hostnames)
                            .field("certificate", &self.certificate)
                            .field("name", &self.name)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub associated_hostnames: Output,
                    pub certificate: Output,
                    pub fingerprint: Output,
                    pub name: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("associated-hostnames", &self.associated_hostnames)
                            .field("certificate", &self.certificate)
                            .field("fingerprint", &self.fingerprint)
                            .field("name", &self.name)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result6 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            associated_hostnames: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            certificate: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            name: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            zone_id: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                        },
                    );
                    let ptr7 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id8,
                        associated_hostnames: associated_hostnames8,
                        certificate: certificate8,
                        fingerprint: fingerprint8,
                        name: name8,
                        zone_id: zone_id8,
                    } = result6;
                    *ptr7.add(0).cast::<i32>() = (account_id8).take_handle() as i32;
                    *ptr7.add(4).cast::<i32>() = (associated_hostnames8).take_handle() as i32;
                    *ptr7.add(8).cast::<i32>() = (certificate8).take_handle() as i32;
                    *ptr7.add(12).cast::<i32>() = (fingerprint8).take_handle() as i32;
                    *ptr7.add(16).cast::<i32>() = (name8).take_handle() as i32;
                    *ptr7.add(20).cast::<i32>() = (zone_id8).take_handle() as i32;
                    ptr7
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_access_mutual_tls_certificate_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/access-mutual-tls-certificate@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_access_mutual_tls_certificate_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 24]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 24]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod access_mutual_tls_hostname_settings {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub settings: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("settings", &self.settings)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub settings: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("settings", &self.settings)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result4 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            settings: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            zone_id: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                        },
                    );
                    let ptr5 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id6,
                        settings: settings6,
                        zone_id: zone_id6,
                    } = result4;
                    *ptr5.add(0).cast::<i32>() = (account_id6).take_handle() as i32;
                    *ptr5.add(4).cast::<i32>() = (settings6).take_handle() as i32;
                    *ptr5.add(8).cast::<i32>() = (zone_id6).take_handle() as i32;
                    ptr5
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_access_mutual_tls_hostname_settings_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/access-mutual-tls-hostname-settings@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_access_mutual_tls_hostname_settings_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod access_organization {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub allow_authenticate_via_warp: &'a Output,
                    pub auth_domain: &'a Output,
                    pub auto_redirect_to_identity: &'a Output,
                    pub custom_pages: &'a Output,
                    pub is_ui_read_only: &'a Output,
                    pub login_designs: &'a Output,
                    pub name: &'a Output,
                    pub session_duration: &'a Output,
                    pub ui_read_only_toggle_reason: &'a Output,
                    pub user_seat_expiration_inactive_time: &'a Output,
                    pub warp_auth_session_duration: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field(
                                "allow-authenticate-via-warp",
                                &self.allow_authenticate_via_warp,
                            )
                            .field("auth-domain", &self.auth_domain)
                            .field("auto-redirect-to-identity", &self.auto_redirect_to_identity)
                            .field("custom-pages", &self.custom_pages)
                            .field("is-ui-read-only", &self.is_ui_read_only)
                            .field("login-designs", &self.login_designs)
                            .field("name", &self.name)
                            .field("session-duration", &self.session_duration)
                            .field(
                                "ui-read-only-toggle-reason",
                                &self.ui_read_only_toggle_reason,
                            )
                            .field(
                                "user-seat-expiration-inactive-time",
                                &self.user_seat_expiration_inactive_time,
                            )
                            .field(
                                "warp-auth-session-duration",
                                &self.warp_auth_session_duration,
                            )
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub allow_authenticate_via_warp: Output,
                    pub auth_domain: Output,
                    pub auto_redirect_to_identity: Output,
                    pub custom_pages: Output,
                    pub is_ui_read_only: Output,
                    pub login_designs: Output,
                    pub name: Output,
                    pub session_duration: Output,
                    pub ui_read_only_toggle_reason: Output,
                    pub user_seat_expiration_inactive_time: Output,
                    pub warp_auth_session_duration: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field(
                                "allow-authenticate-via-warp",
                                &self.allow_authenticate_via_warp,
                            )
                            .field("auth-domain", &self.auth_domain)
                            .field("auto-redirect-to-identity", &self.auto_redirect_to_identity)
                            .field("custom-pages", &self.custom_pages)
                            .field("is-ui-read-only", &self.is_ui_read_only)
                            .field("login-designs", &self.login_designs)
                            .field("name", &self.name)
                            .field("session-duration", &self.session_duration)
                            .field(
                                "ui-read-only-toggle-reason",
                                &self.ui_read_only_toggle_reason,
                            )
                            .field(
                                "user-seat-expiration-inactive-time",
                                &self.user_seat_expiration_inactive_time,
                            )
                            .field(
                                "warp-auth-session-duration",
                                &self.warp_auth_session_duration,
                            )
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                    arg11: i32,
                    arg12: i32,
                    arg13: i32,
                    arg14: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let handle7;
                    let handle8;
                    let handle9;
                    let handle10;
                    let handle11;
                    let handle12;
                    let handle13;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result14 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            allow_authenticate_via_warp: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            auth_domain: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            auto_redirect_to_identity: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            custom_pages: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            is_ui_read_only: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                            login_designs: {
                                handle7 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg8 as u32);
                                &handle7
                            },
                            name: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg9 as u32);
                                &handle8
                            },
                            session_duration: {
                                handle9 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg10 as u32);
                                &handle9
                            },
                            ui_read_only_toggle_reason: {
                                handle10 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg11 as u32);
                                &handle10
                            },
                            user_seat_expiration_inactive_time: {
                                handle11 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg12 as u32);
                                &handle11
                            },
                            warp_auth_session_duration: {
                                handle12 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg13 as u32);
                                &handle12
                            },
                            zone_id: {
                                handle13 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg14 as u32);
                                &handle13
                            },
                        },
                    );
                    let ptr15 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id16,
                        allow_authenticate_via_warp: allow_authenticate_via_warp16,
                        auth_domain: auth_domain16,
                        auto_redirect_to_identity: auto_redirect_to_identity16,
                        custom_pages: custom_pages16,
                        is_ui_read_only: is_ui_read_only16,
                        login_designs: login_designs16,
                        name: name16,
                        session_duration: session_duration16,
                        ui_read_only_toggle_reason: ui_read_only_toggle_reason16,
                        user_seat_expiration_inactive_time: user_seat_expiration_inactive_time16,
                        warp_auth_session_duration: warp_auth_session_duration16,
                        zone_id: zone_id16,
                    } = result14;
                    *ptr15.add(0).cast::<i32>() = (account_id16).take_handle() as i32;
                    *ptr15.add(4).cast::<i32>() =
                        (allow_authenticate_via_warp16).take_handle() as i32;
                    *ptr15.add(8).cast::<i32>() = (auth_domain16).take_handle() as i32;
                    *ptr15.add(12).cast::<i32>() =
                        (auto_redirect_to_identity16).take_handle() as i32;
                    *ptr15.add(16).cast::<i32>() = (custom_pages16).take_handle() as i32;
                    *ptr15.add(20).cast::<i32>() = (is_ui_read_only16).take_handle() as i32;
                    *ptr15.add(24).cast::<i32>() = (login_designs16).take_handle() as i32;
                    *ptr15.add(28).cast::<i32>() = (name16).take_handle() as i32;
                    *ptr15.add(32).cast::<i32>() = (session_duration16).take_handle() as i32;
                    *ptr15.add(36).cast::<i32>() =
                        (ui_read_only_toggle_reason16).take_handle() as i32;
                    *ptr15.add(40).cast::<i32>() =
                        (user_seat_expiration_inactive_time16).take_handle() as i32;
                    *ptr15.add(44).cast::<i32>() =
                        (warp_auth_session_duration16).take_handle() as i32;
                    *ptr15.add(48).cast::<i32>() = (zone_id16).take_handle() as i32;
                    ptr15
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_access_organization_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/access-organization@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,arg9: i32,arg10: i32,arg11: i32,arg12: i32,arg13: i32,arg14: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_access_organization_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 52]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 52]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod access_policy {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub application_id: &'a Output,
                    pub approval_groups: &'a Output,
                    pub approval_required: &'a Output,
                    pub decision: &'a Output,
                    pub excludes: &'a Output,
                    pub includes: &'a Output,
                    pub isolation_required: &'a Output,
                    pub name: &'a Output,
                    pub precedence: &'a Output,
                    pub purpose_justification_prompt: &'a Output,
                    pub purpose_justification_required: &'a Output,
                    pub requires: &'a Output,
                    pub session_duration: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("application-id", &self.application_id)
                            .field("approval-groups", &self.approval_groups)
                            .field("approval-required", &self.approval_required)
                            .field("decision", &self.decision)
                            .field("excludes", &self.excludes)
                            .field("includes", &self.includes)
                            .field("isolation-required", &self.isolation_required)
                            .field("name", &self.name)
                            .field("precedence", &self.precedence)
                            .field(
                                "purpose-justification-prompt",
                                &self.purpose_justification_prompt,
                            )
                            .field(
                                "purpose-justification-required",
                                &self.purpose_justification_required,
                            )
                            .field("requires", &self.requires)
                            .field("session-duration", &self.session_duration)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub application_id: Output,
                    pub approval_groups: Output,
                    pub approval_required: Output,
                    pub decision: Output,
                    pub excludes: Output,
                    pub includes: Output,
                    pub isolation_required: Output,
                    pub name: Output,
                    pub precedence: Output,
                    pub purpose_justification_prompt: Output,
                    pub purpose_justification_required: Output,
                    pub requires: Output,
                    pub session_duration: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("application-id", &self.application_id)
                            .field("approval-groups", &self.approval_groups)
                            .field("approval-required", &self.approval_required)
                            .field("decision", &self.decision)
                            .field("excludes", &self.excludes)
                            .field("includes", &self.includes)
                            .field("isolation-required", &self.isolation_required)
                            .field("name", &self.name)
                            .field("precedence", &self.precedence)
                            .field(
                                "purpose-justification-prompt",
                                &self.purpose_justification_prompt,
                            )
                            .field(
                                "purpose-justification-required",
                                &self.purpose_justification_required,
                            )
                            .field("requires", &self.requires)
                            .field("session-duration", &self.session_duration)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle4;
                    let handle6;
                    let handle8;
                    let handle10;
                    let handle12;
                    let handle14;
                    let handle16;
                    let handle18;
                    let handle20;
                    let handle22;
                    let handle24;
                    let handle26;
                    let handle28;
                    let handle30;
                    let handle32;
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let len2 = l1;
                    let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                    let l3 = *arg0.add(8).cast::<i32>();
                    let l5 = *arg0.add(12).cast::<i32>();
                    let l7 = *arg0.add(16).cast::<i32>();
                    let l9 = *arg0.add(20).cast::<i32>();
                    let l11 = *arg0.add(24).cast::<i32>();
                    let l13 = *arg0.add(28).cast::<i32>();
                    let l15 = *arg0.add(32).cast::<i32>();
                    let l17 = *arg0.add(36).cast::<i32>();
                    let l19 = *arg0.add(40).cast::<i32>();
                    let l21 = *arg0.add(44).cast::<i32>();
                    let l23 = *arg0.add(48).cast::<i32>();
                    let l25 = *arg0.add(52).cast::<i32>();
                    let l27 = *arg0.add(56).cast::<i32>();
                    let l29 = *arg0.add(60).cast::<i32>();
                    let l31 = *arg0.add(64).cast::<i32>();
                    let result33 = T::invoke(
                        _rt::string_lift(bytes2),
                        Args {
                            account_id: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l3 as u32);
                                &handle4
                            },
                            application_id: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l5 as u32);
                                &handle6
                            },
                            approval_groups: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l7 as u32);
                                &handle8
                            },
                            approval_required: {
                                handle10 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l9 as u32);
                                &handle10
                            },
                            decision: {
                                handle12 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l11 as u32);
                                &handle12
                            },
                            excludes: {
                                handle14 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l13 as u32);
                                &handle14
                            },
                            includes: {
                                handle16 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l15 as u32);
                                &handle16
                            },
                            isolation_required: {
                                handle18 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l17 as u32);
                                &handle18
                            },
                            name: {
                                handle20 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l19 as u32);
                                &handle20
                            },
                            precedence: {
                                handle22 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l21 as u32);
                                &handle22
                            },
                            purpose_justification_prompt: {
                                handle24 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l23 as u32);
                                &handle24
                            },
                            purpose_justification_required: {
                                handle26 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l25 as u32);
                                &handle26
                            },
                            requires: {
                                handle28 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l27 as u32);
                                &handle28
                            },
                            session_duration: {
                                handle30 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l29 as u32);
                                &handle30
                            },
                            zone_id: {
                                handle32 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l31 as u32);
                                &handle32
                            },
                        },
                    );
                    _rt::cabi_dealloc(arg0, 68, 4);
                    let ptr34 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id35,
                        application_id: application_id35,
                        approval_groups: approval_groups35,
                        approval_required: approval_required35,
                        decision: decision35,
                        excludes: excludes35,
                        includes: includes35,
                        isolation_required: isolation_required35,
                        name: name35,
                        precedence: precedence35,
                        purpose_justification_prompt: purpose_justification_prompt35,
                        purpose_justification_required: purpose_justification_required35,
                        requires: requires35,
                        session_duration: session_duration35,
                        zone_id: zone_id35,
                    } = result33;
                    *ptr34.add(0).cast::<i32>() = (account_id35).take_handle() as i32;
                    *ptr34.add(4).cast::<i32>() = (application_id35).take_handle() as i32;
                    *ptr34.add(8).cast::<i32>() = (approval_groups35).take_handle() as i32;
                    *ptr34.add(12).cast::<i32>() = (approval_required35).take_handle() as i32;
                    *ptr34.add(16).cast::<i32>() = (decision35).take_handle() as i32;
                    *ptr34.add(20).cast::<i32>() = (excludes35).take_handle() as i32;
                    *ptr34.add(24).cast::<i32>() = (includes35).take_handle() as i32;
                    *ptr34.add(28).cast::<i32>() = (isolation_required35).take_handle() as i32;
                    *ptr34.add(32).cast::<i32>() = (name35).take_handle() as i32;
                    *ptr34.add(36).cast::<i32>() = (precedence35).take_handle() as i32;
                    *ptr34.add(40).cast::<i32>() =
                        (purpose_justification_prompt35).take_handle() as i32;
                    *ptr34.add(44).cast::<i32>() =
                        (purpose_justification_required35).take_handle() as i32;
                    *ptr34.add(48).cast::<i32>() = (requires35).take_handle() as i32;
                    *ptr34.add(52).cast::<i32>() = (session_duration35).take_handle() as i32;
                    *ptr34.add(56).cast::<i32>() = (zone_id35).take_handle() as i32;
                    ptr34
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_access_policy_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/access-policy@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_access_policy_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 60]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 60]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod access_rule {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub configuration: &'a Output,
                    pub mode: &'a Output,
                    pub notes: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("configuration", &self.configuration)
                            .field("mode", &self.mode)
                            .field("notes", &self.notes)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub configuration: Output,
                    pub mode: Output,
                    pub notes: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("configuration", &self.configuration)
                            .field("mode", &self.mode)
                            .field("notes", &self.notes)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result6 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            configuration: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            mode: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            notes: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            zone_id: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                        },
                    );
                    let ptr7 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id8,
                        configuration: configuration8,
                        mode: mode8,
                        notes: notes8,
                        zone_id: zone_id8,
                    } = result6;
                    *ptr7.add(0).cast::<i32>() = (account_id8).take_handle() as i32;
                    *ptr7.add(4).cast::<i32>() = (configuration8).take_handle() as i32;
                    *ptr7.add(8).cast::<i32>() = (mode8).take_handle() as i32;
                    *ptr7.add(12).cast::<i32>() = (notes8).take_handle() as i32;
                    *ptr7.add(16).cast::<i32>() = (zone_id8).take_handle() as i32;
                    ptr7
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_access_rule_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/access-rule@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_access_rule_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 20]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 20]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod access_service_token {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub duration: &'a Output,
                    pub min_days_for_renewal: &'a Output,
                    pub name: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("duration", &self.duration)
                            .field("min-days-for-renewal", &self.min_days_for_renewal)
                            .field("name", &self.name)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub client_id: Output,
                    pub client_secret: Output,
                    pub duration: Output,
                    pub expires_at: Output,
                    pub min_days_for_renewal: Output,
                    pub name: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("client-id", &self.client_id)
                            .field("client-secret", &self.client_secret)
                            .field("duration", &self.duration)
                            .field("expires-at", &self.expires_at)
                            .field("min-days-for-renewal", &self.min_days_for_renewal)
                            .field("name", &self.name)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result6 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            duration: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            min_days_for_renewal: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            name: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            zone_id: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                        },
                    );
                    let ptr7 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id8,
                        client_id: client_id8,
                        client_secret: client_secret8,
                        duration: duration8,
                        expires_at: expires_at8,
                        min_days_for_renewal: min_days_for_renewal8,
                        name: name8,
                        zone_id: zone_id8,
                    } = result6;
                    *ptr7.add(0).cast::<i32>() = (account_id8).take_handle() as i32;
                    *ptr7.add(4).cast::<i32>() = (client_id8).take_handle() as i32;
                    *ptr7.add(8).cast::<i32>() = (client_secret8).take_handle() as i32;
                    *ptr7.add(12).cast::<i32>() = (duration8).take_handle() as i32;
                    *ptr7.add(16).cast::<i32>() = (expires_at8).take_handle() as i32;
                    *ptr7.add(20).cast::<i32>() = (min_days_for_renewal8).take_handle() as i32;
                    *ptr7.add(24).cast::<i32>() = (name8).take_handle() as i32;
                    *ptr7.add(28).cast::<i32>() = (zone_id8).take_handle() as i32;
                    ptr7
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_access_service_token_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/access-service-token@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_access_service_token_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 32]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 32]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod access_tag {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub app_count: &'a Output,
                    pub name: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("app-count", &self.app_count)
                            .field("name", &self.name)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub app_count: Output,
                    pub name: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("app-count", &self.app_count)
                            .field("name", &self.name)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result5 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            app_count: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            name: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            zone_id: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                        },
                    );
                    let ptr6 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id7,
                        app_count: app_count7,
                        name: name7,
                        zone_id: zone_id7,
                    } = result5;
                    *ptr6.add(0).cast::<i32>() = (account_id7).take_handle() as i32;
                    *ptr6.add(4).cast::<i32>() = (app_count7).take_handle() as i32;
                    *ptr6.add(8).cast::<i32>() = (name7).take_handle() as i32;
                    *ptr6.add(12).cast::<i32>() = (zone_id7).take_handle() as i32;
                    ptr6
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_access_tag_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/access-tag@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_access_tag_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod account {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub enforce_twofactor: &'a Output,
                    pub name: &'a Output,
                    pub type_: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("enforce-twofactor", &self.enforce_twofactor)
                            .field("name", &self.name)
                            .field("type", &self.type_)
                            .finish()
                    }
                }
                pub struct Res {
                    pub enforce_twofactor: Output,
                    pub name: Output,
                    pub type_: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("enforce-twofactor", &self.enforce_twofactor)
                            .field("name", &self.name)
                            .field("type", &self.type_)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result4 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            enforce_twofactor: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            name: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            type_: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                        },
                    );
                    let ptr5 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        enforce_twofactor: enforce_twofactor6,
                        name: name6,
                        type_: type_6,
                    } = result4;
                    *ptr5.add(0).cast::<i32>() = (enforce_twofactor6).take_handle() as i32;
                    *ptr5.add(4).cast::<i32>() = (name6).take_handle() as i32;
                    *ptr5.add(8).cast::<i32>() = (type_6).take_handle() as i32;
                    ptr5
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_account_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/account@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_account_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod account_member {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub email_address: &'a Output,
                    pub role_ids: &'a Output,
                    pub status: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("email-address", &self.email_address)
                            .field("role-ids", &self.role_ids)
                            .field("status", &self.status)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub email_address: Output,
                    pub role_ids: Output,
                    pub status: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("email-address", &self.email_address)
                            .field("role-ids", &self.role_ids)
                            .field("status", &self.status)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result5 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            email_address: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            role_ids: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            status: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                        },
                    );
                    let ptr6 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id7,
                        email_address: email_address7,
                        role_ids: role_ids7,
                        status: status7,
                    } = result5;
                    *ptr6.add(0).cast::<i32>() = (account_id7).take_handle() as i32;
                    *ptr6.add(4).cast::<i32>() = (email_address7).take_handle() as i32;
                    *ptr6.add(8).cast::<i32>() = (role_ids7).take_handle() as i32;
                    *ptr6.add(12).cast::<i32>() = (status7).take_handle() as i32;
                    ptr6
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_account_member_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/account-member@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_account_member_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod address_map {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub default_sni: &'a Output,
                    pub description: &'a Output,
                    pub enabled: &'a Output,
                    pub ips: &'a Output,
                    pub memberships: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("default-sni", &self.default_sni)
                            .field("description", &self.description)
                            .field("enabled", &self.enabled)
                            .field("ips", &self.ips)
                            .field("memberships", &self.memberships)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub can_delete: Output,
                    pub can_modify_ips: Output,
                    pub default_sni: Output,
                    pub description: Output,
                    pub enabled: Output,
                    pub ips: Output,
                    pub memberships: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("can-delete", &self.can_delete)
                            .field("can-modify-ips", &self.can_modify_ips)
                            .field("default-sni", &self.default_sni)
                            .field("description", &self.description)
                            .field("enabled", &self.enabled)
                            .field("ips", &self.ips)
                            .field("memberships", &self.memberships)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result7 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            default_sni: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            description: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            enabled: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            ips: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            memberships: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                        },
                    );
                    let ptr8 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id9,
                        can_delete: can_delete9,
                        can_modify_ips: can_modify_ips9,
                        default_sni: default_sni9,
                        description: description9,
                        enabled: enabled9,
                        ips: ips9,
                        memberships: memberships9,
                    } = result7;
                    *ptr8.add(0).cast::<i32>() = (account_id9).take_handle() as i32;
                    *ptr8.add(4).cast::<i32>() = (can_delete9).take_handle() as i32;
                    *ptr8.add(8).cast::<i32>() = (can_modify_ips9).take_handle() as i32;
                    *ptr8.add(12).cast::<i32>() = (default_sni9).take_handle() as i32;
                    *ptr8.add(16).cast::<i32>() = (description9).take_handle() as i32;
                    *ptr8.add(20).cast::<i32>() = (enabled9).take_handle() as i32;
                    *ptr8.add(24).cast::<i32>() = (ips9).take_handle() as i32;
                    *ptr8.add(28).cast::<i32>() = (memberships9).take_handle() as i32;
                    ptr8
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_address_map_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/address-map@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_address_map_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 32]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 32]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod api_shield {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub auth_id_characteristics: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("auth-id-characteristics", &self.auth_id_characteristics)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub auth_id_characteristics: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("auth-id-characteristics", &self.auth_id_characteristics)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result3 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            auth_id_characteristics: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            zone_id: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                        },
                    );
                    let ptr4 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        auth_id_characteristics: auth_id_characteristics5,
                        zone_id: zone_id5,
                    } = result3;
                    *ptr4.add(0).cast::<i32>() = (auth_id_characteristics5).take_handle() as i32;
                    *ptr4.add(4).cast::<i32>() = (zone_id5).take_handle() as i32;
                    ptr4
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_api_shield_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/api-shield@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_api_shield_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 8]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod api_shield_operation {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub endpoint: &'a Output,
                    pub host: &'a Output,
                    pub method: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("endpoint", &self.endpoint)
                            .field("host", &self.host)
                            .field("method", &self.method)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub endpoint: Output,
                    pub host: Output,
                    pub method: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("endpoint", &self.endpoint)
                            .field("host", &self.host)
                            .field("method", &self.method)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result5 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            endpoint: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            host: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            method: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            zone_id: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                        },
                    );
                    let ptr6 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        endpoint: endpoint7,
                        host: host7,
                        method: method7,
                        zone_id: zone_id7,
                    } = result5;
                    *ptr6.add(0).cast::<i32>() = (endpoint7).take_handle() as i32;
                    *ptr6.add(4).cast::<i32>() = (host7).take_handle() as i32;
                    *ptr6.add(8).cast::<i32>() = (method7).take_handle() as i32;
                    *ptr6.add(12).cast::<i32>() = (zone_id7).take_handle() as i32;
                    ptr6
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_api_shield_operation_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/api-shield-operation@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_api_shield_operation_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod api_shield_operation_schema_validation_settings {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub mitigation_action: &'a Output,
                    pub operation_id: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("mitigation-action", &self.mitigation_action)
                            .field("operation-id", &self.operation_id)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub mitigation_action: Output,
                    pub operation_id: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("mitigation-action", &self.mitigation_action)
                            .field("operation-id", &self.operation_id)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result4 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            mitigation_action: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            operation_id: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            zone_id: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                        },
                    );
                    let ptr5 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        mitigation_action: mitigation_action6,
                        operation_id: operation_id6,
                        zone_id: zone_id6,
                    } = result4;
                    *ptr5.add(0).cast::<i32>() = (mitigation_action6).take_handle() as i32;
                    *ptr5.add(4).cast::<i32>() = (operation_id6).take_handle() as i32;
                    *ptr5.add(8).cast::<i32>() = (zone_id6).take_handle() as i32;
                    ptr5
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_api_shield_operation_schema_validation_settings_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/api-shield-operation-schema-validation-settings@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_api_shield_operation_schema_validation_settings_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod api_shield_schema {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub kind: &'a Output,
                    pub name: &'a Output,
                    pub source: &'a Output,
                    pub validation_enabled: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("kind", &self.kind)
                            .field("name", &self.name)
                            .field("source", &self.source)
                            .field("validation-enabled", &self.validation_enabled)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub kind: Output,
                    pub name: Output,
                    pub source: Output,
                    pub validation_enabled: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("kind", &self.kind)
                            .field("name", &self.name)
                            .field("source", &self.source)
                            .field("validation-enabled", &self.validation_enabled)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result6 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            kind: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            name: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            source: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            validation_enabled: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            zone_id: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                        },
                    );
                    let ptr7 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        kind: kind8,
                        name: name8,
                        source: source8,
                        validation_enabled: validation_enabled8,
                        zone_id: zone_id8,
                    } = result6;
                    *ptr7.add(0).cast::<i32>() = (kind8).take_handle() as i32;
                    *ptr7.add(4).cast::<i32>() = (name8).take_handle() as i32;
                    *ptr7.add(8).cast::<i32>() = (source8).take_handle() as i32;
                    *ptr7.add(12).cast::<i32>() = (validation_enabled8).take_handle() as i32;
                    *ptr7.add(16).cast::<i32>() = (zone_id8).take_handle() as i32;
                    ptr7
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_api_shield_schema_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/api-shield-schema@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_api_shield_schema_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 20]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 20]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod api_shield_schema_validation_settings {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub validation_default_mitigation_action: &'a Output,
                    pub validation_override_mitigation_action: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field(
                                "validation-default-mitigation-action",
                                &self.validation_default_mitigation_action,
                            )
                            .field(
                                "validation-override-mitigation-action",
                                &self.validation_override_mitigation_action,
                            )
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub validation_default_mitigation_action: Output,
                    pub validation_override_mitigation_action: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field(
                                "validation-default-mitigation-action",
                                &self.validation_default_mitigation_action,
                            )
                            .field(
                                "validation-override-mitigation-action",
                                &self.validation_override_mitigation_action,
                            )
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result4 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            validation_default_mitigation_action: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            validation_override_mitigation_action: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            zone_id: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                        },
                    );
                    let ptr5 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        validation_default_mitigation_action: validation_default_mitigation_action6,
                        validation_override_mitigation_action:
                            validation_override_mitigation_action6,
                        zone_id: zone_id6,
                    } = result4;
                    *ptr5.add(0).cast::<i32>() =
                        (validation_default_mitigation_action6).take_handle() as i32;
                    *ptr5.add(4).cast::<i32>() =
                        (validation_override_mitigation_action6).take_handle() as i32;
                    *ptr5.add(8).cast::<i32>() = (zone_id6).take_handle() as i32;
                    ptr5
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_api_shield_schema_validation_settings_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/api-shield-schema-validation-settings@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_api_shield_schema_validation_settings_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod api_token {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub condition: &'a Output,
                    pub expires_on: &'a Output,
                    pub name: &'a Output,
                    pub not_before: &'a Output,
                    pub policies: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("condition", &self.condition)
                            .field("expires-on", &self.expires_on)
                            .field("name", &self.name)
                            .field("not-before", &self.not_before)
                            .field("policies", &self.policies)
                            .finish()
                    }
                }
                pub struct Res {
                    pub condition: Output,
                    pub expires_on: Output,
                    pub issued_on: Output,
                    pub modified_on: Output,
                    pub name: Output,
                    pub not_before: Output,
                    pub policies: Output,
                    pub status: Output,
                    pub value: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("condition", &self.condition)
                            .field("expires-on", &self.expires_on)
                            .field("issued-on", &self.issued_on)
                            .field("modified-on", &self.modified_on)
                            .field("name", &self.name)
                            .field("not-before", &self.not_before)
                            .field("policies", &self.policies)
                            .field("status", &self.status)
                            .field("value", &self.value)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result6 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            condition: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            expires_on: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            name: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            not_before: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            policies: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                        },
                    );
                    let ptr7 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        condition: condition8,
                        expires_on: expires_on8,
                        issued_on: issued_on8,
                        modified_on: modified_on8,
                        name: name8,
                        not_before: not_before8,
                        policies: policies8,
                        status: status8,
                        value: value8,
                    } = result6;
                    *ptr7.add(0).cast::<i32>() = (condition8).take_handle() as i32;
                    *ptr7.add(4).cast::<i32>() = (expires_on8).take_handle() as i32;
                    *ptr7.add(8).cast::<i32>() = (issued_on8).take_handle() as i32;
                    *ptr7.add(12).cast::<i32>() = (modified_on8).take_handle() as i32;
                    *ptr7.add(16).cast::<i32>() = (name8).take_handle() as i32;
                    *ptr7.add(20).cast::<i32>() = (not_before8).take_handle() as i32;
                    *ptr7.add(24).cast::<i32>() = (policies8).take_handle() as i32;
                    *ptr7.add(28).cast::<i32>() = (status8).take_handle() as i32;
                    *ptr7.add(32).cast::<i32>() = (value8).take_handle() as i32;
                    ptr7
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_api_token_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/api-token@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_api_token_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 36]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 36]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod argo {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub smart_routing: &'a Output,
                    pub tiered_caching: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("smart-routing", &self.smart_routing)
                            .field("tiered-caching", &self.tiered_caching)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub smart_routing: Output,
                    pub tiered_caching: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("smart-routing", &self.smart_routing)
                            .field("tiered-caching", &self.tiered_caching)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result4 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            smart_routing: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            tiered_caching: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            zone_id: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                        },
                    );
                    let ptr5 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        smart_routing: smart_routing6,
                        tiered_caching: tiered_caching6,
                        zone_id: zone_id6,
                    } = result4;
                    *ptr5.add(0).cast::<i32>() = (smart_routing6).take_handle() as i32;
                    *ptr5.add(4).cast::<i32>() = (tiered_caching6).take_handle() as i32;
                    *ptr5.add(8).cast::<i32>() = (zone_id6).take_handle() as i32;
                    ptr5
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_argo_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/argo@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_argo_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod authenticated_origin_pulls {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub authenticated_origin_pulls_certificate: &'a Output,
                    pub enabled: &'a Output,
                    pub hostname: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field(
                                "authenticated-origin-pulls-certificate",
                                &self.authenticated_origin_pulls_certificate,
                            )
                            .field("enabled", &self.enabled)
                            .field("hostname", &self.hostname)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub authenticated_origin_pulls_certificate: Output,
                    pub enabled: Output,
                    pub hostname: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field(
                                "authenticated-origin-pulls-certificate",
                                &self.authenticated_origin_pulls_certificate,
                            )
                            .field("enabled", &self.enabled)
                            .field("hostname", &self.hostname)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result5 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            authenticated_origin_pulls_certificate: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            enabled: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            hostname: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            zone_id: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                        },
                    );
                    let ptr6 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        authenticated_origin_pulls_certificate:
                            authenticated_origin_pulls_certificate7,
                        enabled: enabled7,
                        hostname: hostname7,
                        zone_id: zone_id7,
                    } = result5;
                    *ptr6.add(0).cast::<i32>() =
                        (authenticated_origin_pulls_certificate7).take_handle() as i32;
                    *ptr6.add(4).cast::<i32>() = (enabled7).take_handle() as i32;
                    *ptr6.add(8).cast::<i32>() = (hostname7).take_handle() as i32;
                    *ptr6.add(12).cast::<i32>() = (zone_id7).take_handle() as i32;
                    ptr6
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_authenticated_origin_pulls_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/authenticated-origin-pulls@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_authenticated_origin_pulls_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod authenticated_origin_pulls_certificate {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub certificate: &'a Output,
                    pub private_key: &'a Output,
                    pub type_: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("certificate", &self.certificate)
                            .field("private-key", &self.private_key)
                            .field("type", &self.type_)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub certificate: Output,
                    pub expires_on: Output,
                    pub issuer: Output,
                    pub private_key: Output,
                    pub serial_number: Output,
                    pub signature: Output,
                    pub status: Output,
                    pub type_: Output,
                    pub uploaded_on: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("certificate", &self.certificate)
                            .field("expires-on", &self.expires_on)
                            .field("issuer", &self.issuer)
                            .field("private-key", &self.private_key)
                            .field("serial-number", &self.serial_number)
                            .field("signature", &self.signature)
                            .field("status", &self.status)
                            .field("type", &self.type_)
                            .field("uploaded-on", &self.uploaded_on)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result5 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            certificate: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            private_key: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            type_: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            zone_id: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                        },
                    );
                    let ptr6 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        certificate: certificate7,
                        expires_on: expires_on7,
                        issuer: issuer7,
                        private_key: private_key7,
                        serial_number: serial_number7,
                        signature: signature7,
                        status: status7,
                        type_: type_7,
                        uploaded_on: uploaded_on7,
                        zone_id: zone_id7,
                    } = result5;
                    *ptr6.add(0).cast::<i32>() = (certificate7).take_handle() as i32;
                    *ptr6.add(4).cast::<i32>() = (expires_on7).take_handle() as i32;
                    *ptr6.add(8).cast::<i32>() = (issuer7).take_handle() as i32;
                    *ptr6.add(12).cast::<i32>() = (private_key7).take_handle() as i32;
                    *ptr6.add(16).cast::<i32>() = (serial_number7).take_handle() as i32;
                    *ptr6.add(20).cast::<i32>() = (signature7).take_handle() as i32;
                    *ptr6.add(24).cast::<i32>() = (status7).take_handle() as i32;
                    *ptr6.add(28).cast::<i32>() = (type_7).take_handle() as i32;
                    *ptr6.add(32).cast::<i32>() = (uploaded_on7).take_handle() as i32;
                    *ptr6.add(36).cast::<i32>() = (zone_id7).take_handle() as i32;
                    ptr6
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_authenticated_origin_pulls_certificate_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/authenticated-origin-pulls-certificate@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_authenticated_origin_pulls_certificate_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 40]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 40]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod bot_management {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub auto_update_model: &'a Output,
                    pub enable_js: &'a Output,
                    pub fight_mode: &'a Output,
                    pub optimize_wordpress: &'a Output,
                    pub sbfm_definitely_automated: &'a Output,
                    pub sbfm_likely_automated: &'a Output,
                    pub sbfm_static_resource_protection: &'a Output,
                    pub sbfm_verified_bots: &'a Output,
                    pub suppress_session_score: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("auto-update-model", &self.auto_update_model)
                            .field("enable-js", &self.enable_js)
                            .field("fight-mode", &self.fight_mode)
                            .field("optimize-wordpress", &self.optimize_wordpress)
                            .field("sbfm-definitely-automated", &self.sbfm_definitely_automated)
                            .field("sbfm-likely-automated", &self.sbfm_likely_automated)
                            .field(
                                "sbfm-static-resource-protection",
                                &self.sbfm_static_resource_protection,
                            )
                            .field("sbfm-verified-bots", &self.sbfm_verified_bots)
                            .field("suppress-session-score", &self.suppress_session_score)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub auto_update_model: Output,
                    pub enable_js: Output,
                    pub fight_mode: Output,
                    pub optimize_wordpress: Output,
                    pub sbfm_definitely_automated: Output,
                    pub sbfm_likely_automated: Output,
                    pub sbfm_static_resource_protection: Output,
                    pub sbfm_verified_bots: Output,
                    pub suppress_session_score: Output,
                    pub using_latest_model: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("auto-update-model", &self.auto_update_model)
                            .field("enable-js", &self.enable_js)
                            .field("fight-mode", &self.fight_mode)
                            .field("optimize-wordpress", &self.optimize_wordpress)
                            .field("sbfm-definitely-automated", &self.sbfm_definitely_automated)
                            .field("sbfm-likely-automated", &self.sbfm_likely_automated)
                            .field(
                                "sbfm-static-resource-protection",
                                &self.sbfm_static_resource_protection,
                            )
                            .field("sbfm-verified-bots", &self.sbfm_verified_bots)
                            .field("suppress-session-score", &self.suppress_session_score)
                            .field("using-latest-model", &self.using_latest_model)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                    arg11: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let handle7;
                    let handle8;
                    let handle9;
                    let handle10;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result11 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            auto_update_model: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            enable_js: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            fight_mode: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            optimize_wordpress: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            sbfm_definitely_automated: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            sbfm_likely_automated: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                            sbfm_static_resource_protection: {
                                handle7 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg8 as u32);
                                &handle7
                            },
                            sbfm_verified_bots: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg9 as u32);
                                &handle8
                            },
                            suppress_session_score: {
                                handle9 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg10 as u32);
                                &handle9
                            },
                            zone_id: {
                                handle10 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg11 as u32);
                                &handle10
                            },
                        },
                    );
                    let ptr12 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        auto_update_model: auto_update_model13,
                        enable_js: enable_js13,
                        fight_mode: fight_mode13,
                        optimize_wordpress: optimize_wordpress13,
                        sbfm_definitely_automated: sbfm_definitely_automated13,
                        sbfm_likely_automated: sbfm_likely_automated13,
                        sbfm_static_resource_protection: sbfm_static_resource_protection13,
                        sbfm_verified_bots: sbfm_verified_bots13,
                        suppress_session_score: suppress_session_score13,
                        using_latest_model: using_latest_model13,
                        zone_id: zone_id13,
                    } = result11;
                    *ptr12.add(0).cast::<i32>() = (auto_update_model13).take_handle() as i32;
                    *ptr12.add(4).cast::<i32>() = (enable_js13).take_handle() as i32;
                    *ptr12.add(8).cast::<i32>() = (fight_mode13).take_handle() as i32;
                    *ptr12.add(12).cast::<i32>() = (optimize_wordpress13).take_handle() as i32;
                    *ptr12.add(16).cast::<i32>() =
                        (sbfm_definitely_automated13).take_handle() as i32;
                    *ptr12.add(20).cast::<i32>() = (sbfm_likely_automated13).take_handle() as i32;
                    *ptr12.add(24).cast::<i32>() =
                        (sbfm_static_resource_protection13).take_handle() as i32;
                    *ptr12.add(28).cast::<i32>() = (sbfm_verified_bots13).take_handle() as i32;
                    *ptr12.add(32).cast::<i32>() = (suppress_session_score13).take_handle() as i32;
                    *ptr12.add(36).cast::<i32>() = (using_latest_model13).take_handle() as i32;
                    *ptr12.add(40).cast::<i32>() = (zone_id13).take_handle() as i32;
                    ptr12
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_bot_management_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/bot-management@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,arg9: i32,arg10: i32,arg11: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_bot_management_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 44]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 44]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod byo_ip_prefix {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub advertisement: &'a Output,
                    pub description: &'a Output,
                    pub prefix_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("advertisement", &self.advertisement)
                            .field("description", &self.description)
                            .field("prefix-id", &self.prefix_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub advertisement: Output,
                    pub description: Output,
                    pub prefix_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("advertisement", &self.advertisement)
                            .field("description", &self.description)
                            .field("prefix-id", &self.prefix_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result5 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            advertisement: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            description: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            prefix_id: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                        },
                    );
                    let ptr6 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id7,
                        advertisement: advertisement7,
                        description: description7,
                        prefix_id: prefix_id7,
                    } = result5;
                    *ptr6.add(0).cast::<i32>() = (account_id7).take_handle() as i32;
                    *ptr6.add(4).cast::<i32>() = (advertisement7).take_handle() as i32;
                    *ptr6.add(8).cast::<i32>() = (description7).take_handle() as i32;
                    *ptr6.add(12).cast::<i32>() = (prefix_id7).take_handle() as i32;
                    ptr6
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_byo_ip_prefix_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/byo-ip-prefix@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_byo_ip_prefix_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod certificate_pack {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub certificate_authority: &'a Output,
                    pub cloudflare_branding: &'a Output,
                    pub hosts: &'a Output,
                    pub type_: &'a Output,
                    pub validation_errors: &'a Output,
                    pub validation_method: &'a Output,
                    pub validation_records: &'a Output,
                    pub validity_days: &'a Output,
                    pub wait_for_active_status: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("certificate-authority", &self.certificate_authority)
                            .field("cloudflare-branding", &self.cloudflare_branding)
                            .field("hosts", &self.hosts)
                            .field("type", &self.type_)
                            .field("validation-errors", &self.validation_errors)
                            .field("validation-method", &self.validation_method)
                            .field("validation-records", &self.validation_records)
                            .field("validity-days", &self.validity_days)
                            .field("wait-for-active-status", &self.wait_for_active_status)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub certificate_authority: Output,
                    pub cloudflare_branding: Output,
                    pub hosts: Output,
                    pub type_: Output,
                    pub validation_errors: Output,
                    pub validation_method: Output,
                    pub validation_records: Output,
                    pub validity_days: Output,
                    pub wait_for_active_status: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("certificate-authority", &self.certificate_authority)
                            .field("cloudflare-branding", &self.cloudflare_branding)
                            .field("hosts", &self.hosts)
                            .field("type", &self.type_)
                            .field("validation-errors", &self.validation_errors)
                            .field("validation-method", &self.validation_method)
                            .field("validation-records", &self.validation_records)
                            .field("validity-days", &self.validity_days)
                            .field("wait-for-active-status", &self.wait_for_active_status)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                    arg11: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let handle7;
                    let handle8;
                    let handle9;
                    let handle10;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result11 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            certificate_authority: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            cloudflare_branding: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            hosts: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            type_: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            validation_errors: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            validation_method: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                            validation_records: {
                                handle7 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg8 as u32);
                                &handle7
                            },
                            validity_days: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg9 as u32);
                                &handle8
                            },
                            wait_for_active_status: {
                                handle9 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg10 as u32);
                                &handle9
                            },
                            zone_id: {
                                handle10 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg11 as u32);
                                &handle10
                            },
                        },
                    );
                    let ptr12 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        certificate_authority: certificate_authority13,
                        cloudflare_branding: cloudflare_branding13,
                        hosts: hosts13,
                        type_: type_13,
                        validation_errors: validation_errors13,
                        validation_method: validation_method13,
                        validation_records: validation_records13,
                        validity_days: validity_days13,
                        wait_for_active_status: wait_for_active_status13,
                        zone_id: zone_id13,
                    } = result11;
                    *ptr12.add(0).cast::<i32>() = (certificate_authority13).take_handle() as i32;
                    *ptr12.add(4).cast::<i32>() = (cloudflare_branding13).take_handle() as i32;
                    *ptr12.add(8).cast::<i32>() = (hosts13).take_handle() as i32;
                    *ptr12.add(12).cast::<i32>() = (type_13).take_handle() as i32;
                    *ptr12.add(16).cast::<i32>() = (validation_errors13).take_handle() as i32;
                    *ptr12.add(20).cast::<i32>() = (validation_method13).take_handle() as i32;
                    *ptr12.add(24).cast::<i32>() = (validation_records13).take_handle() as i32;
                    *ptr12.add(28).cast::<i32>() = (validity_days13).take_handle() as i32;
                    *ptr12.add(32).cast::<i32>() = (wait_for_active_status13).take_handle() as i32;
                    *ptr12.add(36).cast::<i32>() = (zone_id13).take_handle() as i32;
                    ptr12
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_certificate_pack_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/certificate-pack@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,arg9: i32,arg10: i32,arg11: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_certificate_pack_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 40]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 40]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod custom_hostname {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub custom_metadata: &'a Output,
                    pub custom_origin_server: &'a Output,
                    pub custom_origin_sni: &'a Output,
                    pub hostname: &'a Output,
                    pub ssls: &'a Output,
                    pub wait_for_ssl_pending_validation: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("custom-metadata", &self.custom_metadata)
                            .field("custom-origin-server", &self.custom_origin_server)
                            .field("custom-origin-sni", &self.custom_origin_sni)
                            .field("hostname", &self.hostname)
                            .field("ssls", &self.ssls)
                            .field(
                                "wait-for-ssl-pending-validation",
                                &self.wait_for_ssl_pending_validation,
                            )
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub custom_metadata: Output,
                    pub custom_origin_server: Output,
                    pub custom_origin_sni: Output,
                    pub hostname: Output,
                    pub ownership_verification: Output,
                    pub ownership_verification_http: Output,
                    pub ssls: Output,
                    pub status: Output,
                    pub wait_for_ssl_pending_validation: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("custom-metadata", &self.custom_metadata)
                            .field("custom-origin-server", &self.custom_origin_server)
                            .field("custom-origin-sni", &self.custom_origin_sni)
                            .field("hostname", &self.hostname)
                            .field("ownership-verification", &self.ownership_verification)
                            .field(
                                "ownership-verification-http",
                                &self.ownership_verification_http,
                            )
                            .field("ssls", &self.ssls)
                            .field("status", &self.status)
                            .field(
                                "wait-for-ssl-pending-validation",
                                &self.wait_for_ssl_pending_validation,
                            )
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let handle7;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result8 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            custom_metadata: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            custom_origin_server: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            custom_origin_sni: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            hostname: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            ssls: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            wait_for_ssl_pending_validation: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                            zone_id: {
                                handle7 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg8 as u32);
                                &handle7
                            },
                        },
                    );
                    let ptr9 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        custom_metadata: custom_metadata10,
                        custom_origin_server: custom_origin_server10,
                        custom_origin_sni: custom_origin_sni10,
                        hostname: hostname10,
                        ownership_verification: ownership_verification10,
                        ownership_verification_http: ownership_verification_http10,
                        ssls: ssls10,
                        status: status10,
                        wait_for_ssl_pending_validation: wait_for_ssl_pending_validation10,
                        zone_id: zone_id10,
                    } = result8;
                    *ptr9.add(0).cast::<i32>() = (custom_metadata10).take_handle() as i32;
                    *ptr9.add(4).cast::<i32>() = (custom_origin_server10).take_handle() as i32;
                    *ptr9.add(8).cast::<i32>() = (custom_origin_sni10).take_handle() as i32;
                    *ptr9.add(12).cast::<i32>() = (hostname10).take_handle() as i32;
                    *ptr9.add(16).cast::<i32>() = (ownership_verification10).take_handle() as i32;
                    *ptr9.add(20).cast::<i32>() =
                        (ownership_verification_http10).take_handle() as i32;
                    *ptr9.add(24).cast::<i32>() = (ssls10).take_handle() as i32;
                    *ptr9.add(28).cast::<i32>() = (status10).take_handle() as i32;
                    *ptr9.add(32).cast::<i32>() =
                        (wait_for_ssl_pending_validation10).take_handle() as i32;
                    *ptr9.add(36).cast::<i32>() = (zone_id10).take_handle() as i32;
                    ptr9
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_custom_hostname_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/custom-hostname@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_custom_hostname_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 40]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 40]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod custom_hostname_fallback_origin {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub origin: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("origin", &self.origin)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub origin: Output,
                    pub status: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("origin", &self.origin)
                            .field("status", &self.status)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result3 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            origin: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            zone_id: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                        },
                    );
                    let ptr4 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        origin: origin5,
                        status: status5,
                        zone_id: zone_id5,
                    } = result3;
                    *ptr4.add(0).cast::<i32>() = (origin5).take_handle() as i32;
                    *ptr4.add(4).cast::<i32>() = (status5).take_handle() as i32;
                    *ptr4.add(8).cast::<i32>() = (zone_id5).take_handle() as i32;
                    ptr4
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_custom_hostname_fallback_origin_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/custom-hostname-fallback-origin@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_custom_hostname_fallback_origin_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod custom_pages {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub state: &'a Output,
                    pub type_: &'a Output,
                    pub url: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("state", &self.state)
                            .field("type", &self.type_)
                            .field("url", &self.url)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub state: Output,
                    pub type_: Output,
                    pub url: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("state", &self.state)
                            .field("type", &self.type_)
                            .field("url", &self.url)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result6 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            state: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            type_: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            url: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            zone_id: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                        },
                    );
                    let ptr7 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id8,
                        state: state8,
                        type_: type_8,
                        url: url8,
                        zone_id: zone_id8,
                    } = result6;
                    *ptr7.add(0).cast::<i32>() = (account_id8).take_handle() as i32;
                    *ptr7.add(4).cast::<i32>() = (state8).take_handle() as i32;
                    *ptr7.add(8).cast::<i32>() = (type_8).take_handle() as i32;
                    *ptr7.add(12).cast::<i32>() = (url8).take_handle() as i32;
                    *ptr7.add(16).cast::<i32>() = (zone_id8).take_handle() as i32;
                    ptr7
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_custom_pages_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/custom-pages@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_custom_pages_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 20]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 20]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod custom_ssl {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub custom_ssl_options: &'a Output,
                    pub custom_ssl_priorities: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("custom-ssl-options", &self.custom_ssl_options)
                            .field("custom-ssl-priorities", &self.custom_ssl_priorities)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub custom_ssl_options: Output,
                    pub custom_ssl_priorities: Output,
                    pub expires_on: Output,
                    pub hosts: Output,
                    pub issuer: Output,
                    pub modified_on: Output,
                    pub priority: Output,
                    pub signature: Output,
                    pub status: Output,
                    pub uploaded_on: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("custom-ssl-options", &self.custom_ssl_options)
                            .field("custom-ssl-priorities", &self.custom_ssl_priorities)
                            .field("expires-on", &self.expires_on)
                            .field("hosts", &self.hosts)
                            .field("issuer", &self.issuer)
                            .field("modified-on", &self.modified_on)
                            .field("priority", &self.priority)
                            .field("signature", &self.signature)
                            .field("status", &self.status)
                            .field("uploaded-on", &self.uploaded_on)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result4 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            custom_ssl_options: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            custom_ssl_priorities: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            zone_id: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                        },
                    );
                    let ptr5 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        custom_ssl_options: custom_ssl_options6,
                        custom_ssl_priorities: custom_ssl_priorities6,
                        expires_on: expires_on6,
                        hosts: hosts6,
                        issuer: issuer6,
                        modified_on: modified_on6,
                        priority: priority6,
                        signature: signature6,
                        status: status6,
                        uploaded_on: uploaded_on6,
                        zone_id: zone_id6,
                    } = result4;
                    *ptr5.add(0).cast::<i32>() = (custom_ssl_options6).take_handle() as i32;
                    *ptr5.add(4).cast::<i32>() = (custom_ssl_priorities6).take_handle() as i32;
                    *ptr5.add(8).cast::<i32>() = (expires_on6).take_handle() as i32;
                    *ptr5.add(12).cast::<i32>() = (hosts6).take_handle() as i32;
                    *ptr5.add(16).cast::<i32>() = (issuer6).take_handle() as i32;
                    *ptr5.add(20).cast::<i32>() = (modified_on6).take_handle() as i32;
                    *ptr5.add(24).cast::<i32>() = (priority6).take_handle() as i32;
                    *ptr5.add(28).cast::<i32>() = (signature6).take_handle() as i32;
                    *ptr5.add(32).cast::<i32>() = (status6).take_handle() as i32;
                    *ptr5.add(36).cast::<i32>() = (uploaded_on6).take_handle() as i32;
                    *ptr5.add(40).cast::<i32>() = (zone_id6).take_handle() as i32;
                    ptr5
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_custom_ssl_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/custom-ssl@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_custom_ssl_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 44]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 44]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod d1_database {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub name: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("name", &self.name)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub name: Output,
                    pub version: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("name", &self.name)
                            .field("version", &self.version)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result3 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            name: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                        },
                    );
                    let ptr4 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id5,
                        name: name5,
                        version: version5,
                    } = result3;
                    *ptr4.add(0).cast::<i32>() = (account_id5).take_handle() as i32;
                    *ptr4.add(4).cast::<i32>() = (name5).take_handle() as i32;
                    *ptr4.add(8).cast::<i32>() = (version5).take_handle() as i32;
                    ptr4
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_d1_database_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/d1-database@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_d1_database_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod device_dex_test {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub data: &'a Output,
                    pub description: &'a Output,
                    pub enabled: &'a Output,
                    pub interval: &'a Output,
                    pub name: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("data", &self.data)
                            .field("description", &self.description)
                            .field("enabled", &self.enabled)
                            .field("interval", &self.interval)
                            .field("name", &self.name)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub created: Output,
                    pub data: Output,
                    pub description: Output,
                    pub enabled: Output,
                    pub interval: Output,
                    pub name: Output,
                    pub updated: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("created", &self.created)
                            .field("data", &self.data)
                            .field("description", &self.description)
                            .field("enabled", &self.enabled)
                            .field("interval", &self.interval)
                            .field("name", &self.name)
                            .field("updated", &self.updated)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result7 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            data: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            description: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            enabled: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            interval: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            name: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                        },
                    );
                    let ptr8 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id9,
                        created: created9,
                        data: data9,
                        description: description9,
                        enabled: enabled9,
                        interval: interval9,
                        name: name9,
                        updated: updated9,
                    } = result7;
                    *ptr8.add(0).cast::<i32>() = (account_id9).take_handle() as i32;
                    *ptr8.add(4).cast::<i32>() = (created9).take_handle() as i32;
                    *ptr8.add(8).cast::<i32>() = (data9).take_handle() as i32;
                    *ptr8.add(12).cast::<i32>() = (description9).take_handle() as i32;
                    *ptr8.add(16).cast::<i32>() = (enabled9).take_handle() as i32;
                    *ptr8.add(20).cast::<i32>() = (interval9).take_handle() as i32;
                    *ptr8.add(24).cast::<i32>() = (name9).take_handle() as i32;
                    *ptr8.add(28).cast::<i32>() = (updated9).take_handle() as i32;
                    ptr8
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_device_dex_test_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/device-dex-test@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_device_dex_test_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 32]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 32]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod device_managed_networks {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub config: &'a Output,
                    pub name: &'a Output,
                    pub type_: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("config", &self.config)
                            .field("name", &self.name)
                            .field("type", &self.type_)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub config: Output,
                    pub name: Output,
                    pub type_: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("config", &self.config)
                            .field("name", &self.name)
                            .field("type", &self.type_)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result5 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            config: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            name: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            type_: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                        },
                    );
                    let ptr6 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id7,
                        config: config7,
                        name: name7,
                        type_: type_7,
                    } = result5;
                    *ptr6.add(0).cast::<i32>() = (account_id7).take_handle() as i32;
                    *ptr6.add(4).cast::<i32>() = (config7).take_handle() as i32;
                    *ptr6.add(8).cast::<i32>() = (name7).take_handle() as i32;
                    *ptr6.add(12).cast::<i32>() = (type_7).take_handle() as i32;
                    ptr6
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_device_managed_networks_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/device-managed-networks@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_device_managed_networks_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod device_policy_certificates {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub enabled: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("enabled", &self.enabled)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub enabled: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("enabled", &self.enabled)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result3 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            enabled: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            zone_id: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                        },
                    );
                    let ptr4 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        enabled: enabled5,
                        zone_id: zone_id5,
                    } = result3;
                    *ptr4.add(0).cast::<i32>() = (enabled5).take_handle() as i32;
                    *ptr4.add(4).cast::<i32>() = (zone_id5).take_handle() as i32;
                    ptr4
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_device_policy_certificates_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/device-policy-certificates@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_device_policy_certificates_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 8]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod device_posture_integration {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub configs: &'a Output,
                    pub identifier: &'a Output,
                    pub interval: &'a Output,
                    pub name: &'a Output,
                    pub type_: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("configs", &self.configs)
                            .field("identifier", &self.identifier)
                            .field("interval", &self.interval)
                            .field("name", &self.name)
                            .field("type", &self.type_)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub configs: Output,
                    pub identifier: Output,
                    pub interval: Output,
                    pub name: Output,
                    pub type_: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("configs", &self.configs)
                            .field("identifier", &self.identifier)
                            .field("interval", &self.interval)
                            .field("name", &self.name)
                            .field("type", &self.type_)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result7 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            configs: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            identifier: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            interval: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            name: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            type_: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                        },
                    );
                    let ptr8 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id9,
                        configs: configs9,
                        identifier: identifier9,
                        interval: interval9,
                        name: name9,
                        type_: type_9,
                    } = result7;
                    *ptr8.add(0).cast::<i32>() = (account_id9).take_handle() as i32;
                    *ptr8.add(4).cast::<i32>() = (configs9).take_handle() as i32;
                    *ptr8.add(8).cast::<i32>() = (identifier9).take_handle() as i32;
                    *ptr8.add(12).cast::<i32>() = (interval9).take_handle() as i32;
                    *ptr8.add(16).cast::<i32>() = (name9).take_handle() as i32;
                    *ptr8.add(20).cast::<i32>() = (type_9).take_handle() as i32;
                    ptr8
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_device_posture_integration_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/device-posture-integration@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_device_posture_integration_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 24]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 24]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod device_posture_rule {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub description: &'a Output,
                    pub expiration: &'a Output,
                    pub inputs: &'a Output,
                    pub matches: &'a Output,
                    pub name: &'a Output,
                    pub schedule: &'a Output,
                    pub type_: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("description", &self.description)
                            .field("expiration", &self.expiration)
                            .field("inputs", &self.inputs)
                            .field("matches", &self.matches)
                            .field("name", &self.name)
                            .field("schedule", &self.schedule)
                            .field("type", &self.type_)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub description: Output,
                    pub expiration: Output,
                    pub inputs: Output,
                    pub matches: Output,
                    pub name: Output,
                    pub schedule: Output,
                    pub type_: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("description", &self.description)
                            .field("expiration", &self.expiration)
                            .field("inputs", &self.inputs)
                            .field("matches", &self.matches)
                            .field("name", &self.name)
                            .field("schedule", &self.schedule)
                            .field("type", &self.type_)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let handle7;
                    let handle8;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result9 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            description: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            expiration: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            inputs: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            matches: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            name: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                            schedule: {
                                handle7 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg8 as u32);
                                &handle7
                            },
                            type_: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg9 as u32);
                                &handle8
                            },
                        },
                    );
                    let ptr10 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id11,
                        description: description11,
                        expiration: expiration11,
                        inputs: inputs11,
                        matches: matches11,
                        name: name11,
                        schedule: schedule11,
                        type_: type_11,
                    } = result9;
                    *ptr10.add(0).cast::<i32>() = (account_id11).take_handle() as i32;
                    *ptr10.add(4).cast::<i32>() = (description11).take_handle() as i32;
                    *ptr10.add(8).cast::<i32>() = (expiration11).take_handle() as i32;
                    *ptr10.add(12).cast::<i32>() = (inputs11).take_handle() as i32;
                    *ptr10.add(16).cast::<i32>() = (matches11).take_handle() as i32;
                    *ptr10.add(20).cast::<i32>() = (name11).take_handle() as i32;
                    *ptr10.add(24).cast::<i32>() = (schedule11).take_handle() as i32;
                    *ptr10.add(28).cast::<i32>() = (type_11).take_handle() as i32;
                    ptr10
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_device_posture_rule_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/device-posture-rule@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,arg9: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_device_posture_rule_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 32]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 32]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod device_settings_policy {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub allow_mode_switch: &'a Output,
                    pub allow_updates: &'a Output,
                    pub allowed_to_leave: &'a Output,
                    pub auto_connect: &'a Output,
                    pub captive_portal: &'a Output,
                    pub default: &'a Output,
                    pub description: &'a Output,
                    pub disable_auto_fallback: &'a Output,
                    pub enabled: &'a Output,
                    pub exclude_office_ips: &'a Output,
                    pub match_: &'a Output,
                    pub name: &'a Output,
                    pub precedence: &'a Output,
                    pub service_mode_v2_mode: &'a Output,
                    pub service_mode_v2_port: &'a Output,
                    pub support_url: &'a Output,
                    pub switch_locked: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("allow-mode-switch", &self.allow_mode_switch)
                            .field("allow-updates", &self.allow_updates)
                            .field("allowed-to-leave", &self.allowed_to_leave)
                            .field("auto-connect", &self.auto_connect)
                            .field("captive-portal", &self.captive_portal)
                            .field("default", &self.default)
                            .field("description", &self.description)
                            .field("disable-auto-fallback", &self.disable_auto_fallback)
                            .field("enabled", &self.enabled)
                            .field("exclude-office-ips", &self.exclude_office_ips)
                            .field("match", &self.match_)
                            .field("name", &self.name)
                            .field("precedence", &self.precedence)
                            .field("service-mode-v2-mode", &self.service_mode_v2_mode)
                            .field("service-mode-v2-port", &self.service_mode_v2_port)
                            .field("support-url", &self.support_url)
                            .field("switch-locked", &self.switch_locked)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub allow_mode_switch: Output,
                    pub allow_updates: Output,
                    pub allowed_to_leave: Output,
                    pub auto_connect: Output,
                    pub captive_portal: Output,
                    pub default: Output,
                    pub description: Output,
                    pub disable_auto_fallback: Output,
                    pub enabled: Output,
                    pub exclude_office_ips: Output,
                    pub match_: Output,
                    pub name: Output,
                    pub precedence: Output,
                    pub service_mode_v2_mode: Output,
                    pub service_mode_v2_port: Output,
                    pub support_url: Output,
                    pub switch_locked: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("allow-mode-switch", &self.allow_mode_switch)
                            .field("allow-updates", &self.allow_updates)
                            .field("allowed-to-leave", &self.allowed_to_leave)
                            .field("auto-connect", &self.auto_connect)
                            .field("captive-portal", &self.captive_portal)
                            .field("default", &self.default)
                            .field("description", &self.description)
                            .field("disable-auto-fallback", &self.disable_auto_fallback)
                            .field("enabled", &self.enabled)
                            .field("exclude-office-ips", &self.exclude_office_ips)
                            .field("match", &self.match_)
                            .field("name", &self.name)
                            .field("precedence", &self.precedence)
                            .field("service-mode-v2-mode", &self.service_mode_v2_mode)
                            .field("service-mode-v2-port", &self.service_mode_v2_port)
                            .field("support-url", &self.support_url)
                            .field("switch-locked", &self.switch_locked)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle4;
                    let handle6;
                    let handle8;
                    let handle10;
                    let handle12;
                    let handle14;
                    let handle16;
                    let handle18;
                    let handle20;
                    let handle22;
                    let handle24;
                    let handle26;
                    let handle28;
                    let handle30;
                    let handle32;
                    let handle34;
                    let handle36;
                    let handle38;
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let len2 = l1;
                    let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                    let l3 = *arg0.add(8).cast::<i32>();
                    let l5 = *arg0.add(12).cast::<i32>();
                    let l7 = *arg0.add(16).cast::<i32>();
                    let l9 = *arg0.add(20).cast::<i32>();
                    let l11 = *arg0.add(24).cast::<i32>();
                    let l13 = *arg0.add(28).cast::<i32>();
                    let l15 = *arg0.add(32).cast::<i32>();
                    let l17 = *arg0.add(36).cast::<i32>();
                    let l19 = *arg0.add(40).cast::<i32>();
                    let l21 = *arg0.add(44).cast::<i32>();
                    let l23 = *arg0.add(48).cast::<i32>();
                    let l25 = *arg0.add(52).cast::<i32>();
                    let l27 = *arg0.add(56).cast::<i32>();
                    let l29 = *arg0.add(60).cast::<i32>();
                    let l31 = *arg0.add(64).cast::<i32>();
                    let l33 = *arg0.add(68).cast::<i32>();
                    let l35 = *arg0.add(72).cast::<i32>();
                    let l37 = *arg0.add(76).cast::<i32>();
                    let result39 = T::invoke(
                        _rt::string_lift(bytes2),
                        Args {
                            account_id: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l3 as u32);
                                &handle4
                            },
                            allow_mode_switch: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l5 as u32);
                                &handle6
                            },
                            allow_updates: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l7 as u32);
                                &handle8
                            },
                            allowed_to_leave: {
                                handle10 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l9 as u32);
                                &handle10
                            },
                            auto_connect: {
                                handle12 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l11 as u32);
                                &handle12
                            },
                            captive_portal: {
                                handle14 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l13 as u32);
                                &handle14
                            },
                            default: {
                                handle16 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l15 as u32);
                                &handle16
                            },
                            description: {
                                handle18 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l17 as u32);
                                &handle18
                            },
                            disable_auto_fallback: {
                                handle20 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l19 as u32);
                                &handle20
                            },
                            enabled: {
                                handle22 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l21 as u32);
                                &handle22
                            },
                            exclude_office_ips: {
                                handle24 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l23 as u32);
                                &handle24
                            },
                            match_: {
                                handle26 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l25 as u32);
                                &handle26
                            },
                            name: {
                                handle28 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l27 as u32);
                                &handle28
                            },
                            precedence: {
                                handle30 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l29 as u32);
                                &handle30
                            },
                            service_mode_v2_mode: {
                                handle32 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l31 as u32);
                                &handle32
                            },
                            service_mode_v2_port: {
                                handle34 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l33 as u32);
                                &handle34
                            },
                            support_url: {
                                handle36 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l35 as u32);
                                &handle36
                            },
                            switch_locked: {
                                handle38 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l37 as u32);
                                &handle38
                            },
                        },
                    );
                    _rt::cabi_dealloc(arg0, 80, 4);
                    let ptr40 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id41,
                        allow_mode_switch: allow_mode_switch41,
                        allow_updates: allow_updates41,
                        allowed_to_leave: allowed_to_leave41,
                        auto_connect: auto_connect41,
                        captive_portal: captive_portal41,
                        default: default41,
                        description: description41,
                        disable_auto_fallback: disable_auto_fallback41,
                        enabled: enabled41,
                        exclude_office_ips: exclude_office_ips41,
                        match_: match_41,
                        name: name41,
                        precedence: precedence41,
                        service_mode_v2_mode: service_mode_v2_mode41,
                        service_mode_v2_port: service_mode_v2_port41,
                        support_url: support_url41,
                        switch_locked: switch_locked41,
                    } = result39;
                    *ptr40.add(0).cast::<i32>() = (account_id41).take_handle() as i32;
                    *ptr40.add(4).cast::<i32>() = (allow_mode_switch41).take_handle() as i32;
                    *ptr40.add(8).cast::<i32>() = (allow_updates41).take_handle() as i32;
                    *ptr40.add(12).cast::<i32>() = (allowed_to_leave41).take_handle() as i32;
                    *ptr40.add(16).cast::<i32>() = (auto_connect41).take_handle() as i32;
                    *ptr40.add(20).cast::<i32>() = (captive_portal41).take_handle() as i32;
                    *ptr40.add(24).cast::<i32>() = (default41).take_handle() as i32;
                    *ptr40.add(28).cast::<i32>() = (description41).take_handle() as i32;
                    *ptr40.add(32).cast::<i32>() = (disable_auto_fallback41).take_handle() as i32;
                    *ptr40.add(36).cast::<i32>() = (enabled41).take_handle() as i32;
                    *ptr40.add(40).cast::<i32>() = (exclude_office_ips41).take_handle() as i32;
                    *ptr40.add(44).cast::<i32>() = (match_41).take_handle() as i32;
                    *ptr40.add(48).cast::<i32>() = (name41).take_handle() as i32;
                    *ptr40.add(52).cast::<i32>() = (precedence41).take_handle() as i32;
                    *ptr40.add(56).cast::<i32>() = (service_mode_v2_mode41).take_handle() as i32;
                    *ptr40.add(60).cast::<i32>() = (service_mode_v2_port41).take_handle() as i32;
                    *ptr40.add(64).cast::<i32>() = (support_url41).take_handle() as i32;
                    *ptr40.add(68).cast::<i32>() = (switch_locked41).take_handle() as i32;
                    ptr40
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_device_settings_policy_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/device-settings-policy@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_device_settings_policy_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 72]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 72]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod dlp_profile {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub allowed_match_count: &'a Output,
                    pub context_awareness: &'a Output,
                    pub description: &'a Output,
                    pub entries: &'a Output,
                    pub name: &'a Output,
                    pub type_: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("allowed-match-count", &self.allowed_match_count)
                            .field("context-awareness", &self.context_awareness)
                            .field("description", &self.description)
                            .field("entries", &self.entries)
                            .field("name", &self.name)
                            .field("type", &self.type_)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub allowed_match_count: Output,
                    pub context_awareness: Output,
                    pub description: Output,
                    pub entries: Output,
                    pub name: Output,
                    pub type_: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("allowed-match-count", &self.allowed_match_count)
                            .field("context-awareness", &self.context_awareness)
                            .field("description", &self.description)
                            .field("entries", &self.entries)
                            .field("name", &self.name)
                            .field("type", &self.type_)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let handle7;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result8 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            allowed_match_count: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            context_awareness: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            description: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            entries: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            name: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                            type_: {
                                handle7 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg8 as u32);
                                &handle7
                            },
                        },
                    );
                    let ptr9 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id10,
                        allowed_match_count: allowed_match_count10,
                        context_awareness: context_awareness10,
                        description: description10,
                        entries: entries10,
                        name: name10,
                        type_: type_10,
                    } = result8;
                    *ptr9.add(0).cast::<i32>() = (account_id10).take_handle() as i32;
                    *ptr9.add(4).cast::<i32>() = (allowed_match_count10).take_handle() as i32;
                    *ptr9.add(8).cast::<i32>() = (context_awareness10).take_handle() as i32;
                    *ptr9.add(12).cast::<i32>() = (description10).take_handle() as i32;
                    *ptr9.add(16).cast::<i32>() = (entries10).take_handle() as i32;
                    *ptr9.add(20).cast::<i32>() = (name10).take_handle() as i32;
                    *ptr9.add(24).cast::<i32>() = (type_10).take_handle() as i32;
                    ptr9
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_dlp_profile_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/dlp-profile@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_dlp_profile_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 28]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 28]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod email_routing_address {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub email: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("email", &self.email)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub created: Output,
                    pub email: Output,
                    pub modified: Output,
                    pub tag: Output,
                    pub verified: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("created", &self.created)
                            .field("email", &self.email)
                            .field("modified", &self.modified)
                            .field("tag", &self.tag)
                            .field("verified", &self.verified)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result3 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            email: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                        },
                    );
                    let ptr4 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id5,
                        created: created5,
                        email: email5,
                        modified: modified5,
                        tag: tag5,
                        verified: verified5,
                    } = result3;
                    *ptr4.add(0).cast::<i32>() = (account_id5).take_handle() as i32;
                    *ptr4.add(4).cast::<i32>() = (created5).take_handle() as i32;
                    *ptr4.add(8).cast::<i32>() = (email5).take_handle() as i32;
                    *ptr4.add(12).cast::<i32>() = (modified5).take_handle() as i32;
                    *ptr4.add(16).cast::<i32>() = (tag5).take_handle() as i32;
                    *ptr4.add(20).cast::<i32>() = (verified5).take_handle() as i32;
                    ptr4
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_email_routing_address_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/email-routing-address@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_email_routing_address_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 24]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 24]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod email_routing_catch_all {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub actions: &'a Output,
                    pub enabled: &'a Output,
                    pub matchers: &'a Output,
                    pub name: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("actions", &self.actions)
                            .field("enabled", &self.enabled)
                            .field("matchers", &self.matchers)
                            .field("name", &self.name)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub actions: Output,
                    pub enabled: Output,
                    pub matchers: Output,
                    pub name: Output,
                    pub tag: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("actions", &self.actions)
                            .field("enabled", &self.enabled)
                            .field("matchers", &self.matchers)
                            .field("name", &self.name)
                            .field("tag", &self.tag)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result6 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            actions: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            enabled: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            matchers: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            name: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            zone_id: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                        },
                    );
                    let ptr7 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        actions: actions8,
                        enabled: enabled8,
                        matchers: matchers8,
                        name: name8,
                        tag: tag8,
                        zone_id: zone_id8,
                    } = result6;
                    *ptr7.add(0).cast::<i32>() = (actions8).take_handle() as i32;
                    *ptr7.add(4).cast::<i32>() = (enabled8).take_handle() as i32;
                    *ptr7.add(8).cast::<i32>() = (matchers8).take_handle() as i32;
                    *ptr7.add(12).cast::<i32>() = (name8).take_handle() as i32;
                    *ptr7.add(16).cast::<i32>() = (tag8).take_handle() as i32;
                    *ptr7.add(20).cast::<i32>() = (zone_id8).take_handle() as i32;
                    ptr7
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_email_routing_catch_all_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/email-routing-catch-all@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_email_routing_catch_all_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 24]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 24]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod email_routing_rule {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub actions: &'a Output,
                    pub enabled: &'a Output,
                    pub matchers: &'a Output,
                    pub name: &'a Output,
                    pub priority: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("actions", &self.actions)
                            .field("enabled", &self.enabled)
                            .field("matchers", &self.matchers)
                            .field("name", &self.name)
                            .field("priority", &self.priority)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub actions: Output,
                    pub enabled: Output,
                    pub matchers: Output,
                    pub name: Output,
                    pub priority: Output,
                    pub tag: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("actions", &self.actions)
                            .field("enabled", &self.enabled)
                            .field("matchers", &self.matchers)
                            .field("name", &self.name)
                            .field("priority", &self.priority)
                            .field("tag", &self.tag)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result7 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            actions: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            enabled: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            matchers: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            name: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            priority: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            zone_id: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                        },
                    );
                    let ptr8 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        actions: actions9,
                        enabled: enabled9,
                        matchers: matchers9,
                        name: name9,
                        priority: priority9,
                        tag: tag9,
                        zone_id: zone_id9,
                    } = result7;
                    *ptr8.add(0).cast::<i32>() = (actions9).take_handle() as i32;
                    *ptr8.add(4).cast::<i32>() = (enabled9).take_handle() as i32;
                    *ptr8.add(8).cast::<i32>() = (matchers9).take_handle() as i32;
                    *ptr8.add(12).cast::<i32>() = (name9).take_handle() as i32;
                    *ptr8.add(16).cast::<i32>() = (priority9).take_handle() as i32;
                    *ptr8.add(20).cast::<i32>() = (tag9).take_handle() as i32;
                    *ptr8.add(24).cast::<i32>() = (zone_id9).take_handle() as i32;
                    ptr8
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_email_routing_rule_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/email-routing-rule@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_email_routing_rule_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 28]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 28]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod email_routing_settings {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub enabled: &'a Output,
                    pub skip_wizard: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("enabled", &self.enabled)
                            .field("skip-wizard", &self.skip_wizard)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub created: Output,
                    pub enabled: Output,
                    pub modified: Output,
                    pub name: Output,
                    pub skip_wizard: Output,
                    pub status: Output,
                    pub tag: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("created", &self.created)
                            .field("enabled", &self.enabled)
                            .field("modified", &self.modified)
                            .field("name", &self.name)
                            .field("skip-wizard", &self.skip_wizard)
                            .field("status", &self.status)
                            .field("tag", &self.tag)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result4 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            enabled: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            skip_wizard: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            zone_id: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                        },
                    );
                    let ptr5 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        created: created6,
                        enabled: enabled6,
                        modified: modified6,
                        name: name6,
                        skip_wizard: skip_wizard6,
                        status: status6,
                        tag: tag6,
                        zone_id: zone_id6,
                    } = result4;
                    *ptr5.add(0).cast::<i32>() = (created6).take_handle() as i32;
                    *ptr5.add(4).cast::<i32>() = (enabled6).take_handle() as i32;
                    *ptr5.add(8).cast::<i32>() = (modified6).take_handle() as i32;
                    *ptr5.add(12).cast::<i32>() = (name6).take_handle() as i32;
                    *ptr5.add(16).cast::<i32>() = (skip_wizard6).take_handle() as i32;
                    *ptr5.add(20).cast::<i32>() = (status6).take_handle() as i32;
                    *ptr5.add(24).cast::<i32>() = (tag6).take_handle() as i32;
                    *ptr5.add(28).cast::<i32>() = (zone_id6).take_handle() as i32;
                    ptr5
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_email_routing_settings_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/email-routing-settings@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_email_routing_settings_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 32]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 32]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod fallback_domain {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub domains: &'a Output,
                    pub policy_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("domains", &self.domains)
                            .field("policy-id", &self.policy_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub domains: Output,
                    pub policy_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("domains", &self.domains)
                            .field("policy-id", &self.policy_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result4 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            domains: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            policy_id: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                        },
                    );
                    let ptr5 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id6,
                        domains: domains6,
                        policy_id: policy_id6,
                    } = result4;
                    *ptr5.add(0).cast::<i32>() = (account_id6).take_handle() as i32;
                    *ptr5.add(4).cast::<i32>() = (domains6).take_handle() as i32;
                    *ptr5.add(8).cast::<i32>() = (policy_id6).take_handle() as i32;
                    ptr5
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_fallback_domain_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/fallback-domain@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_fallback_domain_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod filter {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub description: &'a Output,
                    pub expression: &'a Output,
                    pub paused: &'a Output,
                    pub ref_: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("description", &self.description)
                            .field("expression", &self.expression)
                            .field("paused", &self.paused)
                            .field("ref", &self.ref_)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub description: Output,
                    pub expression: Output,
                    pub paused: Output,
                    pub ref_: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("description", &self.description)
                            .field("expression", &self.expression)
                            .field("paused", &self.paused)
                            .field("ref", &self.ref_)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result6 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            description: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            expression: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            paused: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            ref_: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            zone_id: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                        },
                    );
                    let ptr7 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        description: description8,
                        expression: expression8,
                        paused: paused8,
                        ref_: ref_8,
                        zone_id: zone_id8,
                    } = result6;
                    *ptr7.add(0).cast::<i32>() = (description8).take_handle() as i32;
                    *ptr7.add(4).cast::<i32>() = (expression8).take_handle() as i32;
                    *ptr7.add(8).cast::<i32>() = (paused8).take_handle() as i32;
                    *ptr7.add(12).cast::<i32>() = (ref_8).take_handle() as i32;
                    *ptr7.add(16).cast::<i32>() = (zone_id8).take_handle() as i32;
                    ptr7
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_filter_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/filter@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_filter_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 20]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 20]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod firewall_rule {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub action: &'a Output,
                    pub description: &'a Output,
                    pub filter_id: &'a Output,
                    pub paused: &'a Output,
                    pub priority: &'a Output,
                    pub products: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("action", &self.action)
                            .field("description", &self.description)
                            .field("filter-id", &self.filter_id)
                            .field("paused", &self.paused)
                            .field("priority", &self.priority)
                            .field("products", &self.products)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub action: Output,
                    pub description: Output,
                    pub filter_id: Output,
                    pub paused: Output,
                    pub priority: Output,
                    pub products: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("action", &self.action)
                            .field("description", &self.description)
                            .field("filter-id", &self.filter_id)
                            .field("paused", &self.paused)
                            .field("priority", &self.priority)
                            .field("products", &self.products)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let handle7;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result8 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            action: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            description: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            filter_id: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            paused: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            priority: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            products: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                            zone_id: {
                                handle7 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg8 as u32);
                                &handle7
                            },
                        },
                    );
                    let ptr9 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        action: action10,
                        description: description10,
                        filter_id: filter_id10,
                        paused: paused10,
                        priority: priority10,
                        products: products10,
                        zone_id: zone_id10,
                    } = result8;
                    *ptr9.add(0).cast::<i32>() = (action10).take_handle() as i32;
                    *ptr9.add(4).cast::<i32>() = (description10).take_handle() as i32;
                    *ptr9.add(8).cast::<i32>() = (filter_id10).take_handle() as i32;
                    *ptr9.add(12).cast::<i32>() = (paused10).take_handle() as i32;
                    *ptr9.add(16).cast::<i32>() = (priority10).take_handle() as i32;
                    *ptr9.add(20).cast::<i32>() = (products10).take_handle() as i32;
                    *ptr9.add(24).cast::<i32>() = (zone_id10).take_handle() as i32;
                    ptr9
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_firewall_rule_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/firewall-rule@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_firewall_rule_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 28]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 28]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod gre_tunnel {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub cloudflare_gre_endpoint: &'a Output,
                    pub customer_gre_endpoint: &'a Output,
                    pub description: &'a Output,
                    pub health_check_enabled: &'a Output,
                    pub health_check_target: &'a Output,
                    pub health_check_type: &'a Output,
                    pub interface_address: &'a Output,
                    pub mtu: &'a Output,
                    pub name: &'a Output,
                    pub ttl: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("cloudflare-gre-endpoint", &self.cloudflare_gre_endpoint)
                            .field("customer-gre-endpoint", &self.customer_gre_endpoint)
                            .field("description", &self.description)
                            .field("health-check-enabled", &self.health_check_enabled)
                            .field("health-check-target", &self.health_check_target)
                            .field("health-check-type", &self.health_check_type)
                            .field("interface-address", &self.interface_address)
                            .field("mtu", &self.mtu)
                            .field("name", &self.name)
                            .field("ttl", &self.ttl)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub cloudflare_gre_endpoint: Output,
                    pub customer_gre_endpoint: Output,
                    pub description: Output,
                    pub health_check_enabled: Output,
                    pub health_check_target: Output,
                    pub health_check_type: Output,
                    pub interface_address: Output,
                    pub mtu: Output,
                    pub name: Output,
                    pub ttl: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("cloudflare-gre-endpoint", &self.cloudflare_gre_endpoint)
                            .field("customer-gre-endpoint", &self.customer_gre_endpoint)
                            .field("description", &self.description)
                            .field("health-check-enabled", &self.health_check_enabled)
                            .field("health-check-target", &self.health_check_target)
                            .field("health-check-type", &self.health_check_type)
                            .field("interface-address", &self.interface_address)
                            .field("mtu", &self.mtu)
                            .field("name", &self.name)
                            .field("ttl", &self.ttl)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                    arg11: i32,
                    arg12: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let handle7;
                    let handle8;
                    let handle9;
                    let handle10;
                    let handle11;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result12 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            cloudflare_gre_endpoint: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            customer_gre_endpoint: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            description: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            health_check_enabled: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            health_check_target: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                            health_check_type: {
                                handle7 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg8 as u32);
                                &handle7
                            },
                            interface_address: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg9 as u32);
                                &handle8
                            },
                            mtu: {
                                handle9 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg10 as u32);
                                &handle9
                            },
                            name: {
                                handle10 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg11 as u32);
                                &handle10
                            },
                            ttl: {
                                handle11 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg12 as u32);
                                &handle11
                            },
                        },
                    );
                    let ptr13 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id14,
                        cloudflare_gre_endpoint: cloudflare_gre_endpoint14,
                        customer_gre_endpoint: customer_gre_endpoint14,
                        description: description14,
                        health_check_enabled: health_check_enabled14,
                        health_check_target: health_check_target14,
                        health_check_type: health_check_type14,
                        interface_address: interface_address14,
                        mtu: mtu14,
                        name: name14,
                        ttl: ttl14,
                    } = result12;
                    *ptr13.add(0).cast::<i32>() = (account_id14).take_handle() as i32;
                    *ptr13.add(4).cast::<i32>() = (cloudflare_gre_endpoint14).take_handle() as i32;
                    *ptr13.add(8).cast::<i32>() = (customer_gre_endpoint14).take_handle() as i32;
                    *ptr13.add(12).cast::<i32>() = (description14).take_handle() as i32;
                    *ptr13.add(16).cast::<i32>() = (health_check_enabled14).take_handle() as i32;
                    *ptr13.add(20).cast::<i32>() = (health_check_target14).take_handle() as i32;
                    *ptr13.add(24).cast::<i32>() = (health_check_type14).take_handle() as i32;
                    *ptr13.add(28).cast::<i32>() = (interface_address14).take_handle() as i32;
                    *ptr13.add(32).cast::<i32>() = (mtu14).take_handle() as i32;
                    *ptr13.add(36).cast::<i32>() = (name14).take_handle() as i32;
                    *ptr13.add(40).cast::<i32>() = (ttl14).take_handle() as i32;
                    ptr13
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_gre_tunnel_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/gre-tunnel@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,arg9: i32,arg10: i32,arg11: i32,arg12: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_gre_tunnel_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 44]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 44]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod healthcheck {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub address: &'a Output,
                    pub allow_insecure: &'a Output,
                    pub check_regions: &'a Output,
                    pub consecutive_fails: &'a Output,
                    pub consecutive_successes: &'a Output,
                    pub description: &'a Output,
                    pub expected_body: &'a Output,
                    pub expected_codes: &'a Output,
                    pub follow_redirects: &'a Output,
                    pub headers: &'a Output,
                    pub interval: &'a Output,
                    pub method: &'a Output,
                    pub name: &'a Output,
                    pub path: &'a Output,
                    pub port: &'a Output,
                    pub retries: &'a Output,
                    pub suspended: &'a Output,
                    pub timeout: &'a Output,
                    pub type_: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("address", &self.address)
                            .field("allow-insecure", &self.allow_insecure)
                            .field("check-regions", &self.check_regions)
                            .field("consecutive-fails", &self.consecutive_fails)
                            .field("consecutive-successes", &self.consecutive_successes)
                            .field("description", &self.description)
                            .field("expected-body", &self.expected_body)
                            .field("expected-codes", &self.expected_codes)
                            .field("follow-redirects", &self.follow_redirects)
                            .field("headers", &self.headers)
                            .field("interval", &self.interval)
                            .field("method", &self.method)
                            .field("name", &self.name)
                            .field("path", &self.path)
                            .field("port", &self.port)
                            .field("retries", &self.retries)
                            .field("suspended", &self.suspended)
                            .field("timeout", &self.timeout)
                            .field("type", &self.type_)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub address: Output,
                    pub allow_insecure: Output,
                    pub check_regions: Output,
                    pub consecutive_fails: Output,
                    pub consecutive_successes: Output,
                    pub created_on: Output,
                    pub description: Output,
                    pub expected_body: Output,
                    pub expected_codes: Output,
                    pub follow_redirects: Output,
                    pub headers: Output,
                    pub interval: Output,
                    pub method: Output,
                    pub modified_on: Output,
                    pub name: Output,
                    pub path: Output,
                    pub port: Output,
                    pub retries: Output,
                    pub suspended: Output,
                    pub timeout: Output,
                    pub type_: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("address", &self.address)
                            .field("allow-insecure", &self.allow_insecure)
                            .field("check-regions", &self.check_regions)
                            .field("consecutive-fails", &self.consecutive_fails)
                            .field("consecutive-successes", &self.consecutive_successes)
                            .field("created-on", &self.created_on)
                            .field("description", &self.description)
                            .field("expected-body", &self.expected_body)
                            .field("expected-codes", &self.expected_codes)
                            .field("follow-redirects", &self.follow_redirects)
                            .field("headers", &self.headers)
                            .field("interval", &self.interval)
                            .field("method", &self.method)
                            .field("modified-on", &self.modified_on)
                            .field("name", &self.name)
                            .field("path", &self.path)
                            .field("port", &self.port)
                            .field("retries", &self.retries)
                            .field("suspended", &self.suspended)
                            .field("timeout", &self.timeout)
                            .field("type", &self.type_)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle4;
                    let handle6;
                    let handle8;
                    let handle10;
                    let handle12;
                    let handle14;
                    let handle16;
                    let handle18;
                    let handle20;
                    let handle22;
                    let handle24;
                    let handle26;
                    let handle28;
                    let handle30;
                    let handle32;
                    let handle34;
                    let handle36;
                    let handle38;
                    let handle40;
                    let handle42;
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let len2 = l1;
                    let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                    let l3 = *arg0.add(8).cast::<i32>();
                    let l5 = *arg0.add(12).cast::<i32>();
                    let l7 = *arg0.add(16).cast::<i32>();
                    let l9 = *arg0.add(20).cast::<i32>();
                    let l11 = *arg0.add(24).cast::<i32>();
                    let l13 = *arg0.add(28).cast::<i32>();
                    let l15 = *arg0.add(32).cast::<i32>();
                    let l17 = *arg0.add(36).cast::<i32>();
                    let l19 = *arg0.add(40).cast::<i32>();
                    let l21 = *arg0.add(44).cast::<i32>();
                    let l23 = *arg0.add(48).cast::<i32>();
                    let l25 = *arg0.add(52).cast::<i32>();
                    let l27 = *arg0.add(56).cast::<i32>();
                    let l29 = *arg0.add(60).cast::<i32>();
                    let l31 = *arg0.add(64).cast::<i32>();
                    let l33 = *arg0.add(68).cast::<i32>();
                    let l35 = *arg0.add(72).cast::<i32>();
                    let l37 = *arg0.add(76).cast::<i32>();
                    let l39 = *arg0.add(80).cast::<i32>();
                    let l41 = *arg0.add(84).cast::<i32>();
                    let result43 = T::invoke(
                        _rt::string_lift(bytes2),
                        Args {
                            address: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l3 as u32);
                                &handle4
                            },
                            allow_insecure: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l5 as u32);
                                &handle6
                            },
                            check_regions: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l7 as u32);
                                &handle8
                            },
                            consecutive_fails: {
                                handle10 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l9 as u32);
                                &handle10
                            },
                            consecutive_successes: {
                                handle12 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l11 as u32);
                                &handle12
                            },
                            description: {
                                handle14 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l13 as u32);
                                &handle14
                            },
                            expected_body: {
                                handle16 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l15 as u32);
                                &handle16
                            },
                            expected_codes: {
                                handle18 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l17 as u32);
                                &handle18
                            },
                            follow_redirects: {
                                handle20 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l19 as u32);
                                &handle20
                            },
                            headers: {
                                handle22 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l21 as u32);
                                &handle22
                            },
                            interval: {
                                handle24 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l23 as u32);
                                &handle24
                            },
                            method: {
                                handle26 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l25 as u32);
                                &handle26
                            },
                            name: {
                                handle28 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l27 as u32);
                                &handle28
                            },
                            path: {
                                handle30 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l29 as u32);
                                &handle30
                            },
                            port: {
                                handle32 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l31 as u32);
                                &handle32
                            },
                            retries: {
                                handle34 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l33 as u32);
                                &handle34
                            },
                            suspended: {
                                handle36 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l35 as u32);
                                &handle36
                            },
                            timeout: {
                                handle38 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l37 as u32);
                                &handle38
                            },
                            type_: {
                                handle40 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l39 as u32);
                                &handle40
                            },
                            zone_id: {
                                handle42 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l41 as u32);
                                &handle42
                            },
                        },
                    );
                    _rt::cabi_dealloc(arg0, 88, 4);
                    let ptr44 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        address: address45,
                        allow_insecure: allow_insecure45,
                        check_regions: check_regions45,
                        consecutive_fails: consecutive_fails45,
                        consecutive_successes: consecutive_successes45,
                        created_on: created_on45,
                        description: description45,
                        expected_body: expected_body45,
                        expected_codes: expected_codes45,
                        follow_redirects: follow_redirects45,
                        headers: headers45,
                        interval: interval45,
                        method: method45,
                        modified_on: modified_on45,
                        name: name45,
                        path: path45,
                        port: port45,
                        retries: retries45,
                        suspended: suspended45,
                        timeout: timeout45,
                        type_: type_45,
                        zone_id: zone_id45,
                    } = result43;
                    *ptr44.add(0).cast::<i32>() = (address45).take_handle() as i32;
                    *ptr44.add(4).cast::<i32>() = (allow_insecure45).take_handle() as i32;
                    *ptr44.add(8).cast::<i32>() = (check_regions45).take_handle() as i32;
                    *ptr44.add(12).cast::<i32>() = (consecutive_fails45).take_handle() as i32;
                    *ptr44.add(16).cast::<i32>() = (consecutive_successes45).take_handle() as i32;
                    *ptr44.add(20).cast::<i32>() = (created_on45).take_handle() as i32;
                    *ptr44.add(24).cast::<i32>() = (description45).take_handle() as i32;
                    *ptr44.add(28).cast::<i32>() = (expected_body45).take_handle() as i32;
                    *ptr44.add(32).cast::<i32>() = (expected_codes45).take_handle() as i32;
                    *ptr44.add(36).cast::<i32>() = (follow_redirects45).take_handle() as i32;
                    *ptr44.add(40).cast::<i32>() = (headers45).take_handle() as i32;
                    *ptr44.add(44).cast::<i32>() = (interval45).take_handle() as i32;
                    *ptr44.add(48).cast::<i32>() = (method45).take_handle() as i32;
                    *ptr44.add(52).cast::<i32>() = (modified_on45).take_handle() as i32;
                    *ptr44.add(56).cast::<i32>() = (name45).take_handle() as i32;
                    *ptr44.add(60).cast::<i32>() = (path45).take_handle() as i32;
                    *ptr44.add(64).cast::<i32>() = (port45).take_handle() as i32;
                    *ptr44.add(68).cast::<i32>() = (retries45).take_handle() as i32;
                    *ptr44.add(72).cast::<i32>() = (suspended45).take_handle() as i32;
                    *ptr44.add(76).cast::<i32>() = (timeout45).take_handle() as i32;
                    *ptr44.add(80).cast::<i32>() = (type_45).take_handle() as i32;
                    *ptr44.add(84).cast::<i32>() = (zone_id45).take_handle() as i32;
                    ptr44
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_healthcheck_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/healthcheck@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_healthcheck_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 88]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 88]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod hostname_tls_setting {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub hostname: &'a Output,
                    pub setting: &'a Output,
                    pub value: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("hostname", &self.hostname)
                            .field("setting", &self.setting)
                            .field("value", &self.value)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub created_at: Output,
                    pub hostname: Output,
                    pub setting: Output,
                    pub updated_at: Output,
                    pub value: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("created-at", &self.created_at)
                            .field("hostname", &self.hostname)
                            .field("setting", &self.setting)
                            .field("updated-at", &self.updated_at)
                            .field("value", &self.value)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result5 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            hostname: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            setting: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            value: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            zone_id: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                        },
                    );
                    let ptr6 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        created_at: created_at7,
                        hostname: hostname7,
                        setting: setting7,
                        updated_at: updated_at7,
                        value: value7,
                        zone_id: zone_id7,
                    } = result5;
                    *ptr6.add(0).cast::<i32>() = (created_at7).take_handle() as i32;
                    *ptr6.add(4).cast::<i32>() = (hostname7).take_handle() as i32;
                    *ptr6.add(8).cast::<i32>() = (setting7).take_handle() as i32;
                    *ptr6.add(12).cast::<i32>() = (updated_at7).take_handle() as i32;
                    *ptr6.add(16).cast::<i32>() = (value7).take_handle() as i32;
                    *ptr6.add(20).cast::<i32>() = (zone_id7).take_handle() as i32;
                    ptr6
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_hostname_tls_setting_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/hostname-tls-setting@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_hostname_tls_setting_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 24]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 24]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod hostname_tls_setting_ciphers {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub hostname: &'a Output,
                    pub ports: &'a Output,
                    pub values: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("hostname", &self.hostname)
                            .field("ports", &self.ports)
                            .field("values", &self.values)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub created_at: Output,
                    pub hostname: Output,
                    pub ports: Output,
                    pub updated_at: Output,
                    pub values: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("created-at", &self.created_at)
                            .field("hostname", &self.hostname)
                            .field("ports", &self.ports)
                            .field("updated-at", &self.updated_at)
                            .field("values", &self.values)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result5 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            hostname: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            ports: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            values: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            zone_id: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                        },
                    );
                    let ptr6 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        created_at: created_at7,
                        hostname: hostname7,
                        ports: ports7,
                        updated_at: updated_at7,
                        values: values7,
                        zone_id: zone_id7,
                    } = result5;
                    *ptr6.add(0).cast::<i32>() = (created_at7).take_handle() as i32;
                    *ptr6.add(4).cast::<i32>() = (hostname7).take_handle() as i32;
                    *ptr6.add(8).cast::<i32>() = (ports7).take_handle() as i32;
                    *ptr6.add(12).cast::<i32>() = (updated_at7).take_handle() as i32;
                    *ptr6.add(16).cast::<i32>() = (values7).take_handle() as i32;
                    *ptr6.add(20).cast::<i32>() = (zone_id7).take_handle() as i32;
                    ptr6
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_hostname_tls_setting_ciphers_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/hostname-tls-setting-ciphers@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_hostname_tls_setting_ciphers_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 24]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 24]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod hyperdrive_config {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub caching: &'a Output,
                    pub name: &'a Output,
                    pub origin: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("caching", &self.caching)
                            .field("name", &self.name)
                            .field("origin", &self.origin)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub caching: Output,
                    pub name: Output,
                    pub origin: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("caching", &self.caching)
                            .field("name", &self.name)
                            .field("origin", &self.origin)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result5 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            caching: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            name: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            origin: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                        },
                    );
                    let ptr6 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id7,
                        caching: caching7,
                        name: name7,
                        origin: origin7,
                    } = result5;
                    *ptr6.add(0).cast::<i32>() = (account_id7).take_handle() as i32;
                    *ptr6.add(4).cast::<i32>() = (caching7).take_handle() as i32;
                    *ptr6.add(8).cast::<i32>() = (name7).take_handle() as i32;
                    *ptr6.add(12).cast::<i32>() = (origin7).take_handle() as i32;
                    ptr6
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_hyperdrive_config_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/hyperdrive-config@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_hyperdrive_config_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod ipsec_tunnel {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub allow_null_cipher: &'a Output,
                    pub cloudflare_endpoint: &'a Output,
                    pub customer_endpoint: &'a Output,
                    pub description: &'a Output,
                    pub fqdn_id: &'a Output,
                    pub health_check_direction: &'a Output,
                    pub health_check_enabled: &'a Output,
                    pub health_check_rate: &'a Output,
                    pub health_check_target: &'a Output,
                    pub health_check_type: &'a Output,
                    pub hex_id: &'a Output,
                    pub interface_address: &'a Output,
                    pub name: &'a Output,
                    pub psk: &'a Output,
                    pub remote_id: &'a Output,
                    pub user_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("allow-null-cipher", &self.allow_null_cipher)
                            .field("cloudflare-endpoint", &self.cloudflare_endpoint)
                            .field("customer-endpoint", &self.customer_endpoint)
                            .field("description", &self.description)
                            .field("fqdn-id", &self.fqdn_id)
                            .field("health-check-direction", &self.health_check_direction)
                            .field("health-check-enabled", &self.health_check_enabled)
                            .field("health-check-rate", &self.health_check_rate)
                            .field("health-check-target", &self.health_check_target)
                            .field("health-check-type", &self.health_check_type)
                            .field("hex-id", &self.hex_id)
                            .field("interface-address", &self.interface_address)
                            .field("name", &self.name)
                            .field("psk", &self.psk)
                            .field("remote-id", &self.remote_id)
                            .field("user-id", &self.user_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub allow_null_cipher: Output,
                    pub cloudflare_endpoint: Output,
                    pub customer_endpoint: Output,
                    pub description: Output,
                    pub fqdn_id: Output,
                    pub health_check_direction: Output,
                    pub health_check_enabled: Output,
                    pub health_check_rate: Output,
                    pub health_check_target: Output,
                    pub health_check_type: Output,
                    pub hex_id: Output,
                    pub interface_address: Output,
                    pub name: Output,
                    pub psk: Output,
                    pub remote_id: Output,
                    pub user_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("allow-null-cipher", &self.allow_null_cipher)
                            .field("cloudflare-endpoint", &self.cloudflare_endpoint)
                            .field("customer-endpoint", &self.customer_endpoint)
                            .field("description", &self.description)
                            .field("fqdn-id", &self.fqdn_id)
                            .field("health-check-direction", &self.health_check_direction)
                            .field("health-check-enabled", &self.health_check_enabled)
                            .field("health-check-rate", &self.health_check_rate)
                            .field("health-check-target", &self.health_check_target)
                            .field("health-check-type", &self.health_check_type)
                            .field("hex-id", &self.hex_id)
                            .field("interface-address", &self.interface_address)
                            .field("name", &self.name)
                            .field("psk", &self.psk)
                            .field("remote-id", &self.remote_id)
                            .field("user-id", &self.user_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle4;
                    let handle6;
                    let handle8;
                    let handle10;
                    let handle12;
                    let handle14;
                    let handle16;
                    let handle18;
                    let handle20;
                    let handle22;
                    let handle24;
                    let handle26;
                    let handle28;
                    let handle30;
                    let handle32;
                    let handle34;
                    let handle36;
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let len2 = l1;
                    let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                    let l3 = *arg0.add(8).cast::<i32>();
                    let l5 = *arg0.add(12).cast::<i32>();
                    let l7 = *arg0.add(16).cast::<i32>();
                    let l9 = *arg0.add(20).cast::<i32>();
                    let l11 = *arg0.add(24).cast::<i32>();
                    let l13 = *arg0.add(28).cast::<i32>();
                    let l15 = *arg0.add(32).cast::<i32>();
                    let l17 = *arg0.add(36).cast::<i32>();
                    let l19 = *arg0.add(40).cast::<i32>();
                    let l21 = *arg0.add(44).cast::<i32>();
                    let l23 = *arg0.add(48).cast::<i32>();
                    let l25 = *arg0.add(52).cast::<i32>();
                    let l27 = *arg0.add(56).cast::<i32>();
                    let l29 = *arg0.add(60).cast::<i32>();
                    let l31 = *arg0.add(64).cast::<i32>();
                    let l33 = *arg0.add(68).cast::<i32>();
                    let l35 = *arg0.add(72).cast::<i32>();
                    let result37 = T::invoke(
                        _rt::string_lift(bytes2),
                        Args {
                            account_id: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l3 as u32);
                                &handle4
                            },
                            allow_null_cipher: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l5 as u32);
                                &handle6
                            },
                            cloudflare_endpoint: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l7 as u32);
                                &handle8
                            },
                            customer_endpoint: {
                                handle10 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l9 as u32);
                                &handle10
                            },
                            description: {
                                handle12 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l11 as u32);
                                &handle12
                            },
                            fqdn_id: {
                                handle14 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l13 as u32);
                                &handle14
                            },
                            health_check_direction: {
                                handle16 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l15 as u32);
                                &handle16
                            },
                            health_check_enabled: {
                                handle18 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l17 as u32);
                                &handle18
                            },
                            health_check_rate: {
                                handle20 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l19 as u32);
                                &handle20
                            },
                            health_check_target: {
                                handle22 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l21 as u32);
                                &handle22
                            },
                            health_check_type: {
                                handle24 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l23 as u32);
                                &handle24
                            },
                            hex_id: {
                                handle26 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l25 as u32);
                                &handle26
                            },
                            interface_address: {
                                handle28 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l27 as u32);
                                &handle28
                            },
                            name: {
                                handle30 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l29 as u32);
                                &handle30
                            },
                            psk: {
                                handle32 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l31 as u32);
                                &handle32
                            },
                            remote_id: {
                                handle34 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l33 as u32);
                                &handle34
                            },
                            user_id: {
                                handle36 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l35 as u32);
                                &handle36
                            },
                        },
                    );
                    _rt::cabi_dealloc(arg0, 76, 4);
                    let ptr38 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id39,
                        allow_null_cipher: allow_null_cipher39,
                        cloudflare_endpoint: cloudflare_endpoint39,
                        customer_endpoint: customer_endpoint39,
                        description: description39,
                        fqdn_id: fqdn_id39,
                        health_check_direction: health_check_direction39,
                        health_check_enabled: health_check_enabled39,
                        health_check_rate: health_check_rate39,
                        health_check_target: health_check_target39,
                        health_check_type: health_check_type39,
                        hex_id: hex_id39,
                        interface_address: interface_address39,
                        name: name39,
                        psk: psk39,
                        remote_id: remote_id39,
                        user_id: user_id39,
                    } = result37;
                    *ptr38.add(0).cast::<i32>() = (account_id39).take_handle() as i32;
                    *ptr38.add(4).cast::<i32>() = (allow_null_cipher39).take_handle() as i32;
                    *ptr38.add(8).cast::<i32>() = (cloudflare_endpoint39).take_handle() as i32;
                    *ptr38.add(12).cast::<i32>() = (customer_endpoint39).take_handle() as i32;
                    *ptr38.add(16).cast::<i32>() = (description39).take_handle() as i32;
                    *ptr38.add(20).cast::<i32>() = (fqdn_id39).take_handle() as i32;
                    *ptr38.add(24).cast::<i32>() = (health_check_direction39).take_handle() as i32;
                    *ptr38.add(28).cast::<i32>() = (health_check_enabled39).take_handle() as i32;
                    *ptr38.add(32).cast::<i32>() = (health_check_rate39).take_handle() as i32;
                    *ptr38.add(36).cast::<i32>() = (health_check_target39).take_handle() as i32;
                    *ptr38.add(40).cast::<i32>() = (health_check_type39).take_handle() as i32;
                    *ptr38.add(44).cast::<i32>() = (hex_id39).take_handle() as i32;
                    *ptr38.add(48).cast::<i32>() = (interface_address39).take_handle() as i32;
                    *ptr38.add(52).cast::<i32>() = (name39).take_handle() as i32;
                    *ptr38.add(56).cast::<i32>() = (psk39).take_handle() as i32;
                    *ptr38.add(60).cast::<i32>() = (remote_id39).take_handle() as i32;
                    *ptr38.add(64).cast::<i32>() = (user_id39).take_handle() as i32;
                    ptr38
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_ipsec_tunnel_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/ipsec-tunnel@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_ipsec_tunnel_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 68]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 68]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod keyless_certificate {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub bundle_method: &'a Output,
                    pub certificate: &'a Output,
                    pub enabled: &'a Output,
                    pub host: &'a Output,
                    pub name: &'a Output,
                    pub port: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("bundle-method", &self.bundle_method)
                            .field("certificate", &self.certificate)
                            .field("enabled", &self.enabled)
                            .field("host", &self.host)
                            .field("name", &self.name)
                            .field("port", &self.port)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub bundle_method: Output,
                    pub certificate: Output,
                    pub enabled: Output,
                    pub host: Output,
                    pub name: Output,
                    pub port: Output,
                    pub status: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("bundle-method", &self.bundle_method)
                            .field("certificate", &self.certificate)
                            .field("enabled", &self.enabled)
                            .field("host", &self.host)
                            .field("name", &self.name)
                            .field("port", &self.port)
                            .field("status", &self.status)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let handle7;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result8 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            bundle_method: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            certificate: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            enabled: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            host: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            name: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            port: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                            zone_id: {
                                handle7 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg8 as u32);
                                &handle7
                            },
                        },
                    );
                    let ptr9 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        bundle_method: bundle_method10,
                        certificate: certificate10,
                        enabled: enabled10,
                        host: host10,
                        name: name10,
                        port: port10,
                        status: status10,
                        zone_id: zone_id10,
                    } = result8;
                    *ptr9.add(0).cast::<i32>() = (bundle_method10).take_handle() as i32;
                    *ptr9.add(4).cast::<i32>() = (certificate10).take_handle() as i32;
                    *ptr9.add(8).cast::<i32>() = (enabled10).take_handle() as i32;
                    *ptr9.add(12).cast::<i32>() = (host10).take_handle() as i32;
                    *ptr9.add(16).cast::<i32>() = (name10).take_handle() as i32;
                    *ptr9.add(20).cast::<i32>() = (port10).take_handle() as i32;
                    *ptr9.add(24).cast::<i32>() = (status10).take_handle() as i32;
                    *ptr9.add(28).cast::<i32>() = (zone_id10).take_handle() as i32;
                    ptr9
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_keyless_certificate_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/keyless-certificate@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_keyless_certificate_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 32]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 32]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod list {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub description: &'a Output,
                    pub items: &'a Output,
                    pub kind: &'a Output,
                    pub name: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("description", &self.description)
                            .field("items", &self.items)
                            .field("kind", &self.kind)
                            .field("name", &self.name)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub description: Output,
                    pub items: Output,
                    pub kind: Output,
                    pub name: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("description", &self.description)
                            .field("items", &self.items)
                            .field("kind", &self.kind)
                            .field("name", &self.name)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result6 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            description: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            items: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            kind: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            name: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                        },
                    );
                    let ptr7 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id8,
                        description: description8,
                        items: items8,
                        kind: kind8,
                        name: name8,
                    } = result6;
                    *ptr7.add(0).cast::<i32>() = (account_id8).take_handle() as i32;
                    *ptr7.add(4).cast::<i32>() = (description8).take_handle() as i32;
                    *ptr7.add(8).cast::<i32>() = (items8).take_handle() as i32;
                    *ptr7.add(12).cast::<i32>() = (kind8).take_handle() as i32;
                    *ptr7.add(16).cast::<i32>() = (name8).take_handle() as i32;
                    ptr7
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_list_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/list@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_list_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 20]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 20]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod list_item {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub asn: &'a Output,
                    pub comment: &'a Output,
                    pub hostname: &'a Output,
                    pub ip: &'a Output,
                    pub list_id: &'a Output,
                    pub redirect: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("asn", &self.asn)
                            .field("comment", &self.comment)
                            .field("hostname", &self.hostname)
                            .field("ip", &self.ip)
                            .field("list-id", &self.list_id)
                            .field("redirect", &self.redirect)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub asn: Output,
                    pub comment: Output,
                    pub hostname: Output,
                    pub ip: Output,
                    pub list_id: Output,
                    pub redirect: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("asn", &self.asn)
                            .field("comment", &self.comment)
                            .field("hostname", &self.hostname)
                            .field("ip", &self.ip)
                            .field("list-id", &self.list_id)
                            .field("redirect", &self.redirect)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let handle7;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result8 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            asn: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            comment: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            hostname: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            ip: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            list_id: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                            redirect: {
                                handle7 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg8 as u32);
                                &handle7
                            },
                        },
                    );
                    let ptr9 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id10,
                        asn: asn10,
                        comment: comment10,
                        hostname: hostname10,
                        ip: ip10,
                        list_id: list_id10,
                        redirect: redirect10,
                    } = result8;
                    *ptr9.add(0).cast::<i32>() = (account_id10).take_handle() as i32;
                    *ptr9.add(4).cast::<i32>() = (asn10).take_handle() as i32;
                    *ptr9.add(8).cast::<i32>() = (comment10).take_handle() as i32;
                    *ptr9.add(12).cast::<i32>() = (hostname10).take_handle() as i32;
                    *ptr9.add(16).cast::<i32>() = (ip10).take_handle() as i32;
                    *ptr9.add(20).cast::<i32>() = (list_id10).take_handle() as i32;
                    *ptr9.add(24).cast::<i32>() = (redirect10).take_handle() as i32;
                    ptr9
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_list_item_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/list-item@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_list_item_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 28]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 28]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod load_balancer {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub adaptive_routings: &'a Output,
                    pub country_pools: &'a Output,
                    pub default_pool_ids: &'a Output,
                    pub description: &'a Output,
                    pub enabled: &'a Output,
                    pub fallback_pool_id: &'a Output,
                    pub location_strategies: &'a Output,
                    pub name: &'a Output,
                    pub pop_pools: &'a Output,
                    pub proxied: &'a Output,
                    pub random_steerings: &'a Output,
                    pub region_pools: &'a Output,
                    pub rules: &'a Output,
                    pub session_affinity: &'a Output,
                    pub session_affinity_attributes: &'a Output,
                    pub session_affinity_ttl: &'a Output,
                    pub steering_policy: &'a Output,
                    pub ttl: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("adaptive-routings", &self.adaptive_routings)
                            .field("country-pools", &self.country_pools)
                            .field("default-pool-ids", &self.default_pool_ids)
                            .field("description", &self.description)
                            .field("enabled", &self.enabled)
                            .field("fallback-pool-id", &self.fallback_pool_id)
                            .field("location-strategies", &self.location_strategies)
                            .field("name", &self.name)
                            .field("pop-pools", &self.pop_pools)
                            .field("proxied", &self.proxied)
                            .field("random-steerings", &self.random_steerings)
                            .field("region-pools", &self.region_pools)
                            .field("rules", &self.rules)
                            .field("session-affinity", &self.session_affinity)
                            .field(
                                "session-affinity-attributes",
                                &self.session_affinity_attributes,
                            )
                            .field("session-affinity-ttl", &self.session_affinity_ttl)
                            .field("steering-policy", &self.steering_policy)
                            .field("ttl", &self.ttl)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub adaptive_routings: Output,
                    pub country_pools: Output,
                    pub created_on: Output,
                    pub default_pool_ids: Output,
                    pub description: Output,
                    pub enabled: Output,
                    pub fallback_pool_id: Output,
                    pub location_strategies: Output,
                    pub modified_on: Output,
                    pub name: Output,
                    pub pop_pools: Output,
                    pub proxied: Output,
                    pub random_steerings: Output,
                    pub region_pools: Output,
                    pub rules: Output,
                    pub session_affinity: Output,
                    pub session_affinity_attributes: Output,
                    pub session_affinity_ttl: Output,
                    pub steering_policy: Output,
                    pub ttl: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("adaptive-routings", &self.adaptive_routings)
                            .field("country-pools", &self.country_pools)
                            .field("created-on", &self.created_on)
                            .field("default-pool-ids", &self.default_pool_ids)
                            .field("description", &self.description)
                            .field("enabled", &self.enabled)
                            .field("fallback-pool-id", &self.fallback_pool_id)
                            .field("location-strategies", &self.location_strategies)
                            .field("modified-on", &self.modified_on)
                            .field("name", &self.name)
                            .field("pop-pools", &self.pop_pools)
                            .field("proxied", &self.proxied)
                            .field("random-steerings", &self.random_steerings)
                            .field("region-pools", &self.region_pools)
                            .field("rules", &self.rules)
                            .field("session-affinity", &self.session_affinity)
                            .field(
                                "session-affinity-attributes",
                                &self.session_affinity_attributes,
                            )
                            .field("session-affinity-ttl", &self.session_affinity_ttl)
                            .field("steering-policy", &self.steering_policy)
                            .field("ttl", &self.ttl)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle4;
                    let handle6;
                    let handle8;
                    let handle10;
                    let handle12;
                    let handle14;
                    let handle16;
                    let handle18;
                    let handle20;
                    let handle22;
                    let handle24;
                    let handle26;
                    let handle28;
                    let handle30;
                    let handle32;
                    let handle34;
                    let handle36;
                    let handle38;
                    let handle40;
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let len2 = l1;
                    let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                    let l3 = *arg0.add(8).cast::<i32>();
                    let l5 = *arg0.add(12).cast::<i32>();
                    let l7 = *arg0.add(16).cast::<i32>();
                    let l9 = *arg0.add(20).cast::<i32>();
                    let l11 = *arg0.add(24).cast::<i32>();
                    let l13 = *arg0.add(28).cast::<i32>();
                    let l15 = *arg0.add(32).cast::<i32>();
                    let l17 = *arg0.add(36).cast::<i32>();
                    let l19 = *arg0.add(40).cast::<i32>();
                    let l21 = *arg0.add(44).cast::<i32>();
                    let l23 = *arg0.add(48).cast::<i32>();
                    let l25 = *arg0.add(52).cast::<i32>();
                    let l27 = *arg0.add(56).cast::<i32>();
                    let l29 = *arg0.add(60).cast::<i32>();
                    let l31 = *arg0.add(64).cast::<i32>();
                    let l33 = *arg0.add(68).cast::<i32>();
                    let l35 = *arg0.add(72).cast::<i32>();
                    let l37 = *arg0.add(76).cast::<i32>();
                    let l39 = *arg0.add(80).cast::<i32>();
                    let result41 = T::invoke(
                        _rt::string_lift(bytes2),
                        Args {
                            adaptive_routings: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l3 as u32);
                                &handle4
                            },
                            country_pools: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l5 as u32);
                                &handle6
                            },
                            default_pool_ids: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l7 as u32);
                                &handle8
                            },
                            description: {
                                handle10 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l9 as u32);
                                &handle10
                            },
                            enabled: {
                                handle12 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l11 as u32);
                                &handle12
                            },
                            fallback_pool_id: {
                                handle14 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l13 as u32);
                                &handle14
                            },
                            location_strategies: {
                                handle16 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l15 as u32);
                                &handle16
                            },
                            name: {
                                handle18 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l17 as u32);
                                &handle18
                            },
                            pop_pools: {
                                handle20 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l19 as u32);
                                &handle20
                            },
                            proxied: {
                                handle22 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l21 as u32);
                                &handle22
                            },
                            random_steerings: {
                                handle24 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l23 as u32);
                                &handle24
                            },
                            region_pools: {
                                handle26 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l25 as u32);
                                &handle26
                            },
                            rules: {
                                handle28 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l27 as u32);
                                &handle28
                            },
                            session_affinity: {
                                handle30 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l29 as u32);
                                &handle30
                            },
                            session_affinity_attributes: {
                                handle32 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l31 as u32);
                                &handle32
                            },
                            session_affinity_ttl: {
                                handle34 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l33 as u32);
                                &handle34
                            },
                            steering_policy: {
                                handle36 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l35 as u32);
                                &handle36
                            },
                            ttl: {
                                handle38 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l37 as u32);
                                &handle38
                            },
                            zone_id: {
                                handle40 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l39 as u32);
                                &handle40
                            },
                        },
                    );
                    _rt::cabi_dealloc(arg0, 84, 4);
                    let ptr42 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        adaptive_routings: adaptive_routings43,
                        country_pools: country_pools43,
                        created_on: created_on43,
                        default_pool_ids: default_pool_ids43,
                        description: description43,
                        enabled: enabled43,
                        fallback_pool_id: fallback_pool_id43,
                        location_strategies: location_strategies43,
                        modified_on: modified_on43,
                        name: name43,
                        pop_pools: pop_pools43,
                        proxied: proxied43,
                        random_steerings: random_steerings43,
                        region_pools: region_pools43,
                        rules: rules43,
                        session_affinity: session_affinity43,
                        session_affinity_attributes: session_affinity_attributes43,
                        session_affinity_ttl: session_affinity_ttl43,
                        steering_policy: steering_policy43,
                        ttl: ttl43,
                        zone_id: zone_id43,
                    } = result41;
                    *ptr42.add(0).cast::<i32>() = (adaptive_routings43).take_handle() as i32;
                    *ptr42.add(4).cast::<i32>() = (country_pools43).take_handle() as i32;
                    *ptr42.add(8).cast::<i32>() = (created_on43).take_handle() as i32;
                    *ptr42.add(12).cast::<i32>() = (default_pool_ids43).take_handle() as i32;
                    *ptr42.add(16).cast::<i32>() = (description43).take_handle() as i32;
                    *ptr42.add(20).cast::<i32>() = (enabled43).take_handle() as i32;
                    *ptr42.add(24).cast::<i32>() = (fallback_pool_id43).take_handle() as i32;
                    *ptr42.add(28).cast::<i32>() = (location_strategies43).take_handle() as i32;
                    *ptr42.add(32).cast::<i32>() = (modified_on43).take_handle() as i32;
                    *ptr42.add(36).cast::<i32>() = (name43).take_handle() as i32;
                    *ptr42.add(40).cast::<i32>() = (pop_pools43).take_handle() as i32;
                    *ptr42.add(44).cast::<i32>() = (proxied43).take_handle() as i32;
                    *ptr42.add(48).cast::<i32>() = (random_steerings43).take_handle() as i32;
                    *ptr42.add(52).cast::<i32>() = (region_pools43).take_handle() as i32;
                    *ptr42.add(56).cast::<i32>() = (rules43).take_handle() as i32;
                    *ptr42.add(60).cast::<i32>() = (session_affinity43).take_handle() as i32;
                    *ptr42.add(64).cast::<i32>() =
                        (session_affinity_attributes43).take_handle() as i32;
                    *ptr42.add(68).cast::<i32>() = (session_affinity_ttl43).take_handle() as i32;
                    *ptr42.add(72).cast::<i32>() = (steering_policy43).take_handle() as i32;
                    *ptr42.add(76).cast::<i32>() = (ttl43).take_handle() as i32;
                    *ptr42.add(80).cast::<i32>() = (zone_id43).take_handle() as i32;
                    ptr42
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_load_balancer_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/load-balancer@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_load_balancer_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 84]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 84]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod load_balancer_monitor {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub allow_insecure: &'a Output,
                    pub consecutive_down: &'a Output,
                    pub consecutive_up: &'a Output,
                    pub description: &'a Output,
                    pub expected_body: &'a Output,
                    pub expected_codes: &'a Output,
                    pub follow_redirects: &'a Output,
                    pub headers: &'a Output,
                    pub interval: &'a Output,
                    pub method: &'a Output,
                    pub path: &'a Output,
                    pub port: &'a Output,
                    pub probe_zone: &'a Output,
                    pub retries: &'a Output,
                    pub timeout: &'a Output,
                    pub type_: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("allow-insecure", &self.allow_insecure)
                            .field("consecutive-down", &self.consecutive_down)
                            .field("consecutive-up", &self.consecutive_up)
                            .field("description", &self.description)
                            .field("expected-body", &self.expected_body)
                            .field("expected-codes", &self.expected_codes)
                            .field("follow-redirects", &self.follow_redirects)
                            .field("headers", &self.headers)
                            .field("interval", &self.interval)
                            .field("method", &self.method)
                            .field("path", &self.path)
                            .field("port", &self.port)
                            .field("probe-zone", &self.probe_zone)
                            .field("retries", &self.retries)
                            .field("timeout", &self.timeout)
                            .field("type", &self.type_)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub allow_insecure: Output,
                    pub consecutive_down: Output,
                    pub consecutive_up: Output,
                    pub created_on: Output,
                    pub description: Output,
                    pub expected_body: Output,
                    pub expected_codes: Output,
                    pub follow_redirects: Output,
                    pub headers: Output,
                    pub interval: Output,
                    pub method: Output,
                    pub modified_on: Output,
                    pub path: Output,
                    pub port: Output,
                    pub probe_zone: Output,
                    pub retries: Output,
                    pub timeout: Output,
                    pub type_: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("allow-insecure", &self.allow_insecure)
                            .field("consecutive-down", &self.consecutive_down)
                            .field("consecutive-up", &self.consecutive_up)
                            .field("created-on", &self.created_on)
                            .field("description", &self.description)
                            .field("expected-body", &self.expected_body)
                            .field("expected-codes", &self.expected_codes)
                            .field("follow-redirects", &self.follow_redirects)
                            .field("headers", &self.headers)
                            .field("interval", &self.interval)
                            .field("method", &self.method)
                            .field("modified-on", &self.modified_on)
                            .field("path", &self.path)
                            .field("port", &self.port)
                            .field("probe-zone", &self.probe_zone)
                            .field("retries", &self.retries)
                            .field("timeout", &self.timeout)
                            .field("type", &self.type_)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle4;
                    let handle6;
                    let handle8;
                    let handle10;
                    let handle12;
                    let handle14;
                    let handle16;
                    let handle18;
                    let handle20;
                    let handle22;
                    let handle24;
                    let handle26;
                    let handle28;
                    let handle30;
                    let handle32;
                    let handle34;
                    let handle36;
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let len2 = l1;
                    let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                    let l3 = *arg0.add(8).cast::<i32>();
                    let l5 = *arg0.add(12).cast::<i32>();
                    let l7 = *arg0.add(16).cast::<i32>();
                    let l9 = *arg0.add(20).cast::<i32>();
                    let l11 = *arg0.add(24).cast::<i32>();
                    let l13 = *arg0.add(28).cast::<i32>();
                    let l15 = *arg0.add(32).cast::<i32>();
                    let l17 = *arg0.add(36).cast::<i32>();
                    let l19 = *arg0.add(40).cast::<i32>();
                    let l21 = *arg0.add(44).cast::<i32>();
                    let l23 = *arg0.add(48).cast::<i32>();
                    let l25 = *arg0.add(52).cast::<i32>();
                    let l27 = *arg0.add(56).cast::<i32>();
                    let l29 = *arg0.add(60).cast::<i32>();
                    let l31 = *arg0.add(64).cast::<i32>();
                    let l33 = *arg0.add(68).cast::<i32>();
                    let l35 = *arg0.add(72).cast::<i32>();
                    let result37 = T::invoke(
                        _rt::string_lift(bytes2),
                        Args {
                            account_id: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l3 as u32);
                                &handle4
                            },
                            allow_insecure: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l5 as u32);
                                &handle6
                            },
                            consecutive_down: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l7 as u32);
                                &handle8
                            },
                            consecutive_up: {
                                handle10 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l9 as u32);
                                &handle10
                            },
                            description: {
                                handle12 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l11 as u32);
                                &handle12
                            },
                            expected_body: {
                                handle14 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l13 as u32);
                                &handle14
                            },
                            expected_codes: {
                                handle16 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l15 as u32);
                                &handle16
                            },
                            follow_redirects: {
                                handle18 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l17 as u32);
                                &handle18
                            },
                            headers: {
                                handle20 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l19 as u32);
                                &handle20
                            },
                            interval: {
                                handle22 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l21 as u32);
                                &handle22
                            },
                            method: {
                                handle24 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l23 as u32);
                                &handle24
                            },
                            path: {
                                handle26 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l25 as u32);
                                &handle26
                            },
                            port: {
                                handle28 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l27 as u32);
                                &handle28
                            },
                            probe_zone: {
                                handle30 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l29 as u32);
                                &handle30
                            },
                            retries: {
                                handle32 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l31 as u32);
                                &handle32
                            },
                            timeout: {
                                handle34 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l33 as u32);
                                &handle34
                            },
                            type_: {
                                handle36 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l35 as u32);
                                &handle36
                            },
                        },
                    );
                    _rt::cabi_dealloc(arg0, 76, 4);
                    let ptr38 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id39,
                        allow_insecure: allow_insecure39,
                        consecutive_down: consecutive_down39,
                        consecutive_up: consecutive_up39,
                        created_on: created_on39,
                        description: description39,
                        expected_body: expected_body39,
                        expected_codes: expected_codes39,
                        follow_redirects: follow_redirects39,
                        headers: headers39,
                        interval: interval39,
                        method: method39,
                        modified_on: modified_on39,
                        path: path39,
                        port: port39,
                        probe_zone: probe_zone39,
                        retries: retries39,
                        timeout: timeout39,
                        type_: type_39,
                    } = result37;
                    *ptr38.add(0).cast::<i32>() = (account_id39).take_handle() as i32;
                    *ptr38.add(4).cast::<i32>() = (allow_insecure39).take_handle() as i32;
                    *ptr38.add(8).cast::<i32>() = (consecutive_down39).take_handle() as i32;
                    *ptr38.add(12).cast::<i32>() = (consecutive_up39).take_handle() as i32;
                    *ptr38.add(16).cast::<i32>() = (created_on39).take_handle() as i32;
                    *ptr38.add(20).cast::<i32>() = (description39).take_handle() as i32;
                    *ptr38.add(24).cast::<i32>() = (expected_body39).take_handle() as i32;
                    *ptr38.add(28).cast::<i32>() = (expected_codes39).take_handle() as i32;
                    *ptr38.add(32).cast::<i32>() = (follow_redirects39).take_handle() as i32;
                    *ptr38.add(36).cast::<i32>() = (headers39).take_handle() as i32;
                    *ptr38.add(40).cast::<i32>() = (interval39).take_handle() as i32;
                    *ptr38.add(44).cast::<i32>() = (method39).take_handle() as i32;
                    *ptr38.add(48).cast::<i32>() = (modified_on39).take_handle() as i32;
                    *ptr38.add(52).cast::<i32>() = (path39).take_handle() as i32;
                    *ptr38.add(56).cast::<i32>() = (port39).take_handle() as i32;
                    *ptr38.add(60).cast::<i32>() = (probe_zone39).take_handle() as i32;
                    *ptr38.add(64).cast::<i32>() = (retries39).take_handle() as i32;
                    *ptr38.add(68).cast::<i32>() = (timeout39).take_handle() as i32;
                    *ptr38.add(72).cast::<i32>() = (type_39).take_handle() as i32;
                    ptr38
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_load_balancer_monitor_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/load-balancer-monitor@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_load_balancer_monitor_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 76]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 76]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod load_balancer_pool {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub check_regions: &'a Output,
                    pub description: &'a Output,
                    pub enabled: &'a Output,
                    pub latitude: &'a Output,
                    pub load_sheddings: &'a Output,
                    pub longitude: &'a Output,
                    pub minimum_origins: &'a Output,
                    pub monitor: &'a Output,
                    pub name: &'a Output,
                    pub notification_email: &'a Output,
                    pub origin_steerings: &'a Output,
                    pub origins: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("check-regions", &self.check_regions)
                            .field("description", &self.description)
                            .field("enabled", &self.enabled)
                            .field("latitude", &self.latitude)
                            .field("load-sheddings", &self.load_sheddings)
                            .field("longitude", &self.longitude)
                            .field("minimum-origins", &self.minimum_origins)
                            .field("monitor", &self.monitor)
                            .field("name", &self.name)
                            .field("notification-email", &self.notification_email)
                            .field("origin-steerings", &self.origin_steerings)
                            .field("origins", &self.origins)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub check_regions: Output,
                    pub created_on: Output,
                    pub description: Output,
                    pub enabled: Output,
                    pub latitude: Output,
                    pub load_sheddings: Output,
                    pub longitude: Output,
                    pub minimum_origins: Output,
                    pub modified_on: Output,
                    pub monitor: Output,
                    pub name: Output,
                    pub notification_email: Output,
                    pub origin_steerings: Output,
                    pub origins: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("check-regions", &self.check_regions)
                            .field("created-on", &self.created_on)
                            .field("description", &self.description)
                            .field("enabled", &self.enabled)
                            .field("latitude", &self.latitude)
                            .field("load-sheddings", &self.load_sheddings)
                            .field("longitude", &self.longitude)
                            .field("minimum-origins", &self.minimum_origins)
                            .field("modified-on", &self.modified_on)
                            .field("monitor", &self.monitor)
                            .field("name", &self.name)
                            .field("notification-email", &self.notification_email)
                            .field("origin-steerings", &self.origin_steerings)
                            .field("origins", &self.origins)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                    arg11: i32,
                    arg12: i32,
                    arg13: i32,
                    arg14: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let handle7;
                    let handle8;
                    let handle9;
                    let handle10;
                    let handle11;
                    let handle12;
                    let handle13;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result14 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            check_regions: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            description: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            enabled: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            latitude: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            load_sheddings: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                            longitude: {
                                handle7 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg8 as u32);
                                &handle7
                            },
                            minimum_origins: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg9 as u32);
                                &handle8
                            },
                            monitor: {
                                handle9 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg10 as u32);
                                &handle9
                            },
                            name: {
                                handle10 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg11 as u32);
                                &handle10
                            },
                            notification_email: {
                                handle11 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg12 as u32);
                                &handle11
                            },
                            origin_steerings: {
                                handle12 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg13 as u32);
                                &handle12
                            },
                            origins: {
                                handle13 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg14 as u32);
                                &handle13
                            },
                        },
                    );
                    let ptr15 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id16,
                        check_regions: check_regions16,
                        created_on: created_on16,
                        description: description16,
                        enabled: enabled16,
                        latitude: latitude16,
                        load_sheddings: load_sheddings16,
                        longitude: longitude16,
                        minimum_origins: minimum_origins16,
                        modified_on: modified_on16,
                        monitor: monitor16,
                        name: name16,
                        notification_email: notification_email16,
                        origin_steerings: origin_steerings16,
                        origins: origins16,
                    } = result14;
                    *ptr15.add(0).cast::<i32>() = (account_id16).take_handle() as i32;
                    *ptr15.add(4).cast::<i32>() = (check_regions16).take_handle() as i32;
                    *ptr15.add(8).cast::<i32>() = (created_on16).take_handle() as i32;
                    *ptr15.add(12).cast::<i32>() = (description16).take_handle() as i32;
                    *ptr15.add(16).cast::<i32>() = (enabled16).take_handle() as i32;
                    *ptr15.add(20).cast::<i32>() = (latitude16).take_handle() as i32;
                    *ptr15.add(24).cast::<i32>() = (load_sheddings16).take_handle() as i32;
                    *ptr15.add(28).cast::<i32>() = (longitude16).take_handle() as i32;
                    *ptr15.add(32).cast::<i32>() = (minimum_origins16).take_handle() as i32;
                    *ptr15.add(36).cast::<i32>() = (modified_on16).take_handle() as i32;
                    *ptr15.add(40).cast::<i32>() = (monitor16).take_handle() as i32;
                    *ptr15.add(44).cast::<i32>() = (name16).take_handle() as i32;
                    *ptr15.add(48).cast::<i32>() = (notification_email16).take_handle() as i32;
                    *ptr15.add(52).cast::<i32>() = (origin_steerings16).take_handle() as i32;
                    *ptr15.add(56).cast::<i32>() = (origins16).take_handle() as i32;
                    ptr15
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_load_balancer_pool_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/load-balancer-pool@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,arg9: i32,arg10: i32,arg11: i32,arg12: i32,arg13: i32,arg14: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_load_balancer_pool_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 60]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 60]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod logpull_retention {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub enabled: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("enabled", &self.enabled)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub enabled: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("enabled", &self.enabled)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result3 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            enabled: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            zone_id: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                        },
                    );
                    let ptr4 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        enabled: enabled5,
                        zone_id: zone_id5,
                    } = result3;
                    *ptr4.add(0).cast::<i32>() = (enabled5).take_handle() as i32;
                    *ptr4.add(4).cast::<i32>() = (zone_id5).take_handle() as i32;
                    ptr4
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_logpull_retention_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/logpull-retention@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_logpull_retention_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 8]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod logpush_job {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub dataset: &'a Output,
                    pub destination_conf: &'a Output,
                    pub enabled: &'a Output,
                    pub filter: &'a Output,
                    pub frequency: &'a Output,
                    pub kind: &'a Output,
                    pub logpull_options: &'a Output,
                    pub max_upload_bytes: &'a Output,
                    pub max_upload_interval_seconds: &'a Output,
                    pub max_upload_records: &'a Output,
                    pub name: &'a Output,
                    pub output_options: &'a Output,
                    pub ownership_challenge: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("dataset", &self.dataset)
                            .field("destination-conf", &self.destination_conf)
                            .field("enabled", &self.enabled)
                            .field("filter", &self.filter)
                            .field("frequency", &self.frequency)
                            .field("kind", &self.kind)
                            .field("logpull-options", &self.logpull_options)
                            .field("max-upload-bytes", &self.max_upload_bytes)
                            .field(
                                "max-upload-interval-seconds",
                                &self.max_upload_interval_seconds,
                            )
                            .field("max-upload-records", &self.max_upload_records)
                            .field("name", &self.name)
                            .field("output-options", &self.output_options)
                            .field("ownership-challenge", &self.ownership_challenge)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub dataset: Output,
                    pub destination_conf: Output,
                    pub enabled: Output,
                    pub filter: Output,
                    pub frequency: Output,
                    pub kind: Output,
                    pub logpull_options: Output,
                    pub max_upload_bytes: Output,
                    pub max_upload_interval_seconds: Output,
                    pub max_upload_records: Output,
                    pub name: Output,
                    pub output_options: Output,
                    pub ownership_challenge: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("dataset", &self.dataset)
                            .field("destination-conf", &self.destination_conf)
                            .field("enabled", &self.enabled)
                            .field("filter", &self.filter)
                            .field("frequency", &self.frequency)
                            .field("kind", &self.kind)
                            .field("logpull-options", &self.logpull_options)
                            .field("max-upload-bytes", &self.max_upload_bytes)
                            .field(
                                "max-upload-interval-seconds",
                                &self.max_upload_interval_seconds,
                            )
                            .field("max-upload-records", &self.max_upload_records)
                            .field("name", &self.name)
                            .field("output-options", &self.output_options)
                            .field("ownership-challenge", &self.ownership_challenge)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle4;
                    let handle6;
                    let handle8;
                    let handle10;
                    let handle12;
                    let handle14;
                    let handle16;
                    let handle18;
                    let handle20;
                    let handle22;
                    let handle24;
                    let handle26;
                    let handle28;
                    let handle30;
                    let handle32;
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let len2 = l1;
                    let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                    let l3 = *arg0.add(8).cast::<i32>();
                    let l5 = *arg0.add(12).cast::<i32>();
                    let l7 = *arg0.add(16).cast::<i32>();
                    let l9 = *arg0.add(20).cast::<i32>();
                    let l11 = *arg0.add(24).cast::<i32>();
                    let l13 = *arg0.add(28).cast::<i32>();
                    let l15 = *arg0.add(32).cast::<i32>();
                    let l17 = *arg0.add(36).cast::<i32>();
                    let l19 = *arg0.add(40).cast::<i32>();
                    let l21 = *arg0.add(44).cast::<i32>();
                    let l23 = *arg0.add(48).cast::<i32>();
                    let l25 = *arg0.add(52).cast::<i32>();
                    let l27 = *arg0.add(56).cast::<i32>();
                    let l29 = *arg0.add(60).cast::<i32>();
                    let l31 = *arg0.add(64).cast::<i32>();
                    let result33 = T::invoke(
                        _rt::string_lift(bytes2),
                        Args {
                            account_id: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l3 as u32);
                                &handle4
                            },
                            dataset: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l5 as u32);
                                &handle6
                            },
                            destination_conf: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l7 as u32);
                                &handle8
                            },
                            enabled: {
                                handle10 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l9 as u32);
                                &handle10
                            },
                            filter: {
                                handle12 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l11 as u32);
                                &handle12
                            },
                            frequency: {
                                handle14 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l13 as u32);
                                &handle14
                            },
                            kind: {
                                handle16 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l15 as u32);
                                &handle16
                            },
                            logpull_options: {
                                handle18 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l17 as u32);
                                &handle18
                            },
                            max_upload_bytes: {
                                handle20 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l19 as u32);
                                &handle20
                            },
                            max_upload_interval_seconds: {
                                handle22 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l21 as u32);
                                &handle22
                            },
                            max_upload_records: {
                                handle24 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l23 as u32);
                                &handle24
                            },
                            name: {
                                handle26 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l25 as u32);
                                &handle26
                            },
                            output_options: {
                                handle28 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l27 as u32);
                                &handle28
                            },
                            ownership_challenge: {
                                handle30 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l29 as u32);
                                &handle30
                            },
                            zone_id: {
                                handle32 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l31 as u32);
                                &handle32
                            },
                        },
                    );
                    _rt::cabi_dealloc(arg0, 68, 4);
                    let ptr34 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id35,
                        dataset: dataset35,
                        destination_conf: destination_conf35,
                        enabled: enabled35,
                        filter: filter35,
                        frequency: frequency35,
                        kind: kind35,
                        logpull_options: logpull_options35,
                        max_upload_bytes: max_upload_bytes35,
                        max_upload_interval_seconds: max_upload_interval_seconds35,
                        max_upload_records: max_upload_records35,
                        name: name35,
                        output_options: output_options35,
                        ownership_challenge: ownership_challenge35,
                        zone_id: zone_id35,
                    } = result33;
                    *ptr34.add(0).cast::<i32>() = (account_id35).take_handle() as i32;
                    *ptr34.add(4).cast::<i32>() = (dataset35).take_handle() as i32;
                    *ptr34.add(8).cast::<i32>() = (destination_conf35).take_handle() as i32;
                    *ptr34.add(12).cast::<i32>() = (enabled35).take_handle() as i32;
                    *ptr34.add(16).cast::<i32>() = (filter35).take_handle() as i32;
                    *ptr34.add(20).cast::<i32>() = (frequency35).take_handle() as i32;
                    *ptr34.add(24).cast::<i32>() = (kind35).take_handle() as i32;
                    *ptr34.add(28).cast::<i32>() = (logpull_options35).take_handle() as i32;
                    *ptr34.add(32).cast::<i32>() = (max_upload_bytes35).take_handle() as i32;
                    *ptr34.add(36).cast::<i32>() =
                        (max_upload_interval_seconds35).take_handle() as i32;
                    *ptr34.add(40).cast::<i32>() = (max_upload_records35).take_handle() as i32;
                    *ptr34.add(44).cast::<i32>() = (name35).take_handle() as i32;
                    *ptr34.add(48).cast::<i32>() = (output_options35).take_handle() as i32;
                    *ptr34.add(52).cast::<i32>() = (ownership_challenge35).take_handle() as i32;
                    *ptr34.add(56).cast::<i32>() = (zone_id35).take_handle() as i32;
                    ptr34
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_logpush_job_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/logpush-job@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_logpush_job_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 60]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 60]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod logpush_ownership_challenge {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub destination_conf: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("destination-conf", &self.destination_conf)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub destination_conf: Output,
                    pub ownership_challenge_filename: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("destination-conf", &self.destination_conf)
                            .field(
                                "ownership-challenge-filename",
                                &self.ownership_challenge_filename,
                            )
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result4 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            destination_conf: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            zone_id: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                        },
                    );
                    let ptr5 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id6,
                        destination_conf: destination_conf6,
                        ownership_challenge_filename: ownership_challenge_filename6,
                        zone_id: zone_id6,
                    } = result4;
                    *ptr5.add(0).cast::<i32>() = (account_id6).take_handle() as i32;
                    *ptr5.add(4).cast::<i32>() = (destination_conf6).take_handle() as i32;
                    *ptr5.add(8).cast::<i32>() =
                        (ownership_challenge_filename6).take_handle() as i32;
                    *ptr5.add(12).cast::<i32>() = (zone_id6).take_handle() as i32;
                    ptr5
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_logpush_ownership_challenge_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/logpush-ownership-challenge@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_logpush_ownership_challenge_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod magic_firewall_ruleset {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub description: &'a Output,
                    pub name: &'a Output,
                    pub rules: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("description", &self.description)
                            .field("name", &self.name)
                            .field("rules", &self.rules)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub description: Output,
                    pub name: Output,
                    pub rules: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("description", &self.description)
                            .field("name", &self.name)
                            .field("rules", &self.rules)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result5 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            description: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            name: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            rules: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                        },
                    );
                    let ptr6 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id7,
                        description: description7,
                        name: name7,
                        rules: rules7,
                    } = result5;
                    *ptr6.add(0).cast::<i32>() = (account_id7).take_handle() as i32;
                    *ptr6.add(4).cast::<i32>() = (description7).take_handle() as i32;
                    *ptr6.add(8).cast::<i32>() = (name7).take_handle() as i32;
                    *ptr6.add(12).cast::<i32>() = (rules7).take_handle() as i32;
                    ptr6
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_magic_firewall_ruleset_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/magic-firewall-ruleset@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_magic_firewall_ruleset_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod managed_headers {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub managed_request_headers: &'a Output,
                    pub managed_response_headers: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("managed-request-headers", &self.managed_request_headers)
                            .field("managed-response-headers", &self.managed_response_headers)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub managed_request_headers: Output,
                    pub managed_response_headers: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("managed-request-headers", &self.managed_request_headers)
                            .field("managed-response-headers", &self.managed_response_headers)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result4 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            managed_request_headers: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            managed_response_headers: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            zone_id: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                        },
                    );
                    let ptr5 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        managed_request_headers: managed_request_headers6,
                        managed_response_headers: managed_response_headers6,
                        zone_id: zone_id6,
                    } = result4;
                    *ptr5.add(0).cast::<i32>() = (managed_request_headers6).take_handle() as i32;
                    *ptr5.add(4).cast::<i32>() = (managed_response_headers6).take_handle() as i32;
                    *ptr5.add(8).cast::<i32>() = (zone_id6).take_handle() as i32;
                    ptr5
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_managed_headers_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/managed-headers@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_managed_headers_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod mtls_certificate {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub ca: &'a Output,
                    pub certificates: &'a Output,
                    pub name: &'a Output,
                    pub private_key: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("ca", &self.ca)
                            .field("certificates", &self.certificates)
                            .field("name", &self.name)
                            .field("private-key", &self.private_key)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub ca: Output,
                    pub certificates: Output,
                    pub expires_on: Output,
                    pub issuer: Output,
                    pub name: Output,
                    pub private_key: Output,
                    pub serial_number: Output,
                    pub signature: Output,
                    pub uploaded_on: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("ca", &self.ca)
                            .field("certificates", &self.certificates)
                            .field("expires-on", &self.expires_on)
                            .field("issuer", &self.issuer)
                            .field("name", &self.name)
                            .field("private-key", &self.private_key)
                            .field("serial-number", &self.serial_number)
                            .field("signature", &self.signature)
                            .field("uploaded-on", &self.uploaded_on)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result6 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            ca: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            certificates: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            name: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            private_key: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                        },
                    );
                    let ptr7 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id8,
                        ca: ca8,
                        certificates: certificates8,
                        expires_on: expires_on8,
                        issuer: issuer8,
                        name: name8,
                        private_key: private_key8,
                        serial_number: serial_number8,
                        signature: signature8,
                        uploaded_on: uploaded_on8,
                    } = result6;
                    *ptr7.add(0).cast::<i32>() = (account_id8).take_handle() as i32;
                    *ptr7.add(4).cast::<i32>() = (ca8).take_handle() as i32;
                    *ptr7.add(8).cast::<i32>() = (certificates8).take_handle() as i32;
                    *ptr7.add(12).cast::<i32>() = (expires_on8).take_handle() as i32;
                    *ptr7.add(16).cast::<i32>() = (issuer8).take_handle() as i32;
                    *ptr7.add(20).cast::<i32>() = (name8).take_handle() as i32;
                    *ptr7.add(24).cast::<i32>() = (private_key8).take_handle() as i32;
                    *ptr7.add(28).cast::<i32>() = (serial_number8).take_handle() as i32;
                    *ptr7.add(32).cast::<i32>() = (signature8).take_handle() as i32;
                    *ptr7.add(36).cast::<i32>() = (uploaded_on8).take_handle() as i32;
                    ptr7
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_mtls_certificate_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/mtls-certificate@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_mtls_certificate_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 40]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 40]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod notification_policy {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub alert_type: &'a Output,
                    pub description: &'a Output,
                    pub email_integrations: &'a Output,
                    pub enabled: &'a Output,
                    pub filters: &'a Output,
                    pub name: &'a Output,
                    pub pagerduty_integrations: &'a Output,
                    pub webhooks_integrations: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("alert-type", &self.alert_type)
                            .field("description", &self.description)
                            .field("email-integrations", &self.email_integrations)
                            .field("enabled", &self.enabled)
                            .field("filters", &self.filters)
                            .field("name", &self.name)
                            .field("pagerduty-integrations", &self.pagerduty_integrations)
                            .field("webhooks-integrations", &self.webhooks_integrations)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub alert_type: Output,
                    pub created: Output,
                    pub description: Output,
                    pub email_integrations: Output,
                    pub enabled: Output,
                    pub filters: Output,
                    pub modified: Output,
                    pub name: Output,
                    pub pagerduty_integrations: Output,
                    pub webhooks_integrations: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("alert-type", &self.alert_type)
                            .field("created", &self.created)
                            .field("description", &self.description)
                            .field("email-integrations", &self.email_integrations)
                            .field("enabled", &self.enabled)
                            .field("filters", &self.filters)
                            .field("modified", &self.modified)
                            .field("name", &self.name)
                            .field("pagerduty-integrations", &self.pagerduty_integrations)
                            .field("webhooks-integrations", &self.webhooks_integrations)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let handle7;
                    let handle8;
                    let handle9;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result10 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            alert_type: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            description: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            email_integrations: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            enabled: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            filters: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                            name: {
                                handle7 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg8 as u32);
                                &handle7
                            },
                            pagerduty_integrations: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg9 as u32);
                                &handle8
                            },
                            webhooks_integrations: {
                                handle9 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg10 as u32);
                                &handle9
                            },
                        },
                    );
                    let ptr11 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id12,
                        alert_type: alert_type12,
                        created: created12,
                        description: description12,
                        email_integrations: email_integrations12,
                        enabled: enabled12,
                        filters: filters12,
                        modified: modified12,
                        name: name12,
                        pagerduty_integrations: pagerduty_integrations12,
                        webhooks_integrations: webhooks_integrations12,
                    } = result10;
                    *ptr11.add(0).cast::<i32>() = (account_id12).take_handle() as i32;
                    *ptr11.add(4).cast::<i32>() = (alert_type12).take_handle() as i32;
                    *ptr11.add(8).cast::<i32>() = (created12).take_handle() as i32;
                    *ptr11.add(12).cast::<i32>() = (description12).take_handle() as i32;
                    *ptr11.add(16).cast::<i32>() = (email_integrations12).take_handle() as i32;
                    *ptr11.add(20).cast::<i32>() = (enabled12).take_handle() as i32;
                    *ptr11.add(24).cast::<i32>() = (filters12).take_handle() as i32;
                    *ptr11.add(28).cast::<i32>() = (modified12).take_handle() as i32;
                    *ptr11.add(32).cast::<i32>() = (name12).take_handle() as i32;
                    *ptr11.add(36).cast::<i32>() = (pagerduty_integrations12).take_handle() as i32;
                    *ptr11.add(40).cast::<i32>() = (webhooks_integrations12).take_handle() as i32;
                    ptr11
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_notification_policy_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/notification-policy@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,arg9: i32,arg10: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_notification_policy_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 44]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 44]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod notification_policy_webhooks {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub name: &'a Output,
                    pub secret: &'a Output,
                    pub url: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("name", &self.name)
                            .field("secret", &self.secret)
                            .field("url", &self.url)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub created_at: Output,
                    pub last_failure: Output,
                    pub last_success: Output,
                    pub name: Output,
                    pub secret: Output,
                    pub type_: Output,
                    pub url: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("created-at", &self.created_at)
                            .field("last-failure", &self.last_failure)
                            .field("last-success", &self.last_success)
                            .field("name", &self.name)
                            .field("secret", &self.secret)
                            .field("type", &self.type_)
                            .field("url", &self.url)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result5 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            name: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            secret: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            url: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                        },
                    );
                    let ptr6 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id7,
                        created_at: created_at7,
                        last_failure: last_failure7,
                        last_success: last_success7,
                        name: name7,
                        secret: secret7,
                        type_: type_7,
                        url: url7,
                    } = result5;
                    *ptr6.add(0).cast::<i32>() = (account_id7).take_handle() as i32;
                    *ptr6.add(4).cast::<i32>() = (created_at7).take_handle() as i32;
                    *ptr6.add(8).cast::<i32>() = (last_failure7).take_handle() as i32;
                    *ptr6.add(12).cast::<i32>() = (last_success7).take_handle() as i32;
                    *ptr6.add(16).cast::<i32>() = (name7).take_handle() as i32;
                    *ptr6.add(20).cast::<i32>() = (secret7).take_handle() as i32;
                    *ptr6.add(24).cast::<i32>() = (type_7).take_handle() as i32;
                    *ptr6.add(28).cast::<i32>() = (url7).take_handle() as i32;
                    ptr6
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_notification_policy_webhooks_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/notification-policy-webhooks@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_notification_policy_webhooks_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 32]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 32]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod observatory_scheduled_test {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub frequency: &'a Output,
                    pub region: &'a Output,
                    pub url: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("frequency", &self.frequency)
                            .field("region", &self.region)
                            .field("url", &self.url)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub frequency: Output,
                    pub region: Output,
                    pub url: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("frequency", &self.frequency)
                            .field("region", &self.region)
                            .field("url", &self.url)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result5 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            frequency: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            region: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            url: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            zone_id: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                        },
                    );
                    let ptr6 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        frequency: frequency7,
                        region: region7,
                        url: url7,
                        zone_id: zone_id7,
                    } = result5;
                    *ptr6.add(0).cast::<i32>() = (frequency7).take_handle() as i32;
                    *ptr6.add(4).cast::<i32>() = (region7).take_handle() as i32;
                    *ptr6.add(8).cast::<i32>() = (url7).take_handle() as i32;
                    *ptr6.add(12).cast::<i32>() = (zone_id7).take_handle() as i32;
                    ptr6
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_observatory_scheduled_test_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/observatory-scheduled-test@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_observatory_scheduled_test_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod origin_ca_certificate {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub csr: &'a Output,
                    pub hostnames: &'a Output,
                    pub min_days_for_renewal: &'a Output,
                    pub request_type: &'a Output,
                    pub requested_validity: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("csr", &self.csr)
                            .field("hostnames", &self.hostnames)
                            .field("min-days-for-renewal", &self.min_days_for_renewal)
                            .field("request-type", &self.request_type)
                            .field("requested-validity", &self.requested_validity)
                            .finish()
                    }
                }
                pub struct Res {
                    pub certificate: Output,
                    pub csr: Output,
                    pub expires_on: Output,
                    pub hostnames: Output,
                    pub min_days_for_renewal: Output,
                    pub request_type: Output,
                    pub requested_validity: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("certificate", &self.certificate)
                            .field("csr", &self.csr)
                            .field("expires-on", &self.expires_on)
                            .field("hostnames", &self.hostnames)
                            .field("min-days-for-renewal", &self.min_days_for_renewal)
                            .field("request-type", &self.request_type)
                            .field("requested-validity", &self.requested_validity)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result6 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            csr: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            hostnames: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            min_days_for_renewal: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            request_type: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            requested_validity: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                        },
                    );
                    let ptr7 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        certificate: certificate8,
                        csr: csr8,
                        expires_on: expires_on8,
                        hostnames: hostnames8,
                        min_days_for_renewal: min_days_for_renewal8,
                        request_type: request_type8,
                        requested_validity: requested_validity8,
                    } = result6;
                    *ptr7.add(0).cast::<i32>() = (certificate8).take_handle() as i32;
                    *ptr7.add(4).cast::<i32>() = (csr8).take_handle() as i32;
                    *ptr7.add(8).cast::<i32>() = (expires_on8).take_handle() as i32;
                    *ptr7.add(12).cast::<i32>() = (hostnames8).take_handle() as i32;
                    *ptr7.add(16).cast::<i32>() = (min_days_for_renewal8).take_handle() as i32;
                    *ptr7.add(20).cast::<i32>() = (request_type8).take_handle() as i32;
                    *ptr7.add(24).cast::<i32>() = (requested_validity8).take_handle() as i32;
                    ptr7
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_origin_ca_certificate_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/origin-ca-certificate@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_origin_ca_certificate_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 28]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 28]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod page_rule {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub actions: &'a Output,
                    pub priority: &'a Output,
                    pub status: &'a Output,
                    pub target: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("actions", &self.actions)
                            .field("priority", &self.priority)
                            .field("status", &self.status)
                            .field("target", &self.target)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub actions: Output,
                    pub priority: Output,
                    pub status: Output,
                    pub target: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("actions", &self.actions)
                            .field("priority", &self.priority)
                            .field("status", &self.status)
                            .field("target", &self.target)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result6 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            actions: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            priority: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            status: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            target: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            zone_id: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                        },
                    );
                    let ptr7 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        actions: actions8,
                        priority: priority8,
                        status: status8,
                        target: target8,
                        zone_id: zone_id8,
                    } = result6;
                    *ptr7.add(0).cast::<i32>() = (actions8).take_handle() as i32;
                    *ptr7.add(4).cast::<i32>() = (priority8).take_handle() as i32;
                    *ptr7.add(8).cast::<i32>() = (status8).take_handle() as i32;
                    *ptr7.add(12).cast::<i32>() = (target8).take_handle() as i32;
                    *ptr7.add(16).cast::<i32>() = (zone_id8).take_handle() as i32;
                    ptr7
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_page_rule_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/page-rule@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_page_rule_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 20]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 20]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod pages_domain {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub domain: &'a Output,
                    pub project_name: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("domain", &self.domain)
                            .field("project-name", &self.project_name)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub domain: Output,
                    pub project_name: Output,
                    pub status: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("domain", &self.domain)
                            .field("project-name", &self.project_name)
                            .field("status", &self.status)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result4 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            domain: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            project_name: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                        },
                    );
                    let ptr5 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id6,
                        domain: domain6,
                        project_name: project_name6,
                        status: status6,
                    } = result4;
                    *ptr5.add(0).cast::<i32>() = (account_id6).take_handle() as i32;
                    *ptr5.add(4).cast::<i32>() = (domain6).take_handle() as i32;
                    *ptr5.add(8).cast::<i32>() = (project_name6).take_handle() as i32;
                    *ptr5.add(12).cast::<i32>() = (status6).take_handle() as i32;
                    ptr5
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_pages_domain_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/pages-domain@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_pages_domain_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod pages_project {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub build_config: &'a Output,
                    pub deployment_configs: &'a Output,
                    pub name: &'a Output,
                    pub production_branch: &'a Output,
                    pub source: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("build-config", &self.build_config)
                            .field("deployment-configs", &self.deployment_configs)
                            .field("name", &self.name)
                            .field("production-branch", &self.production_branch)
                            .field("source", &self.source)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub build_config: Output,
                    pub created_on: Output,
                    pub deployment_configs: Output,
                    pub domains: Output,
                    pub name: Output,
                    pub production_branch: Output,
                    pub source: Output,
                    pub subdomain: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("build-config", &self.build_config)
                            .field("created-on", &self.created_on)
                            .field("deployment-configs", &self.deployment_configs)
                            .field("domains", &self.domains)
                            .field("name", &self.name)
                            .field("production-branch", &self.production_branch)
                            .field("source", &self.source)
                            .field("subdomain", &self.subdomain)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result7 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            build_config: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            deployment_configs: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            name: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            production_branch: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            source: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                        },
                    );
                    let ptr8 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id9,
                        build_config: build_config9,
                        created_on: created_on9,
                        deployment_configs: deployment_configs9,
                        domains: domains9,
                        name: name9,
                        production_branch: production_branch9,
                        source: source9,
                        subdomain: subdomain9,
                    } = result7;
                    *ptr8.add(0).cast::<i32>() = (account_id9).take_handle() as i32;
                    *ptr8.add(4).cast::<i32>() = (build_config9).take_handle() as i32;
                    *ptr8.add(8).cast::<i32>() = (created_on9).take_handle() as i32;
                    *ptr8.add(12).cast::<i32>() = (deployment_configs9).take_handle() as i32;
                    *ptr8.add(16).cast::<i32>() = (domains9).take_handle() as i32;
                    *ptr8.add(20).cast::<i32>() = (name9).take_handle() as i32;
                    *ptr8.add(24).cast::<i32>() = (production_branch9).take_handle() as i32;
                    *ptr8.add(28).cast::<i32>() = (source9).take_handle() as i32;
                    *ptr8.add(32).cast::<i32>() = (subdomain9).take_handle() as i32;
                    ptr8
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_pages_project_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/pages-project@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_pages_project_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 36]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 36]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod queue {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub name: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("name", &self.name)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub name: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("name", &self.name)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result3 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            name: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                        },
                    );
                    let ptr4 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id5,
                        name: name5,
                    } = result3;
                    *ptr4.add(0).cast::<i32>() = (account_id5).take_handle() as i32;
                    *ptr4.add(4).cast::<i32>() = (name5).take_handle() as i32;
                    ptr4
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_queue_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/queue@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_queue_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 8]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod r2_bucket {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub location: &'a Output,
                    pub name: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("location", &self.location)
                            .field("name", &self.name)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub location: Output,
                    pub name: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("location", &self.location)
                            .field("name", &self.name)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result4 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            location: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            name: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                        },
                    );
                    let ptr5 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id6,
                        location: location6,
                        name: name6,
                    } = result4;
                    *ptr5.add(0).cast::<i32>() = (account_id6).take_handle() as i32;
                    *ptr5.add(4).cast::<i32>() = (location6).take_handle() as i32;
                    *ptr5.add(8).cast::<i32>() = (name6).take_handle() as i32;
                    ptr5
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_r2_bucket_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/r2-bucket@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_r2_bucket_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod rate_limit {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub action: &'a Output,
                    pub bypass_url_patterns: &'a Output,
                    pub correlate: &'a Output,
                    pub description: &'a Output,
                    pub disabled: &'a Output,
                    pub match_: &'a Output,
                    pub period: &'a Output,
                    pub threshold: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("action", &self.action)
                            .field("bypass-url-patterns", &self.bypass_url_patterns)
                            .field("correlate", &self.correlate)
                            .field("description", &self.description)
                            .field("disabled", &self.disabled)
                            .field("match", &self.match_)
                            .field("period", &self.period)
                            .field("threshold", &self.threshold)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub action: Output,
                    pub bypass_url_patterns: Output,
                    pub correlate: Output,
                    pub description: Output,
                    pub disabled: Output,
                    pub match_: Output,
                    pub period: Output,
                    pub threshold: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("action", &self.action)
                            .field("bypass-url-patterns", &self.bypass_url_patterns)
                            .field("correlate", &self.correlate)
                            .field("description", &self.description)
                            .field("disabled", &self.disabled)
                            .field("match", &self.match_)
                            .field("period", &self.period)
                            .field("threshold", &self.threshold)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let handle7;
                    let handle8;
                    let handle9;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result10 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            action: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            bypass_url_patterns: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            correlate: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            description: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            disabled: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            match_: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                            period: {
                                handle7 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg8 as u32);
                                &handle7
                            },
                            threshold: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg9 as u32);
                                &handle8
                            },
                            zone_id: {
                                handle9 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg10 as u32);
                                &handle9
                            },
                        },
                    );
                    let ptr11 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        action: action12,
                        bypass_url_patterns: bypass_url_patterns12,
                        correlate: correlate12,
                        description: description12,
                        disabled: disabled12,
                        match_: match_12,
                        period: period12,
                        threshold: threshold12,
                        zone_id: zone_id12,
                    } = result10;
                    *ptr11.add(0).cast::<i32>() = (action12).take_handle() as i32;
                    *ptr11.add(4).cast::<i32>() = (bypass_url_patterns12).take_handle() as i32;
                    *ptr11.add(8).cast::<i32>() = (correlate12).take_handle() as i32;
                    *ptr11.add(12).cast::<i32>() = (description12).take_handle() as i32;
                    *ptr11.add(16).cast::<i32>() = (disabled12).take_handle() as i32;
                    *ptr11.add(20).cast::<i32>() = (match_12).take_handle() as i32;
                    *ptr11.add(24).cast::<i32>() = (period12).take_handle() as i32;
                    *ptr11.add(28).cast::<i32>() = (threshold12).take_handle() as i32;
                    *ptr11.add(32).cast::<i32>() = (zone_id12).take_handle() as i32;
                    ptr11
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_rate_limit_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/rate-limit@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,arg9: i32,arg10: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_rate_limit_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 36]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 36]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod record {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub allow_overwrite: &'a Output,
                    pub comment: &'a Output,
                    pub data: &'a Output,
                    pub name: &'a Output,
                    pub priority: &'a Output,
                    pub proxied: &'a Output,
                    pub tags: &'a Output,
                    pub ttl: &'a Output,
                    pub type_: &'a Output,
                    pub value: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("allow-overwrite", &self.allow_overwrite)
                            .field("comment", &self.comment)
                            .field("data", &self.data)
                            .field("name", &self.name)
                            .field("priority", &self.priority)
                            .field("proxied", &self.proxied)
                            .field("tags", &self.tags)
                            .field("ttl", &self.ttl)
                            .field("type", &self.type_)
                            .field("value", &self.value)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub allow_overwrite: Output,
                    pub comment: Output,
                    pub created_on: Output,
                    pub data: Output,
                    pub hostname: Output,
                    pub metadata: Output,
                    pub modified_on: Output,
                    pub name: Output,
                    pub priority: Output,
                    pub proxiable: Output,
                    pub proxied: Output,
                    pub tags: Output,
                    pub ttl: Output,
                    pub type_: Output,
                    pub value: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("allow-overwrite", &self.allow_overwrite)
                            .field("comment", &self.comment)
                            .field("created-on", &self.created_on)
                            .field("data", &self.data)
                            .field("hostname", &self.hostname)
                            .field("metadata", &self.metadata)
                            .field("modified-on", &self.modified_on)
                            .field("name", &self.name)
                            .field("priority", &self.priority)
                            .field("proxiable", &self.proxiable)
                            .field("proxied", &self.proxied)
                            .field("tags", &self.tags)
                            .field("ttl", &self.ttl)
                            .field("type", &self.type_)
                            .field("value", &self.value)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                    arg11: i32,
                    arg12: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let handle7;
                    let handle8;
                    let handle9;
                    let handle10;
                    let handle11;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result12 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            allow_overwrite: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            comment: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            data: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            name: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            priority: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            proxied: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                            tags: {
                                handle7 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg8 as u32);
                                &handle7
                            },
                            ttl: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg9 as u32);
                                &handle8
                            },
                            type_: {
                                handle9 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg10 as u32);
                                &handle9
                            },
                            value: {
                                handle10 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg11 as u32);
                                &handle10
                            },
                            zone_id: {
                                handle11 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg12 as u32);
                                &handle11
                            },
                        },
                    );
                    let ptr13 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        allow_overwrite: allow_overwrite14,
                        comment: comment14,
                        created_on: created_on14,
                        data: data14,
                        hostname: hostname14,
                        metadata: metadata14,
                        modified_on: modified_on14,
                        name: name14,
                        priority: priority14,
                        proxiable: proxiable14,
                        proxied: proxied14,
                        tags: tags14,
                        ttl: ttl14,
                        type_: type_14,
                        value: value14,
                        zone_id: zone_id14,
                    } = result12;
                    *ptr13.add(0).cast::<i32>() = (allow_overwrite14).take_handle() as i32;
                    *ptr13.add(4).cast::<i32>() = (comment14).take_handle() as i32;
                    *ptr13.add(8).cast::<i32>() = (created_on14).take_handle() as i32;
                    *ptr13.add(12).cast::<i32>() = (data14).take_handle() as i32;
                    *ptr13.add(16).cast::<i32>() = (hostname14).take_handle() as i32;
                    *ptr13.add(20).cast::<i32>() = (metadata14).take_handle() as i32;
                    *ptr13.add(24).cast::<i32>() = (modified_on14).take_handle() as i32;
                    *ptr13.add(28).cast::<i32>() = (name14).take_handle() as i32;
                    *ptr13.add(32).cast::<i32>() = (priority14).take_handle() as i32;
                    *ptr13.add(36).cast::<i32>() = (proxiable14).take_handle() as i32;
                    *ptr13.add(40).cast::<i32>() = (proxied14).take_handle() as i32;
                    *ptr13.add(44).cast::<i32>() = (tags14).take_handle() as i32;
                    *ptr13.add(48).cast::<i32>() = (ttl14).take_handle() as i32;
                    *ptr13.add(52).cast::<i32>() = (type_14).take_handle() as i32;
                    *ptr13.add(56).cast::<i32>() = (value14).take_handle() as i32;
                    *ptr13.add(60).cast::<i32>() = (zone_id14).take_handle() as i32;
                    ptr13
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_record_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/record@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,arg9: i32,arg10: i32,arg11: i32,arg12: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_record_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 64]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 64]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod regional_hostname {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub hostname: &'a Output,
                    pub region_key: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("hostname", &self.hostname)
                            .field("region-key", &self.region_key)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub created_on: Output,
                    pub hostname: Output,
                    pub region_key: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("created-on", &self.created_on)
                            .field("hostname", &self.hostname)
                            .field("region-key", &self.region_key)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result4 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            hostname: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            region_key: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            zone_id: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                        },
                    );
                    let ptr5 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        created_on: created_on6,
                        hostname: hostname6,
                        region_key: region_key6,
                        zone_id: zone_id6,
                    } = result4;
                    *ptr5.add(0).cast::<i32>() = (created_on6).take_handle() as i32;
                    *ptr5.add(4).cast::<i32>() = (hostname6).take_handle() as i32;
                    *ptr5.add(8).cast::<i32>() = (region_key6).take_handle() as i32;
                    *ptr5.add(12).cast::<i32>() = (zone_id6).take_handle() as i32;
                    ptr5
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_regional_hostname_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/regional-hostname@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_regional_hostname_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod regional_tiered_cache {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub value: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("value", &self.value)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub value: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("value", &self.value)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result3 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            value: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            zone_id: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                        },
                    );
                    let ptr4 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        value: value5,
                        zone_id: zone_id5,
                    } = result3;
                    *ptr4.add(0).cast::<i32>() = (value5).take_handle() as i32;
                    *ptr4.add(4).cast::<i32>() = (zone_id5).take_handle() as i32;
                    ptr4
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_regional_tiered_cache_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/regional-tiered-cache@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_regional_tiered_cache_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 8]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod ruleset {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub description: &'a Output,
                    pub kind: &'a Output,
                    pub name: &'a Output,
                    pub phase: &'a Output,
                    pub rules: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("description", &self.description)
                            .field("kind", &self.kind)
                            .field("name", &self.name)
                            .field("phase", &self.phase)
                            .field("rules", &self.rules)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub description: Output,
                    pub kind: Output,
                    pub name: Output,
                    pub phase: Output,
                    pub rules: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("description", &self.description)
                            .field("kind", &self.kind)
                            .field("name", &self.name)
                            .field("phase", &self.phase)
                            .field("rules", &self.rules)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let handle7;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result8 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            description: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            kind: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            name: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            phase: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            rules: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                            zone_id: {
                                handle7 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg8 as u32);
                                &handle7
                            },
                        },
                    );
                    let ptr9 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id10,
                        description: description10,
                        kind: kind10,
                        name: name10,
                        phase: phase10,
                        rules: rules10,
                        zone_id: zone_id10,
                    } = result8;
                    *ptr9.add(0).cast::<i32>() = (account_id10).take_handle() as i32;
                    *ptr9.add(4).cast::<i32>() = (description10).take_handle() as i32;
                    *ptr9.add(8).cast::<i32>() = (kind10).take_handle() as i32;
                    *ptr9.add(12).cast::<i32>() = (name10).take_handle() as i32;
                    *ptr9.add(16).cast::<i32>() = (phase10).take_handle() as i32;
                    *ptr9.add(20).cast::<i32>() = (rules10).take_handle() as i32;
                    *ptr9.add(24).cast::<i32>() = (zone_id10).take_handle() as i32;
                    ptr9
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_ruleset_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/ruleset@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_ruleset_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 28]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 28]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod spectrum_application {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub argo_smart_routing: &'a Output,
                    pub dns: &'a Output,
                    pub edge_ips: &'a Output,
                    pub ip_firewall: &'a Output,
                    pub origin_directs: &'a Output,
                    pub origin_dns: &'a Output,
                    pub origin_port: &'a Output,
                    pub origin_port_range: &'a Output,
                    pub protocol: &'a Output,
                    pub proxy_protocol: &'a Output,
                    pub tls: &'a Output,
                    pub traffic_type: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("argo-smart-routing", &self.argo_smart_routing)
                            .field("dns", &self.dns)
                            .field("edge-ips", &self.edge_ips)
                            .field("ip-firewall", &self.ip_firewall)
                            .field("origin-directs", &self.origin_directs)
                            .field("origin-dns", &self.origin_dns)
                            .field("origin-port", &self.origin_port)
                            .field("origin-port-range", &self.origin_port_range)
                            .field("protocol", &self.protocol)
                            .field("proxy-protocol", &self.proxy_protocol)
                            .field("tls", &self.tls)
                            .field("traffic-type", &self.traffic_type)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub argo_smart_routing: Output,
                    pub dns: Output,
                    pub edge_ips: Output,
                    pub ip_firewall: Output,
                    pub origin_directs: Output,
                    pub origin_dns: Output,
                    pub origin_port: Output,
                    pub origin_port_range: Output,
                    pub protocol: Output,
                    pub proxy_protocol: Output,
                    pub tls: Output,
                    pub traffic_type: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("argo-smart-routing", &self.argo_smart_routing)
                            .field("dns", &self.dns)
                            .field("edge-ips", &self.edge_ips)
                            .field("ip-firewall", &self.ip_firewall)
                            .field("origin-directs", &self.origin_directs)
                            .field("origin-dns", &self.origin_dns)
                            .field("origin-port", &self.origin_port)
                            .field("origin-port-range", &self.origin_port_range)
                            .field("protocol", &self.protocol)
                            .field("proxy-protocol", &self.proxy_protocol)
                            .field("tls", &self.tls)
                            .field("traffic-type", &self.traffic_type)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                    arg11: i32,
                    arg12: i32,
                    arg13: i32,
                    arg14: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let handle7;
                    let handle8;
                    let handle9;
                    let handle10;
                    let handle11;
                    let handle12;
                    let handle13;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result14 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            argo_smart_routing: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            dns: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            edge_ips: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            ip_firewall: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            origin_directs: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            origin_dns: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                            origin_port: {
                                handle7 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg8 as u32);
                                &handle7
                            },
                            origin_port_range: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg9 as u32);
                                &handle8
                            },
                            protocol: {
                                handle9 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg10 as u32);
                                &handle9
                            },
                            proxy_protocol: {
                                handle10 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg11 as u32);
                                &handle10
                            },
                            tls: {
                                handle11 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg12 as u32);
                                &handle11
                            },
                            traffic_type: {
                                handle12 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg13 as u32);
                                &handle12
                            },
                            zone_id: {
                                handle13 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg14 as u32);
                                &handle13
                            },
                        },
                    );
                    let ptr15 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        argo_smart_routing: argo_smart_routing16,
                        dns: dns16,
                        edge_ips: edge_ips16,
                        ip_firewall: ip_firewall16,
                        origin_directs: origin_directs16,
                        origin_dns: origin_dns16,
                        origin_port: origin_port16,
                        origin_port_range: origin_port_range16,
                        protocol: protocol16,
                        proxy_protocol: proxy_protocol16,
                        tls: tls16,
                        traffic_type: traffic_type16,
                        zone_id: zone_id16,
                    } = result14;
                    *ptr15.add(0).cast::<i32>() = (argo_smart_routing16).take_handle() as i32;
                    *ptr15.add(4).cast::<i32>() = (dns16).take_handle() as i32;
                    *ptr15.add(8).cast::<i32>() = (edge_ips16).take_handle() as i32;
                    *ptr15.add(12).cast::<i32>() = (ip_firewall16).take_handle() as i32;
                    *ptr15.add(16).cast::<i32>() = (origin_directs16).take_handle() as i32;
                    *ptr15.add(20).cast::<i32>() = (origin_dns16).take_handle() as i32;
                    *ptr15.add(24).cast::<i32>() = (origin_port16).take_handle() as i32;
                    *ptr15.add(28).cast::<i32>() = (origin_port_range16).take_handle() as i32;
                    *ptr15.add(32).cast::<i32>() = (protocol16).take_handle() as i32;
                    *ptr15.add(36).cast::<i32>() = (proxy_protocol16).take_handle() as i32;
                    *ptr15.add(40).cast::<i32>() = (tls16).take_handle() as i32;
                    *ptr15.add(44).cast::<i32>() = (traffic_type16).take_handle() as i32;
                    *ptr15.add(48).cast::<i32>() = (zone_id16).take_handle() as i32;
                    ptr15
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_spectrum_application_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/spectrum-application@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,arg9: i32,arg10: i32,arg11: i32,arg12: i32,arg13: i32,arg14: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_spectrum_application_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 52]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 52]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod split_tunnel {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub mode: &'a Output,
                    pub policy_id: &'a Output,
                    pub tunnels: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("mode", &self.mode)
                            .field("policy-id", &self.policy_id)
                            .field("tunnels", &self.tunnels)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub mode: Output,
                    pub policy_id: Output,
                    pub tunnels: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("mode", &self.mode)
                            .field("policy-id", &self.policy_id)
                            .field("tunnels", &self.tunnels)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result5 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            mode: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            policy_id: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            tunnels: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                        },
                    );
                    let ptr6 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id7,
                        mode: mode7,
                        policy_id: policy_id7,
                        tunnels: tunnels7,
                    } = result5;
                    *ptr6.add(0).cast::<i32>() = (account_id7).take_handle() as i32;
                    *ptr6.add(4).cast::<i32>() = (mode7).take_handle() as i32;
                    *ptr6.add(8).cast::<i32>() = (policy_id7).take_handle() as i32;
                    *ptr6.add(12).cast::<i32>() = (tunnels7).take_handle() as i32;
                    ptr6
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_split_tunnel_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/split-tunnel@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_split_tunnel_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod static_route {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub colo_names: &'a Output,
                    pub colo_regions: &'a Output,
                    pub description: &'a Output,
                    pub nexthop: &'a Output,
                    pub prefix: &'a Output,
                    pub priority: &'a Output,
                    pub weight: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("colo-names", &self.colo_names)
                            .field("colo-regions", &self.colo_regions)
                            .field("description", &self.description)
                            .field("nexthop", &self.nexthop)
                            .field("prefix", &self.prefix)
                            .field("priority", &self.priority)
                            .field("weight", &self.weight)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub colo_names: Output,
                    pub colo_regions: Output,
                    pub description: Output,
                    pub nexthop: Output,
                    pub prefix: Output,
                    pub priority: Output,
                    pub weight: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("colo-names", &self.colo_names)
                            .field("colo-regions", &self.colo_regions)
                            .field("description", &self.description)
                            .field("nexthop", &self.nexthop)
                            .field("prefix", &self.prefix)
                            .field("priority", &self.priority)
                            .field("weight", &self.weight)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let handle7;
                    let handle8;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result9 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            colo_names: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            colo_regions: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            description: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            nexthop: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            prefix: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                            priority: {
                                handle7 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg8 as u32);
                                &handle7
                            },
                            weight: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg9 as u32);
                                &handle8
                            },
                        },
                    );
                    let ptr10 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id11,
                        colo_names: colo_names11,
                        colo_regions: colo_regions11,
                        description: description11,
                        nexthop: nexthop11,
                        prefix: prefix11,
                        priority: priority11,
                        weight: weight11,
                    } = result9;
                    *ptr10.add(0).cast::<i32>() = (account_id11).take_handle() as i32;
                    *ptr10.add(4).cast::<i32>() = (colo_names11).take_handle() as i32;
                    *ptr10.add(8).cast::<i32>() = (colo_regions11).take_handle() as i32;
                    *ptr10.add(12).cast::<i32>() = (description11).take_handle() as i32;
                    *ptr10.add(16).cast::<i32>() = (nexthop11).take_handle() as i32;
                    *ptr10.add(20).cast::<i32>() = (prefix11).take_handle() as i32;
                    *ptr10.add(24).cast::<i32>() = (priority11).take_handle() as i32;
                    *ptr10.add(28).cast::<i32>() = (weight11).take_handle() as i32;
                    ptr10
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_static_route_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/static-route@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,arg9: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_static_route_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 32]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 32]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod teams_account {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub activity_log_enabled: &'a Output,
                    pub antivirus: &'a Output,
                    pub block_page: &'a Output,
                    pub body_scanning: &'a Output,
                    pub extended_email_matching: &'a Output,
                    pub fips: &'a Output,
                    pub logging: &'a Output,
                    pub non_identity_browser_isolation_enabled: &'a Output,
                    pub payload_log: &'a Output,
                    pub protocol_detection_enabled: &'a Output,
                    pub proxy: &'a Output,
                    pub ssh_session_log: &'a Output,
                    pub tls_decrypt_enabled: &'a Output,
                    pub url_browser_isolation_enabled: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("activity-log-enabled", &self.activity_log_enabled)
                            .field("antivirus", &self.antivirus)
                            .field("block-page", &self.block_page)
                            .field("body-scanning", &self.body_scanning)
                            .field("extended-email-matching", &self.extended_email_matching)
                            .field("fips", &self.fips)
                            .field("logging", &self.logging)
                            .field(
                                "non-identity-browser-isolation-enabled",
                                &self.non_identity_browser_isolation_enabled,
                            )
                            .field("payload-log", &self.payload_log)
                            .field(
                                "protocol-detection-enabled",
                                &self.protocol_detection_enabled,
                            )
                            .field("proxy", &self.proxy)
                            .field("ssh-session-log", &self.ssh_session_log)
                            .field("tls-decrypt-enabled", &self.tls_decrypt_enabled)
                            .field(
                                "url-browser-isolation-enabled",
                                &self.url_browser_isolation_enabled,
                            )
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub activity_log_enabled: Output,
                    pub antivirus: Output,
                    pub block_page: Output,
                    pub body_scanning: Output,
                    pub extended_email_matching: Output,
                    pub fips: Output,
                    pub logging: Output,
                    pub non_identity_browser_isolation_enabled: Output,
                    pub payload_log: Output,
                    pub protocol_detection_enabled: Output,
                    pub proxy: Output,
                    pub ssh_session_log: Output,
                    pub tls_decrypt_enabled: Output,
                    pub url_browser_isolation_enabled: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("activity-log-enabled", &self.activity_log_enabled)
                            .field("antivirus", &self.antivirus)
                            .field("block-page", &self.block_page)
                            .field("body-scanning", &self.body_scanning)
                            .field("extended-email-matching", &self.extended_email_matching)
                            .field("fips", &self.fips)
                            .field("logging", &self.logging)
                            .field(
                                "non-identity-browser-isolation-enabled",
                                &self.non_identity_browser_isolation_enabled,
                            )
                            .field("payload-log", &self.payload_log)
                            .field(
                                "protocol-detection-enabled",
                                &self.protocol_detection_enabled,
                            )
                            .field("proxy", &self.proxy)
                            .field("ssh-session-log", &self.ssh_session_log)
                            .field("tls-decrypt-enabled", &self.tls_decrypt_enabled)
                            .field(
                                "url-browser-isolation-enabled",
                                &self.url_browser_isolation_enabled,
                            )
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle4;
                    let handle6;
                    let handle8;
                    let handle10;
                    let handle12;
                    let handle14;
                    let handle16;
                    let handle18;
                    let handle20;
                    let handle22;
                    let handle24;
                    let handle26;
                    let handle28;
                    let handle30;
                    let handle32;
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let len2 = l1;
                    let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                    let l3 = *arg0.add(8).cast::<i32>();
                    let l5 = *arg0.add(12).cast::<i32>();
                    let l7 = *arg0.add(16).cast::<i32>();
                    let l9 = *arg0.add(20).cast::<i32>();
                    let l11 = *arg0.add(24).cast::<i32>();
                    let l13 = *arg0.add(28).cast::<i32>();
                    let l15 = *arg0.add(32).cast::<i32>();
                    let l17 = *arg0.add(36).cast::<i32>();
                    let l19 = *arg0.add(40).cast::<i32>();
                    let l21 = *arg0.add(44).cast::<i32>();
                    let l23 = *arg0.add(48).cast::<i32>();
                    let l25 = *arg0.add(52).cast::<i32>();
                    let l27 = *arg0.add(56).cast::<i32>();
                    let l29 = *arg0.add(60).cast::<i32>();
                    let l31 = *arg0.add(64).cast::<i32>();
                    let result33 = T::invoke(
                        _rt::string_lift(bytes2),
                        Args {
                            account_id: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l3 as u32);
                                &handle4
                            },
                            activity_log_enabled: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l5 as u32);
                                &handle6
                            },
                            antivirus: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l7 as u32);
                                &handle8
                            },
                            block_page: {
                                handle10 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l9 as u32);
                                &handle10
                            },
                            body_scanning: {
                                handle12 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l11 as u32);
                                &handle12
                            },
                            extended_email_matching: {
                                handle14 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l13 as u32);
                                &handle14
                            },
                            fips: {
                                handle16 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l15 as u32);
                                &handle16
                            },
                            logging: {
                                handle18 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l17 as u32);
                                &handle18
                            },
                            non_identity_browser_isolation_enabled: {
                                handle20 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l19 as u32);
                                &handle20
                            },
                            payload_log: {
                                handle22 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l21 as u32);
                                &handle22
                            },
                            protocol_detection_enabled: {
                                handle24 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l23 as u32);
                                &handle24
                            },
                            proxy: {
                                handle26 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l25 as u32);
                                &handle26
                            },
                            ssh_session_log: {
                                handle28 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l27 as u32);
                                &handle28
                            },
                            tls_decrypt_enabled: {
                                handle30 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l29 as u32);
                                &handle30
                            },
                            url_browser_isolation_enabled: {
                                handle32 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l31 as u32);
                                &handle32
                            },
                        },
                    );
                    _rt::cabi_dealloc(arg0, 68, 4);
                    let ptr34 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id35,
                        activity_log_enabled: activity_log_enabled35,
                        antivirus: antivirus35,
                        block_page: block_page35,
                        body_scanning: body_scanning35,
                        extended_email_matching: extended_email_matching35,
                        fips: fips35,
                        logging: logging35,
                        non_identity_browser_isolation_enabled:
                            non_identity_browser_isolation_enabled35,
                        payload_log: payload_log35,
                        protocol_detection_enabled: protocol_detection_enabled35,
                        proxy: proxy35,
                        ssh_session_log: ssh_session_log35,
                        tls_decrypt_enabled: tls_decrypt_enabled35,
                        url_browser_isolation_enabled: url_browser_isolation_enabled35,
                    } = result33;
                    *ptr34.add(0).cast::<i32>() = (account_id35).take_handle() as i32;
                    *ptr34.add(4).cast::<i32>() = (activity_log_enabled35).take_handle() as i32;
                    *ptr34.add(8).cast::<i32>() = (antivirus35).take_handle() as i32;
                    *ptr34.add(12).cast::<i32>() = (block_page35).take_handle() as i32;
                    *ptr34.add(16).cast::<i32>() = (body_scanning35).take_handle() as i32;
                    *ptr34.add(20).cast::<i32>() = (extended_email_matching35).take_handle() as i32;
                    *ptr34.add(24).cast::<i32>() = (fips35).take_handle() as i32;
                    *ptr34.add(28).cast::<i32>() = (logging35).take_handle() as i32;
                    *ptr34.add(32).cast::<i32>() =
                        (non_identity_browser_isolation_enabled35).take_handle() as i32;
                    *ptr34.add(36).cast::<i32>() = (payload_log35).take_handle() as i32;
                    *ptr34.add(40).cast::<i32>() =
                        (protocol_detection_enabled35).take_handle() as i32;
                    *ptr34.add(44).cast::<i32>() = (proxy35).take_handle() as i32;
                    *ptr34.add(48).cast::<i32>() = (ssh_session_log35).take_handle() as i32;
                    *ptr34.add(52).cast::<i32>() = (tls_decrypt_enabled35).take_handle() as i32;
                    *ptr34.add(56).cast::<i32>() =
                        (url_browser_isolation_enabled35).take_handle() as i32;
                    ptr34
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_teams_account_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/teams-account@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_teams_account_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 60]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 60]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod teams_list {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub description: &'a Output,
                    pub items: &'a Output,
                    pub name: &'a Output,
                    pub type_: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("description", &self.description)
                            .field("items", &self.items)
                            .field("name", &self.name)
                            .field("type", &self.type_)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub description: Output,
                    pub items: Output,
                    pub name: Output,
                    pub type_: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("description", &self.description)
                            .field("items", &self.items)
                            .field("name", &self.name)
                            .field("type", &self.type_)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result6 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            description: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            items: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            name: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            type_: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                        },
                    );
                    let ptr7 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id8,
                        description: description8,
                        items: items8,
                        name: name8,
                        type_: type_8,
                    } = result6;
                    *ptr7.add(0).cast::<i32>() = (account_id8).take_handle() as i32;
                    *ptr7.add(4).cast::<i32>() = (description8).take_handle() as i32;
                    *ptr7.add(8).cast::<i32>() = (items8).take_handle() as i32;
                    *ptr7.add(12).cast::<i32>() = (name8).take_handle() as i32;
                    *ptr7.add(16).cast::<i32>() = (type_8).take_handle() as i32;
                    ptr7
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_teams_list_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/teams-list@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_teams_list_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 20]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 20]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod teams_location {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub client_default: &'a Output,
                    pub name: &'a Output,
                    pub networks: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("client-default", &self.client_default)
                            .field("name", &self.name)
                            .field("networks", &self.networks)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub anonymized_logs_enabled: Output,
                    pub client_default: Output,
                    pub doh_subdomain: Output,
                    pub ip: Output,
                    pub ipv4_destination: Output,
                    pub name: Output,
                    pub networks: Output,
                    pub policy_ids: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("anonymized-logs-enabled", &self.anonymized_logs_enabled)
                            .field("client-default", &self.client_default)
                            .field("doh-subdomain", &self.doh_subdomain)
                            .field("ip", &self.ip)
                            .field("ipv4-destination", &self.ipv4_destination)
                            .field("name", &self.name)
                            .field("networks", &self.networks)
                            .field("policy-ids", &self.policy_ids)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result5 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            client_default: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            name: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            networks: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                        },
                    );
                    let ptr6 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id7,
                        anonymized_logs_enabled: anonymized_logs_enabled7,
                        client_default: client_default7,
                        doh_subdomain: doh_subdomain7,
                        ip: ip7,
                        ipv4_destination: ipv4_destination7,
                        name: name7,
                        networks: networks7,
                        policy_ids: policy_ids7,
                    } = result5;
                    *ptr6.add(0).cast::<i32>() = (account_id7).take_handle() as i32;
                    *ptr6.add(4).cast::<i32>() = (anonymized_logs_enabled7).take_handle() as i32;
                    *ptr6.add(8).cast::<i32>() = (client_default7).take_handle() as i32;
                    *ptr6.add(12).cast::<i32>() = (doh_subdomain7).take_handle() as i32;
                    *ptr6.add(16).cast::<i32>() = (ip7).take_handle() as i32;
                    *ptr6.add(20).cast::<i32>() = (ipv4_destination7).take_handle() as i32;
                    *ptr6.add(24).cast::<i32>() = (name7).take_handle() as i32;
                    *ptr6.add(28).cast::<i32>() = (networks7).take_handle() as i32;
                    *ptr6.add(32).cast::<i32>() = (policy_ids7).take_handle() as i32;
                    ptr6
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_teams_location_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/teams-location@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_teams_location_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 36]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 36]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod teams_proxy_endpoint {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub ips: &'a Output,
                    pub name: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("ips", &self.ips)
                            .field("name", &self.name)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub ips: Output,
                    pub name: Output,
                    pub subdomain: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("ips", &self.ips)
                            .field("name", &self.name)
                            .field("subdomain", &self.subdomain)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result4 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            ips: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            name: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                        },
                    );
                    let ptr5 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id6,
                        ips: ips6,
                        name: name6,
                        subdomain: subdomain6,
                    } = result4;
                    *ptr5.add(0).cast::<i32>() = (account_id6).take_handle() as i32;
                    *ptr5.add(4).cast::<i32>() = (ips6).take_handle() as i32;
                    *ptr5.add(8).cast::<i32>() = (name6).take_handle() as i32;
                    *ptr5.add(12).cast::<i32>() = (subdomain6).take_handle() as i32;
                    ptr5
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_teams_proxy_endpoint_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/teams-proxy-endpoint@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_teams_proxy_endpoint_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod teams_rule {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub action: &'a Output,
                    pub description: &'a Output,
                    pub device_posture: &'a Output,
                    pub enabled: &'a Output,
                    pub filters: &'a Output,
                    pub identity: &'a Output,
                    pub name: &'a Output,
                    pub precedence: &'a Output,
                    pub rule_settings: &'a Output,
                    pub traffic: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("action", &self.action)
                            .field("description", &self.description)
                            .field("device-posture", &self.device_posture)
                            .field("enabled", &self.enabled)
                            .field("filters", &self.filters)
                            .field("identity", &self.identity)
                            .field("name", &self.name)
                            .field("precedence", &self.precedence)
                            .field("rule-settings", &self.rule_settings)
                            .field("traffic", &self.traffic)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub action: Output,
                    pub description: Output,
                    pub device_posture: Output,
                    pub enabled: Output,
                    pub filters: Output,
                    pub identity: Output,
                    pub name: Output,
                    pub precedence: Output,
                    pub rule_settings: Output,
                    pub traffic: Output,
                    pub version: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("action", &self.action)
                            .field("description", &self.description)
                            .field("device-posture", &self.device_posture)
                            .field("enabled", &self.enabled)
                            .field("filters", &self.filters)
                            .field("identity", &self.identity)
                            .field("name", &self.name)
                            .field("precedence", &self.precedence)
                            .field("rule-settings", &self.rule_settings)
                            .field("traffic", &self.traffic)
                            .field("version", &self.version)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                    arg11: i32,
                    arg12: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let handle7;
                    let handle8;
                    let handle9;
                    let handle10;
                    let handle11;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result12 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            action: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            description: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            device_posture: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            enabled: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            filters: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                            identity: {
                                handle7 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg8 as u32);
                                &handle7
                            },
                            name: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg9 as u32);
                                &handle8
                            },
                            precedence: {
                                handle9 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg10 as u32);
                                &handle9
                            },
                            rule_settings: {
                                handle10 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg11 as u32);
                                &handle10
                            },
                            traffic: {
                                handle11 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg12 as u32);
                                &handle11
                            },
                        },
                    );
                    let ptr13 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id14,
                        action: action14,
                        description: description14,
                        device_posture: device_posture14,
                        enabled: enabled14,
                        filters: filters14,
                        identity: identity14,
                        name: name14,
                        precedence: precedence14,
                        rule_settings: rule_settings14,
                        traffic: traffic14,
                        version: version14,
                    } = result12;
                    *ptr13.add(0).cast::<i32>() = (account_id14).take_handle() as i32;
                    *ptr13.add(4).cast::<i32>() = (action14).take_handle() as i32;
                    *ptr13.add(8).cast::<i32>() = (description14).take_handle() as i32;
                    *ptr13.add(12).cast::<i32>() = (device_posture14).take_handle() as i32;
                    *ptr13.add(16).cast::<i32>() = (enabled14).take_handle() as i32;
                    *ptr13.add(20).cast::<i32>() = (filters14).take_handle() as i32;
                    *ptr13.add(24).cast::<i32>() = (identity14).take_handle() as i32;
                    *ptr13.add(28).cast::<i32>() = (name14).take_handle() as i32;
                    *ptr13.add(32).cast::<i32>() = (precedence14).take_handle() as i32;
                    *ptr13.add(36).cast::<i32>() = (rule_settings14).take_handle() as i32;
                    *ptr13.add(40).cast::<i32>() = (traffic14).take_handle() as i32;
                    *ptr13.add(44).cast::<i32>() = (version14).take_handle() as i32;
                    ptr13
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_teams_rule_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/teams-rule@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,arg9: i32,arg10: i32,arg11: i32,arg12: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_teams_rule_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 48]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 48]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod tiered_cache {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub cache_type: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("cache-type", &self.cache_type)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub cache_type: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("cache-type", &self.cache_type)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result3 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            cache_type: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            zone_id: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                        },
                    );
                    let ptr4 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        cache_type: cache_type5,
                        zone_id: zone_id5,
                    } = result3;
                    *ptr4.add(0).cast::<i32>() = (cache_type5).take_handle() as i32;
                    *ptr4.add(4).cast::<i32>() = (zone_id5).take_handle() as i32;
                    ptr4
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_tiered_cache_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/tiered-cache@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_tiered_cache_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 8]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod total_tls {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub certificate_authority: &'a Output,
                    pub enabled: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("certificate-authority", &self.certificate_authority)
                            .field("enabled", &self.enabled)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub certificate_authority: Output,
                    pub enabled: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("certificate-authority", &self.certificate_authority)
                            .field("enabled", &self.enabled)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result4 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            certificate_authority: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            enabled: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            zone_id: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                        },
                    );
                    let ptr5 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        certificate_authority: certificate_authority6,
                        enabled: enabled6,
                        zone_id: zone_id6,
                    } = result4;
                    *ptr5.add(0).cast::<i32>() = (certificate_authority6).take_handle() as i32;
                    *ptr5.add(4).cast::<i32>() = (enabled6).take_handle() as i32;
                    *ptr5.add(8).cast::<i32>() = (zone_id6).take_handle() as i32;
                    ptr5
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_total_tls_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/total-tls@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_total_tls_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod tunnel {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub config_src: &'a Output,
                    pub name: &'a Output,
                    pub secret: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("config-src", &self.config_src)
                            .field("name", &self.name)
                            .field("secret", &self.secret)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub cname: Output,
                    pub config_src: Output,
                    pub name: Output,
                    pub secret: Output,
                    pub tunnel_token: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("cname", &self.cname)
                            .field("config-src", &self.config_src)
                            .field("name", &self.name)
                            .field("secret", &self.secret)
                            .field("tunnel-token", &self.tunnel_token)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result5 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            config_src: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            name: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            secret: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                        },
                    );
                    let ptr6 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id7,
                        cname: cname7,
                        config_src: config_src7,
                        name: name7,
                        secret: secret7,
                        tunnel_token: tunnel_token7,
                    } = result5;
                    *ptr6.add(0).cast::<i32>() = (account_id7).take_handle() as i32;
                    *ptr6.add(4).cast::<i32>() = (cname7).take_handle() as i32;
                    *ptr6.add(8).cast::<i32>() = (config_src7).take_handle() as i32;
                    *ptr6.add(12).cast::<i32>() = (name7).take_handle() as i32;
                    *ptr6.add(16).cast::<i32>() = (secret7).take_handle() as i32;
                    *ptr6.add(20).cast::<i32>() = (tunnel_token7).take_handle() as i32;
                    ptr6
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_tunnel_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/tunnel@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_tunnel_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 24]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 24]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod tunnel_config {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub config: &'a Output,
                    pub tunnel_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("config", &self.config)
                            .field("tunnel-id", &self.tunnel_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub config: Output,
                    pub tunnel_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("config", &self.config)
                            .field("tunnel-id", &self.tunnel_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result4 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            config: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            tunnel_id: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                        },
                    );
                    let ptr5 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id6,
                        config: config6,
                        tunnel_id: tunnel_id6,
                    } = result4;
                    *ptr5.add(0).cast::<i32>() = (account_id6).take_handle() as i32;
                    *ptr5.add(4).cast::<i32>() = (config6).take_handle() as i32;
                    *ptr5.add(8).cast::<i32>() = (tunnel_id6).take_handle() as i32;
                    ptr5
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_tunnel_config_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/tunnel-config@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_tunnel_config_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod tunnel_route {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub comment: &'a Output,
                    pub network: &'a Output,
                    pub tunnel_id: &'a Output,
                    pub virtual_network_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("comment", &self.comment)
                            .field("network", &self.network)
                            .field("tunnel-id", &self.tunnel_id)
                            .field("virtual-network-id", &self.virtual_network_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub comment: Output,
                    pub network: Output,
                    pub tunnel_id: Output,
                    pub virtual_network_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("comment", &self.comment)
                            .field("network", &self.network)
                            .field("tunnel-id", &self.tunnel_id)
                            .field("virtual-network-id", &self.virtual_network_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result6 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            comment: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            network: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            tunnel_id: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            virtual_network_id: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                        },
                    );
                    let ptr7 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id8,
                        comment: comment8,
                        network: network8,
                        tunnel_id: tunnel_id8,
                        virtual_network_id: virtual_network_id8,
                    } = result6;
                    *ptr7.add(0).cast::<i32>() = (account_id8).take_handle() as i32;
                    *ptr7.add(4).cast::<i32>() = (comment8).take_handle() as i32;
                    *ptr7.add(8).cast::<i32>() = (network8).take_handle() as i32;
                    *ptr7.add(12).cast::<i32>() = (tunnel_id8).take_handle() as i32;
                    *ptr7.add(16).cast::<i32>() = (virtual_network_id8).take_handle() as i32;
                    ptr7
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_tunnel_route_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/tunnel-route@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_tunnel_route_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 20]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 20]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod tunnel_virtual_network {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub comment: &'a Output,
                    pub is_default_network: &'a Output,
                    pub name: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("comment", &self.comment)
                            .field("is-default-network", &self.is_default_network)
                            .field("name", &self.name)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub comment: Output,
                    pub is_default_network: Output,
                    pub name: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("comment", &self.comment)
                            .field("is-default-network", &self.is_default_network)
                            .field("name", &self.name)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result5 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            comment: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            is_default_network: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            name: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                        },
                    );
                    let ptr6 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id7,
                        comment: comment7,
                        is_default_network: is_default_network7,
                        name: name7,
                    } = result5;
                    *ptr6.add(0).cast::<i32>() = (account_id7).take_handle() as i32;
                    *ptr6.add(4).cast::<i32>() = (comment7).take_handle() as i32;
                    *ptr6.add(8).cast::<i32>() = (is_default_network7).take_handle() as i32;
                    *ptr6.add(12).cast::<i32>() = (name7).take_handle() as i32;
                    ptr6
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_tunnel_virtual_network_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/tunnel-virtual-network@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_tunnel_virtual_network_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod turnstile_widget {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub bot_fight_mode: &'a Output,
                    pub domains: &'a Output,
                    pub mode: &'a Output,
                    pub name: &'a Output,
                    pub offlabel: &'a Output,
                    pub region: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("bot-fight-mode", &self.bot_fight_mode)
                            .field("domains", &self.domains)
                            .field("mode", &self.mode)
                            .field("name", &self.name)
                            .field("offlabel", &self.offlabel)
                            .field("region", &self.region)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub bot_fight_mode: Output,
                    pub domains: Output,
                    pub mode: Output,
                    pub name: Output,
                    pub offlabel: Output,
                    pub region: Output,
                    pub secret: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("bot-fight-mode", &self.bot_fight_mode)
                            .field("domains", &self.domains)
                            .field("mode", &self.mode)
                            .field("name", &self.name)
                            .field("offlabel", &self.offlabel)
                            .field("region", &self.region)
                            .field("secret", &self.secret)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let handle7;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result8 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            bot_fight_mode: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            domains: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            mode: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            name: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            offlabel: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                            region: {
                                handle7 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg8 as u32);
                                &handle7
                            },
                        },
                    );
                    let ptr9 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id10,
                        bot_fight_mode: bot_fight_mode10,
                        domains: domains10,
                        mode: mode10,
                        name: name10,
                        offlabel: offlabel10,
                        region: region10,
                        secret: secret10,
                    } = result8;
                    *ptr9.add(0).cast::<i32>() = (account_id10).take_handle() as i32;
                    *ptr9.add(4).cast::<i32>() = (bot_fight_mode10).take_handle() as i32;
                    *ptr9.add(8).cast::<i32>() = (domains10).take_handle() as i32;
                    *ptr9.add(12).cast::<i32>() = (mode10).take_handle() as i32;
                    *ptr9.add(16).cast::<i32>() = (name10).take_handle() as i32;
                    *ptr9.add(20).cast::<i32>() = (offlabel10).take_handle() as i32;
                    *ptr9.add(24).cast::<i32>() = (region10).take_handle() as i32;
                    *ptr9.add(28).cast::<i32>() = (secret10).take_handle() as i32;
                    ptr9
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_turnstile_widget_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/turnstile-widget@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_turnstile_widget_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 32]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 32]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod url_normalization_settings {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub scope: &'a Output,
                    pub type_: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("scope", &self.scope)
                            .field("type", &self.type_)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub scope: Output,
                    pub type_: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("scope", &self.scope)
                            .field("type", &self.type_)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result4 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            scope: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            type_: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            zone_id: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                        },
                    );
                    let ptr5 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        scope: scope6,
                        type_: type_6,
                        zone_id: zone_id6,
                    } = result4;
                    *ptr5.add(0).cast::<i32>() = (scope6).take_handle() as i32;
                    *ptr5.add(4).cast::<i32>() = (type_6).take_handle() as i32;
                    *ptr5.add(8).cast::<i32>() = (zone_id6).take_handle() as i32;
                    ptr5
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_url_normalization_settings_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/url-normalization-settings@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_url_normalization_settings_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod user_agent_blocking_rule {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub configuration: &'a Output,
                    pub description: &'a Output,
                    pub mode: &'a Output,
                    pub paused: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("configuration", &self.configuration)
                            .field("description", &self.description)
                            .field("mode", &self.mode)
                            .field("paused", &self.paused)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub configuration: Output,
                    pub description: Output,
                    pub mode: Output,
                    pub paused: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("configuration", &self.configuration)
                            .field("description", &self.description)
                            .field("mode", &self.mode)
                            .field("paused", &self.paused)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result6 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            configuration: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            description: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            mode: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            paused: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            zone_id: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                        },
                    );
                    let ptr7 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        configuration: configuration8,
                        description: description8,
                        mode: mode8,
                        paused: paused8,
                        zone_id: zone_id8,
                    } = result6;
                    *ptr7.add(0).cast::<i32>() = (configuration8).take_handle() as i32;
                    *ptr7.add(4).cast::<i32>() = (description8).take_handle() as i32;
                    *ptr7.add(8).cast::<i32>() = (mode8).take_handle() as i32;
                    *ptr7.add(12).cast::<i32>() = (paused8).take_handle() as i32;
                    *ptr7.add(16).cast::<i32>() = (zone_id8).take_handle() as i32;
                    ptr7
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_user_agent_blocking_rule_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/user-agent-blocking-rule@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_user_agent_blocking_rule_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 20]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 20]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod waiting_room {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub additional_routes: &'a Output,
                    pub cookie_suffix: &'a Output,
                    pub custom_page_html: &'a Output,
                    pub default_template_language: &'a Output,
                    pub description: &'a Output,
                    pub disable_session_renewal: &'a Output,
                    pub host: &'a Output,
                    pub json_response_enabled: &'a Output,
                    pub name: &'a Output,
                    pub new_users_per_minute: &'a Output,
                    pub path: &'a Output,
                    pub queue_all: &'a Output,
                    pub queueing_method: &'a Output,
                    pub queueing_status_code: &'a Output,
                    pub session_duration: &'a Output,
                    pub suspended: &'a Output,
                    pub total_active_users: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("additional-routes", &self.additional_routes)
                            .field("cookie-suffix", &self.cookie_suffix)
                            .field("custom-page-html", &self.custom_page_html)
                            .field("default-template-language", &self.default_template_language)
                            .field("description", &self.description)
                            .field("disable-session-renewal", &self.disable_session_renewal)
                            .field("host", &self.host)
                            .field("json-response-enabled", &self.json_response_enabled)
                            .field("name", &self.name)
                            .field("new-users-per-minute", &self.new_users_per_minute)
                            .field("path", &self.path)
                            .field("queue-all", &self.queue_all)
                            .field("queueing-method", &self.queueing_method)
                            .field("queueing-status-code", &self.queueing_status_code)
                            .field("session-duration", &self.session_duration)
                            .field("suspended", &self.suspended)
                            .field("total-active-users", &self.total_active_users)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub additional_routes: Output,
                    pub cookie_suffix: Output,
                    pub custom_page_html: Output,
                    pub default_template_language: Output,
                    pub description: Output,
                    pub disable_session_renewal: Output,
                    pub host: Output,
                    pub json_response_enabled: Output,
                    pub name: Output,
                    pub new_users_per_minute: Output,
                    pub path: Output,
                    pub queue_all: Output,
                    pub queueing_method: Output,
                    pub queueing_status_code: Output,
                    pub session_duration: Output,
                    pub suspended: Output,
                    pub total_active_users: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("additional-routes", &self.additional_routes)
                            .field("cookie-suffix", &self.cookie_suffix)
                            .field("custom-page-html", &self.custom_page_html)
                            .field("default-template-language", &self.default_template_language)
                            .field("description", &self.description)
                            .field("disable-session-renewal", &self.disable_session_renewal)
                            .field("host", &self.host)
                            .field("json-response-enabled", &self.json_response_enabled)
                            .field("name", &self.name)
                            .field("new-users-per-minute", &self.new_users_per_minute)
                            .field("path", &self.path)
                            .field("queue-all", &self.queue_all)
                            .field("queueing-method", &self.queueing_method)
                            .field("queueing-status-code", &self.queueing_status_code)
                            .field("session-duration", &self.session_duration)
                            .field("suspended", &self.suspended)
                            .field("total-active-users", &self.total_active_users)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle4;
                    let handle6;
                    let handle8;
                    let handle10;
                    let handle12;
                    let handle14;
                    let handle16;
                    let handle18;
                    let handle20;
                    let handle22;
                    let handle24;
                    let handle26;
                    let handle28;
                    let handle30;
                    let handle32;
                    let handle34;
                    let handle36;
                    let handle38;
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let len2 = l1;
                    let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                    let l3 = *arg0.add(8).cast::<i32>();
                    let l5 = *arg0.add(12).cast::<i32>();
                    let l7 = *arg0.add(16).cast::<i32>();
                    let l9 = *arg0.add(20).cast::<i32>();
                    let l11 = *arg0.add(24).cast::<i32>();
                    let l13 = *arg0.add(28).cast::<i32>();
                    let l15 = *arg0.add(32).cast::<i32>();
                    let l17 = *arg0.add(36).cast::<i32>();
                    let l19 = *arg0.add(40).cast::<i32>();
                    let l21 = *arg0.add(44).cast::<i32>();
                    let l23 = *arg0.add(48).cast::<i32>();
                    let l25 = *arg0.add(52).cast::<i32>();
                    let l27 = *arg0.add(56).cast::<i32>();
                    let l29 = *arg0.add(60).cast::<i32>();
                    let l31 = *arg0.add(64).cast::<i32>();
                    let l33 = *arg0.add(68).cast::<i32>();
                    let l35 = *arg0.add(72).cast::<i32>();
                    let l37 = *arg0.add(76).cast::<i32>();
                    let result39 = T::invoke(
                        _rt::string_lift(bytes2),
                        Args {
                            additional_routes: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l3 as u32);
                                &handle4
                            },
                            cookie_suffix: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l5 as u32);
                                &handle6
                            },
                            custom_page_html: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l7 as u32);
                                &handle8
                            },
                            default_template_language: {
                                handle10 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l9 as u32);
                                &handle10
                            },
                            description: {
                                handle12 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l11 as u32);
                                &handle12
                            },
                            disable_session_renewal: {
                                handle14 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l13 as u32);
                                &handle14
                            },
                            host: {
                                handle16 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l15 as u32);
                                &handle16
                            },
                            json_response_enabled: {
                                handle18 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l17 as u32);
                                &handle18
                            },
                            name: {
                                handle20 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l19 as u32);
                                &handle20
                            },
                            new_users_per_minute: {
                                handle22 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l21 as u32);
                                &handle22
                            },
                            path: {
                                handle24 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l23 as u32);
                                &handle24
                            },
                            queue_all: {
                                handle26 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l25 as u32);
                                &handle26
                            },
                            queueing_method: {
                                handle28 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l27 as u32);
                                &handle28
                            },
                            queueing_status_code: {
                                handle30 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l29 as u32);
                                &handle30
                            },
                            session_duration: {
                                handle32 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l31 as u32);
                                &handle32
                            },
                            suspended: {
                                handle34 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l33 as u32);
                                &handle34
                            },
                            total_active_users: {
                                handle36 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l35 as u32);
                                &handle36
                            },
                            zone_id: {
                                handle38 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l37 as u32);
                                &handle38
                            },
                        },
                    );
                    _rt::cabi_dealloc(arg0, 80, 4);
                    let ptr40 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        additional_routes: additional_routes41,
                        cookie_suffix: cookie_suffix41,
                        custom_page_html: custom_page_html41,
                        default_template_language: default_template_language41,
                        description: description41,
                        disable_session_renewal: disable_session_renewal41,
                        host: host41,
                        json_response_enabled: json_response_enabled41,
                        name: name41,
                        new_users_per_minute: new_users_per_minute41,
                        path: path41,
                        queue_all: queue_all41,
                        queueing_method: queueing_method41,
                        queueing_status_code: queueing_status_code41,
                        session_duration: session_duration41,
                        suspended: suspended41,
                        total_active_users: total_active_users41,
                        zone_id: zone_id41,
                    } = result39;
                    *ptr40.add(0).cast::<i32>() = (additional_routes41).take_handle() as i32;
                    *ptr40.add(4).cast::<i32>() = (cookie_suffix41).take_handle() as i32;
                    *ptr40.add(8).cast::<i32>() = (custom_page_html41).take_handle() as i32;
                    *ptr40.add(12).cast::<i32>() =
                        (default_template_language41).take_handle() as i32;
                    *ptr40.add(16).cast::<i32>() = (description41).take_handle() as i32;
                    *ptr40.add(20).cast::<i32>() = (disable_session_renewal41).take_handle() as i32;
                    *ptr40.add(24).cast::<i32>() = (host41).take_handle() as i32;
                    *ptr40.add(28).cast::<i32>() = (json_response_enabled41).take_handle() as i32;
                    *ptr40.add(32).cast::<i32>() = (name41).take_handle() as i32;
                    *ptr40.add(36).cast::<i32>() = (new_users_per_minute41).take_handle() as i32;
                    *ptr40.add(40).cast::<i32>() = (path41).take_handle() as i32;
                    *ptr40.add(44).cast::<i32>() = (queue_all41).take_handle() as i32;
                    *ptr40.add(48).cast::<i32>() = (queueing_method41).take_handle() as i32;
                    *ptr40.add(52).cast::<i32>() = (queueing_status_code41).take_handle() as i32;
                    *ptr40.add(56).cast::<i32>() = (session_duration41).take_handle() as i32;
                    *ptr40.add(60).cast::<i32>() = (suspended41).take_handle() as i32;
                    *ptr40.add(64).cast::<i32>() = (total_active_users41).take_handle() as i32;
                    *ptr40.add(68).cast::<i32>() = (zone_id41).take_handle() as i32;
                    ptr40
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_waiting_room_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/waiting-room@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_waiting_room_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 72]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 72]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod waiting_room_event {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub custom_page_html: &'a Output,
                    pub description: &'a Output,
                    pub disable_session_renewal: &'a Output,
                    pub event_end_time: &'a Output,
                    pub event_start_time: &'a Output,
                    pub name: &'a Output,
                    pub new_users_per_minute: &'a Output,
                    pub prequeue_start_time: &'a Output,
                    pub queueing_method: &'a Output,
                    pub session_duration: &'a Output,
                    pub shuffle_at_event_start: &'a Output,
                    pub suspended: &'a Output,
                    pub total_active_users: &'a Output,
                    pub waiting_room_id: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("custom-page-html", &self.custom_page_html)
                            .field("description", &self.description)
                            .field("disable-session-renewal", &self.disable_session_renewal)
                            .field("event-end-time", &self.event_end_time)
                            .field("event-start-time", &self.event_start_time)
                            .field("name", &self.name)
                            .field("new-users-per-minute", &self.new_users_per_minute)
                            .field("prequeue-start-time", &self.prequeue_start_time)
                            .field("queueing-method", &self.queueing_method)
                            .field("session-duration", &self.session_duration)
                            .field("shuffle-at-event-start", &self.shuffle_at_event_start)
                            .field("suspended", &self.suspended)
                            .field("total-active-users", &self.total_active_users)
                            .field("waiting-room-id", &self.waiting_room_id)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub created_on: Output,
                    pub custom_page_html: Output,
                    pub description: Output,
                    pub disable_session_renewal: Output,
                    pub event_end_time: Output,
                    pub event_start_time: Output,
                    pub modified_on: Output,
                    pub name: Output,
                    pub new_users_per_minute: Output,
                    pub prequeue_start_time: Output,
                    pub queueing_method: Output,
                    pub session_duration: Output,
                    pub shuffle_at_event_start: Output,
                    pub suspended: Output,
                    pub total_active_users: Output,
                    pub waiting_room_id: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("created-on", &self.created_on)
                            .field("custom-page-html", &self.custom_page_html)
                            .field("description", &self.description)
                            .field("disable-session-renewal", &self.disable_session_renewal)
                            .field("event-end-time", &self.event_end_time)
                            .field("event-start-time", &self.event_start_time)
                            .field("modified-on", &self.modified_on)
                            .field("name", &self.name)
                            .field("new-users-per-minute", &self.new_users_per_minute)
                            .field("prequeue-start-time", &self.prequeue_start_time)
                            .field("queueing-method", &self.queueing_method)
                            .field("session-duration", &self.session_duration)
                            .field("shuffle-at-event-start", &self.shuffle_at_event_start)
                            .field("suspended", &self.suspended)
                            .field("total-active-users", &self.total_active_users)
                            .field("waiting-room-id", &self.waiting_room_id)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle4;
                    let handle6;
                    let handle8;
                    let handle10;
                    let handle12;
                    let handle14;
                    let handle16;
                    let handle18;
                    let handle20;
                    let handle22;
                    let handle24;
                    let handle26;
                    let handle28;
                    let handle30;
                    let handle32;
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let len2 = l1;
                    let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                    let l3 = *arg0.add(8).cast::<i32>();
                    let l5 = *arg0.add(12).cast::<i32>();
                    let l7 = *arg0.add(16).cast::<i32>();
                    let l9 = *arg0.add(20).cast::<i32>();
                    let l11 = *arg0.add(24).cast::<i32>();
                    let l13 = *arg0.add(28).cast::<i32>();
                    let l15 = *arg0.add(32).cast::<i32>();
                    let l17 = *arg0.add(36).cast::<i32>();
                    let l19 = *arg0.add(40).cast::<i32>();
                    let l21 = *arg0.add(44).cast::<i32>();
                    let l23 = *arg0.add(48).cast::<i32>();
                    let l25 = *arg0.add(52).cast::<i32>();
                    let l27 = *arg0.add(56).cast::<i32>();
                    let l29 = *arg0.add(60).cast::<i32>();
                    let l31 = *arg0.add(64).cast::<i32>();
                    let result33 = T::invoke(
                        _rt::string_lift(bytes2),
                        Args {
                            custom_page_html: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l3 as u32);
                                &handle4
                            },
                            description: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l5 as u32);
                                &handle6
                            },
                            disable_session_renewal: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l7 as u32);
                                &handle8
                            },
                            event_end_time: {
                                handle10 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l9 as u32);
                                &handle10
                            },
                            event_start_time: {
                                handle12 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l11 as u32);
                                &handle12
                            },
                            name: {
                                handle14 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l13 as u32);
                                &handle14
                            },
                            new_users_per_minute: {
                                handle16 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l15 as u32);
                                &handle16
                            },
                            prequeue_start_time: {
                                handle18 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l17 as u32);
                                &handle18
                            },
                            queueing_method: {
                                handle20 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l19 as u32);
                                &handle20
                            },
                            session_duration: {
                                handle22 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l21 as u32);
                                &handle22
                            },
                            shuffle_at_event_start: {
                                handle24 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l23 as u32);
                                &handle24
                            },
                            suspended: {
                                handle26 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l25 as u32);
                                &handle26
                            },
                            total_active_users: {
                                handle28 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l27 as u32);
                                &handle28
                            },
                            waiting_room_id: {
                                handle30 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l29 as u32);
                                &handle30
                            },
                            zone_id: {
                                handle32 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l31 as u32);
                                &handle32
                            },
                        },
                    );
                    _rt::cabi_dealloc(arg0, 68, 4);
                    let ptr34 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        created_on: created_on35,
                        custom_page_html: custom_page_html35,
                        description: description35,
                        disable_session_renewal: disable_session_renewal35,
                        event_end_time: event_end_time35,
                        event_start_time: event_start_time35,
                        modified_on: modified_on35,
                        name: name35,
                        new_users_per_minute: new_users_per_minute35,
                        prequeue_start_time: prequeue_start_time35,
                        queueing_method: queueing_method35,
                        session_duration: session_duration35,
                        shuffle_at_event_start: shuffle_at_event_start35,
                        suspended: suspended35,
                        total_active_users: total_active_users35,
                        waiting_room_id: waiting_room_id35,
                        zone_id: zone_id35,
                    } = result33;
                    *ptr34.add(0).cast::<i32>() = (created_on35).take_handle() as i32;
                    *ptr34.add(4).cast::<i32>() = (custom_page_html35).take_handle() as i32;
                    *ptr34.add(8).cast::<i32>() = (description35).take_handle() as i32;
                    *ptr34.add(12).cast::<i32>() = (disable_session_renewal35).take_handle() as i32;
                    *ptr34.add(16).cast::<i32>() = (event_end_time35).take_handle() as i32;
                    *ptr34.add(20).cast::<i32>() = (event_start_time35).take_handle() as i32;
                    *ptr34.add(24).cast::<i32>() = (modified_on35).take_handle() as i32;
                    *ptr34.add(28).cast::<i32>() = (name35).take_handle() as i32;
                    *ptr34.add(32).cast::<i32>() = (new_users_per_minute35).take_handle() as i32;
                    *ptr34.add(36).cast::<i32>() = (prequeue_start_time35).take_handle() as i32;
                    *ptr34.add(40).cast::<i32>() = (queueing_method35).take_handle() as i32;
                    *ptr34.add(44).cast::<i32>() = (session_duration35).take_handle() as i32;
                    *ptr34.add(48).cast::<i32>() = (shuffle_at_event_start35).take_handle() as i32;
                    *ptr34.add(52).cast::<i32>() = (suspended35).take_handle() as i32;
                    *ptr34.add(56).cast::<i32>() = (total_active_users35).take_handle() as i32;
                    *ptr34.add(60).cast::<i32>() = (waiting_room_id35).take_handle() as i32;
                    *ptr34.add(64).cast::<i32>() = (zone_id35).take_handle() as i32;
                    ptr34
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_waiting_room_event_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/waiting-room-event@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_waiting_room_event_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 68]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 68]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod waiting_room_rules {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub rules: &'a Output,
                    pub waiting_room_id: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("rules", &self.rules)
                            .field("waiting-room-id", &self.waiting_room_id)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub rules: Output,
                    pub waiting_room_id: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("rules", &self.rules)
                            .field("waiting-room-id", &self.waiting_room_id)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result4 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            rules: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            waiting_room_id: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            zone_id: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                        },
                    );
                    let ptr5 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        rules: rules6,
                        waiting_room_id: waiting_room_id6,
                        zone_id: zone_id6,
                    } = result4;
                    *ptr5.add(0).cast::<i32>() = (rules6).take_handle() as i32;
                    *ptr5.add(4).cast::<i32>() = (waiting_room_id6).take_handle() as i32;
                    *ptr5.add(8).cast::<i32>() = (zone_id6).take_handle() as i32;
                    ptr5
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_waiting_room_rules_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/waiting-room-rules@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_waiting_room_rules_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod waiting_room_settings {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub search_engine_crawler_bypass: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field(
                                "search-engine-crawler-bypass",
                                &self.search_engine_crawler_bypass,
                            )
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub search_engine_crawler_bypass: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field(
                                "search-engine-crawler-bypass",
                                &self.search_engine_crawler_bypass,
                            )
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result3 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            search_engine_crawler_bypass: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            zone_id: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                        },
                    );
                    let ptr4 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        search_engine_crawler_bypass: search_engine_crawler_bypass5,
                        zone_id: zone_id5,
                    } = result3;
                    *ptr4.add(0).cast::<i32>() =
                        (search_engine_crawler_bypass5).take_handle() as i32;
                    *ptr4.add(4).cast::<i32>() = (zone_id5).take_handle() as i32;
                    ptr4
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_waiting_room_settings_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/waiting-room-settings@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_waiting_room_settings_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 8]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod web3_hostname {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub description: &'a Output,
                    pub dnslink: &'a Output,
                    pub name: &'a Output,
                    pub target: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("description", &self.description)
                            .field("dnslink", &self.dnslink)
                            .field("name", &self.name)
                            .field("target", &self.target)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub created_on: Output,
                    pub description: Output,
                    pub dnslink: Output,
                    pub modified_on: Output,
                    pub name: Output,
                    pub status: Output,
                    pub target: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("created-on", &self.created_on)
                            .field("description", &self.description)
                            .field("dnslink", &self.dnslink)
                            .field("modified-on", &self.modified_on)
                            .field("name", &self.name)
                            .field("status", &self.status)
                            .field("target", &self.target)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result6 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            description: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            dnslink: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            name: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            target: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            zone_id: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                        },
                    );
                    let ptr7 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        created_on: created_on8,
                        description: description8,
                        dnslink: dnslink8,
                        modified_on: modified_on8,
                        name: name8,
                        status: status8,
                        target: target8,
                        zone_id: zone_id8,
                    } = result6;
                    *ptr7.add(0).cast::<i32>() = (created_on8).take_handle() as i32;
                    *ptr7.add(4).cast::<i32>() = (description8).take_handle() as i32;
                    *ptr7.add(8).cast::<i32>() = (dnslink8).take_handle() as i32;
                    *ptr7.add(12).cast::<i32>() = (modified_on8).take_handle() as i32;
                    *ptr7.add(16).cast::<i32>() = (name8).take_handle() as i32;
                    *ptr7.add(20).cast::<i32>() = (status8).take_handle() as i32;
                    *ptr7.add(24).cast::<i32>() = (target8).take_handle() as i32;
                    *ptr7.add(28).cast::<i32>() = (zone_id8).take_handle() as i32;
                    ptr7
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_web3_hostname_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/web3-hostname@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_web3_hostname_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 32]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 32]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod web_analytics_rule {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub host: &'a Output,
                    pub inclusive: &'a Output,
                    pub is_paused: &'a Output,
                    pub paths: &'a Output,
                    pub ruleset_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("host", &self.host)
                            .field("inclusive", &self.inclusive)
                            .field("is-paused", &self.is_paused)
                            .field("paths", &self.paths)
                            .field("ruleset-id", &self.ruleset_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub host: Output,
                    pub inclusive: Output,
                    pub is_paused: Output,
                    pub paths: Output,
                    pub ruleset_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("host", &self.host)
                            .field("inclusive", &self.inclusive)
                            .field("is-paused", &self.is_paused)
                            .field("paths", &self.paths)
                            .field("ruleset-id", &self.ruleset_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result7 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            host: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            inclusive: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            is_paused: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            paths: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            ruleset_id: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                        },
                    );
                    let ptr8 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id9,
                        host: host9,
                        inclusive: inclusive9,
                        is_paused: is_paused9,
                        paths: paths9,
                        ruleset_id: ruleset_id9,
                    } = result7;
                    *ptr8.add(0).cast::<i32>() = (account_id9).take_handle() as i32;
                    *ptr8.add(4).cast::<i32>() = (host9).take_handle() as i32;
                    *ptr8.add(8).cast::<i32>() = (inclusive9).take_handle() as i32;
                    *ptr8.add(12).cast::<i32>() = (is_paused9).take_handle() as i32;
                    *ptr8.add(16).cast::<i32>() = (paths9).take_handle() as i32;
                    *ptr8.add(20).cast::<i32>() = (ruleset_id9).take_handle() as i32;
                    ptr8
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_web_analytics_rule_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/web-analytics-rule@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_web_analytics_rule_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 24]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 24]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod web_analytics_site {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub auto_install: &'a Output,
                    pub host: &'a Output,
                    pub zone_tag: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("auto-install", &self.auto_install)
                            .field("host", &self.host)
                            .field("zone-tag", &self.zone_tag)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub auto_install: Output,
                    pub host: Output,
                    pub ruleset_id: Output,
                    pub site_tag: Output,
                    pub site_token: Output,
                    pub snippet: Output,
                    pub zone_tag: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("auto-install", &self.auto_install)
                            .field("host", &self.host)
                            .field("ruleset-id", &self.ruleset_id)
                            .field("site-tag", &self.site_tag)
                            .field("site-token", &self.site_token)
                            .field("snippet", &self.snippet)
                            .field("zone-tag", &self.zone_tag)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result5 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            auto_install: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            host: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            zone_tag: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                        },
                    );
                    let ptr6 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id7,
                        auto_install: auto_install7,
                        host: host7,
                        ruleset_id: ruleset_id7,
                        site_tag: site_tag7,
                        site_token: site_token7,
                        snippet: snippet7,
                        zone_tag: zone_tag7,
                    } = result5;
                    *ptr6.add(0).cast::<i32>() = (account_id7).take_handle() as i32;
                    *ptr6.add(4).cast::<i32>() = (auto_install7).take_handle() as i32;
                    *ptr6.add(8).cast::<i32>() = (host7).take_handle() as i32;
                    *ptr6.add(12).cast::<i32>() = (ruleset_id7).take_handle() as i32;
                    *ptr6.add(16).cast::<i32>() = (site_tag7).take_handle() as i32;
                    *ptr6.add(20).cast::<i32>() = (site_token7).take_handle() as i32;
                    *ptr6.add(24).cast::<i32>() = (snippet7).take_handle() as i32;
                    *ptr6.add(28).cast::<i32>() = (zone_tag7).take_handle() as i32;
                    ptr6
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_web_analytics_site_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/web-analytics-site@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_web_analytics_site_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 32]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 32]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod worker_cron_trigger {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub schedules: &'a Output,
                    pub script_name: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("schedules", &self.schedules)
                            .field("script-name", &self.script_name)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub schedules: Output,
                    pub script_name: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("schedules", &self.schedules)
                            .field("script-name", &self.script_name)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result4 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            schedules: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            script_name: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                        },
                    );
                    let ptr5 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id6,
                        schedules: schedules6,
                        script_name: script_name6,
                    } = result4;
                    *ptr5.add(0).cast::<i32>() = (account_id6).take_handle() as i32;
                    *ptr5.add(4).cast::<i32>() = (schedules6).take_handle() as i32;
                    *ptr5.add(8).cast::<i32>() = (script_name6).take_handle() as i32;
                    ptr5
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_worker_cron_trigger_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/worker-cron-trigger@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_worker_cron_trigger_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod worker_domain {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub environment: &'a Output,
                    pub hostname: &'a Output,
                    pub service: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("environment", &self.environment)
                            .field("hostname", &self.hostname)
                            .field("service", &self.service)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub environment: Output,
                    pub hostname: Output,
                    pub service: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("environment", &self.environment)
                            .field("hostname", &self.hostname)
                            .field("service", &self.service)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result6 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            environment: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            hostname: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            service: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            zone_id: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                        },
                    );
                    let ptr7 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id8,
                        environment: environment8,
                        hostname: hostname8,
                        service: service8,
                        zone_id: zone_id8,
                    } = result6;
                    *ptr7.add(0).cast::<i32>() = (account_id8).take_handle() as i32;
                    *ptr7.add(4).cast::<i32>() = (environment8).take_handle() as i32;
                    *ptr7.add(8).cast::<i32>() = (hostname8).take_handle() as i32;
                    *ptr7.add(12).cast::<i32>() = (service8).take_handle() as i32;
                    *ptr7.add(16).cast::<i32>() = (zone_id8).take_handle() as i32;
                    ptr7
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_worker_domain_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/worker-domain@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_worker_domain_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 20]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 20]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod worker_route {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub pattern: &'a Output,
                    pub script_name: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("pattern", &self.pattern)
                            .field("script-name", &self.script_name)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub pattern: Output,
                    pub script_name: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("pattern", &self.pattern)
                            .field("script-name", &self.script_name)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result4 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            pattern: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            script_name: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            zone_id: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                        },
                    );
                    let ptr5 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        pattern: pattern6,
                        script_name: script_name6,
                        zone_id: zone_id6,
                    } = result4;
                    *ptr5.add(0).cast::<i32>() = (pattern6).take_handle() as i32;
                    *ptr5.add(4).cast::<i32>() = (script_name6).take_handle() as i32;
                    *ptr5.add(8).cast::<i32>() = (zone_id6).take_handle() as i32;
                    ptr5
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_worker_route_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/worker-route@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_worker_route_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 12]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod worker_script {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub analytics_engine_bindings: &'a Output,
                    pub compatibility_date: &'a Output,
                    pub compatibility_flags: &'a Output,
                    pub content: &'a Output,
                    pub d1_database_bindings: &'a Output,
                    pub dispatch_namespace: &'a Output,
                    pub kv_namespace_bindings: &'a Output,
                    pub logpush: &'a Output,
                    pub module: &'a Output,
                    pub name: &'a Output,
                    pub placements: &'a Output,
                    pub plain_text_bindings: &'a Output,
                    pub queue_bindings: &'a Output,
                    pub r2_bucket_bindings: &'a Output,
                    pub secret_text_bindings: &'a Output,
                    pub service_bindings: &'a Output,
                    pub tags: &'a Output,
                    pub webassembly_bindings: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("analytics-engine-bindings", &self.analytics_engine_bindings)
                            .field("compatibility-date", &self.compatibility_date)
                            .field("compatibility-flags", &self.compatibility_flags)
                            .field("content", &self.content)
                            .field("d1-database-bindings", &self.d1_database_bindings)
                            .field("dispatch-namespace", &self.dispatch_namespace)
                            .field("kv-namespace-bindings", &self.kv_namespace_bindings)
                            .field("logpush", &self.logpush)
                            .field("module", &self.module)
                            .field("name", &self.name)
                            .field("placements", &self.placements)
                            .field("plain-text-bindings", &self.plain_text_bindings)
                            .field("queue-bindings", &self.queue_bindings)
                            .field("r2-bucket-bindings", &self.r2_bucket_bindings)
                            .field("secret-text-bindings", &self.secret_text_bindings)
                            .field("service-bindings", &self.service_bindings)
                            .field("tags", &self.tags)
                            .field("webassembly-bindings", &self.webassembly_bindings)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub analytics_engine_bindings: Output,
                    pub compatibility_date: Output,
                    pub compatibility_flags: Output,
                    pub content: Output,
                    pub d1_database_bindings: Output,
                    pub dispatch_namespace: Output,
                    pub kv_namespace_bindings: Output,
                    pub logpush: Output,
                    pub module: Output,
                    pub name: Output,
                    pub placements: Output,
                    pub plain_text_bindings: Output,
                    pub queue_bindings: Output,
                    pub r2_bucket_bindings: Output,
                    pub secret_text_bindings: Output,
                    pub service_bindings: Output,
                    pub tags: Output,
                    pub webassembly_bindings: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("analytics-engine-bindings", &self.analytics_engine_bindings)
                            .field("compatibility-date", &self.compatibility_date)
                            .field("compatibility-flags", &self.compatibility_flags)
                            .field("content", &self.content)
                            .field("d1-database-bindings", &self.d1_database_bindings)
                            .field("dispatch-namespace", &self.dispatch_namespace)
                            .field("kv-namespace-bindings", &self.kv_namespace_bindings)
                            .field("logpush", &self.logpush)
                            .field("module", &self.module)
                            .field("name", &self.name)
                            .field("placements", &self.placements)
                            .field("plain-text-bindings", &self.plain_text_bindings)
                            .field("queue-bindings", &self.queue_bindings)
                            .field("r2-bucket-bindings", &self.r2_bucket_bindings)
                            .field("secret-text-bindings", &self.secret_text_bindings)
                            .field("service-bindings", &self.service_bindings)
                            .field("tags", &self.tags)
                            .field("webassembly-bindings", &self.webassembly_bindings)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle4;
                    let handle6;
                    let handle8;
                    let handle10;
                    let handle12;
                    let handle14;
                    let handle16;
                    let handle18;
                    let handle20;
                    let handle22;
                    let handle24;
                    let handle26;
                    let handle28;
                    let handle30;
                    let handle32;
                    let handle34;
                    let handle36;
                    let handle38;
                    let handle40;
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let len2 = l1;
                    let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                    let l3 = *arg0.add(8).cast::<i32>();
                    let l5 = *arg0.add(12).cast::<i32>();
                    let l7 = *arg0.add(16).cast::<i32>();
                    let l9 = *arg0.add(20).cast::<i32>();
                    let l11 = *arg0.add(24).cast::<i32>();
                    let l13 = *arg0.add(28).cast::<i32>();
                    let l15 = *arg0.add(32).cast::<i32>();
                    let l17 = *arg0.add(36).cast::<i32>();
                    let l19 = *arg0.add(40).cast::<i32>();
                    let l21 = *arg0.add(44).cast::<i32>();
                    let l23 = *arg0.add(48).cast::<i32>();
                    let l25 = *arg0.add(52).cast::<i32>();
                    let l27 = *arg0.add(56).cast::<i32>();
                    let l29 = *arg0.add(60).cast::<i32>();
                    let l31 = *arg0.add(64).cast::<i32>();
                    let l33 = *arg0.add(68).cast::<i32>();
                    let l35 = *arg0.add(72).cast::<i32>();
                    let l37 = *arg0.add(76).cast::<i32>();
                    let l39 = *arg0.add(80).cast::<i32>();
                    let result41 = T::invoke(
                        _rt::string_lift(bytes2),
                        Args {
                            account_id: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l3 as u32);
                                &handle4
                            },
                            analytics_engine_bindings: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l5 as u32);
                                &handle6
                            },
                            compatibility_date: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l7 as u32);
                                &handle8
                            },
                            compatibility_flags: {
                                handle10 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l9 as u32);
                                &handle10
                            },
                            content: {
                                handle12 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l11 as u32);
                                &handle12
                            },
                            d1_database_bindings: {
                                handle14 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l13 as u32);
                                &handle14
                            },
                            dispatch_namespace: {
                                handle16 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l15 as u32);
                                &handle16
                            },
                            kv_namespace_bindings: {
                                handle18 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l17 as u32);
                                &handle18
                            },
                            logpush: {
                                handle20 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l19 as u32);
                                &handle20
                            },
                            module: {
                                handle22 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l21 as u32);
                                &handle22
                            },
                            name: {
                                handle24 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l23 as u32);
                                &handle24
                            },
                            placements: {
                                handle26 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l25 as u32);
                                &handle26
                            },
                            plain_text_bindings: {
                                handle28 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l27 as u32);
                                &handle28
                            },
                            queue_bindings: {
                                handle30 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l29 as u32);
                                &handle30
                            },
                            r2_bucket_bindings: {
                                handle32 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l31 as u32);
                                &handle32
                            },
                            secret_text_bindings: {
                                handle34 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l33 as u32);
                                &handle34
                            },
                            service_bindings: {
                                handle36 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l35 as u32);
                                &handle36
                            },
                            tags: {
                                handle38 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l37 as u32);
                                &handle38
                            },
                            webassembly_bindings: {
                                handle40 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(l39 as u32);
                                &handle40
                            },
                        },
                    );
                    _rt::cabi_dealloc(arg0, 84, 4);
                    let ptr42 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id43,
                        analytics_engine_bindings: analytics_engine_bindings43,
                        compatibility_date: compatibility_date43,
                        compatibility_flags: compatibility_flags43,
                        content: content43,
                        d1_database_bindings: d1_database_bindings43,
                        dispatch_namespace: dispatch_namespace43,
                        kv_namespace_bindings: kv_namespace_bindings43,
                        logpush: logpush43,
                        module: module43,
                        name: name43,
                        placements: placements43,
                        plain_text_bindings: plain_text_bindings43,
                        queue_bindings: queue_bindings43,
                        r2_bucket_bindings: r2_bucket_bindings43,
                        secret_text_bindings: secret_text_bindings43,
                        service_bindings: service_bindings43,
                        tags: tags43,
                        webassembly_bindings: webassembly_bindings43,
                    } = result41;
                    *ptr42.add(0).cast::<i32>() = (account_id43).take_handle() as i32;
                    *ptr42.add(4).cast::<i32>() =
                        (analytics_engine_bindings43).take_handle() as i32;
                    *ptr42.add(8).cast::<i32>() = (compatibility_date43).take_handle() as i32;
                    *ptr42.add(12).cast::<i32>() = (compatibility_flags43).take_handle() as i32;
                    *ptr42.add(16).cast::<i32>() = (content43).take_handle() as i32;
                    *ptr42.add(20).cast::<i32>() = (d1_database_bindings43).take_handle() as i32;
                    *ptr42.add(24).cast::<i32>() = (dispatch_namespace43).take_handle() as i32;
                    *ptr42.add(28).cast::<i32>() = (kv_namespace_bindings43).take_handle() as i32;
                    *ptr42.add(32).cast::<i32>() = (logpush43).take_handle() as i32;
                    *ptr42.add(36).cast::<i32>() = (module43).take_handle() as i32;
                    *ptr42.add(40).cast::<i32>() = (name43).take_handle() as i32;
                    *ptr42.add(44).cast::<i32>() = (placements43).take_handle() as i32;
                    *ptr42.add(48).cast::<i32>() = (plain_text_bindings43).take_handle() as i32;
                    *ptr42.add(52).cast::<i32>() = (queue_bindings43).take_handle() as i32;
                    *ptr42.add(56).cast::<i32>() = (r2_bucket_bindings43).take_handle() as i32;
                    *ptr42.add(60).cast::<i32>() = (secret_text_bindings43).take_handle() as i32;
                    *ptr42.add(64).cast::<i32>() = (service_bindings43).take_handle() as i32;
                    *ptr42.add(68).cast::<i32>() = (tags43).take_handle() as i32;
                    *ptr42.add(72).cast::<i32>() = (webassembly_bindings43).take_handle() as i32;
                    ptr42
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_worker_script_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/worker-script@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_worker_script_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 76]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 76]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod worker_secret {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub name: &'a Output,
                    pub script_name: &'a Output,
                    pub secret_text: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("name", &self.name)
                            .field("script-name", &self.script_name)
                            .field("secret-text", &self.secret_text)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub name: Output,
                    pub script_name: Output,
                    pub secret_text: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("name", &self.name)
                            .field("script-name", &self.script_name)
                            .field("secret-text", &self.secret_text)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result5 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            name: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            script_name: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            secret_text: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                        },
                    );
                    let ptr6 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id7,
                        name: name7,
                        script_name: script_name7,
                        secret_text: secret_text7,
                    } = result5;
                    *ptr6.add(0).cast::<i32>() = (account_id7).take_handle() as i32;
                    *ptr6.add(4).cast::<i32>() = (name7).take_handle() as i32;
                    *ptr6.add(8).cast::<i32>() = (script_name7).take_handle() as i32;
                    *ptr6.add(12).cast::<i32>() = (secret_text7).take_handle() as i32;
                    ptr6
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_worker_secret_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/worker-secret@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_worker_secret_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod workers_for_platforms_namespace {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub name: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("name", &self.name)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub name: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("name", &self.name)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result3 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            name: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                        },
                    );
                    let ptr4 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id5,
                        name: name5,
                    } = result3;
                    *ptr4.add(0).cast::<i32>() = (account_id5).take_handle() as i32;
                    *ptr4.add(4).cast::<i32>() = (name5).take_handle() as i32;
                    ptr4
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_workers_for_platforms_namespace_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/workers-for-platforms-namespace@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_workers_for_platforms_namespace_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 8]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod workers_kv {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub key: &'a Output,
                    pub namespace_id: &'a Output,
                    pub value: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("key", &self.key)
                            .field("namespace-id", &self.namespace_id)
                            .field("value", &self.value)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub key: Output,
                    pub namespace_id: Output,
                    pub value: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("key", &self.key)
                            .field("namespace-id", &self.namespace_id)
                            .field("value", &self.value)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result5 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            key: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            namespace_id: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            value: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                        },
                    );
                    let ptr6 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id7,
                        key: key7,
                        namespace_id: namespace_id7,
                        value: value7,
                    } = result5;
                    *ptr6.add(0).cast::<i32>() = (account_id7).take_handle() as i32;
                    *ptr6.add(4).cast::<i32>() = (key7).take_handle() as i32;
                    *ptr6.add(8).cast::<i32>() = (namespace_id7).take_handle() as i32;
                    *ptr6.add(12).cast::<i32>() = (value7).take_handle() as i32;
                    ptr6
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_workers_kv_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/workers-kv@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_workers_kv_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod workers_kv_namespace {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub title: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("title", &self.title)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub title: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("title", &self.title)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result3 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            title: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                        },
                    );
                    let ptr4 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id5,
                        title: title5,
                    } = result3;
                    *ptr4.add(0).cast::<i32>() = (account_id5).take_handle() as i32;
                    *ptr4.add(4).cast::<i32>() = (title5).take_handle() as i32;
                    ptr4
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_workers_kv_namespace_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/workers-kv-namespace@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_workers_kv_namespace_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 8]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod zone {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub account_id: &'a Output,
                    pub jump_start: &'a Output,
                    pub paused: &'a Output,
                    pub plan: &'a Output,
                    pub type_: &'a Output,
                    pub zone: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("account-id", &self.account_id)
                            .field("jump-start", &self.jump_start)
                            .field("paused", &self.paused)
                            .field("plan", &self.plan)
                            .field("type", &self.type_)
                            .field("zone", &self.zone)
                            .finish()
                    }
                }
                pub struct Res {
                    pub account_id: Output,
                    pub jump_start: Output,
                    pub meta: Output,
                    pub name_servers: Output,
                    pub paused: Output,
                    pub plan: Output,
                    pub status: Output,
                    pub type_: Output,
                    pub vanity_name_servers: Output,
                    pub verification_key: Output,
                    pub zone: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("account-id", &self.account_id)
                            .field("jump-start", &self.jump_start)
                            .field("meta", &self.meta)
                            .field("name-servers", &self.name_servers)
                            .field("paused", &self.paused)
                            .field("plan", &self.plan)
                            .field("status", &self.status)
                            .field("type", &self.type_)
                            .field("vanity-name-servers", &self.vanity_name_servers)
                            .field("verification-key", &self.verification_key)
                            .field("zone", &self.zone)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result7 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            account_id: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            jump_start: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            paused: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            plan: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            type_: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            zone: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                        },
                    );
                    let ptr8 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        account_id: account_id9,
                        jump_start: jump_start9,
                        meta: meta9,
                        name_servers: name_servers9,
                        paused: paused9,
                        plan: plan9,
                        status: status9,
                        type_: type_9,
                        vanity_name_servers: vanity_name_servers9,
                        verification_key: verification_key9,
                        zone: zone9,
                    } = result7;
                    *ptr8.add(0).cast::<i32>() = (account_id9).take_handle() as i32;
                    *ptr8.add(4).cast::<i32>() = (jump_start9).take_handle() as i32;
                    *ptr8.add(8).cast::<i32>() = (meta9).take_handle() as i32;
                    *ptr8.add(12).cast::<i32>() = (name_servers9).take_handle() as i32;
                    *ptr8.add(16).cast::<i32>() = (paused9).take_handle() as i32;
                    *ptr8.add(20).cast::<i32>() = (plan9).take_handle() as i32;
                    *ptr8.add(24).cast::<i32>() = (status9).take_handle() as i32;
                    *ptr8.add(28).cast::<i32>() = (type_9).take_handle() as i32;
                    *ptr8.add(32).cast::<i32>() = (vanity_name_servers9).take_handle() as i32;
                    *ptr8.add(36).cast::<i32>() = (verification_key9).take_handle() as i32;
                    *ptr8.add(40).cast::<i32>() = (zone9).take_handle() as i32;
                    ptr8
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_zone_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/zone@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_zone_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 44]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 44]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod zone_cache_reserve {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub enabled: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("enabled", &self.enabled)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub enabled: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("enabled", &self.enabled)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result3 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            enabled: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            zone_id: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                        },
                    );
                    let ptr4 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        enabled: enabled5,
                        zone_id: zone_id5,
                    } = result3;
                    *ptr4.add(0).cast::<i32>() = (enabled5).take_handle() as i32;
                    *ptr4.add(4).cast::<i32>() = (zone_id5).take_handle() as i32;
                    ptr4
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_zone_cache_reserve_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/zone-cache-reserve@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_zone_cache_reserve_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 8]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod zone_cache_variants {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub avifs: &'a Output,
                    pub bmps: &'a Output,
                    pub gifs: &'a Output,
                    pub jp2s: &'a Output,
                    pub jpegs: &'a Output,
                    pub jpg2s: &'a Output,
                    pub jpgs: &'a Output,
                    pub pngs: &'a Output,
                    pub tiffs: &'a Output,
                    pub tifs: &'a Output,
                    pub webps: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("avifs", &self.avifs)
                            .field("bmps", &self.bmps)
                            .field("gifs", &self.gifs)
                            .field("jp2s", &self.jp2s)
                            .field("jpegs", &self.jpegs)
                            .field("jpg2s", &self.jpg2s)
                            .field("jpgs", &self.jpgs)
                            .field("pngs", &self.pngs)
                            .field("tiffs", &self.tiffs)
                            .field("tifs", &self.tifs)
                            .field("webps", &self.webps)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub avifs: Output,
                    pub bmps: Output,
                    pub gifs: Output,
                    pub jp2s: Output,
                    pub jpegs: Output,
                    pub jpg2s: Output,
                    pub jpgs: Output,
                    pub pngs: Output,
                    pub tiffs: Output,
                    pub tifs: Output,
                    pub webps: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("avifs", &self.avifs)
                            .field("bmps", &self.bmps)
                            .field("gifs", &self.gifs)
                            .field("jp2s", &self.jp2s)
                            .field("jpegs", &self.jpegs)
                            .field("jpg2s", &self.jpg2s)
                            .field("jpgs", &self.jpgs)
                            .field("pngs", &self.pngs)
                            .field("tiffs", &self.tiffs)
                            .field("tifs", &self.tifs)
                            .field("webps", &self.webps)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                    arg11: i32,
                    arg12: i32,
                    arg13: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let handle7;
                    let handle8;
                    let handle9;
                    let handle10;
                    let handle11;
                    let handle12;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result13 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            avifs: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            bmps: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            gifs: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            jp2s: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            jpegs: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            jpg2s: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                            jpgs: {
                                handle7 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg8 as u32);
                                &handle7
                            },
                            pngs: {
                                handle8 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg9 as u32);
                                &handle8
                            },
                            tiffs: {
                                handle9 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg10 as u32);
                                &handle9
                            },
                            tifs: {
                                handle10 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg11 as u32);
                                &handle10
                            },
                            webps: {
                                handle11 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg12 as u32);
                                &handle11
                            },
                            zone_id: {
                                handle12 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg13 as u32);
                                &handle12
                            },
                        },
                    );
                    let ptr14 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        avifs: avifs15,
                        bmps: bmps15,
                        gifs: gifs15,
                        jp2s: jp2s15,
                        jpegs: jpegs15,
                        jpg2s: jpg2s15,
                        jpgs: jpgs15,
                        pngs: pngs15,
                        tiffs: tiffs15,
                        tifs: tifs15,
                        webps: webps15,
                        zone_id: zone_id15,
                    } = result13;
                    *ptr14.add(0).cast::<i32>() = (avifs15).take_handle() as i32;
                    *ptr14.add(4).cast::<i32>() = (bmps15).take_handle() as i32;
                    *ptr14.add(8).cast::<i32>() = (gifs15).take_handle() as i32;
                    *ptr14.add(12).cast::<i32>() = (jp2s15).take_handle() as i32;
                    *ptr14.add(16).cast::<i32>() = (jpegs15).take_handle() as i32;
                    *ptr14.add(20).cast::<i32>() = (jpg2s15).take_handle() as i32;
                    *ptr14.add(24).cast::<i32>() = (jpgs15).take_handle() as i32;
                    *ptr14.add(28).cast::<i32>() = (pngs15).take_handle() as i32;
                    *ptr14.add(32).cast::<i32>() = (tiffs15).take_handle() as i32;
                    *ptr14.add(36).cast::<i32>() = (tifs15).take_handle() as i32;
                    *ptr14.add(40).cast::<i32>() = (webps15).take_handle() as i32;
                    *ptr14.add(44).cast::<i32>() = (zone_id15).take_handle() as i32;
                    ptr14
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_zone_cache_variants_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/zone-cache-variants@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,arg8: i32,arg9: i32,arg10: i32,arg11: i32,arg12: i32,arg13: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_zone_cache_variants_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 48]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 48]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod zone_dnssec {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub modified_on: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("modified-on", &self.modified_on)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub algorithm: Output,
                    pub digest: Output,
                    pub digest_algorithm: Output,
                    pub digest_type: Output,
                    pub ds: Output,
                    pub flags: Output,
                    pub key_tag: Output,
                    pub key_type: Output,
                    pub modified_on: Output,
                    pub public_key: Output,
                    pub status: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("algorithm", &self.algorithm)
                            .field("digest", &self.digest)
                            .field("digest-algorithm", &self.digest_algorithm)
                            .field("digest-type", &self.digest_type)
                            .field("ds", &self.ds)
                            .field("flags", &self.flags)
                            .field("key-tag", &self.key_tag)
                            .field("key-type", &self.key_type)
                            .field("modified-on", &self.modified_on)
                            .field("public-key", &self.public_key)
                            .field("status", &self.status)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result3 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            modified_on: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            zone_id: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                        },
                    );
                    let ptr4 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        algorithm: algorithm5,
                        digest: digest5,
                        digest_algorithm: digest_algorithm5,
                        digest_type: digest_type5,
                        ds: ds5,
                        flags: flags5,
                        key_tag: key_tag5,
                        key_type: key_type5,
                        modified_on: modified_on5,
                        public_key: public_key5,
                        status: status5,
                        zone_id: zone_id5,
                    } = result3;
                    *ptr4.add(0).cast::<i32>() = (algorithm5).take_handle() as i32;
                    *ptr4.add(4).cast::<i32>() = (digest5).take_handle() as i32;
                    *ptr4.add(8).cast::<i32>() = (digest_algorithm5).take_handle() as i32;
                    *ptr4.add(12).cast::<i32>() = (digest_type5).take_handle() as i32;
                    *ptr4.add(16).cast::<i32>() = (ds5).take_handle() as i32;
                    *ptr4.add(20).cast::<i32>() = (flags5).take_handle() as i32;
                    *ptr4.add(24).cast::<i32>() = (key_tag5).take_handle() as i32;
                    *ptr4.add(28).cast::<i32>() = (key_type5).take_handle() as i32;
                    *ptr4.add(32).cast::<i32>() = (modified_on5).take_handle() as i32;
                    *ptr4.add(36).cast::<i32>() = (public_key5).take_handle() as i32;
                    *ptr4.add(40).cast::<i32>() = (status5).take_handle() as i32;
                    *ptr4.add(44).cast::<i32>() = (zone_id5).take_handle() as i32;
                    ptr4
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_zone_dnssec_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/zone-dnssec@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_zone_dnssec_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 48]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 48]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod zone_hold {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub hold: &'a Output,
                    pub hold_after: &'a Output,
                    pub include_subdomains: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("hold", &self.hold)
                            .field("hold-after", &self.hold_after)
                            .field("include-subdomains", &self.include_subdomains)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub hold: Output,
                    pub hold_after: Output,
                    pub include_subdomains: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("hold", &self.hold)
                            .field("hold-after", &self.hold_after)
                            .field("include-subdomains", &self.include_subdomains)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result5 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            hold: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            hold_after: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            include_subdomains: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            zone_id: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                        },
                    );
                    let ptr6 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        hold: hold7,
                        hold_after: hold_after7,
                        include_subdomains: include_subdomains7,
                        zone_id: zone_id7,
                    } = result5;
                    *ptr6.add(0).cast::<i32>() = (hold7).take_handle() as i32;
                    *ptr6.add(4).cast::<i32>() = (hold_after7).take_handle() as i32;
                    *ptr6.add(8).cast::<i32>() = (include_subdomains7).take_handle() as i32;
                    *ptr6.add(12).cast::<i32>() = (zone_id7).take_handle() as i32;
                    ptr6
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_zone_hold_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/zone-hold@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_zone_hold_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 16]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod zone_lockdown {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub configurations: &'a Output,
                    pub description: &'a Output,
                    pub paused: &'a Output,
                    pub priority: &'a Output,
                    pub urls: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("configurations", &self.configurations)
                            .field("description", &self.description)
                            .field("paused", &self.paused)
                            .field("priority", &self.priority)
                            .field("urls", &self.urls)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub configurations: Output,
                    pub description: Output,
                    pub paused: Output,
                    pub priority: Output,
                    pub urls: Output,
                    pub zone_id: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("configurations", &self.configurations)
                            .field("description", &self.description)
                            .field("paused", &self.paused)
                            .field("priority", &self.priority)
                            .field("urls", &self.urls)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let handle3;
                    let handle4;
                    let handle5;
                    let handle6;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result7 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            configurations: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            description: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                            paused: {
                                handle3 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg4 as u32);
                                &handle3
                            },
                            priority: {
                                handle4 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg5 as u32);
                                &handle4
                            },
                            urls: {
                                handle5 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg6 as u32);
                                &handle5
                            },
                            zone_id: {
                                handle6 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg7 as u32);
                                &handle6
                            },
                        },
                    );
                    let ptr8 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        configurations: configurations9,
                        description: description9,
                        paused: paused9,
                        priority: priority9,
                        urls: urls9,
                        zone_id: zone_id9,
                    } = result7;
                    *ptr8.add(0).cast::<i32>() = (configurations9).take_handle() as i32;
                    *ptr8.add(4).cast::<i32>() = (description9).take_handle() as i32;
                    *ptr8.add(8).cast::<i32>() = (paused9).take_handle() as i32;
                    *ptr8.add(12).cast::<i32>() = (priority9).take_handle() as i32;
                    *ptr8.add(16).cast::<i32>() = (urls9).take_handle() as i32;
                    *ptr8.add(20).cast::<i32>() = (zone_id9).take_handle() as i32;
                    ptr8
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_zone_lockdown_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/zone-lockdown@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,arg4: i32,arg5: i32,arg6: i32,arg7: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_zone_lockdown_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 24]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 24]);
            }

            #[allow(dead_code, clippy::all)]
            pub mod zone_settings_override {
                #[used]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                static __FORCE_SECTION_REF: fn() =
                    super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Output =
                    super::super::super::super::component::pulumi_wasm::output_interface::Output;
                pub struct Args<'a> {
                    pub settings: &'a Output,
                    pub zone_id: &'a Output,
                }
                impl<'a> ::core::fmt::Debug for Args<'a> {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Args")
                            .field("settings", &self.settings)
                            .field("zone-id", &self.zone_id)
                            .finish()
                    }
                }
                pub struct Res {
                    pub initial_settings: Output,
                    pub initial_settings_read_at: Output,
                    pub readonly_settings: Output,
                    pub settings: Output,
                    pub zone_id: Output,
                    pub zone_status: Output,
                    pub zone_type: Output,
                }
                impl ::core::fmt::Debug for Res {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        f.debug_struct("Res")
                            .field("initial-settings", &self.initial_settings)
                            .field("initial-settings-read-at", &self.initial_settings_read_at)
                            .field("readonly-settings", &self.readonly_settings)
                            .field("settings", &self.settings)
                            .field("zone-id", &self.zone_id)
                            .field("zone-status", &self.zone_status)
                            .field("zone-type", &self.zone_type)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_invoke_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")]
                    _rt::run_ctors_once();
                    let handle1;
                    let handle2;
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result3 = T::invoke(
                        _rt::string_lift(bytes0),
                        Args {
                            settings: {
                                handle1 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg2 as u32);
                                &handle1
                            },
                            zone_id: {
                                handle2 = super::super::super::super::component::pulumi_wasm::output_interface::Output::from_handle(arg3 as u32);
                                &handle2
                            },
                        },
                    );
                    let ptr4 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let Res {
                        initial_settings: initial_settings5,
                        initial_settings_read_at: initial_settings_read_at5,
                        readonly_settings: readonly_settings5,
                        settings: settings5,
                        zone_id: zone_id5,
                        zone_status: zone_status5,
                        zone_type: zone_type5,
                    } = result3;
                    *ptr4.add(0).cast::<i32>() = (initial_settings5).take_handle() as i32;
                    *ptr4.add(4).cast::<i32>() = (initial_settings_read_at5).take_handle() as i32;
                    *ptr4.add(8).cast::<i32>() = (readonly_settings5).take_handle() as i32;
                    *ptr4.add(12).cast::<i32>() = (settings5).take_handle() as i32;
                    *ptr4.add(16).cast::<i32>() = (zone_id5).take_handle() as i32;
                    *ptr4.add(20).cast::<i32>() = (zone_status5).take_handle() as i32;
                    *ptr4.add(24).cast::<i32>() = (zone_type5).take_handle() as i32;
                    ptr4
                }
                pub trait Guest {
                    fn invoke(name: _rt::String, args: Args<'_>) -> Res;
                }
                #[doc(hidden)]

                macro_rules! __export_pulumi_cloudflare_zone_settings_override_5_24_1_zero_zero_zero_dev_cabi{
  ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

    #[export_name = "pulumi:cloudflare/zone-settings-override@5.24.1-ZERO.ZERO.ZERO-DEV#invoke"]
    unsafe extern "C" fn export_invoke(arg0: *mut u8,arg1: usize,arg2: i32,arg3: i32,) -> *mut u8 {
      $($path_to_types)*::_export_invoke_cabi::<$ty>(arg0, arg1, arg2, arg3)
    }
  };);
}
                #[doc(hidden)]
                pub(crate) use __export_pulumi_cloudflare_zone_settings_override_5_24_1_zero_zero_zero_dev_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 28]);
                static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 28]);
            }
        }
    }
}
mod _rt {

    use core::fmt;
    use core::marker;
    use core::sync::atomic::{AtomicU32, Ordering::Relaxed};

    /// A type which represents a component model resource, either imported or
    /// exported into this component.
    ///
    /// This is a low-level wrapper which handles the lifetime of the resource
    /// (namely this has a destructor). The `T` provided defines the component model
    /// intrinsics that this wrapper uses.
    ///
    /// One of the chief purposes of this type is to provide `Deref` implementations
    /// to access the underlying data when it is owned.
    ///
    /// This type is primarily used in generated code for exported and imported
    /// resources.
    #[repr(transparent)]
    pub struct Resource<T: WasmResource> {
        // NB: This would ideally be `u32` but it is not. The fact that this has
        // interior mutability is not exposed in the API of this type except for the
        // `take_handle` method which is supposed to in theory be private.
        //
        // This represents, almost all the time, a valid handle value. When it's
        // invalid it's stored as `u32::MAX`.
        handle: AtomicU32,
        _marker: marker::PhantomData<T>,
    }

    /// A trait which all wasm resources implement, namely providing the ability to
    /// drop a resource.
    ///
    /// This generally is implemented by generated code, not user-facing code.
    #[allow(clippy::missing_safety_doc)]
    pub unsafe trait WasmResource {
        /// Invokes the `[resource-drop]...` intrinsic.
        unsafe fn drop(handle: u32);
    }

    impl<T: WasmResource> Resource<T> {
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
            debug_assert!(handle != u32::MAX);
            Self {
                handle: AtomicU32::new(handle),
                _marker: marker::PhantomData,
            }
        }

        /// Takes ownership of the handle owned by `resource`.
        ///
        /// Note that this ideally would be `into_handle` taking `Resource<T>` by
        /// ownership. The code generator does not enable that in all situations,
        /// unfortunately, so this is provided instead.
        ///
        /// Also note that `take_handle` is in theory only ever called on values
        /// owned by a generated function. For example a generated function might
        /// take `Resource<T>` as an argument but then call `take_handle` on a
        /// reference to that argument. In that sense the dynamic nature of
        /// `take_handle` should only be exposed internally to generated code, not
        /// to user code.
        #[doc(hidden)]
        pub fn take_handle(resource: &Resource<T>) -> u32 {
            resource.handle.swap(u32::MAX, Relaxed)
        }

        #[doc(hidden)]
        pub fn handle(resource: &Resource<T>) -> u32 {
            resource.handle.load(Relaxed)
        }
    }

    impl<T: WasmResource> fmt::Debug for Resource<T> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Resource")
                .field("handle", &self.handle)
                .finish()
        }
    }

    impl<T: WasmResource> Drop for Resource<T> {
        fn drop(&mut self) {
            unsafe {
                match self.handle.load(Relaxed) {
                    // If this handle was "taken" then don't do anything in the
                    // destructor.
                    u32::MAX => {}

                    // ... but otherwise do actually destroy it with the imported
                    // component model intrinsic as defined through `T`.
                    other => T::drop(other),
                }
            }
        }
    }
    pub use alloc_crate::alloc;
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr as *mut u8, layout);
    }

    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    extern crate alloc as alloc_crate;
}

/// Generates `#[no_mangle]` functions to export the specified type as the
/// root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_cloudflare_pulumi_impl {
  ($ty:ident) => (self::export!($ty with_types_in self););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::exports::pulumi::cloudflare::access_application::__export_pulumi_cloudflare_access_application_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::access_application);
  $($path_to_types_root)*::exports::pulumi::cloudflare::access_ca_certificate::__export_pulumi_cloudflare_access_ca_certificate_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::access_ca_certificate);
  $($path_to_types_root)*::exports::pulumi::cloudflare::access_custom_page::__export_pulumi_cloudflare_access_custom_page_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::access_custom_page);
  $($path_to_types_root)*::exports::pulumi::cloudflare::access_group::__export_pulumi_cloudflare_access_group_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::access_group);
  $($path_to_types_root)*::exports::pulumi::cloudflare::access_identity_provider::__export_pulumi_cloudflare_access_identity_provider_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::access_identity_provider);
  $($path_to_types_root)*::exports::pulumi::cloudflare::access_keys_configuration::__export_pulumi_cloudflare_access_keys_configuration_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::access_keys_configuration);
  $($path_to_types_root)*::exports::pulumi::cloudflare::access_mutual_tls_certificate::__export_pulumi_cloudflare_access_mutual_tls_certificate_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::access_mutual_tls_certificate);
  $($path_to_types_root)*::exports::pulumi::cloudflare::access_mutual_tls_hostname_settings::__export_pulumi_cloudflare_access_mutual_tls_hostname_settings_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::access_mutual_tls_hostname_settings);
  $($path_to_types_root)*::exports::pulumi::cloudflare::access_organization::__export_pulumi_cloudflare_access_organization_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::access_organization);
  $($path_to_types_root)*::exports::pulumi::cloudflare::access_policy::__export_pulumi_cloudflare_access_policy_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::access_policy);
  $($path_to_types_root)*::exports::pulumi::cloudflare::access_rule::__export_pulumi_cloudflare_access_rule_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::access_rule);
  $($path_to_types_root)*::exports::pulumi::cloudflare::access_service_token::__export_pulumi_cloudflare_access_service_token_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::access_service_token);
  $($path_to_types_root)*::exports::pulumi::cloudflare::access_tag::__export_pulumi_cloudflare_access_tag_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::access_tag);
  $($path_to_types_root)*::exports::pulumi::cloudflare::account::__export_pulumi_cloudflare_account_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::account);
  $($path_to_types_root)*::exports::pulumi::cloudflare::account_member::__export_pulumi_cloudflare_account_member_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::account_member);
  $($path_to_types_root)*::exports::pulumi::cloudflare::address_map::__export_pulumi_cloudflare_address_map_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::address_map);
  $($path_to_types_root)*::exports::pulumi::cloudflare::api_shield::__export_pulumi_cloudflare_api_shield_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::api_shield);
  $($path_to_types_root)*::exports::pulumi::cloudflare::api_shield_operation::__export_pulumi_cloudflare_api_shield_operation_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::api_shield_operation);
  $($path_to_types_root)*::exports::pulumi::cloudflare::api_shield_operation_schema_validation_settings::__export_pulumi_cloudflare_api_shield_operation_schema_validation_settings_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::api_shield_operation_schema_validation_settings);
  $($path_to_types_root)*::exports::pulumi::cloudflare::api_shield_schema::__export_pulumi_cloudflare_api_shield_schema_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::api_shield_schema);
  $($path_to_types_root)*::exports::pulumi::cloudflare::api_shield_schema_validation_settings::__export_pulumi_cloudflare_api_shield_schema_validation_settings_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::api_shield_schema_validation_settings);
  $($path_to_types_root)*::exports::pulumi::cloudflare::api_token::__export_pulumi_cloudflare_api_token_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::api_token);
  $($path_to_types_root)*::exports::pulumi::cloudflare::argo::__export_pulumi_cloudflare_argo_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::argo);
  $($path_to_types_root)*::exports::pulumi::cloudflare::authenticated_origin_pulls::__export_pulumi_cloudflare_authenticated_origin_pulls_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::authenticated_origin_pulls);
  $($path_to_types_root)*::exports::pulumi::cloudflare::authenticated_origin_pulls_certificate::__export_pulumi_cloudflare_authenticated_origin_pulls_certificate_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::authenticated_origin_pulls_certificate);
  $($path_to_types_root)*::exports::pulumi::cloudflare::bot_management::__export_pulumi_cloudflare_bot_management_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::bot_management);
  $($path_to_types_root)*::exports::pulumi::cloudflare::byo_ip_prefix::__export_pulumi_cloudflare_byo_ip_prefix_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::byo_ip_prefix);
  $($path_to_types_root)*::exports::pulumi::cloudflare::certificate_pack::__export_pulumi_cloudflare_certificate_pack_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::certificate_pack);
  $($path_to_types_root)*::exports::pulumi::cloudflare::custom_hostname::__export_pulumi_cloudflare_custom_hostname_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::custom_hostname);
  $($path_to_types_root)*::exports::pulumi::cloudflare::custom_hostname_fallback_origin::__export_pulumi_cloudflare_custom_hostname_fallback_origin_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::custom_hostname_fallback_origin);
  $($path_to_types_root)*::exports::pulumi::cloudflare::custom_pages::__export_pulumi_cloudflare_custom_pages_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::custom_pages);
  $($path_to_types_root)*::exports::pulumi::cloudflare::custom_ssl::__export_pulumi_cloudflare_custom_ssl_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::custom_ssl);
  $($path_to_types_root)*::exports::pulumi::cloudflare::d1_database::__export_pulumi_cloudflare_d1_database_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::d1_database);
  $($path_to_types_root)*::exports::pulumi::cloudflare::device_dex_test::__export_pulumi_cloudflare_device_dex_test_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::device_dex_test);
  $($path_to_types_root)*::exports::pulumi::cloudflare::device_managed_networks::__export_pulumi_cloudflare_device_managed_networks_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::device_managed_networks);
  $($path_to_types_root)*::exports::pulumi::cloudflare::device_policy_certificates::__export_pulumi_cloudflare_device_policy_certificates_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::device_policy_certificates);
  $($path_to_types_root)*::exports::pulumi::cloudflare::device_posture_integration::__export_pulumi_cloudflare_device_posture_integration_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::device_posture_integration);
  $($path_to_types_root)*::exports::pulumi::cloudflare::device_posture_rule::__export_pulumi_cloudflare_device_posture_rule_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::device_posture_rule);
  $($path_to_types_root)*::exports::pulumi::cloudflare::device_settings_policy::__export_pulumi_cloudflare_device_settings_policy_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::device_settings_policy);
  $($path_to_types_root)*::exports::pulumi::cloudflare::dlp_profile::__export_pulumi_cloudflare_dlp_profile_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::dlp_profile);
  $($path_to_types_root)*::exports::pulumi::cloudflare::email_routing_address::__export_pulumi_cloudflare_email_routing_address_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::email_routing_address);
  $($path_to_types_root)*::exports::pulumi::cloudflare::email_routing_catch_all::__export_pulumi_cloudflare_email_routing_catch_all_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::email_routing_catch_all);
  $($path_to_types_root)*::exports::pulumi::cloudflare::email_routing_rule::__export_pulumi_cloudflare_email_routing_rule_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::email_routing_rule);
  $($path_to_types_root)*::exports::pulumi::cloudflare::email_routing_settings::__export_pulumi_cloudflare_email_routing_settings_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::email_routing_settings);
  $($path_to_types_root)*::exports::pulumi::cloudflare::fallback_domain::__export_pulumi_cloudflare_fallback_domain_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::fallback_domain);
  $($path_to_types_root)*::exports::pulumi::cloudflare::filter::__export_pulumi_cloudflare_filter_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::filter);
  $($path_to_types_root)*::exports::pulumi::cloudflare::firewall_rule::__export_pulumi_cloudflare_firewall_rule_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::firewall_rule);
  $($path_to_types_root)*::exports::pulumi::cloudflare::gre_tunnel::__export_pulumi_cloudflare_gre_tunnel_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::gre_tunnel);
  $($path_to_types_root)*::exports::pulumi::cloudflare::healthcheck::__export_pulumi_cloudflare_healthcheck_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::healthcheck);
  $($path_to_types_root)*::exports::pulumi::cloudflare::hostname_tls_setting::__export_pulumi_cloudflare_hostname_tls_setting_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::hostname_tls_setting);
  $($path_to_types_root)*::exports::pulumi::cloudflare::hostname_tls_setting_ciphers::__export_pulumi_cloudflare_hostname_tls_setting_ciphers_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::hostname_tls_setting_ciphers);
  $($path_to_types_root)*::exports::pulumi::cloudflare::hyperdrive_config::__export_pulumi_cloudflare_hyperdrive_config_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::hyperdrive_config);
  $($path_to_types_root)*::exports::pulumi::cloudflare::ipsec_tunnel::__export_pulumi_cloudflare_ipsec_tunnel_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::ipsec_tunnel);
  $($path_to_types_root)*::exports::pulumi::cloudflare::keyless_certificate::__export_pulumi_cloudflare_keyless_certificate_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::keyless_certificate);
  $($path_to_types_root)*::exports::pulumi::cloudflare::list::__export_pulumi_cloudflare_list_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::list);
  $($path_to_types_root)*::exports::pulumi::cloudflare::list_item::__export_pulumi_cloudflare_list_item_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::list_item);
  $($path_to_types_root)*::exports::pulumi::cloudflare::load_balancer::__export_pulumi_cloudflare_load_balancer_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::load_balancer);
  $($path_to_types_root)*::exports::pulumi::cloudflare::load_balancer_monitor::__export_pulumi_cloudflare_load_balancer_monitor_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::load_balancer_monitor);
  $($path_to_types_root)*::exports::pulumi::cloudflare::load_balancer_pool::__export_pulumi_cloudflare_load_balancer_pool_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::load_balancer_pool);
  $($path_to_types_root)*::exports::pulumi::cloudflare::logpull_retention::__export_pulumi_cloudflare_logpull_retention_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::logpull_retention);
  $($path_to_types_root)*::exports::pulumi::cloudflare::logpush_job::__export_pulumi_cloudflare_logpush_job_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::logpush_job);
  $($path_to_types_root)*::exports::pulumi::cloudflare::logpush_ownership_challenge::__export_pulumi_cloudflare_logpush_ownership_challenge_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::logpush_ownership_challenge);
  $($path_to_types_root)*::exports::pulumi::cloudflare::magic_firewall_ruleset::__export_pulumi_cloudflare_magic_firewall_ruleset_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::magic_firewall_ruleset);
  $($path_to_types_root)*::exports::pulumi::cloudflare::managed_headers::__export_pulumi_cloudflare_managed_headers_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::managed_headers);
  $($path_to_types_root)*::exports::pulumi::cloudflare::mtls_certificate::__export_pulumi_cloudflare_mtls_certificate_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::mtls_certificate);
  $($path_to_types_root)*::exports::pulumi::cloudflare::notification_policy::__export_pulumi_cloudflare_notification_policy_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::notification_policy);
  $($path_to_types_root)*::exports::pulumi::cloudflare::notification_policy_webhooks::__export_pulumi_cloudflare_notification_policy_webhooks_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::notification_policy_webhooks);
  $($path_to_types_root)*::exports::pulumi::cloudflare::observatory_scheduled_test::__export_pulumi_cloudflare_observatory_scheduled_test_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::observatory_scheduled_test);
  $($path_to_types_root)*::exports::pulumi::cloudflare::origin_ca_certificate::__export_pulumi_cloudflare_origin_ca_certificate_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::origin_ca_certificate);
  $($path_to_types_root)*::exports::pulumi::cloudflare::page_rule::__export_pulumi_cloudflare_page_rule_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::page_rule);
  $($path_to_types_root)*::exports::pulumi::cloudflare::pages_domain::__export_pulumi_cloudflare_pages_domain_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::pages_domain);
  $($path_to_types_root)*::exports::pulumi::cloudflare::pages_project::__export_pulumi_cloudflare_pages_project_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::pages_project);
  $($path_to_types_root)*::exports::pulumi::cloudflare::queue::__export_pulumi_cloudflare_queue_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::queue);
  $($path_to_types_root)*::exports::pulumi::cloudflare::r2_bucket::__export_pulumi_cloudflare_r2_bucket_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::r2_bucket);
  $($path_to_types_root)*::exports::pulumi::cloudflare::rate_limit::__export_pulumi_cloudflare_rate_limit_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::rate_limit);
  $($path_to_types_root)*::exports::pulumi::cloudflare::record::__export_pulumi_cloudflare_record_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::record);
  $($path_to_types_root)*::exports::pulumi::cloudflare::regional_hostname::__export_pulumi_cloudflare_regional_hostname_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::regional_hostname);
  $($path_to_types_root)*::exports::pulumi::cloudflare::regional_tiered_cache::__export_pulumi_cloudflare_regional_tiered_cache_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::regional_tiered_cache);
  $($path_to_types_root)*::exports::pulumi::cloudflare::ruleset::__export_pulumi_cloudflare_ruleset_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::ruleset);
  $($path_to_types_root)*::exports::pulumi::cloudflare::spectrum_application::__export_pulumi_cloudflare_spectrum_application_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::spectrum_application);
  $($path_to_types_root)*::exports::pulumi::cloudflare::split_tunnel::__export_pulumi_cloudflare_split_tunnel_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::split_tunnel);
  $($path_to_types_root)*::exports::pulumi::cloudflare::static_route::__export_pulumi_cloudflare_static_route_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::static_route);
  $($path_to_types_root)*::exports::pulumi::cloudflare::teams_account::__export_pulumi_cloudflare_teams_account_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::teams_account);
  $($path_to_types_root)*::exports::pulumi::cloudflare::teams_list::__export_pulumi_cloudflare_teams_list_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::teams_list);
  $($path_to_types_root)*::exports::pulumi::cloudflare::teams_location::__export_pulumi_cloudflare_teams_location_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::teams_location);
  $($path_to_types_root)*::exports::pulumi::cloudflare::teams_proxy_endpoint::__export_pulumi_cloudflare_teams_proxy_endpoint_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::teams_proxy_endpoint);
  $($path_to_types_root)*::exports::pulumi::cloudflare::teams_rule::__export_pulumi_cloudflare_teams_rule_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::teams_rule);
  $($path_to_types_root)*::exports::pulumi::cloudflare::tiered_cache::__export_pulumi_cloudflare_tiered_cache_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::tiered_cache);
  $($path_to_types_root)*::exports::pulumi::cloudflare::total_tls::__export_pulumi_cloudflare_total_tls_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::total_tls);
  $($path_to_types_root)*::exports::pulumi::cloudflare::tunnel::__export_pulumi_cloudflare_tunnel_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::tunnel);
  $($path_to_types_root)*::exports::pulumi::cloudflare::tunnel_config::__export_pulumi_cloudflare_tunnel_config_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::tunnel_config);
  $($path_to_types_root)*::exports::pulumi::cloudflare::tunnel_route::__export_pulumi_cloudflare_tunnel_route_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::tunnel_route);
  $($path_to_types_root)*::exports::pulumi::cloudflare::tunnel_virtual_network::__export_pulumi_cloudflare_tunnel_virtual_network_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::tunnel_virtual_network);
  $($path_to_types_root)*::exports::pulumi::cloudflare::turnstile_widget::__export_pulumi_cloudflare_turnstile_widget_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::turnstile_widget);
  $($path_to_types_root)*::exports::pulumi::cloudflare::url_normalization_settings::__export_pulumi_cloudflare_url_normalization_settings_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::url_normalization_settings);
  $($path_to_types_root)*::exports::pulumi::cloudflare::user_agent_blocking_rule::__export_pulumi_cloudflare_user_agent_blocking_rule_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::user_agent_blocking_rule);
  $($path_to_types_root)*::exports::pulumi::cloudflare::waiting_room::__export_pulumi_cloudflare_waiting_room_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::waiting_room);
  $($path_to_types_root)*::exports::pulumi::cloudflare::waiting_room_event::__export_pulumi_cloudflare_waiting_room_event_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::waiting_room_event);
  $($path_to_types_root)*::exports::pulumi::cloudflare::waiting_room_rules::__export_pulumi_cloudflare_waiting_room_rules_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::waiting_room_rules);
  $($path_to_types_root)*::exports::pulumi::cloudflare::waiting_room_settings::__export_pulumi_cloudflare_waiting_room_settings_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::waiting_room_settings);
  $($path_to_types_root)*::exports::pulumi::cloudflare::web3_hostname::__export_pulumi_cloudflare_web3_hostname_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::web3_hostname);
  $($path_to_types_root)*::exports::pulumi::cloudflare::web_analytics_rule::__export_pulumi_cloudflare_web_analytics_rule_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::web_analytics_rule);
  $($path_to_types_root)*::exports::pulumi::cloudflare::web_analytics_site::__export_pulumi_cloudflare_web_analytics_site_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::web_analytics_site);
  $($path_to_types_root)*::exports::pulumi::cloudflare::worker_cron_trigger::__export_pulumi_cloudflare_worker_cron_trigger_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::worker_cron_trigger);
  $($path_to_types_root)*::exports::pulumi::cloudflare::worker_domain::__export_pulumi_cloudflare_worker_domain_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::worker_domain);
  $($path_to_types_root)*::exports::pulumi::cloudflare::worker_route::__export_pulumi_cloudflare_worker_route_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::worker_route);
  $($path_to_types_root)*::exports::pulumi::cloudflare::worker_script::__export_pulumi_cloudflare_worker_script_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::worker_script);
  $($path_to_types_root)*::exports::pulumi::cloudflare::worker_secret::__export_pulumi_cloudflare_worker_secret_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::worker_secret);
  $($path_to_types_root)*::exports::pulumi::cloudflare::workers_for_platforms_namespace::__export_pulumi_cloudflare_workers_for_platforms_namespace_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::workers_for_platforms_namespace);
  $($path_to_types_root)*::exports::pulumi::cloudflare::workers_kv::__export_pulumi_cloudflare_workers_kv_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::workers_kv);
  $($path_to_types_root)*::exports::pulumi::cloudflare::workers_kv_namespace::__export_pulumi_cloudflare_workers_kv_namespace_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::workers_kv_namespace);
  $($path_to_types_root)*::exports::pulumi::cloudflare::zone::__export_pulumi_cloudflare_zone_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::zone);
  $($path_to_types_root)*::exports::pulumi::cloudflare::zone_cache_reserve::__export_pulumi_cloudflare_zone_cache_reserve_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::zone_cache_reserve);
  $($path_to_types_root)*::exports::pulumi::cloudflare::zone_cache_variants::__export_pulumi_cloudflare_zone_cache_variants_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::zone_cache_variants);
  $($path_to_types_root)*::exports::pulumi::cloudflare::zone_dnssec::__export_pulumi_cloudflare_zone_dnssec_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::zone_dnssec);
  $($path_to_types_root)*::exports::pulumi::cloudflare::zone_hold::__export_pulumi_cloudflare_zone_hold_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::zone_hold);
  $($path_to_types_root)*::exports::pulumi::cloudflare::zone_lockdown::__export_pulumi_cloudflare_zone_lockdown_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::zone_lockdown);
  $($path_to_types_root)*::exports::pulumi::cloudflare::zone_settings_override::__export_pulumi_cloudflare_zone_settings_override_5_24_1_zero_zero_zero_dev_cabi!($ty with_types_in $($path_to_types_root)*::exports::pulumi::cloudflare::zone_settings_override);
  )
}
#[doc(inline)]
pub(crate) use __export_cloudflare_pulumi_impl as export;

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.25.0:cloudflare-pulumi:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 37493] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xec\xa3\x02\x01A\x02\
\x01A\xf1\x01\x01B\x0c\x04\0\x06output\x03\x01\x01i\0\x01@\x01\x05values\0\x01\x04\
\0\x13[constructor]output\x01\x02\x01h\0\x01@\x02\x04self\x03\x0dfunction-names\0\
\x01\x04\0\x12[method]output.map\x01\x04\x01@\x01\x04self\x03\0\x01\x04\0\x18[me\
thod]output.duplicate\x01\x05\x01p\x01\x01@\x01\x07outputs\x06\0\x01\x04\0\x07co\
mbine\x01\x07\x03\x010component:pulumi-wasm/output-interface@0.0.0-DEV\x05\0\x02\
\x03\0\0\x06output\x01B\x13\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\
\x01r\x02\x04names\x05value\x02\x04\0\x0cobject-field\x03\0\x03\x01r\x01\x04name\
s\x04\0\x0cresult-field\x03\0\x05\x01i\x01\x01r\x02\x04names\x06output\x07\x04\0\
\x1eregister-resource-result-field\x03\0\x08\x01p\x04\x01p\x06\x01r\x04\x04types\
\x04names\x06object\x0a\x07results\x0b\x04\0\x19register-resource-request\x03\0\x0c\
\x01p\x09\x01r\x01\x06fields\x0e\x04\0\x18register-resource-result\x03\0\x0f\x01\
@\x01\x07request\x0d\0\x10\x04\0\x08register\x01\x11\x03\x012component:pulumi-wa\
sm/register-interface@0.0.0-DEV\x05\x02\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06ou\
tput\x03\0\0\x01h\x01\x01r\x1d\x0aaccount-id\x02\x1ballow-authenticate-via-warp\x02\
\x0callowed-idps\x02\x15app-launcher-logo-url\x02\x14app-launcher-visible\x02\x19\
auto-redirect-to-identity\x02\x08bg-color\x02\x0ccors-headers\x02\x13custom-deny\
-message\x02\x0fcustom-deny-url\x02\x1ccustom-non-identity-deny-url\x02\x0ccusto\
m-pages\x02\x06domain\x02\x15enable-binding-cookie\x02\x0cfooter-links\x02\x0fhe\
ader-bg-color\x02\x1ahttp-only-cookie-attribute\x02\x13landing-page-design\x02\x08\
logo-url\x02\x04name\x02\x08saas-app\x02\x1asame-site-cookie-attribute\x02\x13se\
lf-hosted-domains\x02\x18service-auth401-redirect\x02\x10session-duration\x02\x11\
skip-interstitial\x02\x04tags\x02\x04type\x02\x07zone-id\x02\x04\0\x04args\x03\0\
\x03\x01i\x01\x01r\x1e\x0aaccount-id\x05\x1ballow-authenticate-via-warp\x05\x0ca\
llowed-idps\x05\x15app-launcher-logo-url\x05\x14app-launcher-visible\x05\x03aud\x05\
\x19auto-redirect-to-identity\x05\x08bg-color\x05\x0ccors-headers\x05\x13custom-\
deny-message\x05\x0fcustom-deny-url\x05\x1ccustom-non-identity-deny-url\x05\x0cc\
ustom-pages\x05\x06domain\x05\x15enable-binding-cookie\x05\x0cfooter-links\x05\x0f\
header-bg-color\x05\x1ahttp-only-cookie-attribute\x05\x13landing-page-design\x05\
\x08logo-url\x05\x04name\x05\x08saas-app\x05\x1asame-site-cookie-attribute\x05\x13\
self-hosted-domains\x05\x18service-auth401-redirect\x05\x10session-duration\x05\x11\
skip-interstitial\x05\x04tags\x05\x04type\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\
\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01>pulumi:clou\
dflare/access-application@5.24.1-ZERO.ZERO.ZERO-DEV\x05\x03\x01B\x0a\x02\x03\x02\
\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x03\x0aaccount-id\x02\x0eapplicat\
ion-id\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x05\x0aaccount-i\
d\x05\x0eapplication-id\x05\x03aud\x05\x0apublic-key\x05\x07zone-id\x05\x04\0\x03\
res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01\
Apulumi:cloudflare/access-ca-certificate@5.24.1-ZERO.ZERO.ZERO-DEV\x05\x04\x01B\x0a\
\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x06\x0aaccount-id\x02\
\x09app-count\x02\x0bcustom-html\x02\x04name\x02\x04type\x02\x07zone-id\x02\x04\0\
\x04args\x03\0\x03\x01i\x01\x01r\x06\x0aaccount-id\x05\x09app-count\x05\x0bcusto\
m-html\x05\x04name\x05\x04type\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\
\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01>pulumi:cloudflare/ac\
cess-custom-page@5.24.1-ZERO.ZERO.ZERO-DEV\x05\x05\x01B\x0a\x02\x03\x02\x01\x01\x04\
\0\x06output\x03\0\0\x01h\x01\x01r\x06\x0aaccount-id\x02\x08excludes\x02\x08incl\
udes\x02\x04name\x02\x08requires\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\
\x01\x01r\x06\x0aaccount-id\x05\x08excludes\x05\x08includes\x05\x04name\x05\x08r\
equires\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\
\x07\x04\0\x06invoke\x01\x08\x04\x018pulumi:cloudflare/access-group@5.24.1-ZERO.\
ZERO.ZERO-DEV\x05\x06\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\
\x01r\x06\x0aaccount-id\x02\x07configs\x02\x04name\x02\x0cscim-configs\x02\x04ty\
pe\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x06\x0aaccount-id\x05\
\x07configs\x05\x04name\x05\x0cscim-configs\x05\x04type\x05\x07zone-id\x05\x04\0\
\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\
\x01Dpulumi:cloudflare/access-identity-provider@5.24.1-ZERO.ZERO.ZERO-DEV\x05\x07\
\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x02\x0aaccou\
nt-id\x02\x1akey-rotation-interval-days\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01\
r\x02\x0aaccount-id\x05\x1akey-rotation-interval-days\x05\x04\0\x03res\x03\0\x06\
\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01Epulumi:clou\
dflare/access-keys-configuration@5.24.1-ZERO.ZERO.ZERO-DEV\x05\x08\x01B\x0a\x02\x03\
\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x05\x0aaccount-id\x02\x14asso\
ciated-hostnames\x02\x0bcertificate\x02\x04name\x02\x07zone-id\x02\x04\0\x04args\
\x03\0\x03\x01i\x01\x01r\x06\x0aaccount-id\x05\x14associated-hostnames\x05\x0bce\
rtificate\x05\x0bfingerprint\x05\x04name\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\
\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01Ipulumi:clou\
dflare/access-mutual-tls-certificate@5.24.1-ZERO.ZERO.ZERO-DEV\x05\x09\x01B\x0a\x02\
\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x03\x0aaccount-id\x02\x08\
settings\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x03\x0aaccount\
-id\x05\x08settings\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04\
args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01Opulumi:cloudflare/access-mutual-t\
ls-hostname-settings@5.24.1-ZERO.ZERO.ZERO-DEV\x05\x0a\x01B\x0a\x02\x03\x02\x01\x01\
\x04\0\x06output\x03\0\0\x01h\x01\x01r\x0d\x0aaccount-id\x02\x1ballow-authentica\
te-via-warp\x02\x0bauth-domain\x02\x19auto-redirect-to-identity\x02\x0ccustom-pa\
ges\x02\x0fis-ui-read-only\x02\x0dlogin-designs\x02\x04name\x02\x10session-durat\
ion\x02\x1aui-read-only-toggle-reason\x02\"user-seat-expiration-inactive-time\x02\
\x1awarp-auth-session-duration\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\
\x01r\x0d\x0aaccount-id\x05\x1ballow-authenticate-via-warp\x05\x0bauth-domain\x05\
\x19auto-redirect-to-identity\x05\x0ccustom-pages\x05\x0fis-ui-read-only\x05\x0d\
login-designs\x05\x04name\x05\x10session-duration\x05\x1aui-read-only-toggle-rea\
son\x05\"user-seat-expiration-inactive-time\x05\x1awarp-auth-session-duration\x05\
\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\
\x06invoke\x01\x08\x04\x01?pulumi:cloudflare/access-organization@5.24.1-ZERO.ZER\
O.ZERO-DEV\x05\x0b\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\
\x01r\x0f\x0aaccount-id\x02\x0eapplication-id\x02\x0fapproval-groups\x02\x11appr\
oval-required\x02\x08decision\x02\x08excludes\x02\x08includes\x02\x12isolation-r\
equired\x02\x04name\x02\x0aprecedence\x02\x1cpurpose-justification-prompt\x02\x1e\
purpose-justification-required\x02\x08requires\x02\x10session-duration\x02\x07zo\
ne-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x0f\x0aaccount-id\x05\x0eapplica\
tion-id\x05\x0fapproval-groups\x05\x11approval-required\x05\x08decision\x05\x08e\
xcludes\x05\x08includes\x05\x12isolation-required\x05\x04name\x05\x0aprecedence\x05\
\x1cpurpose-justification-prompt\x05\x1epurpose-justification-required\x05\x08re\
quires\x05\x10session-duration\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\
\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x019pulumi:cloudflare/ac\
cess-policy@5.24.1-ZERO.ZERO.ZERO-DEV\x05\x0c\x01B\x0a\x02\x03\x02\x01\x01\x04\0\
\x06output\x03\0\0\x01h\x01\x01r\x05\x0aaccount-id\x02\x0dconfiguration\x02\x04m\
ode\x02\x05notes\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x05\x0a\
account-id\x05\x0dconfiguration\x05\x04mode\x05\x05notes\x05\x07zone-id\x05\x04\0\
\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\
\x017pulumi:cloudflare/access-rule@5.24.1-ZERO.ZERO.ZERO-DEV\x05\x0d\x01B\x0a\x02\
\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x05\x0aaccount-id\x02\x08\
duration\x02\x14min-days-for-renewal\x02\x04name\x02\x07zone-id\x02\x04\0\x04arg\
s\x03\0\x03\x01i\x01\x01r\x08\x0aaccount-id\x05\x09client-id\x05\x0dclient-secre\
t\x05\x08duration\x05\x0aexpires-at\x05\x14min-days-for-renewal\x05\x04name\x05\x07\
zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06\
invoke\x01\x08\x04\x01@pulumi:cloudflare/access-service-token@5.24.1-ZERO.ZERO.Z\
ERO-DEV\x05\x0e\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01\
r\x04\x0aaccount-id\x02\x09app-count\x02\x04name\x02\x07zone-id\x02\x04\0\x04arg\
s\x03\0\x03\x01i\x01\x01r\x04\x0aaccount-id\x05\x09app-count\x05\x04name\x05\x07\
zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06\
invoke\x01\x08\x04\x016pulumi:cloudflare/access-tag@5.24.1-ZERO.ZERO.ZERO-DEV\x05\
\x0f\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x03\x11e\
nforce-twofactor\x02\x04name\x02\x04type\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01\
r\x03\x11enforce-twofactor\x05\x04name\x05\x04type\x05\x04\0\x03res\x03\0\x06\x01\
@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x013pulumi:cloudfla\
re/account@5.24.1-ZERO.ZERO.ZERO-DEV\x05\x10\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06\
output\x03\0\0\x01h\x01\x01r\x04\x0aaccount-id\x02\x0demail-address\x02\x08role-\
ids\x02\x06status\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x04\x0aaccount-id\x05\
\x0demail-address\x05\x08role-ids\x05\x06status\x05\x04\0\x03res\x03\0\x06\x01@\x02\
\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01:pulumi:cloudflare/ac\
count-member@5.24.1-ZERO.ZERO.ZERO-DEV\x05\x11\x01B\x0a\x02\x03\x02\x01\x01\x04\0\
\x06output\x03\0\0\x01h\x01\x01r\x06\x0aaccount-id\x02\x0bdefault-sni\x02\x0bdes\
cription\x02\x07enabled\x02\x03ips\x02\x0bmemberships\x02\x04\0\x04args\x03\0\x03\
\x01i\x01\x01r\x08\x0aaccount-id\x05\x0acan-delete\x05\x0ecan-modify-ips\x05\x0b\
default-sni\x05\x0bdescription\x05\x07enabled\x05\x03ips\x05\x0bmemberships\x05\x04\
\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\
\x017pulumi:cloudflare/address-map@5.24.1-ZERO.ZERO.ZERO-DEV\x05\x12\x01B\x0a\x02\
\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x02\x17auth-id-characteri\
stics\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x02\x17auth-id-ch\
aracteristics\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04arg\
s\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x016pulumi:cloudflare/api-shield@5.24.1-\
ZERO.ZERO.ZERO-DEV\x05\x13\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01\
h\x01\x01r\x04\x08endpoint\x02\x04host\x02\x06method\x02\x07zone-id\x02\x04\0\x04\
args\x03\0\x03\x01i\x01\x01r\x04\x08endpoint\x05\x04host\x05\x06method\x05\x07zo\
ne-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06in\
voke\x01\x08\x04\x01@pulumi:cloudflare/api-shield-operation@5.24.1-ZERO.ZERO.ZER\
O-DEV\x05\x14\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\
\x03\x11mitigation-action\x02\x0coperation-id\x02\x07zone-id\x02\x04\0\x04args\x03\
\0\x03\x01i\x01\x01r\x03\x11mitigation-action\x05\x0coperation-id\x05\x07zone-id\
\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\
\x08\x04\x01[pulumi:cloudflare/api-shield-operation-schema-validation-settings@5\
.24.1-ZERO.ZERO.ZERO-DEV\x05\x15\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\
\0\0\x01h\x01\x01r\x05\x04kind\x02\x04name\x02\x06source\x02\x12validation-enabl\
ed\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x05\x04kind\x05\x04n\
ame\x05\x06source\x05\x12validation-enabled\x05\x07zone-id\x05\x04\0\x03res\x03\0\
\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01=pulumi:\
cloudflare/api-shield-schema@5.24.1-ZERO.ZERO.ZERO-DEV\x05\x16\x01B\x0a\x02\x03\x02\
\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x03$validation-default-mitigation\
-action\x02%validation-override-mitigation-action\x02\x07zone-id\x02\x04\0\x04ar\
gs\x03\0\x03\x01i\x01\x01r\x03$validation-default-mitigation-action\x05%validati\
on-override-mitigation-action\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\
\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01Qpulumi:cloudflare/ap\
i-shield-schema-validation-settings@5.24.1-ZERO.ZERO.ZERO-DEV\x05\x17\x01B\x0a\x02\
\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x05\x09condition\x02\x0ae\
xpires-on\x02\x04name\x02\x0anot-before\x02\x08policies\x02\x04\0\x04args\x03\0\x03\
\x01i\x01\x01r\x09\x09condition\x05\x0aexpires-on\x05\x09issued-on\x05\x0bmodifi\
ed-on\x05\x04name\x05\x0anot-before\x05\x08policies\x05\x06status\x05\x05value\x05\
\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\
\x04\x015pulumi:cloudflare/api-token@5.24.1-ZERO.ZERO.ZERO-DEV\x05\x18\x01B\x0a\x02\
\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x03\x0dsmart-routing\x02\x0e\
tiered-caching\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x03\x0ds\
mart-routing\x05\x0etiered-caching\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01\
@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x010pulumi:cloudfla\
re/argo@5.24.1-ZERO.ZERO.ZERO-DEV\x05\x19\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06\
output\x03\0\0\x01h\x01\x01r\x04&authenticated-origin-pulls-certificate\x02\x07e\
nabled\x02\x08hostname\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x04\
&authenticated-origin-pulls-certificate\x05\x07enabled\x05\x08hostname\x05\x07zo\
ne-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06in\
voke\x01\x08\x04\x01Fpulumi:cloudflare/authenticated-origin-pulls@5.24.1-ZERO.ZE\
RO.ZERO-DEV\x05\x1a\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\
\x01r\x04\x0bcertificate\x02\x0bprivate-key\x02\x04type\x02\x07zone-id\x02\x04\0\
\x04args\x03\0\x03\x01i\x01\x01r\x0a\x0bcertificate\x05\x0aexpires-on\x05\x06iss\
uer\x05\x0bprivate-key\x05\x0dserial-number\x05\x09signature\x05\x06status\x05\x04\
type\x05\x0buploaded-on\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04na\
mes\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01Rpulumi:cloudflare/authenti\
cated-origin-pulls-certificate@5.24.1-ZERO.ZERO.ZERO-DEV\x05\x1b\x01B\x0a\x02\x03\
\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x0a\x11auto-update-model\x02\x09\
enable-js\x02\x0afight-mode\x02\x12optimize-wordpress\x02\x19sbfm-definitely-aut\
omated\x02\x15sbfm-likely-automated\x02\x1fsbfm-static-resource-protection\x02\x12\
sbfm-verified-bots\x02\x16suppress-session-score\x02\x07zone-id\x02\x04\0\x04arg\
s\x03\0\x03\x01i\x01\x01r\x0b\x11auto-update-model\x05\x09enable-js\x05\x0afight\
-mode\x05\x12optimize-wordpress\x05\x19sbfm-definitely-automated\x05\x15sbfm-lik\
ely-automated\x05\x1fsbfm-static-resource-protection\x05\x12sbfm-verified-bots\x05\
\x16suppress-session-score\x05\x12using-latest-model\x05\x07zone-id\x05\x04\0\x03\
res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01\
:pulumi:cloudflare/bot-management@5.24.1-ZERO.ZERO.ZERO-DEV\x05\x1c\x01B\x0a\x02\
\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x04\x0aaccount-id\x02\x0d\
advertisement\x02\x0bdescription\x02\x09prefix-id\x02\x04\0\x04args\x03\0\x03\x01\
i\x01\x01r\x04\x0aaccount-id\x05\x0dadvertisement\x05\x0bdescription\x05\x09pref\
ix-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06in\
voke\x01\x08\x04\x019pulumi:cloudflare/byo-ip-prefix@5.24.1-ZERO.ZERO.ZERO-DEV\x05\
\x1d\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x0a\x15c\
ertificate-authority\x02\x13cloudflare-branding\x02\x05hosts\x02\x04type\x02\x11\
validation-errors\x02\x11validation-method\x02\x12validation-records\x02\x0dvali\
dity-days\x02\x16wait-for-active-status\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\
\x01i\x01\x01r\x0a\x15certificate-authority\x05\x13cloudflare-branding\x05\x05ho\
sts\x05\x04type\x05\x11validation-errors\x05\x11validation-method\x05\x12validat\
ion-records\x05\x0dvalidity-days\x05\x16wait-for-active-status\x05\x07zone-id\x05\
\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\
\x04\x01<pulumi:cloudflare/certificate-pack@5.24.1-ZERO.ZERO.ZERO-DEV\x05\x1e\x01\
B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x07\x0fcustom-me\
tadata\x02\x14custom-origin-server\x02\x11custom-origin-sni\x02\x08hostname\x02\x04\
ssls\x02\x1fwait-for-ssl-pending-validation\x02\x07zone-id\x02\x04\0\x04args\x03\
\0\x03\x01i\x01\x01r\x0a\x0fcustom-metadata\x05\x14custom-origin-server\x05\x11c\
ustom-origin-sni\x05\x08hostname\x05\x16ownership-verification\x05\x1bownership-\
verification-http\x05\x04ssls\x05\x06status\x05\x1fwait-for-ssl-pending-validati\
on\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\
\x04\0\x06invoke\x01\x08\x04\x01;pulumi:cloudflare/custom-hostname@5.24.1-ZERO.Z\
ERO.ZERO-DEV\x05\x1f\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\
\x01r\x02\x06origin\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x03\
\x06origin\x05\x06status\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04n\
ames\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01Kpulumi:cloudflare/custom-\
hostname-fallback-origin@5.24.1-ZERO.ZERO.ZERO-DEV\x05\x20\x01B\x0a\x02\x03\x02\x01\
\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x05\x0aaccount-id\x02\x05state\x02\x04\
type\x02\x03url\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x05\x0a\
account-id\x05\x05state\x05\x04type\x05\x03url\x05\x07zone-id\x05\x04\0\x03res\x03\
\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x018pulum\
i:cloudflare/custom-pages@5.24.1-ZERO.ZERO.ZERO-DEV\x05!\x01B\x0a\x02\x03\x02\x01\
\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x03\x12custom-ssl-options\x02\x15cust\
om-ssl-priorities\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x0b\x12\
custom-ssl-options\x05\x15custom-ssl-priorities\x05\x0aexpires-on\x05\x05hosts\x05\
\x06issuer\x05\x0bmodified-on\x05\x08priority\x05\x09signature\x05\x06status\x05\
\x0buploaded-on\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04a\
rgs\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x016pulumi:cloudflare/custom-ssl@5.24.\
1-ZERO.ZERO.ZERO-DEV\x05\"\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01\
h\x01\x01r\x02\x0aaccount-id\x02\x04name\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01\
r\x03\x0aaccount-id\x05\x04name\x05\x07version\x05\x04\0\x03res\x03\0\x06\x01@\x02\
\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x017pulumi:cloudflare/d1\
-database@5.24.1-ZERO.ZERO.ZERO-DEV\x05#\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06o\
utput\x03\0\0\x01h\x01\x01r\x06\x0aaccount-id\x02\x04data\x02\x0bdescription\x02\
\x07enabled\x02\x08interval\x02\x04name\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01\
r\x08\x0aaccount-id\x05\x07created\x05\x04data\x05\x0bdescription\x05\x07enabled\
\x05\x08interval\x05\x04name\x05\x07updated\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04\
names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01;pulumi:cloudflare/device\
-dex-test@5.24.1-ZERO.ZERO.ZERO-DEV\x05$\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06o\
utput\x03\0\0\x01h\x01\x01r\x04\x0aaccount-id\x02\x06config\x02\x04name\x02\x04t\
ype\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x04\x0aaccount-id\x05\x06config\x05\
\x04name\x05\x04type\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\
\x04\0\x06invoke\x01\x08\x04\x01Cpulumi:cloudflare/device-managed-networks@5.24.\
1-ZERO.ZERO.ZERO-DEV\x05%\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01\
h\x01\x01r\x02\x07enabled\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01\
r\x02\x07enabled\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04\
args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01Fpulumi:cloudflare/device-policy-c\
ertificates@5.24.1-ZERO.ZERO.ZERO-DEV\x05&\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06\
output\x03\0\0\x01h\x01\x01r\x06\x0aaccount-id\x02\x07configs\x02\x0aidentifier\x02\
\x08interval\x02\x04name\x02\x04type\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x06\
\x0aaccount-id\x05\x07configs\x05\x0aidentifier\x05\x08interval\x05\x04name\x05\x04\
type\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06inv\
oke\x01\x08\x04\x01Fpulumi:cloudflare/device-posture-integration@5.24.1-ZERO.ZER\
O.ZERO-DEV\x05'\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01\
r\x08\x0aaccount-id\x02\x0bdescription\x02\x0aexpiration\x02\x06inputs\x02\x07ma\
tches\x02\x04name\x02\x08schedule\x02\x04type\x02\x04\0\x04args\x03\0\x03\x01i\x01\
\x01r\x08\x0aaccount-id\x05\x0bdescription\x05\x0aexpiration\x05\x06inputs\x05\x07\
matches\x05\x04name\x05\x08schedule\x05\x04type\x05\x04\0\x03res\x03\0\x06\x01@\x02\
\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01?pulumi:cloudflare/de\
vice-posture-rule@5.24.1-ZERO.ZERO.ZERO-DEV\x05(\x01B\x0a\x02\x03\x02\x01\x01\x04\
\0\x06output\x03\0\0\x01h\x01\x01r\x12\x0aaccount-id\x02\x11allow-mode-switch\x02\
\x0dallow-updates\x02\x10allowed-to-leave\x02\x0cauto-connect\x02\x0ecaptive-por\
tal\x02\x07default\x02\x0bdescription\x02\x15disable-auto-fallback\x02\x07enable\
d\x02\x12exclude-office-ips\x02\x05match\x02\x04name\x02\x0aprecedence\x02\x14se\
rvice-mode-v2-mode\x02\x14service-mode-v2-port\x02\x0bsupport-url\x02\x0dswitch-\
locked\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x12\x0aaccount-id\x05\x11allow-\
mode-switch\x05\x0dallow-updates\x05\x10allowed-to-leave\x05\x0cauto-connect\x05\
\x0ecaptive-portal\x05\x07default\x05\x0bdescription\x05\x15disable-auto-fallbac\
k\x05\x07enabled\x05\x12exclude-office-ips\x05\x05match\x05\x04name\x05\x0aprece\
dence\x05\x14service-mode-v2-mode\x05\x14service-mode-v2-port\x05\x0bsupport-url\
\x05\x0dswitch-locked\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\
\x07\x04\0\x06invoke\x01\x08\x04\x01Bpulumi:cloudflare/device-settings-policy@5.\
24.1-ZERO.ZERO.ZERO-DEV\x05)\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\
\x01h\x01\x01r\x07\x0aaccount-id\x02\x13allowed-match-count\x02\x11context-aware\
ness\x02\x0bdescription\x02\x07entries\x02\x04name\x02\x04type\x02\x04\0\x04args\
\x03\0\x03\x01i\x01\x01r\x07\x0aaccount-id\x05\x13allowed-match-count\x05\x11con\
text-awareness\x05\x0bdescription\x05\x07entries\x05\x04name\x05\x04type\x05\x04\
\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\
\x017pulumi:cloudflare/dlp-profile@5.24.1-ZERO.ZERO.ZERO-DEV\x05*\x01B\x0a\x02\x03\
\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x02\x0aaccount-id\x02\x05emai\
l\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x06\x0aaccount-id\x05\x07created\x05\
\x05email\x05\x08modified\x05\x03tag\x05\x08verified\x05\x04\0\x03res\x03\0\x06\x01\
@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01Apulumi:cloudfla\
re/email-routing-address@5.24.1-ZERO.ZERO.ZERO-DEV\x05+\x01B\x0a\x02\x03\x02\x01\
\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x05\x07actions\x02\x07enabled\x02\x08\
matchers\x02\x04name\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x06\
\x07actions\x05\x07enabled\x05\x08matchers\x05\x04name\x05\x03tag\x05\x07zone-id\
\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\
\x08\x04\x01Cpulumi:cloudflare/email-routing-catch-all@5.24.1-ZERO.ZERO.ZERO-DEV\
\x05,\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x06\x07\
actions\x02\x07enabled\x02\x08matchers\x02\x04name\x02\x08priority\x02\x07zone-i\
d\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x07\x07actions\x05\x07enabled\x05\x08\
matchers\x05\x04name\x05\x08priority\x05\x03tag\x05\x07zone-id\x05\x04\0\x03res\x03\
\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01>pulum\
i:cloudflare/email-routing-rule@5.24.1-ZERO.ZERO.ZERO-DEV\x05-\x01B\x0a\x02\x03\x02\
\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x03\x07enabled\x02\x0bskip-wizard\
\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x08\x07created\x05\x07\
enabled\x05\x08modified\x05\x04name\x05\x0bskip-wizard\x05\x06status\x05\x03tag\x05\
\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\
\x06invoke\x01\x08\x04\x01Bpulumi:cloudflare/email-routing-settings@5.24.1-ZERO.\
ZERO.ZERO-DEV\x05.\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\
\x01r\x03\x0aaccount-id\x02\x07domains\x02\x09policy-id\x02\x04\0\x04args\x03\0\x03\
\x01i\x01\x01r\x03\x0aaccount-id\x05\x07domains\x05\x09policy-id\x05\x04\0\x03re\
s\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01;\
pulumi:cloudflare/fallback-domain@5.24.1-ZERO.ZERO.ZERO-DEV\x05/\x01B\x0a\x02\x03\
\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x05\x0bdescription\x02\x0aexp\
ression\x02\x06paused\x02\x03ref\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\
\x01\x01r\x05\x0bdescription\x05\x0aexpression\x05\x06paused\x05\x03ref\x05\x07z\
one-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06i\
nvoke\x01\x08\x04\x012pulumi:cloudflare/filter@5.24.1-ZERO.ZERO.ZERO-DEV\x050\x01\
B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x07\x06action\x02\
\x0bdescription\x02\x09filter-id\x02\x06paused\x02\x08priority\x02\x08products\x02\
\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x07\x06action\x05\x0bdescr\
iption\x05\x09filter-id\x05\x06paused\x05\x08priority\x05\x08products\x05\x07zon\
e-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06inv\
oke\x01\x08\x04\x019pulumi:cloudflare/firewall-rule@5.24.1-ZERO.ZERO.ZERO-DEV\x05\
1\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x0b\x0aacco\
unt-id\x02\x17cloudflare-gre-endpoint\x02\x15customer-gre-endpoint\x02\x0bdescri\
ption\x02\x14health-check-enabled\x02\x13health-check-target\x02\x11health-check\
-type\x02\x11interface-address\x02\x03mtu\x02\x04name\x02\x03ttl\x02\x04\0\x04ar\
gs\x03\0\x03\x01i\x01\x01r\x0b\x0aaccount-id\x05\x17cloudflare-gre-endpoint\x05\x15\
customer-gre-endpoint\x05\x0bdescription\x05\x14health-check-enabled\x05\x13heal\
th-check-target\x05\x11health-check-type\x05\x11interface-address\x05\x03mtu\x05\
\x04name\x05\x03ttl\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\
\x04\0\x06invoke\x01\x08\x04\x016pulumi:cloudflare/gre-tunnel@5.24.1-ZERO.ZERO.Z\
ERO-DEV\x052\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x14\
\x07address\x02\x0eallow-insecure\x02\x0dcheck-regions\x02\x11consecutive-fails\x02\
\x15consecutive-successes\x02\x0bdescription\x02\x0dexpected-body\x02\x0eexpecte\
d-codes\x02\x10follow-redirects\x02\x07headers\x02\x08interval\x02\x06method\x02\
\x04name\x02\x04path\x02\x04port\x02\x07retries\x02\x09suspended\x02\x07timeout\x02\
\x04type\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x16\x07address\
\x05\x0eallow-insecure\x05\x0dcheck-regions\x05\x11consecutive-fails\x05\x15cons\
ecutive-successes\x05\x0acreated-on\x05\x0bdescription\x05\x0dexpected-body\x05\x0e\
expected-codes\x05\x10follow-redirects\x05\x07headers\x05\x08interval\x05\x06met\
hod\x05\x0bmodified-on\x05\x04name\x05\x04path\x05\x04port\x05\x07retries\x05\x09\
suspended\x05\x07timeout\x05\x04type\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01\
@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x017pulumi:cloudfla\
re/healthcheck@5.24.1-ZERO.ZERO.ZERO-DEV\x053\x01B\x0a\x02\x03\x02\x01\x01\x04\0\
\x06output\x03\0\0\x01h\x01\x01r\x04\x08hostname\x02\x07setting\x02\x05value\x02\
\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x06\x0acreated-at\x05\x08h\
ostname\x05\x07setting\x05\x0aupdated-at\x05\x05value\x05\x07zone-id\x05\x04\0\x03\
res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01\
@pulumi:cloudflare/hostname-tls-setting@5.24.1-ZERO.ZERO.ZERO-DEV\x054\x01B\x0a\x02\
\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x04\x08hostname\x02\x05po\
rts\x02\x06values\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x06\x0a\
created-at\x05\x08hostname\x05\x05ports\x05\x0aupdated-at\x05\x06values\x05\x07z\
one-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06i\
nvoke\x01\x08\x04\x01Hpulumi:cloudflare/hostname-tls-setting-ciphers@5.24.1-ZERO\
.ZERO.ZERO-DEV\x055\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\
\x01r\x04\x0aaccount-id\x02\x07caching\x02\x04name\x02\x06origin\x02\x04\0\x04ar\
gs\x03\0\x03\x01i\x01\x01r\x04\x0aaccount-id\x05\x07caching\x05\x04name\x05\x06o\
rigin\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06in\
voke\x01\x08\x04\x01=pulumi:cloudflare/hyperdrive-config@5.24.1-ZERO.ZERO.ZERO-D\
EV\x056\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x11\x0a\
account-id\x02\x11allow-null-cipher\x02\x13cloudflare-endpoint\x02\x11customer-e\
ndpoint\x02\x0bdescription\x02\x07fqdn-id\x02\x16health-check-direction\x02\x14h\
ealth-check-enabled\x02\x11health-check-rate\x02\x13health-check-target\x02\x11h\
ealth-check-type\x02\x06hex-id\x02\x11interface-address\x02\x04name\x02\x03psk\x02\
\x09remote-id\x02\x07user-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x11\x0aac\
count-id\x05\x11allow-null-cipher\x05\x13cloudflare-endpoint\x05\x11customer-end\
point\x05\x0bdescription\x05\x07fqdn-id\x05\x16health-check-direction\x05\x14hea\
lth-check-enabled\x05\x11health-check-rate\x05\x13health-check-target\x05\x11hea\
lth-check-type\x05\x06hex-id\x05\x11interface-address\x05\x04name\x05\x03psk\x05\
\x09remote-id\x05\x07user-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04arg\
s\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x018pulumi:cloudflare/ipsec-tunnel@5.24.\
1-ZERO.ZERO.ZERO-DEV\x057\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01\
h\x01\x01r\x07\x0dbundle-method\x02\x0bcertificate\x02\x07enabled\x02\x04host\x02\
\x04name\x02\x04port\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x08\
\x0dbundle-method\x05\x0bcertificate\x05\x07enabled\x05\x04host\x05\x04name\x05\x04\
port\x05\x06status\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04\
args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01?pulumi:cloudflare/keyless-certifi\
cate@5.24.1-ZERO.ZERO.ZERO-DEV\x058\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\
\x03\0\0\x01h\x01\x01r\x05\x0aaccount-id\x02\x0bdescription\x02\x05items\x02\x04\
kind\x02\x04name\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x05\x0aaccount-id\x05\
\x0bdescription\x05\x05items\x05\x04kind\x05\x04name\x05\x04\0\x03res\x03\0\x06\x01\
@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x010pulumi:cloudfla\
re/list@5.24.1-ZERO.ZERO.ZERO-DEV\x059\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06out\
put\x03\0\0\x01h\x01\x01r\x07\x0aaccount-id\x02\x03asn\x02\x07comment\x02\x08hos\
tname\x02\x02ip\x02\x07list-id\x02\x08redirect\x02\x04\0\x04args\x03\0\x03\x01i\x01\
\x01r\x07\x0aaccount-id\x05\x03asn\x05\x07comment\x05\x08hostname\x05\x02ip\x05\x07\
list-id\x05\x08redirect\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\
\0\x07\x04\0\x06invoke\x01\x08\x04\x015pulumi:cloudflare/list-item@5.24.1-ZERO.Z\
ERO.ZERO-DEV\x05:\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01\
r\x13\x11adaptive-routings\x02\x0dcountry-pools\x02\x10default-pool-ids\x02\x0bd\
escription\x02\x07enabled\x02\x10fallback-pool-id\x02\x13location-strategies\x02\
\x04name\x02\x09pop-pools\x02\x07proxied\x02\x10random-steerings\x02\x0cregion-p\
ools\x02\x05rules\x02\x10session-affinity\x02\x1bsession-affinity-attributes\x02\
\x14session-affinity-ttl\x02\x0fsteering-policy\x02\x03ttl\x02\x07zone-id\x02\x04\
\0\x04args\x03\0\x03\x01i\x01\x01r\x15\x11adaptive-routings\x05\x0dcountry-pools\
\x05\x0acreated-on\x05\x10default-pool-ids\x05\x0bdescription\x05\x07enabled\x05\
\x10fallback-pool-id\x05\x13location-strategies\x05\x0bmodified-on\x05\x04name\x05\
\x09pop-pools\x05\x07proxied\x05\x10random-steerings\x05\x0cregion-pools\x05\x05\
rules\x05\x10session-affinity\x05\x1bsession-affinity-attributes\x05\x14session-\
affinity-ttl\x05\x0fsteering-policy\x05\x03ttl\x05\x07zone-id\x05\x04\0\x03res\x03\
\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x019pulum\
i:cloudflare/load-balancer@5.24.1-ZERO.ZERO.ZERO-DEV\x05;\x01B\x0a\x02\x03\x02\x01\
\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x11\x0aaccount-id\x02\x0eallow-insecu\
re\x02\x10consecutive-down\x02\x0econsecutive-up\x02\x0bdescription\x02\x0dexpec\
ted-body\x02\x0eexpected-codes\x02\x10follow-redirects\x02\x07headers\x02\x08int\
erval\x02\x06method\x02\x04path\x02\x04port\x02\x0aprobe-zone\x02\x07retries\x02\
\x07timeout\x02\x04type\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x13\x0aaccount\
-id\x05\x0eallow-insecure\x05\x10consecutive-down\x05\x0econsecutive-up\x05\x0ac\
reated-on\x05\x0bdescription\x05\x0dexpected-body\x05\x0eexpected-codes\x05\x10f\
ollow-redirects\x05\x07headers\x05\x08interval\x05\x06method\x05\x0bmodified-on\x05\
\x04path\x05\x04port\x05\x0aprobe-zone\x05\x07retries\x05\x07timeout\x05\x04type\
\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\
\x08\x04\x01Apulumi:cloudflare/load-balancer-monitor@5.24.1-ZERO.ZERO.ZERO-DEV\x05\
<\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x0d\x0aacco\
unt-id\x02\x0dcheck-regions\x02\x0bdescription\x02\x07enabled\x02\x08latitude\x02\
\x0eload-sheddings\x02\x09longitude\x02\x0fminimum-origins\x02\x07monitor\x02\x04\
name\x02\x12notification-email\x02\x10origin-steerings\x02\x07origins\x02\x04\0\x04\
args\x03\0\x03\x01i\x01\x01r\x0f\x0aaccount-id\x05\x0dcheck-regions\x05\x0acreat\
ed-on\x05\x0bdescription\x05\x07enabled\x05\x08latitude\x05\x0eload-sheddings\x05\
\x09longitude\x05\x0fminimum-origins\x05\x0bmodified-on\x05\x07monitor\x05\x04na\
me\x05\x12notification-email\x05\x10origin-steerings\x05\x07origins\x05\x04\0\x03\
res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01\
>pulumi:cloudflare/load-balancer-pool@5.24.1-ZERO.ZERO.ZERO-DEV\x05=\x01B\x0a\x02\
\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x02\x07enabled\x02\x07zon\
e-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x02\x07enabled\x05\x07zone-id\x05\
\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\
\x04\x01=pulumi:cloudflare/logpull-retention@5.24.1-ZERO.ZERO.ZERO-DEV\x05>\x01B\
\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x0f\x0aaccount-id\
\x02\x07dataset\x02\x10destination-conf\x02\x07enabled\x02\x06filter\x02\x09freq\
uency\x02\x04kind\x02\x0flogpull-options\x02\x10max-upload-bytes\x02\x1bmax-uplo\
ad-interval-seconds\x02\x12max-upload-records\x02\x04name\x02\x0eoutput-options\x02\
\x13ownership-challenge\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\
\x0f\x0aaccount-id\x05\x07dataset\x05\x10destination-conf\x05\x07enabled\x05\x06\
filter\x05\x09frequency\x05\x04kind\x05\x0flogpull-options\x05\x10max-upload-byt\
es\x05\x1bmax-upload-interval-seconds\x05\x12max-upload-records\x05\x04name\x05\x0e\
output-options\x05\x13ownership-challenge\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\
\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x017pulumi:clou\
dflare/logpush-job@5.24.1-ZERO.ZERO.ZERO-DEV\x05?\x01B\x0a\x02\x03\x02\x01\x01\x04\
\0\x06output\x03\0\0\x01h\x01\x01r\x03\x0aaccount-id\x02\x10destination-conf\x02\
\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x04\x0aaccount-id\x05\x10d\
estination-conf\x05\x1cownership-challenge-filename\x05\x07zone-id\x05\x04\0\x03\
res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01\
Gpulumi:cloudflare/logpush-ownership-challenge@5.24.1-ZERO.ZERO.ZERO-DEV\x05@\x01\
B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x04\x0aaccount-i\
d\x02\x0bdescription\x02\x04name\x02\x05rules\x02\x04\0\x04args\x03\0\x03\x01i\x01\
\x01r\x04\x0aaccount-id\x05\x0bdescription\x05\x04name\x05\x05rules\x05\x04\0\x03\
res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01\
Bpulumi:cloudflare/magic-firewall-ruleset@5.24.1-ZERO.ZERO.ZERO-DEV\x05A\x01B\x0a\
\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x03\x17managed-reques\
t-headers\x02\x18managed-response-headers\x02\x07zone-id\x02\x04\0\x04args\x03\0\
\x03\x01i\x01\x01r\x03\x17managed-request-headers\x05\x18managed-response-header\
s\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\
\0\x06invoke\x01\x08\x04\x01;pulumi:cloudflare/managed-headers@5.24.1-ZERO.ZERO.\
ZERO-DEV\x05B\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\
\x05\x0aaccount-id\x02\x02ca\x02\x0ccertificates\x02\x04name\x02\x0bprivate-key\x02\
\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x0a\x0aaccount-id\x05\x02ca\x05\x0ccertif\
icates\x05\x0aexpires-on\x05\x06issuer\x05\x04name\x05\x0bprivate-key\x05\x0dser\
ial-number\x05\x09signature\x05\x0buploaded-on\x05\x04\0\x03res\x03\0\x06\x01@\x02\
\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01<pulumi:cloudflare/mt\
ls-certificate@5.24.1-ZERO.ZERO.ZERO-DEV\x05C\x01B\x0a\x02\x03\x02\x01\x01\x04\0\
\x06output\x03\0\0\x01h\x01\x01r\x09\x0aaccount-id\x02\x0aalert-type\x02\x0bdesc\
ription\x02\x12email-integrations\x02\x07enabled\x02\x07filters\x02\x04name\x02\x16\
pagerduty-integrations\x02\x15webhooks-integrations\x02\x04\0\x04args\x03\0\x03\x01\
i\x01\x01r\x0b\x0aaccount-id\x05\x0aalert-type\x05\x07created\x05\x0bdescription\
\x05\x12email-integrations\x05\x07enabled\x05\x07filters\x05\x08modified\x05\x04\
name\x05\x16pagerduty-integrations\x05\x15webhooks-integrations\x05\x04\0\x03res\
\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01?p\
ulumi:cloudflare/notification-policy@5.24.1-ZERO.ZERO.ZERO-DEV\x05D\x01B\x0a\x02\
\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x04\x0aaccount-id\x02\x04\
name\x02\x06secret\x02\x03url\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x08\x0aa\
ccount-id\x05\x0acreated-at\x05\x0clast-failure\x05\x0clast-success\x05\x04name\x05\
\x06secret\x05\x04type\x05\x03url\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04\
args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01Hpulumi:cloudflare/notification-po\
licy-webhooks@5.24.1-ZERO.ZERO.ZERO-DEV\x05E\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06\
output\x03\0\0\x01h\x01\x01r\x04\x09frequency\x02\x06region\x02\x03url\x02\x07zo\
ne-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x04\x09frequency\x05\x06region\x05\
\x03url\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\
\x07\x04\0\x06invoke\x01\x08\x04\x01Fpulumi:cloudflare/observatory-scheduled-tes\
t@5.24.1-ZERO.ZERO.ZERO-DEV\x05F\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\
\0\0\x01h\x01\x01r\x05\x03csr\x02\x09hostnames\x02\x14min-days-for-renewal\x02\x0c\
request-type\x02\x12requested-validity\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\
\x07\x0bcertificate\x05\x03csr\x05\x0aexpires-on\x05\x09hostnames\x05\x14min-day\
s-for-renewal\x05\x0crequest-type\x05\x12requested-validity\x05\x04\0\x03res\x03\
\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01Apulum\
i:cloudflare/origin-ca-certificate@5.24.1-ZERO.ZERO.ZERO-DEV\x05G\x01B\x0a\x02\x03\
\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x05\x07actions\x02\x08priorit\
y\x02\x06status\x02\x06target\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\
\x01r\x05\x07actions\x05\x08priority\x05\x06status\x05\x06target\x05\x07zone-id\x05\
\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\
\x04\x015pulumi:cloudflare/page-rule@5.24.1-ZERO.ZERO.ZERO-DEV\x05H\x01B\x0a\x02\
\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x03\x0aaccount-id\x02\x06\
domain\x02\x0cproject-name\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x04\x0aacco\
unt-id\x05\x06domain\x05\x0cproject-name\x05\x06status\x05\x04\0\x03res\x03\0\x06\
\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x018pulumi:clou\
dflare/pages-domain@5.24.1-ZERO.ZERO.ZERO-DEV\x05I\x01B\x0a\x02\x03\x02\x01\x01\x04\
\0\x06output\x03\0\0\x01h\x01\x01r\x06\x0aaccount-id\x02\x0cbuild-config\x02\x12\
deployment-configs\x02\x04name\x02\x11production-branch\x02\x06source\x02\x04\0\x04\
args\x03\0\x03\x01i\x01\x01r\x09\x0aaccount-id\x05\x0cbuild-config\x05\x0acreate\
d-on\x05\x12deployment-configs\x05\x07domains\x05\x04name\x05\x11production-bran\
ch\x05\x06source\x05\x09subdomain\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04\
args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x019pulumi:cloudflare/pages-project@5\
.24.1-ZERO.ZERO.ZERO-DEV\x05J\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\
\0\x01h\x01\x01r\x02\x0aaccount-id\x02\x04name\x02\x04\0\x04args\x03\0\x03\x01i\x01\
\x01r\x02\x0aaccount-id\x05\x04name\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\
\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x011pulumi:cloudflare/queue@5.24.\
1-ZERO.ZERO.ZERO-DEV\x05K\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01\
h\x01\x01r\x03\x0aaccount-id\x02\x08location\x02\x04name\x02\x04\0\x04args\x03\0\
\x03\x01i\x01\x01r\x03\x0aaccount-id\x05\x08location\x05\x04name\x05\x04\0\x03re\
s\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x015\
pulumi:cloudflare/r2-bucket@5.24.1-ZERO.ZERO.ZERO-DEV\x05L\x01B\x0a\x02\x03\x02\x01\
\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x09\x06action\x02\x13bypass-url-patte\
rns\x02\x09correlate\x02\x0bdescription\x02\x08disabled\x02\x05match\x02\x06peri\
od\x02\x09threshold\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x09\
\x06action\x05\x13bypass-url-patterns\x05\x09correlate\x05\x0bdescription\x05\x08\
disabled\x05\x05match\x05\x06period\x05\x09threshold\x05\x07zone-id\x05\x04\0\x03\
res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01\
6pulumi:cloudflare/rate-limit@5.24.1-ZERO.ZERO.ZERO-DEV\x05M\x01B\x0a\x02\x03\x02\
\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x0b\x0fallow-overwrite\x02\x07com\
ment\x02\x04data\x02\x04name\x02\x08priority\x02\x07proxied\x02\x04tags\x02\x03t\
tl\x02\x04type\x02\x05value\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01\
r\x10\x0fallow-overwrite\x05\x07comment\x05\x0acreated-on\x05\x04data\x05\x08hos\
tname\x05\x08metadata\x05\x0bmodified-on\x05\x04name\x05\x08priority\x05\x09prox\
iable\x05\x07proxied\x05\x04tags\x05\x03ttl\x05\x04type\x05\x05value\x05\x07zone\
-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invo\
ke\x01\x08\x04\x012pulumi:cloudflare/record@5.24.1-ZERO.ZERO.ZERO-DEV\x05N\x01B\x0a\
\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x03\x08hostname\x02\x0a\
region-key\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x04\x0acreat\
ed-on\x05\x08hostname\x05\x0aregion-key\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\
\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01=pulumi:clou\
dflare/regional-hostname@5.24.1-ZERO.ZERO.ZERO-DEV\x05O\x01B\x0a\x02\x03\x02\x01\
\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x02\x05value\x02\x07zone-id\x02\x04\0\
\x04args\x03\0\x03\x01i\x01\x01r\x02\x05value\x05\x07zone-id\x05\x04\0\x03res\x03\
\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01Apulum\
i:cloudflare/regional-tiered-cache@5.24.1-ZERO.ZERO.ZERO-DEV\x05P\x01B\x0a\x02\x03\
\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x07\x0aaccount-id\x02\x0bdesc\
ription\x02\x04kind\x02\x04name\x02\x05phase\x02\x05rules\x02\x07zone-id\x02\x04\
\0\x04args\x03\0\x03\x01i\x01\x01r\x07\x0aaccount-id\x05\x0bdescription\x05\x04k\
ind\x05\x04name\x05\x05phase\x05\x05rules\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\
\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x013pulumi:clou\
dflare/ruleset@5.24.1-ZERO.ZERO.ZERO-DEV\x05Q\x01B\x0a\x02\x03\x02\x01\x01\x04\0\
\x06output\x03\0\0\x01h\x01\x01r\x0d\x12argo-smart-routing\x02\x03dns\x02\x08edg\
e-ips\x02\x0bip-firewall\x02\x0eorigin-directs\x02\x0aorigin-dns\x02\x0borigin-p\
ort\x02\x11origin-port-range\x02\x08protocol\x02\x0eproxy-protocol\x02\x03tls\x02\
\x0ctraffic-type\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x0d\x12\
argo-smart-routing\x05\x03dns\x05\x08edge-ips\x05\x0bip-firewall\x05\x0eorigin-d\
irects\x05\x0aorigin-dns\x05\x0borigin-port\x05\x11origin-port-range\x05\x08prot\
ocol\x05\x0eproxy-protocol\x05\x03tls\x05\x0ctraffic-type\x05\x07zone-id\x05\x04\
\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\
\x01@pulumi:cloudflare/spectrum-application@5.24.1-ZERO.ZERO.ZERO-DEV\x05R\x01B\x0a\
\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x04\x0aaccount-id\x02\
\x04mode\x02\x09policy-id\x02\x07tunnels\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01\
r\x04\x0aaccount-id\x05\x04mode\x05\x09policy-id\x05\x07tunnels\x05\x04\0\x03res\
\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x018p\
ulumi:cloudflare/split-tunnel@5.24.1-ZERO.ZERO.ZERO-DEV\x05S\x01B\x0a\x02\x03\x02\
\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x08\x0aaccount-id\x02\x0acolo-nam\
es\x02\x0ccolo-regions\x02\x0bdescription\x02\x07nexthop\x02\x06prefix\x02\x08pr\
iority\x02\x06weight\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x08\x0aaccount-id\
\x05\x0acolo-names\x05\x0ccolo-regions\x05\x0bdescription\x05\x07nexthop\x05\x06\
prefix\x05\x08priority\x05\x06weight\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04name\
s\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x018pulumi:cloudflare/static-rou\
te@5.24.1-ZERO.ZERO.ZERO-DEV\x05T\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\
\0\0\x01h\x01\x01r\x0f\x0aaccount-id\x02\x14activity-log-enabled\x02\x09antiviru\
s\x02\x0ablock-page\x02\x0dbody-scanning\x02\x17extended-email-matching\x02\x04f\
ips\x02\x07logging\x02&non-identity-browser-isolation-enabled\x02\x0bpayload-log\
\x02\x1aprotocol-detection-enabled\x02\x05proxy\x02\x0fssh-session-log\x02\x13tl\
s-decrypt-enabled\x02\x1durl-browser-isolation-enabled\x02\x04\0\x04args\x03\0\x03\
\x01i\x01\x01r\x0f\x0aaccount-id\x05\x14activity-log-enabled\x05\x09antivirus\x05\
\x0ablock-page\x05\x0dbody-scanning\x05\x17extended-email-matching\x05\x04fips\x05\
\x07logging\x05&non-identity-browser-isolation-enabled\x05\x0bpayload-log\x05\x1a\
protocol-detection-enabled\x05\x05proxy\x05\x0fssh-session-log\x05\x13tls-decryp\
t-enabled\x05\x1durl-browser-isolation-enabled\x05\x04\0\x03res\x03\0\x06\x01@\x02\
\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x019pulumi:cloudflare/te\
ams-account@5.24.1-ZERO.ZERO.ZERO-DEV\x05U\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06\
output\x03\0\0\x01h\x01\x01r\x05\x0aaccount-id\x02\x0bdescription\x02\x05items\x02\
\x04name\x02\x04type\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x05\x0aaccount-id\
\x05\x0bdescription\x05\x05items\x05\x04name\x05\x04type\x05\x04\0\x03res\x03\0\x06\
\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x016pulumi:clou\
dflare/teams-list@5.24.1-ZERO.ZERO.ZERO-DEV\x05V\x01B\x0a\x02\x03\x02\x01\x01\x04\
\0\x06output\x03\0\0\x01h\x01\x01r\x04\x0aaccount-id\x02\x0eclient-default\x02\x04\
name\x02\x08networks\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x09\x0aaccount-id\
\x05\x17anonymized-logs-enabled\x05\x0eclient-default\x05\x0ddoh-subdomain\x05\x02\
ip\x05\x10ipv4-destination\x05\x04name\x05\x08networks\x05\x0apolicy-ids\x05\x04\
\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\
\x01:pulumi:cloudflare/teams-location@5.24.1-ZERO.ZERO.ZERO-DEV\x05W\x01B\x0a\x02\
\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x03\x0aaccount-id\x02\x03\
ips\x02\x04name\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x04\x0aaccount-id\x05\x03\
ips\x05\x04name\x05\x09subdomain\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04\
args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01@pulumi:cloudflare/teams-proxy-end\
point@5.24.1-ZERO.ZERO.ZERO-DEV\x05X\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06outpu\
t\x03\0\0\x01h\x01\x01r\x0b\x0aaccount-id\x02\x06action\x02\x0bdescription\x02\x0e\
device-posture\x02\x07enabled\x02\x07filters\x02\x08identity\x02\x04name\x02\x0a\
precedence\x02\x0drule-settings\x02\x07traffic\x02\x04\0\x04args\x03\0\x03\x01i\x01\
\x01r\x0c\x0aaccount-id\x05\x06action\x05\x0bdescription\x05\x0edevice-posture\x05\
\x07enabled\x05\x07filters\x05\x08identity\x05\x04name\x05\x0aprecedence\x05\x0d\
rule-settings\x05\x07traffic\x05\x07version\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04\
names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x016pulumi:cloudflare/teams-\
rule@5.24.1-ZERO.ZERO.ZERO-DEV\x05Y\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\
\x03\0\0\x01h\x01\x01r\x02\x0acache-type\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\
\x01i\x01\x01r\x02\x0acache-type\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\
\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x018pulumi:cloudflare/ti\
ered-cache@5.24.1-ZERO.ZERO.ZERO-DEV\x05Z\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06\
output\x03\0\0\x01h\x01\x01r\x03\x15certificate-authority\x02\x07enabled\x02\x07\
zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x03\x15certificate-authority\x05\
\x07enabled\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\
\0\x07\x04\0\x06invoke\x01\x08\x04\x015pulumi:cloudflare/total-tls@5.24.1-ZERO.Z\
ERO.ZERO-DEV\x05[\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01\
r\x04\x0aaccount-id\x02\x0aconfig-src\x02\x04name\x02\x06secret\x02\x04\0\x04arg\
s\x03\0\x03\x01i\x01\x01r\x06\x0aaccount-id\x05\x05cname\x05\x0aconfig-src\x05\x04\
name\x05\x06secret\x05\x0ctunnel-token\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04na\
mes\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x012pulumi:cloudflare/tunnel@5\
.24.1-ZERO.ZERO.ZERO-DEV\x05\\\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\
\0\x01h\x01\x01r\x03\x0aaccount-id\x02\x06config\x02\x09tunnel-id\x02\x04\0\x04a\
rgs\x03\0\x03\x01i\x01\x01r\x03\x0aaccount-id\x05\x06config\x05\x09tunnel-id\x05\
\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\
\x04\x019pulumi:cloudflare/tunnel-config@5.24.1-ZERO.ZERO.ZERO-DEV\x05]\x01B\x0a\
\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x05\x0aaccount-id\x02\
\x07comment\x02\x07network\x02\x09tunnel-id\x02\x12virtual-network-id\x02\x04\0\x04\
args\x03\0\x03\x01i\x01\x01r\x05\x0aaccount-id\x05\x07comment\x05\x07network\x05\
\x09tunnel-id\x05\x12virtual-network-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04n\
ames\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x018pulumi:cloudflare/tunnel-\
route@5.24.1-ZERO.ZERO.ZERO-DEV\x05^\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06outpu\
t\x03\0\0\x01h\x01\x01r\x04\x0aaccount-id\x02\x07comment\x02\x12is-default-netwo\
rk\x02\x04name\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x04\x0aaccount-id\x05\x07\
comment\x05\x12is-default-network\x05\x04name\x05\x04\0\x03res\x03\0\x06\x01@\x02\
\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01Bpulumi:cloudflare/tu\
nnel-virtual-network@5.24.1-ZERO.ZERO.ZERO-DEV\x05_\x01B\x0a\x02\x03\x02\x01\x01\
\x04\0\x06output\x03\0\0\x01h\x01\x01r\x07\x0aaccount-id\x02\x0ebot-fight-mode\x02\
\x07domains\x02\x04mode\x02\x04name\x02\x08offlabel\x02\x06region\x02\x04\0\x04a\
rgs\x03\0\x03\x01i\x01\x01r\x08\x0aaccount-id\x05\x0ebot-fight-mode\x05\x07domai\
ns\x05\x04mode\x05\x04name\x05\x08offlabel\x05\x06region\x05\x06secret\x05\x04\0\
\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\
\x01<pulumi:cloudflare/turnstile-widget@5.24.1-ZERO.ZERO.ZERO-DEV\x05`\x01B\x0a\x02\
\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x03\x05scope\x02\x04type\x02\
\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x03\x05scope\x05\x04type\x05\
\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\
\x06invoke\x01\x08\x04\x01Fpulumi:cloudflare/url-normalization-settings@5.24.1-Z\
ERO.ZERO.ZERO-DEV\x05a\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\
\x01\x01r\x05\x0dconfiguration\x02\x0bdescription\x02\x04mode\x02\x06paused\x02\x07\
zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x05\x0dconfiguration\x05\x0bde\
scription\x05\x04mode\x05\x06paused\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01\
@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01Dpulumi:cloudfla\
re/user-agent-blocking-rule@5.24.1-ZERO.ZERO.ZERO-DEV\x05b\x01B\x0a\x02\x03\x02\x01\
\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x12\x11additional-routes\x02\x0dcooki\
e-suffix\x02\x10custom-page-html\x02\x19default-template-language\x02\x0bdescrip\
tion\x02\x17disable-session-renewal\x02\x04host\x02\x15json-response-enabled\x02\
\x04name\x02\x14new-users-per-minute\x02\x04path\x02\x09queue-all\x02\x0fqueuein\
g-method\x02\x14queueing-status-code\x02\x10session-duration\x02\x09suspended\x02\
\x12total-active-users\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x12\
\x11additional-routes\x05\x0dcookie-suffix\x05\x10custom-page-html\x05\x19defaul\
t-template-language\x05\x0bdescription\x05\x17disable-session-renewal\x05\x04hos\
t\x05\x15json-response-enabled\x05\x04name\x05\x14new-users-per-minute\x05\x04pa\
th\x05\x09queue-all\x05\x0fqueueing-method\x05\x14queueing-status-code\x05\x10se\
ssion-duration\x05\x09suspended\x05\x12total-active-users\x05\x07zone-id\x05\x04\
\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\
\x018pulumi:cloudflare/waiting-room@5.24.1-ZERO.ZERO.ZERO-DEV\x05c\x01B\x0a\x02\x03\
\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x0f\x10custom-page-html\x02\x0b\
description\x02\x17disable-session-renewal\x02\x0eevent-end-time\x02\x10event-st\
art-time\x02\x04name\x02\x14new-users-per-minute\x02\x13prequeue-start-time\x02\x0f\
queueing-method\x02\x10session-duration\x02\x16shuffle-at-event-start\x02\x09sus\
pended\x02\x12total-active-users\x02\x0fwaiting-room-id\x02\x07zone-id\x02\x04\0\
\x04args\x03\0\x03\x01i\x01\x01r\x11\x0acreated-on\x05\x10custom-page-html\x05\x0b\
description\x05\x17disable-session-renewal\x05\x0eevent-end-time\x05\x10event-st\
art-time\x05\x0bmodified-on\x05\x04name\x05\x14new-users-per-minute\x05\x13prequ\
eue-start-time\x05\x0fqueueing-method\x05\x10session-duration\x05\x16shuffle-at-\
event-start\x05\x09suspended\x05\x12total-active-users\x05\x0fwaiting-room-id\x05\
\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\
\x06invoke\x01\x08\x04\x01>pulumi:cloudflare/waiting-room-event@5.24.1-ZERO.ZERO\
.ZERO-DEV\x05d\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01\
r\x03\x05rules\x02\x0fwaiting-room-id\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\
\x01i\x01\x01r\x03\x05rules\x05\x0fwaiting-room-id\x05\x07zone-id\x05\x04\0\x03r\
es\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01\
>pulumi:cloudflare/waiting-room-rules@5.24.1-ZERO.ZERO.ZERO-DEV\x05e\x01B\x0a\x02\
\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x02\x1csearch-engine-craw\
ler-bypass\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x02\x1csearc\
h-engine-crawler-bypass\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04na\
mes\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01Apulumi:cloudflare/waiting-\
room-settings@5.24.1-ZERO.ZERO.ZERO-DEV\x05f\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06\
output\x03\0\0\x01h\x01\x01r\x05\x0bdescription\x02\x07dnslink\x02\x04name\x02\x06\
target\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x08\x0acreated-o\
n\x05\x0bdescription\x05\x07dnslink\x05\x0bmodified-on\x05\x04name\x05\x06status\
\x05\x06target\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04ar\
gs\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x019pulumi:cloudflare/web3-hostname@5.2\
4.1-ZERO.ZERO.ZERO-DEV\x05g\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\
\x01h\x01\x01r\x06\x0aaccount-id\x02\x04host\x02\x09inclusive\x02\x09is-paused\x02\
\x05paths\x02\x0aruleset-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x06\x0aacc\
ount-id\x05\x04host\x05\x09inclusive\x05\x09is-paused\x05\x05paths\x05\x0arulese\
t-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06inv\
oke\x01\x08\x04\x01>pulumi:cloudflare/web-analytics-rule@5.24.1-ZERO.ZERO.ZERO-D\
EV\x05h\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x04\x0a\
account-id\x02\x0cauto-install\x02\x04host\x02\x08zone-tag\x02\x04\0\x04args\x03\
\0\x03\x01i\x01\x01r\x08\x0aaccount-id\x05\x0cauto-install\x05\x04host\x05\x0aru\
leset-id\x05\x08site-tag\x05\x0asite-token\x05\x07snippet\x05\x08zone-tag\x05\x04\
\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\
\x01>pulumi:cloudflare/web-analytics-site@5.24.1-ZERO.ZERO.ZERO-DEV\x05i\x01B\x0a\
\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x03\x0aaccount-id\x02\
\x09schedules\x02\x0bscript-name\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x03\x0a\
account-id\x05\x09schedules\x05\x0bscript-name\x05\x04\0\x03res\x03\0\x06\x01@\x02\
\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01?pulumi:cloudflare/wo\
rker-cron-trigger@5.24.1-ZERO.ZERO.ZERO-DEV\x05j\x01B\x0a\x02\x03\x02\x01\x01\x04\
\0\x06output\x03\0\0\x01h\x01\x01r\x05\x0aaccount-id\x02\x0benvironment\x02\x08h\
ostname\x02\x07service\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x05\
\x0aaccount-id\x05\x0benvironment\x05\x08hostname\x05\x07service\x05\x07zone-id\x05\
\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\
\x04\x019pulumi:cloudflare/worker-domain@5.24.1-ZERO.ZERO.ZERO-DEV\x05k\x01B\x0a\
\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x03\x07pattern\x02\x0b\
script-name\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x03\x07patt\
ern\x05\x0bscript-name\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04nam\
es\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x018pulumi:cloudflare/worker-ro\
ute@5.24.1-ZERO.ZERO.ZERO-DEV\x05l\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\
\0\0\x01h\x01\x01r\x13\x0aaccount-id\x02\x19analytics-engine-bindings\x02\x12com\
patibility-date\x02\x13compatibility-flags\x02\x07content\x02\x14d1-database-bin\
dings\x02\x12dispatch-namespace\x02\x15kv-namespace-bindings\x02\x07logpush\x02\x06\
module\x02\x04name\x02\x0aplacements\x02\x13plain-text-bindings\x02\x0equeue-bin\
dings\x02\x12r2-bucket-bindings\x02\x14secret-text-bindings\x02\x10service-bindi\
ngs\x02\x04tags\x02\x14webassembly-bindings\x02\x04\0\x04args\x03\0\x03\x01i\x01\
\x01r\x13\x0aaccount-id\x05\x19analytics-engine-bindings\x05\x12compatibility-da\
te\x05\x13compatibility-flags\x05\x07content\x05\x14d1-database-bindings\x05\x12\
dispatch-namespace\x05\x15kv-namespace-bindings\x05\x07logpush\x05\x06module\x05\
\x04name\x05\x0aplacements\x05\x13plain-text-bindings\x05\x0equeue-bindings\x05\x12\
r2-bucket-bindings\x05\x14secret-text-bindings\x05\x10service-bindings\x05\x04ta\
gs\x05\x14webassembly-bindings\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04a\
rgs\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x019pulumi:cloudflare/worker-script@5.\
24.1-ZERO.ZERO.ZERO-DEV\x05m\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\
\x01h\x01\x01r\x04\x0aaccount-id\x02\x04name\x02\x0bscript-name\x02\x0bsecret-te\
xt\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x04\x0aaccount-id\x05\x04name\x05\x0b\
script-name\x05\x0bsecret-text\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04a\
rgs\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x019pulumi:cloudflare/worker-secret@5.\
24.1-ZERO.ZERO.ZERO-DEV\x05n\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\
\x01h\x01\x01r\x02\x0aaccount-id\x02\x04name\x02\x04\0\x04args\x03\0\x03\x01i\x01\
\x01r\x02\x0aaccount-id\x05\x04name\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\
\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01Kpulumi:cloudflare/workers-for\
-platforms-namespace@5.24.1-ZERO.ZERO.ZERO-DEV\x05o\x01B\x0a\x02\x03\x02\x01\x01\
\x04\0\x06output\x03\0\0\x01h\x01\x01r\x04\x0aaccount-id\x02\x03key\x02\x0cnames\
pace-id\x02\x05value\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x04\x0aaccount-id\
\x05\x03key\x05\x0cnamespace-id\x05\x05value\x05\x04\0\x03res\x03\0\x06\x01@\x02\
\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x016pulumi:cloudflare/wo\
rkers-kv@5.24.1-ZERO.ZERO.ZERO-DEV\x05p\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06ou\
tput\x03\0\0\x01h\x01\x01r\x02\x0aaccount-id\x02\x05title\x02\x04\0\x04args\x03\0\
\x03\x01i\x01\x01r\x02\x0aaccount-id\x05\x05title\x05\x04\0\x03res\x03\0\x06\x01\
@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01@pulumi:cloudfla\
re/workers-kv-namespace@5.24.1-ZERO.ZERO.ZERO-DEV\x05q\x01B\x0a\x02\x03\x02\x01\x01\
\x04\0\x06output\x03\0\0\x01h\x01\x01r\x06\x0aaccount-id\x02\x0ajump-start\x02\x06\
paused\x02\x04plan\x02\x04type\x02\x04zone\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01\
r\x0b\x0aaccount-id\x05\x0ajump-start\x05\x04meta\x05\x0cname-servers\x05\x06pau\
sed\x05\x04plan\x05\x06status\x05\x04type\x05\x13vanity-name-servers\x05\x10veri\
fication-key\x05\x04zone\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\
\0\x07\x04\0\x06invoke\x01\x08\x04\x010pulumi:cloudflare/zone@5.24.1-ZERO.ZERO.Z\
ERO-DEV\x05r\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\x01r\x02\
\x07enabled\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x02\x07enab\
led\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\
\x04\0\x06invoke\x01\x08\x04\x01>pulumi:cloudflare/zone-cache-reserve@5.24.1-ZER\
O.ZERO.ZERO-DEV\x05s\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\
\x01r\x0c\x05avifs\x02\x04bmps\x02\x04gifs\x02\x04jp2s\x02\x05jpegs\x02\x05jpg2s\
\x02\x04jpgs\x02\x04pngs\x02\x05tiffs\x02\x04tifs\x02\x05webps\x02\x07zone-id\x02\
\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x0c\x05avifs\x05\x04bmps\x05\x04gifs\x05\x04\
jp2s\x05\x05jpegs\x05\x05jpg2s\x05\x04jpgs\x05\x04pngs\x05\x05tiffs\x05\x04tifs\x05\
\x05webps\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\
\0\x07\x04\0\x06invoke\x01\x08\x04\x01?pulumi:cloudflare/zone-cache-variants@5.2\
4.1-ZERO.ZERO.ZERO-DEV\x05t\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\
\x01h\x01\x01r\x02\x0bmodified-on\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01\
i\x01\x01r\x0c\x09algorithm\x05\x06digest\x05\x10digest-algorithm\x05\x0bdigest-\
type\x05\x02ds\x05\x05flags\x05\x07key-tag\x05\x08key-type\x05\x0bmodified-on\x05\
\x0apublic-key\x05\x06status\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04\
names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x017pulumi:cloudflare/zone-d\
nssec@5.24.1-ZERO.ZERO.ZERO-DEV\x05u\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06outpu\
t\x03\0\0\x01h\x01\x01r\x04\x04hold\x02\x0ahold-after\x02\x12include-subdomains\x02\
\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x04\x04hold\x05\x0ahold-af\
ter\x05\x12include-subdomains\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\
\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x015pulumi:cloudflare/zo\
ne-hold@5.24.1-ZERO.ZERO.ZERO-DEV\x05v\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06out\
put\x03\0\0\x01h\x01\x01r\x06\x0econfigurations\x02\x0bdescription\x02\x06paused\
\x02\x08priority\x02\x04urls\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\
\x01r\x06\x0econfigurations\x05\x0bdescription\x05\x06paused\x05\x08priority\x05\
\x04urls\x05\x07zone-id\x05\x04\0\x03res\x03\0\x06\x01@\x02\x04names\x04args\x04\
\0\x07\x04\0\x06invoke\x01\x08\x04\x019pulumi:cloudflare/zone-lockdown@5.24.1-ZE\
RO.ZERO.ZERO-DEV\x05w\x01B\x0a\x02\x03\x02\x01\x01\x04\0\x06output\x03\0\0\x01h\x01\
\x01r\x02\x08settings\x02\x07zone-id\x02\x04\0\x04args\x03\0\x03\x01i\x01\x01r\x07\
\x10initial-settings\x05\x18initial-settings-read-at\x05\x11readonly-settings\x05\
\x08settings\x05\x07zone-id\x05\x0bzone-status\x05\x09zone-type\x05\x04\0\x03res\
\x03\0\x06\x01@\x02\x04names\x04args\x04\0\x07\x04\0\x06invoke\x01\x08\x04\x01Bp\
ulumi:cloudflare/zone-settings-override@5.24.1-ZERO.ZERO.ZERO-DEV\x05x\x04\x01=p\
ulumi:cloudflare/cloudflare-pulumi@5.24.1-ZERO.ZERO.ZERO-DEV\x04\0\x0b\x17\x01\0\
\x11cloudflare-pulumi\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-com\
ponent\x070.208.1\x10wit-bindgen-rust\x060.25.0";

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
