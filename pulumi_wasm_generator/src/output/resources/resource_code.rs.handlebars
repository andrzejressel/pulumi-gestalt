{{#if resource.input_properties}}
#[derive(bon::Builder, Clone)]
#[builder(finish_fn = build_struct)]
pub struct {{resource.struct_name}}Args {
{{#each resource.input_properties}}
    {{#each description_lines}}
    /// {{&this}}
    {{/each}}
    {{#if default}}
    #[builder(into, default)]
    {{else if skip}}
    #[builder(skip)]
    {{else}}
    #[builder(into)]
    {{/if}}
    {{#unless private}}pub {{/unless}}{{arg_name}}: pulumi_wasm_rust::Output<{{&type_}}>,
{{/each}}
}
{{/if}}

{{#if resource.output_properties}}
pub struct {{resource.struct_name}}Result {
{{#each resource.output_properties}}
    {{#each description_lines}}
        /// {{&this}}
    {{/each}}
    pub {{arg_name}}: pulumi_wasm_rust::Output<{{&type_}}>,
{{/each}}
}
{{/if}}

///
/// Registers a new resource with the given unique name and arguments
///
#[allow(non_snake_case, unused_imports)]
pub fn create(
    name: &str,
{{#if resource.input_properties}}
    args: {{resource.struct_name}}Args
{{/if}}
) {{#if resource.output_properties}} -> {{resource.struct_name}}Result{{/if}} {
    use pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
    use pulumi_wasm_wit::client_bindings::component::pulumi_wasm::output_interface::Output as WitOutput;
    use pulumi_wasm_rust::Output;
    use std::collections::HashMap;

{{#each resource.input_properties}}
    let {{arg_name}}_binding = args.{{arg_name}}.get_inner();
{{/each}}

    let request = register_interface::RegisterResourceRequest {
        type_: "{{resource.type}}".into(),
        name: name.to_string(),
        object: Vec::from([
            {{#each resource.input_properties}}
                register_interface::ObjectField { name: "{{name}}".into(), value: &{{arg_name}}_binding },
            {{/each}}
        ]),
        results: vec![
            {{#each resource.output_properties}}
                register_interface::ResultField { name: "{{name}}".into() },
            {{/each}}
        ],
    };

{{#if resource.output_properties}}
    fn into_domain<F: serde::Serialize>(output: WitOutput) -> Output<F> {
        unsafe { Output::<F>::new_from_handle(output) }
    }

    let o = register_interface::register(&request);
    let mut hashmap: HashMap<String, _> = o.fields.into_iter().map(|f| (f.name, f.output)).collect();
    {{resource.struct_name}}Result {
    {{#each resource.output_properties}}
        {{arg_name}}: into_domain(hashmap.remove("{{name}}").unwrap()),
    {{/each}}
    }
{{else}}
    register_interface::register(&request);
{{/if}}
}
