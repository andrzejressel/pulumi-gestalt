pub mod access_application {
    //! Provides a Cloudflare Access Application resource. Access
    //! Applications are used to restrict access to a whole application using an
    //! authorisation gateway managed by Cloudflare.
    //!
    //! > It's required that an `account_id` or `zone_id` is provided and in
    //!    most cases using either is fine. However, if you're using a scoped
    //!    access token, you must provide the argument that matches the token's
    //!    scope. For example, an access token that is scoped to the "example.com"
    //!    zone needs to use the `zone_id` argument.
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/accessApplication:AccessApplication example <account_id>/<application_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct AccessApplicationArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// When set to true, users can authenticate to this application using their WARP session. When set to false this application will always require direct IdP authentication. This setting always overrides the organization setting for WARP authentication.
        #[builder(into, default)]
        pub allow_authenticate_via_warp: pulumi_wasm_rust::Output<Option<bool>>,
        /// The identity providers selected for the application.
        #[builder(into, default)]
        pub allowed_idps: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The logo URL of the app launcher.
        #[builder(into, default)]
        pub app_launcher_logo_url: pulumi_wasm_rust::Output<Option<String>>,
        /// Option to show/hide applications in App Launcher. Defaults to `true`.
        #[builder(into, default)]
        pub app_launcher_visible: pulumi_wasm_rust::Output<Option<bool>>,
        /// Option to skip identity provider selection if only one is configured in `allowed_idps`. Defaults to `false`.
        #[builder(into, default)]
        pub auto_redirect_to_identity: pulumi_wasm_rust::Output<Option<bool>>,
        /// The background color of the app launcher.
        #[builder(into, default)]
        pub bg_color: pulumi_wasm_rust::Output<Option<String>>,
        /// CORS configuration for the Access Application. See below for reference structure.
        #[builder(into, default)]
        pub cors_headers: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessApplicationCorsHeader>>,
        >,
        /// Option that returns a custom error message when a user is denied access to the application.
        #[builder(into, default)]
        pub custom_deny_message: pulumi_wasm_rust::Output<Option<String>>,
        /// Option that redirects to a custom URL when a user is denied access to the application via identity based rules.
        #[builder(into, default)]
        pub custom_deny_url: pulumi_wasm_rust::Output<Option<String>>,
        /// Option that redirects to a custom URL when a user is denied access to the application via non identity rules.
        #[builder(into, default)]
        pub custom_non_identity_deny_url: pulumi_wasm_rust::Output<Option<String>>,
        /// The custom pages selected for the application.
        #[builder(into, default)]
        pub custom_pages: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The primary hostname and path that Access will secure. If the app is visible in the App Launcher dashboard, this is the domain that will be displayed.
        #[builder(into, default)]
        pub domain: pulumi_wasm_rust::Output<Option<String>>,
        /// Option to provide increased security against compromised authorization tokens and CSRF attacks by requiring an additional "binding" cookie on requests. Defaults to `false`.
        #[builder(into, default)]
        pub enable_binding_cookie: pulumi_wasm_rust::Output<Option<bool>>,
        /// The footer links of the app launcher.
        #[builder(into, default)]
        pub footer_links: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessApplicationFooterLink>>,
        >,
        /// The background color of the header bar in the app launcher.
        #[builder(into, default)]
        pub header_bg_color: pulumi_wasm_rust::Output<Option<String>>,
        /// Option to add the `HttpOnly` cookie flag to access tokens.
        #[builder(into, default)]
        pub http_only_cookie_attribute: pulumi_wasm_rust::Output<Option<bool>>,
        /// The landing page design of the app launcher.
        #[builder(into, default)]
        pub landing_page_design: pulumi_wasm_rust::Output<
            Option<super::types::AccessApplicationLandingPageDesign>,
        >,
        /// Image URL for the logo shown in the app launcher dashboard.
        #[builder(into, default)]
        pub logo_url: pulumi_wasm_rust::Output<Option<String>>,
        /// Friendly name of the Access Application.
        #[builder(into, default)]
        pub name: pulumi_wasm_rust::Output<Option<String>>,
        /// Allows options preflight requests to bypass Access authentication and go directly to the origin. Cannot turn on if cors_headers is set. Defaults to `false`.
        #[builder(into, default)]
        pub options_preflight_bypass: pulumi_wasm_rust::Output<Option<bool>>,
        /// The policies associated with the application, in ascending order of precedence. Warning: Do not use this field while you still have this application ID referenced as `application_id` in any `cloudflare.AccessPolicy` resource, as it can result in an inconsistent state.
        #[builder(into, default)]
        pub policies: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// SaaS configuration for the Access Application.
        #[builder(into, default)]
        pub saas_app: pulumi_wasm_rust::Output<
            Option<super::types::AccessApplicationSaasApp>,
        >,
        /// Defines the same-site cookie setting for access tokens. Available values: `none`, `lax`, `strict`.
        #[builder(into, default)]
        pub same_site_cookie_attribute: pulumi_wasm_rust::Output<Option<String>>,
        /// Configuration for provisioning to this application via SCIM. This is currently in closed beta.
        #[builder(into, default)]
        pub scim_config: pulumi_wasm_rust::Output<
            Option<super::types::AccessApplicationScimConfig>,
        >,
        /// List of domains that access will secure. Only present for self_hosted, vnc, and ssh applications. Always includes the value set as `domain`.
        #[builder(into, default)]
        pub self_hosted_domains: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Option to return a 401 status code in service authentication rules on failed requests. Defaults to `false`.
        #[builder(into, default)]
        pub service_auth401_redirect: pulumi_wasm_rust::Output<Option<bool>>,
        /// How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`. Defaults to `24h`.
        #[builder(into, default)]
        pub session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// Option to skip the App Launcher landing page. Defaults to `false`.
        #[builder(into, default)]
        pub skip_app_launcher_login_page: pulumi_wasm_rust::Output<Option<bool>>,
        /// Option to skip the authorization interstitial when using the CLI. Defaults to `false`.
        #[builder(into, default)]
        pub skip_interstitial: pulumi_wasm_rust::Output<Option<bool>>,
        /// The itags associated with the application.
        #[builder(into, default)]
        pub tags: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The payload for an infrastructure application which defines the port, protocol, and target attributes. Only applicable to Infrastructure Applications, in which case this field is required.
        #[builder(into, default)]
        pub target_criterias: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessApplicationTargetCriteria>>,
        >,
        /// The application type. Available values: `app_launcher`, `bookmark`, `biso`, `dash_sso`, `saas`, `self_hosted`, `ssh`, `vnc`, `warp`, `infrastructure`. Defaults to `self_hosted`.
        #[builder(into, default)]
        pub type_: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct AccessApplicationResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// When set to true, users can authenticate to this application using their WARP session. When set to false this application will always require direct IdP authentication. This setting always overrides the organization setting for WARP authentication.
        pub allow_authenticate_via_warp: pulumi_wasm_rust::Output<Option<bool>>,
        /// The identity providers selected for the application.
        pub allowed_idps: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The logo URL of the app launcher.
        pub app_launcher_logo_url: pulumi_wasm_rust::Output<Option<String>>,
        /// Option to show/hide applications in App Launcher. Defaults to `true`.
        pub app_launcher_visible: pulumi_wasm_rust::Output<Option<bool>>,
        /// Application Audience (AUD) Tag of the application.
        pub aud: pulumi_wasm_rust::Output<String>,
        /// Option to skip identity provider selection if only one is configured in `allowed_idps`. Defaults to `false`.
        pub auto_redirect_to_identity: pulumi_wasm_rust::Output<Option<bool>>,
        /// The background color of the app launcher.
        pub bg_color: pulumi_wasm_rust::Output<Option<String>>,
        /// CORS configuration for the Access Application. See below for reference structure.
        pub cors_headers: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessApplicationCorsHeader>>,
        >,
        /// Option that returns a custom error message when a user is denied access to the application.
        pub custom_deny_message: pulumi_wasm_rust::Output<Option<String>>,
        /// Option that redirects to a custom URL when a user is denied access to the application via identity based rules.
        pub custom_deny_url: pulumi_wasm_rust::Output<Option<String>>,
        /// Option that redirects to a custom URL when a user is denied access to the application via non identity rules.
        pub custom_non_identity_deny_url: pulumi_wasm_rust::Output<Option<String>>,
        /// The custom pages selected for the application.
        pub custom_pages: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The primary hostname and path that Access will secure. If the app is visible in the App Launcher dashboard, this is the domain that will be displayed.
        pub domain: pulumi_wasm_rust::Output<String>,
        /// Option to provide increased security against compromised authorization tokens and CSRF attacks by requiring an additional "binding" cookie on requests. Defaults to `false`.
        pub enable_binding_cookie: pulumi_wasm_rust::Output<Option<bool>>,
        /// The footer links of the app launcher.
        pub footer_links: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessApplicationFooterLink>>,
        >,
        /// The background color of the header bar in the app launcher.
        pub header_bg_color: pulumi_wasm_rust::Output<Option<String>>,
        /// Option to add the `HttpOnly` cookie flag to access tokens.
        pub http_only_cookie_attribute: pulumi_wasm_rust::Output<Option<bool>>,
        /// The landing page design of the app launcher.
        pub landing_page_design: pulumi_wasm_rust::Output<
            Option<super::types::AccessApplicationLandingPageDesign>,
        >,
        /// Image URL for the logo shown in the app launcher dashboard.
        pub logo_url: pulumi_wasm_rust::Output<Option<String>>,
        /// Friendly name of the Access Application.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Allows options preflight requests to bypass Access authentication and go directly to the origin. Cannot turn on if cors_headers is set. Defaults to `false`.
        pub options_preflight_bypass: pulumi_wasm_rust::Output<Option<bool>>,
        /// The policies associated with the application, in ascending order of precedence. Warning: Do not use this field while you still have this application ID referenced as `application_id` in any `cloudflare.AccessPolicy` resource, as it can result in an inconsistent state.
        pub policies: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// SaaS configuration for the Access Application.
        pub saas_app: pulumi_wasm_rust::Output<
            Option<super::types::AccessApplicationSaasApp>,
        >,
        /// Defines the same-site cookie setting for access tokens. Available values: `none`, `lax`, `strict`.
        pub same_site_cookie_attribute: pulumi_wasm_rust::Output<Option<String>>,
        /// Configuration for provisioning to this application via SCIM. This is currently in closed beta.
        pub scim_config: pulumi_wasm_rust::Output<
            Option<super::types::AccessApplicationScimConfig>,
        >,
        /// List of domains that access will secure. Only present for self_hosted, vnc, and ssh applications. Always includes the value set as `domain`.
        pub self_hosted_domains: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Option to return a 401 status code in service authentication rules on failed requests. Defaults to `false`.
        pub service_auth401_redirect: pulumi_wasm_rust::Output<Option<bool>>,
        /// How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`. Defaults to `24h`.
        pub session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// Option to skip the App Launcher landing page. Defaults to `false`.
        pub skip_app_launcher_login_page: pulumi_wasm_rust::Output<Option<bool>>,
        /// Option to skip the authorization interstitial when using the CLI. Defaults to `false`.
        pub skip_interstitial: pulumi_wasm_rust::Output<Option<bool>>,
        /// The itags associated with the application.
        pub tags: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The payload for an infrastructure application which defines the port, protocol, and target attributes. Only applicable to Infrastructure Applications, in which case this field is required.
        pub target_criterias: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessApplicationTargetCriteria>>,
        >,
        /// The application type. Available values: `app_launcher`, `bookmark`, `biso`, `dash_sso`, `saas`, `self_hosted`, `ssh`, `vnc`, `warp`, `infrastructure`. Defaults to `self_hosted`.
        pub type_: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: AccessApplicationArgs) -> AccessApplicationResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let allow_authenticate_via_warp_binding = args
            .allow_authenticate_via_warp
            .get_inner();
        let allowed_idps_binding = args.allowed_idps.get_inner();
        let app_launcher_logo_url_binding = args.app_launcher_logo_url.get_inner();
        let app_launcher_visible_binding = args.app_launcher_visible.get_inner();
        let auto_redirect_to_identity_binding = args
            .auto_redirect_to_identity
            .get_inner();
        let bg_color_binding = args.bg_color.get_inner();
        let cors_headers_binding = args.cors_headers.get_inner();
        let custom_deny_message_binding = args.custom_deny_message.get_inner();
        let custom_deny_url_binding = args.custom_deny_url.get_inner();
        let custom_non_identity_deny_url_binding = args
            .custom_non_identity_deny_url
            .get_inner();
        let custom_pages_binding = args.custom_pages.get_inner();
        let domain_binding = args.domain.get_inner();
        let enable_binding_cookie_binding = args.enable_binding_cookie.get_inner();
        let footer_links_binding = args.footer_links.get_inner();
        let header_bg_color_binding = args.header_bg_color.get_inner();
        let http_only_cookie_attribute_binding = args
            .http_only_cookie_attribute
            .get_inner();
        let landing_page_design_binding = args.landing_page_design.get_inner();
        let logo_url_binding = args.logo_url.get_inner();
        let name_binding = args.name.get_inner();
        let options_preflight_bypass_binding = args.options_preflight_bypass.get_inner();
        let policies_binding = args.policies.get_inner();
        let saas_app_binding = args.saas_app.get_inner();
        let same_site_cookie_attribute_binding = args
            .same_site_cookie_attribute
            .get_inner();
        let scim_config_binding = args.scim_config.get_inner();
        let self_hosted_domains_binding = args.self_hosted_domains.get_inner();
        let service_auth401_redirect_binding = args.service_auth401_redirect.get_inner();
        let session_duration_binding = args.session_duration.get_inner();
        let skip_app_launcher_login_page_binding = args
            .skip_app_launcher_login_page
            .get_inner();
        let skip_interstitial_binding = args.skip_interstitial.get_inner();
        let tags_binding = args.tags.get_inner();
        let target_criterias_binding = args.target_criterias.get_inner();
        let type__binding = args.type_.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/accessApplication:AccessApplication".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "allowAuthenticateViaWarp".into(),
                    value: &allow_authenticate_via_warp_binding,
                },
                register_interface::ObjectField {
                    name: "allowedIdps".into(),
                    value: &allowed_idps_binding,
                },
                register_interface::ObjectField {
                    name: "appLauncherLogoUrl".into(),
                    value: &app_launcher_logo_url_binding,
                },
                register_interface::ObjectField {
                    name: "appLauncherVisible".into(),
                    value: &app_launcher_visible_binding,
                },
                register_interface::ObjectField {
                    name: "autoRedirectToIdentity".into(),
                    value: &auto_redirect_to_identity_binding,
                },
                register_interface::ObjectField {
                    name: "bgColor".into(),
                    value: &bg_color_binding,
                },
                register_interface::ObjectField {
                    name: "corsHeaders".into(),
                    value: &cors_headers_binding,
                },
                register_interface::ObjectField {
                    name: "customDenyMessage".into(),
                    value: &custom_deny_message_binding,
                },
                register_interface::ObjectField {
                    name: "customDenyUrl".into(),
                    value: &custom_deny_url_binding,
                },
                register_interface::ObjectField {
                    name: "customNonIdentityDenyUrl".into(),
                    value: &custom_non_identity_deny_url_binding,
                },
                register_interface::ObjectField {
                    name: "customPages".into(),
                    value: &custom_pages_binding,
                },
                register_interface::ObjectField {
                    name: "domain".into(),
                    value: &domain_binding,
                },
                register_interface::ObjectField {
                    name: "enableBindingCookie".into(),
                    value: &enable_binding_cookie_binding,
                },
                register_interface::ObjectField {
                    name: "footerLinks".into(),
                    value: &footer_links_binding,
                },
                register_interface::ObjectField {
                    name: "headerBgColor".into(),
                    value: &header_bg_color_binding,
                },
                register_interface::ObjectField {
                    name: "httpOnlyCookieAttribute".into(),
                    value: &http_only_cookie_attribute_binding,
                },
                register_interface::ObjectField {
                    name: "landingPageDesign".into(),
                    value: &landing_page_design_binding,
                },
                register_interface::ObjectField {
                    name: "logoUrl".into(),
                    value: &logo_url_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "optionsPreflightBypass".into(),
                    value: &options_preflight_bypass_binding,
                },
                register_interface::ObjectField {
                    name: "policies".into(),
                    value: &policies_binding,
                },
                register_interface::ObjectField {
                    name: "saasApp".into(),
                    value: &saas_app_binding,
                },
                register_interface::ObjectField {
                    name: "sameSiteCookieAttribute".into(),
                    value: &same_site_cookie_attribute_binding,
                },
                register_interface::ObjectField {
                    name: "scimConfig".into(),
                    value: &scim_config_binding,
                },
                register_interface::ObjectField {
                    name: "selfHostedDomains".into(),
                    value: &self_hosted_domains_binding,
                },
                register_interface::ObjectField {
                    name: "serviceAuth401Redirect".into(),
                    value: &service_auth401_redirect_binding,
                },
                register_interface::ObjectField {
                    name: "sessionDuration".into(),
                    value: &session_duration_binding,
                },
                register_interface::ObjectField {
                    name: "skipAppLauncherLoginPage".into(),
                    value: &skip_app_launcher_login_page_binding,
                },
                register_interface::ObjectField {
                    name: "skipInterstitial".into(),
                    value: &skip_interstitial_binding,
                },
                register_interface::ObjectField {
                    name: "tags".into(),
                    value: &tags_binding,
                },
                register_interface::ObjectField {
                    name: "targetCriterias".into(),
                    value: &target_criterias_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "allowAuthenticateViaWarp".into(),
                },
                register_interface::ResultField {
                    name: "allowedIdps".into(),
                },
                register_interface::ResultField {
                    name: "appLauncherLogoUrl".into(),
                },
                register_interface::ResultField {
                    name: "appLauncherVisible".into(),
                },
                register_interface::ResultField {
                    name: "aud".into(),
                },
                register_interface::ResultField {
                    name: "autoRedirectToIdentity".into(),
                },
                register_interface::ResultField {
                    name: "bgColor".into(),
                },
                register_interface::ResultField {
                    name: "corsHeaders".into(),
                },
                register_interface::ResultField {
                    name: "customDenyMessage".into(),
                },
                register_interface::ResultField {
                    name: "customDenyUrl".into(),
                },
                register_interface::ResultField {
                    name: "customNonIdentityDenyUrl".into(),
                },
                register_interface::ResultField {
                    name: "customPages".into(),
                },
                register_interface::ResultField {
                    name: "domain".into(),
                },
                register_interface::ResultField {
                    name: "enableBindingCookie".into(),
                },
                register_interface::ResultField {
                    name: "footerLinks".into(),
                },
                register_interface::ResultField {
                    name: "headerBgColor".into(),
                },
                register_interface::ResultField {
                    name: "httpOnlyCookieAttribute".into(),
                },
                register_interface::ResultField {
                    name: "landingPageDesign".into(),
                },
                register_interface::ResultField {
                    name: "logoUrl".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "optionsPreflightBypass".into(),
                },
                register_interface::ResultField {
                    name: "policies".into(),
                },
                register_interface::ResultField {
                    name: "saasApp".into(),
                },
                register_interface::ResultField {
                    name: "sameSiteCookieAttribute".into(),
                },
                register_interface::ResultField {
                    name: "scimConfig".into(),
                },
                register_interface::ResultField {
                    name: "selfHostedDomains".into(),
                },
                register_interface::ResultField {
                    name: "serviceAuth401Redirect".into(),
                },
                register_interface::ResultField {
                    name: "sessionDuration".into(),
                },
                register_interface::ResultField {
                    name: "skipAppLauncherLoginPage".into(),
                },
                register_interface::ResultField {
                    name: "skipInterstitial".into(),
                },
                register_interface::ResultField {
                    name: "tags".into(),
                },
                register_interface::ResultField {
                    name: "targetCriterias".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        AccessApplicationResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            allow_authenticate_via_warp: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("allowAuthenticateViaWarp").unwrap(),
            ),
            allowed_idps: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("allowedIdps").unwrap(),
            ),
            app_launcher_logo_url: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("appLauncherLogoUrl").unwrap(),
            ),
            app_launcher_visible: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("appLauncherVisible").unwrap(),
            ),
            aud: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("aud").unwrap(),
            ),
            auto_redirect_to_identity: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("autoRedirectToIdentity").unwrap(),
            ),
            bg_color: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("bgColor").unwrap(),
            ),
            cors_headers: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("corsHeaders").unwrap(),
            ),
            custom_deny_message: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customDenyMessage").unwrap(),
            ),
            custom_deny_url: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customDenyUrl").unwrap(),
            ),
            custom_non_identity_deny_url: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customNonIdentityDenyUrl").unwrap(),
            ),
            custom_pages: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customPages").unwrap(),
            ),
            domain: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("domain").unwrap(),
            ),
            enable_binding_cookie: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enableBindingCookie").unwrap(),
            ),
            footer_links: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("footerLinks").unwrap(),
            ),
            header_bg_color: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("headerBgColor").unwrap(),
            ),
            http_only_cookie_attribute: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("httpOnlyCookieAttribute").unwrap(),
            ),
            landing_page_design: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("landingPageDesign").unwrap(),
            ),
            logo_url: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("logoUrl").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            options_preflight_bypass: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("optionsPreflightBypass").unwrap(),
            ),
            policies: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("policies").unwrap(),
            ),
            saas_app: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("saasApp").unwrap(),
            ),
            same_site_cookie_attribute: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("sameSiteCookieAttribute").unwrap(),
            ),
            scim_config: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("scimConfig").unwrap(),
            ),
            self_hosted_domains: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("selfHostedDomains").unwrap(),
            ),
            service_auth401_redirect: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("serviceAuth401Redirect").unwrap(),
            ),
            session_duration: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("sessionDuration").unwrap(),
            ),
            skip_app_launcher_login_page: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("skipAppLauncherLoginPage").unwrap(),
            ),
            skip_interstitial: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("skipInterstitial").unwrap(),
            ),
            tags: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tags").unwrap(),
            ),
            target_criterias: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("targetCriterias").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod access_ca_certificate {
    //! Cloudflare Access can replace traditional SSH key models with
    //! short-lived certificates issued to your users based on the token
    //! generated by their Access login.
    //!
    //! > It's required that an `account_id` or `zone_id` is provided and in
    //!    most cases using either is fine. However, if you're using a scoped
    //!    access token, you must provide the argument that matches the token's
    //!    scope. For example, an access token that is scoped to the "example.com"
    //!    zone needs to use the `zone_id` argument.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let anotherExample = access_ca_certificate::create(
    //!         "anotherExample",
    //!         AccessCaCertificateArgs::builder()
    //!             .application_id("fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //!     let example = access_ca_certificate::create(
    //!         "example",
    //!         AccessCaCertificateArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .application_id("6cd6cea3-3ef2-4542-9aea-85a0bbcd5414")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! Account level CA certificate import.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/accessCaCertificate:AccessCaCertificate example account/<account_id>/<application_id>
    //! ```
    //!
    //! Zone level CA certificate import.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/accessCaCertificate:AccessCaCertificate example account/<zone_id>/<application_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct AccessCaCertificateArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The Access Application ID to associate with the CA certificate.
        #[builder(into)]
        pub application_id: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct AccessCaCertificateResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The Access Application ID to associate with the CA certificate.
        pub application_id: pulumi_wasm_rust::Output<String>,
        /// Application Audience (AUD) Tag of the CA certificate.
        pub aud: pulumi_wasm_rust::Output<String>,
        /// Cryptographic public key of the generated CA certificate.
        pub public_key: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: AccessCaCertificateArgs,
    ) -> AccessCaCertificateResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let application_id_binding = args.application_id.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/accessCaCertificate:AccessCaCertificate".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "applicationId".into(),
                    value: &application_id_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "applicationId".into(),
                },
                register_interface::ResultField {
                    name: "aud".into(),
                },
                register_interface::ResultField {
                    name: "publicKey".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        AccessCaCertificateResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            application_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("applicationId").unwrap(),
            ),
            aud: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("aud").unwrap(),
            ),
            public_key: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("publicKey").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod access_custom_page {
    //! Provides a resource to customize the pages your end users will see
    //! when trying to reach applications behind Cloudflare Access.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = access_custom_page::create(
    //!         "example",
    //!         AccessCustomPageArgs::builder()
    //!             .custom_html("<html><body><h1>Forbidden</h1></body></html>")
    //!             .name("example")
    //!             .type_("forbidden")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct AccessCustomPageArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Number of apps to display on the custom page.
        #[builder(into, default)]
        pub app_count: pulumi_wasm_rust::Output<Option<i32>>,
        /// Custom HTML to display on the custom page.
        #[builder(into, default)]
        pub custom_html: pulumi_wasm_rust::Output<Option<String>>,
        /// Friendly name of the Access Custom Page configuration.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// Type of Access custom page to create. Available values: `identity_denied`, `forbidden`.
        #[builder(into)]
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct AccessCustomPageResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Number of apps to display on the custom page.
        pub app_count: pulumi_wasm_rust::Output<Option<i32>>,
        /// Custom HTML to display on the custom page.
        pub custom_html: pulumi_wasm_rust::Output<Option<String>>,
        /// Friendly name of the Access Custom Page configuration.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Type of Access custom page to create. Available values: `identity_denied`, `forbidden`.
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: AccessCustomPageArgs) -> AccessCustomPageResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let app_count_binding = args.app_count.get_inner();
        let custom_html_binding = args.custom_html.get_inner();
        let name_binding = args.name.get_inner();
        let type__binding = args.type_.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/accessCustomPage:AccessCustomPage".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "appCount".into(),
                    value: &app_count_binding,
                },
                register_interface::ObjectField {
                    name: "customHtml".into(),
                    value: &custom_html_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "appCount".into(),
                },
                register_interface::ResultField {
                    name: "customHtml".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        AccessCustomPageResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            app_count: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("appCount").unwrap(),
            ),
            custom_html: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customHtml").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod access_group {
    //! Provides a Cloudflare Access Group resource. Access Groups are used
    //! in conjunction with Access Policies to restrict access to a
    //! particular resource based on group membership.
    //!
    //! > It's required that an `account_id` or `zone_id` is provided and in
    //!    most cases using either is fine. However, if you're using a scoped
    //!    access token, you must provide the argument that matches the token's
    //!    scope. For example, an access token that is scoped to the "example.com"
    //!    zone needs to use the `zone_id` argument.
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/accessGroup:AccessGroup example <account_id>/<group_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct AccessGroupArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        #[builder(into, default)]
        pub excludes: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessGroupExclude>>,
        >,
        #[builder(into)]
        pub includes: pulumi_wasm_rust::Output<Vec<super::types::AccessGroupInclude>>,
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        #[builder(into, default)]
        pub requires: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessGroupRequire>>,
        >,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct AccessGroupResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        pub excludes: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessGroupExclude>>,
        >,
        pub includes: pulumi_wasm_rust::Output<Vec<super::types::AccessGroupInclude>>,
        pub name: pulumi_wasm_rust::Output<String>,
        pub requires: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessGroupRequire>>,
        >,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: AccessGroupArgs) -> AccessGroupResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let excludes_binding = args.excludes.get_inner();
        let includes_binding = args.includes.get_inner();
        let name_binding = args.name.get_inner();
        let requires_binding = args.requires.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/accessGroup:AccessGroup".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "excludes".into(),
                    value: &excludes_binding,
                },
                register_interface::ObjectField {
                    name: "includes".into(),
                    value: &includes_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "requires".into(),
                    value: &requires_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "excludes".into(),
                },
                register_interface::ResultField {
                    name: "includes".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "requires".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        AccessGroupResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            excludes: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("excludes").unwrap(),
            ),
            includes: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("includes").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            requires: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("requires").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod access_identity_provider {
    //! Provides a Cloudflare Access Identity Provider resource. Identity
    //! Providers are used as an authentication or authorisation source
    //! within Access.
    //!
    //! > It's required that an `account_id` or `zone_id` is provided and in
    //!    most cases using either is fine. However, if you're using a scoped
    //!    access token, you must provide the argument that matches the token's
    //!    scope. For example, an access token that is scoped to the "example.com"
    //!    zone needs to use the `zone_id` argument.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let githubOauth = access_identity_provider::create(
    //!         "githubOauth",
    //!         AccessIdentityProviderArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .configs(
    //!                 vec![
    //!                     AccessIdentityProviderConfig::builder().clientId("example")
    //!                     .clientSecret("secret_key").build_struct(),
    //!                 ],
    //!             )
    //!             .name("GitHub OAuth")
    //!             .type_("github")
    //!             .build_struct(),
    //!     );
    //!     let jumpcloudSaml = access_identity_provider::create(
    //!         "jumpcloudSaml",
    //!         AccessIdentityProviderArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .configs(
    //!                 vec![
    //!                     AccessIdentityProviderConfig::builder().attributes(vec!["email",
    //!                     "username",])
    //!                     .idpPublicCert("MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o")
    //!                     .issuerUrl("jumpcloud").signRequest(false)
    //!                     .ssoTargetUrl("https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess")
    //!                     .build_struct(),
    //!                 ],
    //!             )
    //!             .name("JumpCloud SAML")
    //!             .type_("saml")
    //!             .build_struct(),
    //!     );
    //!     let okta = access_identity_provider::create(
    //!         "okta",
    //!         AccessIdentityProviderArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .configs(
    //!                 vec![
    //!                     AccessIdentityProviderConfig::builder().apiToken("okta_api_token")
    //!                     .clientId("example").clientSecret("secret_key")
    //!                     .oktaAccount("https://example.com").build_struct(),
    //!                 ],
    //!             )
    //!             .name("Okta")
    //!             .type_("okta")
    //!             .build_struct(),
    //!     );
    //!     let pinLogin = access_identity_provider::create(
    //!         "pinLogin",
    //!         AccessIdentityProviderArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .name("PIN login")
    //!             .type_("onetimepin")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/accessIdentityProvider:AccessIdentityProvider example <account_id>/<identity_provider_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct AccessIdentityProviderArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Provider configuration from the [developer documentation](https://developers.cloudflare.com/access/configuring-identity-providers/).
        #[builder(into, default)]
        pub configs: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessIdentityProviderConfig>>,
        >,
        /// Friendly name of the Access Identity Provider configuration.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// Configuration for SCIM settings for a given IDP.
        #[builder(into, default)]
        pub scim_configs: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessIdentityProviderScimConfig>>,
        >,
        /// The provider type to use. Available values: `azureAD`, `centrify`, `facebook`, `github`, `google`, `google-apps`, `linkedin`, `oidc`, `okta`, `onelogin`, `onetimepin`, `pingone`, `saml`, `yandex`.
        #[builder(into)]
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct AccessIdentityProviderResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Provider configuration from the [developer documentation](https://developers.cloudflare.com/access/configuring-identity-providers/).
        pub configs: pulumi_wasm_rust::Output<
            Vec<super::types::AccessIdentityProviderConfig>,
        >,
        /// Friendly name of the Access Identity Provider configuration.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Configuration for SCIM settings for a given IDP.
        pub scim_configs: pulumi_wasm_rust::Output<
            Vec<super::types::AccessIdentityProviderScimConfig>,
        >,
        /// The provider type to use. Available values: `azureAD`, `centrify`, `facebook`, `github`, `google`, `google-apps`, `linkedin`, `oidc`, `okta`, `onelogin`, `onetimepin`, `pingone`, `saml`, `yandex`.
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: AccessIdentityProviderArgs,
    ) -> AccessIdentityProviderResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let configs_binding = args.configs.get_inner();
        let name_binding = args.name.get_inner();
        let scim_configs_binding = args.scim_configs.get_inner();
        let type__binding = args.type_.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/accessIdentityProvider:AccessIdentityProvider"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "configs".into(),
                    value: &configs_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "scimConfigs".into(),
                    value: &scim_configs_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "configs".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "scimConfigs".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        AccessIdentityProviderResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            configs: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("configs").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            scim_configs: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("scimConfigs").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod access_keys_configuration {
    //! Access Keys Configuration defines the rotation policy for the keys
    //! that access will use to sign data.
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct AccessKeysConfigurationArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Number of days to trigger a rotation of the keys.
        #[builder(into, default)]
        pub key_rotation_interval_days: pulumi_wasm_rust::Output<Option<i32>>,
    }
    #[allow(dead_code)]
    pub struct AccessKeysConfigurationResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Number of days to trigger a rotation of the keys.
        pub key_rotation_interval_days: pulumi_wasm_rust::Output<i32>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: AccessKeysConfigurationArgs,
    ) -> AccessKeysConfigurationResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let key_rotation_interval_days_binding = args
            .key_rotation_interval_days
            .get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/accessKeysConfiguration:AccessKeysConfiguration"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "keyRotationIntervalDays".into(),
                    value: &key_rotation_interval_days_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "keyRotationIntervalDays".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        AccessKeysConfigurationResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            key_rotation_interval_days: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("keyRotationIntervalDays").unwrap(),
            ),
        }
    }
}
pub mod access_mutual_tls_certificate {
    //! Provides a Cloudflare Access Mutual TLS Certificate resource.
    //! Mutual TLS authentication ensures that the traffic is secure and
    //! trusted in both directions between a client and server and can be
    //!  used with Access to only allows requests from devices with a
    //!  corresponding client certificate.
    //!
    //! > It's required that an `account_id` or `zone_id` is provided and in
    //!    most cases using either is fine. However, if you're using a scoped
    //!    access token, you must provide the argument that matches the token's
    //!    scope. For example, an access token that is scoped to the "example.com"
    //!    zone needs to use the `zone_id` argument.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let myCert = access_mutual_tls_certificate::create(
    //!         "myCert",
    //!         AccessMutualTlsCertificateArgs::builder()
    //!             .associated_hostnames(vec!["staging.example.com",])
    //!             .certificate("${caPem}")
    //!             .name("My Root Cert")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! Account level import.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/accessMutualTlsCertificate:AccessMutualTlsCertificate example account/<account_id>/<mutual_tls_certificate_id>
    //! ```
    //!
    //! Zone level import.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/accessMutualTlsCertificate:AccessMutualTlsCertificate example zone/<zone_id>/<mutual_tls_certificate_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct AccessMutualTlsCertificateArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The hostnames that will be prompted for this certificate.
        #[builder(into, default)]
        pub associated_hostnames: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The Root CA for your certificates.
        #[builder(into, default)]
        pub certificate: pulumi_wasm_rust::Output<Option<String>>,
        /// The name of the certificate.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct AccessMutualTlsCertificateResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The hostnames that will be prompted for this certificate.
        pub associated_hostnames: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The Root CA for your certificates.
        pub certificate: pulumi_wasm_rust::Output<Option<String>>,
        pub fingerprint: pulumi_wasm_rust::Output<String>,
        /// The name of the certificate.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: AccessMutualTlsCertificateArgs,
    ) -> AccessMutualTlsCertificateResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let associated_hostnames_binding = args.associated_hostnames.get_inner();
        let certificate_binding = args.certificate.get_inner();
        let name_binding = args.name.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/accessMutualTlsCertificate:AccessMutualTlsCertificate"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "associatedHostnames".into(),
                    value: &associated_hostnames_binding,
                },
                register_interface::ObjectField {
                    name: "certificate".into(),
                    value: &certificate_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "associatedHostnames".into(),
                },
                register_interface::ResultField {
                    name: "certificate".into(),
                },
                register_interface::ResultField {
                    name: "fingerprint".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        AccessMutualTlsCertificateResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            associated_hostnames: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("associatedHostnames").unwrap(),
            ),
            certificate: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("certificate").unwrap(),
            ),
            fingerprint: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("fingerprint").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod access_mutual_tls_hostname_settings {
    //! Provides a Cloudflare Access Mutual TLS Certificate Settings resource.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = access_mutual_tls_hostname_settings::create(
    //!         "example",
    //!         AccessMutualTlsHostnameSettingsArgs::builder()
    //!             .settings(
    //!                 vec![
    //!                     AccessMutualTlsHostnameSettingsSetting::builder().chinaNetwork(false)
    //!                     .clientCertificateForwarding(true).hostname("example.com")
    //!                     .build_struct(),
    //!                 ],
    //!             )
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! Account level mTLS hostname settings import.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/accessMutualTlsHostnameSettings:AccessMutualTlsHostnameSettings example account/<account_id>
    //! ```
    //!
    //! Zone level mTLS hostname settings import.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/accessMutualTlsHostnameSettings:AccessMutualTlsHostnameSettings example zone/<zone_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct AccessMutualTlsHostnameSettingsArgs {
        /// The account identifier to target for the resource.
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        #[builder(into, default)]
        pub settings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessMutualTlsHostnameSettingsSetting>>,
        >,
        /// The zone identifier to target for the resource.
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct AccessMutualTlsHostnameSettingsResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        pub settings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessMutualTlsHostnameSettingsSetting>>,
        >,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: AccessMutualTlsHostnameSettingsArgs,
    ) -> AccessMutualTlsHostnameSettingsResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let settings_binding = args.settings.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/accessMutualTlsHostnameSettings:AccessMutualTlsHostnameSettings"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "settings".into(),
                    value: &settings_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "settings".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        AccessMutualTlsHostnameSettingsResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            settings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("settings").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod access_organization {
    //! A Zero Trust organization defines the user login experience.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = access_organization::create(
    //!         "example",
    //!         AccessOrganizationArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .auth_domain("example.cloudflareaccess.com")
    //!             .auto_redirect_to_identity(false)
    //!             .is_ui_read_only(false)
    //!             .login_designs(
    //!                 vec![
    //!                     AccessOrganizationLoginDesign::builder().backgroundColor("#ffffff")
    //!                     .footerText("My footer text").headerText("My header text")
    //!                     .logoPath("https://example.com/logo.png").textColor("#000000")
    //!                     .build_struct(),
    //!                 ],
    //!             )
    //!             .name("example.cloudflareaccess.com")
    //!             .user_seat_expiration_inactive_time("720h")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/accessOrganization:AccessOrganization example <account_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct AccessOrganizationArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// When set to true, users can authenticate via WARP for any application in your organization. Application settings will take precedence over this value.
        #[builder(into, default)]
        pub allow_authenticate_via_warp: pulumi_wasm_rust::Output<Option<bool>>,
        /// The unique subdomain assigned to your Zero Trust organization.
        #[builder(into)]
        pub auth_domain: pulumi_wasm_rust::Output<String>,
        /// When set to true, users skip the identity provider selection step during login.
        #[builder(into, default)]
        pub auto_redirect_to_identity: pulumi_wasm_rust::Output<Option<bool>>,
        /// Custom pages for your Zero Trust organization.
        #[builder(into, default)]
        pub custom_pages: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessOrganizationCustomPage>>,
        >,
        /// When set to true, this will disable all editing of Access resources via the Zero Trust Dashboard.
        #[builder(into, default)]
        pub is_ui_read_only: pulumi_wasm_rust::Output<Option<bool>>,
        #[builder(into, default)]
        pub login_designs: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessOrganizationLoginDesign>>,
        >,
        /// The name of your Zero Trust organization.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.
        #[builder(into, default)]
        pub session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// A description of the reason why the UI read only field is being toggled.
        #[builder(into, default)]
        pub ui_read_only_toggle_reason: pulumi_wasm_rust::Output<Option<String>>,
        /// The amount of time a user seat is inactive before it expires. When the user seat exceeds the set time of inactivity, the user is removed as an active seat and no longer counts against your Teams seat count. Must be in the format `300ms` or `2h45m`.
        #[builder(into, default)]
        pub user_seat_expiration_inactive_time: pulumi_wasm_rust::Output<Option<String>>,
        /// The amount of time that tokens issued for applications will be valid. Must be in the format 30m or 2h45m. Valid time units are: m, h.
        #[builder(into, default)]
        pub warp_auth_session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct AccessOrganizationResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// When set to true, users can authenticate via WARP for any application in your organization. Application settings will take precedence over this value.
        pub allow_authenticate_via_warp: pulumi_wasm_rust::Output<Option<bool>>,
        /// The unique subdomain assigned to your Zero Trust organization.
        pub auth_domain: pulumi_wasm_rust::Output<String>,
        /// When set to true, users skip the identity provider selection step during login.
        pub auto_redirect_to_identity: pulumi_wasm_rust::Output<Option<bool>>,
        /// Custom pages for your Zero Trust organization.
        pub custom_pages: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessOrganizationCustomPage>>,
        >,
        /// When set to true, this will disable all editing of Access resources via the Zero Trust Dashboard.
        pub is_ui_read_only: pulumi_wasm_rust::Output<Option<bool>>,
        pub login_designs: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessOrganizationLoginDesign>>,
        >,
        /// The name of your Zero Trust organization.
        pub name: pulumi_wasm_rust::Output<String>,
        /// How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.
        pub session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// A description of the reason why the UI read only field is being toggled.
        pub ui_read_only_toggle_reason: pulumi_wasm_rust::Output<Option<String>>,
        /// The amount of time a user seat is inactive before it expires. When the user seat exceeds the set time of inactivity, the user is removed as an active seat and no longer counts against your Teams seat count. Must be in the format `300ms` or `2h45m`.
        pub user_seat_expiration_inactive_time: pulumi_wasm_rust::Output<Option<String>>,
        /// The amount of time that tokens issued for applications will be valid. Must be in the format 30m or 2h45m. Valid time units are: m, h.
        pub warp_auth_session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: AccessOrganizationArgs) -> AccessOrganizationResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let allow_authenticate_via_warp_binding = args
            .allow_authenticate_via_warp
            .get_inner();
        let auth_domain_binding = args.auth_domain.get_inner();
        let auto_redirect_to_identity_binding = args
            .auto_redirect_to_identity
            .get_inner();
        let custom_pages_binding = args.custom_pages.get_inner();
        let is_ui_read_only_binding = args.is_ui_read_only.get_inner();
        let login_designs_binding = args.login_designs.get_inner();
        let name_binding = args.name.get_inner();
        let session_duration_binding = args.session_duration.get_inner();
        let ui_read_only_toggle_reason_binding = args
            .ui_read_only_toggle_reason
            .get_inner();
        let user_seat_expiration_inactive_time_binding = args
            .user_seat_expiration_inactive_time
            .get_inner();
        let warp_auth_session_duration_binding = args
            .warp_auth_session_duration
            .get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/accessOrganization:AccessOrganization".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "allowAuthenticateViaWarp".into(),
                    value: &allow_authenticate_via_warp_binding,
                },
                register_interface::ObjectField {
                    name: "authDomain".into(),
                    value: &auth_domain_binding,
                },
                register_interface::ObjectField {
                    name: "autoRedirectToIdentity".into(),
                    value: &auto_redirect_to_identity_binding,
                },
                register_interface::ObjectField {
                    name: "customPages".into(),
                    value: &custom_pages_binding,
                },
                register_interface::ObjectField {
                    name: "isUiReadOnly".into(),
                    value: &is_ui_read_only_binding,
                },
                register_interface::ObjectField {
                    name: "loginDesigns".into(),
                    value: &login_designs_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "sessionDuration".into(),
                    value: &session_duration_binding,
                },
                register_interface::ObjectField {
                    name: "uiReadOnlyToggleReason".into(),
                    value: &ui_read_only_toggle_reason_binding,
                },
                register_interface::ObjectField {
                    name: "userSeatExpirationInactiveTime".into(),
                    value: &user_seat_expiration_inactive_time_binding,
                },
                register_interface::ObjectField {
                    name: "warpAuthSessionDuration".into(),
                    value: &warp_auth_session_duration_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "allowAuthenticateViaWarp".into(),
                },
                register_interface::ResultField {
                    name: "authDomain".into(),
                },
                register_interface::ResultField {
                    name: "autoRedirectToIdentity".into(),
                },
                register_interface::ResultField {
                    name: "customPages".into(),
                },
                register_interface::ResultField {
                    name: "isUiReadOnly".into(),
                },
                register_interface::ResultField {
                    name: "loginDesigns".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "sessionDuration".into(),
                },
                register_interface::ResultField {
                    name: "uiReadOnlyToggleReason".into(),
                },
                register_interface::ResultField {
                    name: "userSeatExpirationInactiveTime".into(),
                },
                register_interface::ResultField {
                    name: "warpAuthSessionDuration".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        AccessOrganizationResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            allow_authenticate_via_warp: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("allowAuthenticateViaWarp").unwrap(),
            ),
            auth_domain: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("authDomain").unwrap(),
            ),
            auto_redirect_to_identity: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("autoRedirectToIdentity").unwrap(),
            ),
            custom_pages: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customPages").unwrap(),
            ),
            is_ui_read_only: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("isUiReadOnly").unwrap(),
            ),
            login_designs: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("loginDesigns").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            session_duration: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("sessionDuration").unwrap(),
            ),
            ui_read_only_toggle_reason: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("uiReadOnlyToggleReason").unwrap(),
            ),
            user_seat_expiration_inactive_time: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("userSeatExpirationInactiveTime").unwrap(),
            ),
            warp_auth_session_duration: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("warpAuthSessionDuration").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod access_policy {
    //! Provides a Cloudflare Access Policy resource. Access Policies are
    //! used in conjunction with Access Applications to restrict access to
    //! a particular resource.
    //!
    //! > It's required that an `account_id` or `zone_id` is provided and in most cases using either is fine.
    //!    However, if you're using a scoped access token, you must provide the argument that matches the token's
    //!    scope. For example, an access token that is scoped to the "example.com" zone needs to use the `zone_id` argument.
    //!    If 'application_id' is omitted, the policy created can be reused by multiple access applications.
    //!    Any cloudflare.AccessApplication resource can reference reusable policies through its `policies` argument.
    //!    To destroy a reusable policy and remove it from all applications' policies lists on the same apply, preemptively set the
    //!    lifecycle option `create_before_destroy` to true on the 'cloudflare_access_policy' resource.
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/accessPolicy:AccessPolicy example account/<account_id>/<application_id>/<policy_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct AccessPolicyArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The ID of the application the policy is associated with. Required when using `precedence`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub application_id: pulumi_wasm_rust::Output<Option<String>>,
        #[builder(into, default)]
        pub approval_groups: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessPolicyApprovalGroup>>,
        >,
        #[builder(into, default)]
        pub approval_required: pulumi_wasm_rust::Output<Option<bool>>,
        /// The rules that define how users may connect to the targets secured by your application. Only applicable to Infrastructure Applications, in which case this field is required.
        #[builder(into, default)]
        pub connection_rules: pulumi_wasm_rust::Output<
            Option<super::types::AccessPolicyConnectionRules>,
        >,
        /// Defines the action Access will take if the policy matches the user. Available values: `allow`, `deny`, `non_identity`, `bypass`.
        #[builder(into)]
        pub decision: pulumi_wasm_rust::Output<String>,
        /// A series of access conditions, see Access Groups.
        #[builder(into, default)]
        pub excludes: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessPolicyExclude>>,
        >,
        /// A series of access conditions, see Access Groups.
        #[builder(into)]
        pub includes: pulumi_wasm_rust::Output<Vec<super::types::AccessPolicyInclude>>,
        /// Require this application to be served in an isolated browser for users matching this policy.
        #[builder(into, default)]
        pub isolation_required: pulumi_wasm_rust::Output<Option<bool>>,
        /// Friendly name of the Access Policy.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The unique precedence for policies on a single application. Required when using `application_id`.
        #[builder(into, default)]
        pub precedence: pulumi_wasm_rust::Output<Option<i32>>,
        /// The prompt to display to the user for a justification for accessing the resource. Required when using `purpose_justification_required`.
        #[builder(into, default)]
        pub purpose_justification_prompt: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether to prompt the user for a justification for accessing the resource.
        #[builder(into, default)]
        pub purpose_justification_required: pulumi_wasm_rust::Output<Option<bool>>,
        /// A series of access conditions, see Access Groups.
        #[builder(into, default)]
        pub requires: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessPolicyRequire>>,
        >,
        /// How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.
        #[builder(into, default)]
        pub session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct AccessPolicyResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The ID of the application the policy is associated with. Required when using `precedence`. **Modifying this attribute will force creation of a new resource.**
        pub application_id: pulumi_wasm_rust::Output<Option<String>>,
        pub approval_groups: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessPolicyApprovalGroup>>,
        >,
        pub approval_required: pulumi_wasm_rust::Output<Option<bool>>,
        /// The rules that define how users may connect to the targets secured by your application. Only applicable to Infrastructure Applications, in which case this field is required.
        pub connection_rules: pulumi_wasm_rust::Output<
            Option<super::types::AccessPolicyConnectionRules>,
        >,
        /// Defines the action Access will take if the policy matches the user. Available values: `allow`, `deny`, `non_identity`, `bypass`.
        pub decision: pulumi_wasm_rust::Output<String>,
        /// A series of access conditions, see Access Groups.
        pub excludes: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessPolicyExclude>>,
        >,
        /// A series of access conditions, see Access Groups.
        pub includes: pulumi_wasm_rust::Output<Vec<super::types::AccessPolicyInclude>>,
        /// Require this application to be served in an isolated browser for users matching this policy.
        pub isolation_required: pulumi_wasm_rust::Output<Option<bool>>,
        /// Friendly name of the Access Policy.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The unique precedence for policies on a single application. Required when using `application_id`.
        pub precedence: pulumi_wasm_rust::Output<Option<i32>>,
        /// The prompt to display to the user for a justification for accessing the resource. Required when using `purpose_justification_required`.
        pub purpose_justification_prompt: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether to prompt the user for a justification for accessing the resource.
        pub purpose_justification_required: pulumi_wasm_rust::Output<Option<bool>>,
        /// A series of access conditions, see Access Groups.
        pub requires: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AccessPolicyRequire>>,
        >,
        /// How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.
        pub session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: AccessPolicyArgs) -> AccessPolicyResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let application_id_binding = args.application_id.get_inner();
        let approval_groups_binding = args.approval_groups.get_inner();
        let approval_required_binding = args.approval_required.get_inner();
        let connection_rules_binding = args.connection_rules.get_inner();
        let decision_binding = args.decision.get_inner();
        let excludes_binding = args.excludes.get_inner();
        let includes_binding = args.includes.get_inner();
        let isolation_required_binding = args.isolation_required.get_inner();
        let name_binding = args.name.get_inner();
        let precedence_binding = args.precedence.get_inner();
        let purpose_justification_prompt_binding = args
            .purpose_justification_prompt
            .get_inner();
        let purpose_justification_required_binding = args
            .purpose_justification_required
            .get_inner();
        let requires_binding = args.requires.get_inner();
        let session_duration_binding = args.session_duration.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/accessPolicy:AccessPolicy".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "applicationId".into(),
                    value: &application_id_binding,
                },
                register_interface::ObjectField {
                    name: "approvalGroups".into(),
                    value: &approval_groups_binding,
                },
                register_interface::ObjectField {
                    name: "approvalRequired".into(),
                    value: &approval_required_binding,
                },
                register_interface::ObjectField {
                    name: "connectionRules".into(),
                    value: &connection_rules_binding,
                },
                register_interface::ObjectField {
                    name: "decision".into(),
                    value: &decision_binding,
                },
                register_interface::ObjectField {
                    name: "excludes".into(),
                    value: &excludes_binding,
                },
                register_interface::ObjectField {
                    name: "includes".into(),
                    value: &includes_binding,
                },
                register_interface::ObjectField {
                    name: "isolationRequired".into(),
                    value: &isolation_required_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "precedence".into(),
                    value: &precedence_binding,
                },
                register_interface::ObjectField {
                    name: "purposeJustificationPrompt".into(),
                    value: &purpose_justification_prompt_binding,
                },
                register_interface::ObjectField {
                    name: "purposeJustificationRequired".into(),
                    value: &purpose_justification_required_binding,
                },
                register_interface::ObjectField {
                    name: "requires".into(),
                    value: &requires_binding,
                },
                register_interface::ObjectField {
                    name: "sessionDuration".into(),
                    value: &session_duration_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "applicationId".into(),
                },
                register_interface::ResultField {
                    name: "approvalGroups".into(),
                },
                register_interface::ResultField {
                    name: "approvalRequired".into(),
                },
                register_interface::ResultField {
                    name: "connectionRules".into(),
                },
                register_interface::ResultField {
                    name: "decision".into(),
                },
                register_interface::ResultField {
                    name: "excludes".into(),
                },
                register_interface::ResultField {
                    name: "includes".into(),
                },
                register_interface::ResultField {
                    name: "isolationRequired".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "precedence".into(),
                },
                register_interface::ResultField {
                    name: "purposeJustificationPrompt".into(),
                },
                register_interface::ResultField {
                    name: "purposeJustificationRequired".into(),
                },
                register_interface::ResultField {
                    name: "requires".into(),
                },
                register_interface::ResultField {
                    name: "sessionDuration".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        AccessPolicyResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            application_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("applicationId").unwrap(),
            ),
            approval_groups: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("approvalGroups").unwrap(),
            ),
            approval_required: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("approvalRequired").unwrap(),
            ),
            connection_rules: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("connectionRules").unwrap(),
            ),
            decision: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("decision").unwrap(),
            ),
            excludes: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("excludes").unwrap(),
            ),
            includes: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("includes").unwrap(),
            ),
            isolation_required: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("isolationRequired").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            precedence: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("precedence").unwrap(),
            ),
            purpose_justification_prompt: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("purposeJustificationPrompt").unwrap(),
            ),
            purpose_justification_required: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("purposeJustificationRequired").unwrap(),
            ),
            requires: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("requires").unwrap(),
            ),
            session_duration: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("sessionDuration").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod access_rule {
    //! Provides a Cloudflare IP Firewall Access Rule resource. Access
    //! control can be applied on basis of IP addresses, IP ranges, AS
    //! numbers or countries.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! configuration:
    //!   # Allowlist office's network IP ranges on all account zones (or other lists of
    //!   # resources).
    //!   myOffice:
    //!     type: list(string)
    //!     default:
    //!       - 192.0.2.0/24
    //!       - 198.51.100.0/24
    //!       - 2001:db8::/56
    //! resources:
    //!   # Challenge requests coming from known Tor exit nodes.
    //!   torExitNodes:
    //!     type: cloudflare:AccessRule
    //!     name: tor_exit_nodes
    //!     properties:
    //!       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
    //!       notes: Requests coming from known Tor exit nodes
    //!       mode: challenge
    //!       configuration:
    //!         target: country
    //!         value: T1
    //!   # Allowlist requests coming from Antarctica, but only for single zone.
    //!   antarctica:
    //!     type: cloudflare:AccessRule
    //!     properties:
    //!       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
    //!       notes: Requests coming from Antarctica
    //!       mode: whitelist
    //!       configuration:
    //!         target: country
    //!         value: AQ
    //!   officeNetwork:
    //!     type: cloudflare:AccessRule
    //!     name: office_network
    //!     properties:
    //!       accountId: f037e56e89293a057740de681ac9abbe
    //!       notes: Requests coming from office network
    //!       mode: whitelist
    //!       configuration:
    //!         target: ip_range
    //!         value:
    //!           fn::select:
    //!             - ${range.value}
    //!             - ${myOffice}
    //!     options: {}
    //! ```
    //!
    //! ## Import
    //!
    //! User level access rule import.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/accessRule:AccessRule default user/<user_id>/<rule_id>
    //! ```
    //!
    //! Zone level access rule import.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/accessRule:AccessRule default zone/<zone_id>/<rule_id>
    //! ```
    //!
    //! Account level access rule import.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/accessRule:AccessRule default account/<account_id>/<rule_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct AccessRuleArgs {
        /// The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Rule configuration to apply to a matched request. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub configuration: pulumi_wasm_rust::Output<
            super::types::AccessRuleConfiguration,
        >,
        /// The action to apply to a matched request. Available values: `block`, `challenge`, `whitelist`, `js_challenge`, `managed_challenge`.
        #[builder(into)]
        pub mode: pulumi_wasm_rust::Output<String>,
        /// A personal note about the rule. Typically used as a reminder or explanation for the rule.
        #[builder(into, default)]
        pub notes: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct AccessRuleResult {
        /// The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Rule configuration to apply to a matched request. **Modifying this attribute will force creation of a new resource.**
        pub configuration: pulumi_wasm_rust::Output<
            super::types::AccessRuleConfiguration,
        >,
        /// The action to apply to a matched request. Available values: `block`, `challenge`, `whitelist`, `js_challenge`, `managed_challenge`.
        pub mode: pulumi_wasm_rust::Output<String>,
        /// A personal note about the rule. Typically used as a reminder or explanation for the rule.
        pub notes: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: AccessRuleArgs) -> AccessRuleResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let configuration_binding = args.configuration.get_inner();
        let mode_binding = args.mode.get_inner();
        let notes_binding = args.notes.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/accessRule:AccessRule".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "configuration".into(),
                    value: &configuration_binding,
                },
                register_interface::ObjectField {
                    name: "mode".into(),
                    value: &mode_binding,
                },
                register_interface::ObjectField {
                    name: "notes".into(),
                    value: &notes_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "configuration".into(),
                },
                register_interface::ResultField {
                    name: "mode".into(),
                },
                register_interface::ResultField {
                    name: "notes".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        AccessRuleResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            configuration: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("configuration").unwrap(),
            ),
            mode: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("mode").unwrap(),
            ),
            notes: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("notes").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod access_service_token {
    //! Access Service Tokens are used for service-to-service communication
    //! when an application is behind Cloudflare Access.
    //!
    //! ## Import
    //!
    //! If you are importing an Access Service Token you will not have the
    //!
    //! client_secret available in the state for use. The client_secret is only
    //!
    //! available once, at creation. In most cases, it is better to just create a new
    //!
    //! resource should you need to reference it in other resources.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/accessServiceToken:AccessServiceToken example <account_id>/<service_token_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct AccessServiceTokenArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Length of time the service token is valid for. Available values: `8760h`, `17520h`, `43800h`, `87600h`, `forever`.
        #[builder(into, default)]
        pub duration: pulumi_wasm_rust::Output<Option<String>>,
        #[builder(into, default)]
        pub min_days_for_renewal: pulumi_wasm_rust::Output<Option<i32>>,
        /// Friendly name of the token's intent.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct AccessServiceTokenResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Client ID associated with the Service Token. **Modifying this attribute will force creation of a new resource.**
        pub client_id: pulumi_wasm_rust::Output<String>,
        /// A secret for interacting with Access protocols. **Modifying this attribute will force creation of a new resource.**
        pub client_secret: pulumi_wasm_rust::Output<String>,
        /// Length of time the service token is valid for. Available values: `8760h`, `17520h`, `43800h`, `87600h`, `forever`.
        pub duration: pulumi_wasm_rust::Output<String>,
        /// Date when the token expires.
        pub expires_at: pulumi_wasm_rust::Output<String>,
        pub min_days_for_renewal: pulumi_wasm_rust::Output<Option<i32>>,
        /// Friendly name of the token's intent.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: AccessServiceTokenArgs) -> AccessServiceTokenResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let duration_binding = args.duration.get_inner();
        let min_days_for_renewal_binding = args.min_days_for_renewal.get_inner();
        let name_binding = args.name.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/accessServiceToken:AccessServiceToken".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "duration".into(),
                    value: &duration_binding,
                },
                register_interface::ObjectField {
                    name: "minDaysForRenewal".into(),
                    value: &min_days_for_renewal_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "clientId".into(),
                },
                register_interface::ResultField {
                    name: "clientSecret".into(),
                },
                register_interface::ResultField {
                    name: "duration".into(),
                },
                register_interface::ResultField {
                    name: "expiresAt".into(),
                },
                register_interface::ResultField {
                    name: "minDaysForRenewal".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        AccessServiceTokenResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            client_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("clientId").unwrap(),
            ),
            client_secret: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("clientSecret").unwrap(),
            ),
            duration: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("duration").unwrap(),
            ),
            expires_at: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("expiresAt").unwrap(),
            ),
            min_days_for_renewal: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("minDaysForRenewal").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod access_tag {
    //! Provides a resource to customize the pages your end users will see
    //! when trying to reach applications behind Cloudflare Access.
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct AccessTagArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Number of apps associated with the tag.
        #[builder(into, default)]
        pub app_count: pulumi_wasm_rust::Output<Option<i32>>,
        /// Friendly name of the Access Tag.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct AccessTagResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Number of apps associated with the tag.
        pub app_count: pulumi_wasm_rust::Output<i32>,
        /// Friendly name of the Access Tag.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: AccessTagArgs) -> AccessTagResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let app_count_binding = args.app_count.get_inner();
        let name_binding = args.name.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/accessTag:AccessTag".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "appCount".into(),
                    value: &app_count_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "appCount".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        AccessTagResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            app_count: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("appCount").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod account {
    //! Provides a Cloudflare Account resource. Account is the basic resource for
    //! working with Cloudflare zones, teams and users.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = account::create(
    //!         "example",
    //!         AccountArgs::builder()
    //!             .enforce_twofactor(true)
    //!             .name("some-enterprise-account")
    //!             .type_("enterprise")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/account:Account example <account_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct AccountArgs {
        /// Whether 2FA is enforced on the account. Defaults to `false`.
        #[builder(into, default)]
        pub enforce_twofactor: pulumi_wasm_rust::Output<Option<bool>>,
        /// The name of the account that is displayed in the Cloudflare dashboard.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// Account type. Available values: `enterprise`, `standard`. Defaults to `standard`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub type_: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct AccountResult {
        /// Whether 2FA is enforced on the account. Defaults to `false`.
        pub enforce_twofactor: pulumi_wasm_rust::Output<Option<bool>>,
        /// The name of the account that is displayed in the Cloudflare dashboard.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Account type. Available values: `enterprise`, `standard`. Defaults to `standard`. **Modifying this attribute will force creation of a new resource.**
        pub type_: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: AccountArgs) -> AccountResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let enforce_twofactor_binding = args.enforce_twofactor.get_inner();
        let name_binding = args.name.get_inner();
        let type__binding = args.type_.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/account:Account".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "enforceTwofactor".into(),
                    value: &enforce_twofactor_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "enforceTwofactor".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        AccountResult {
            enforce_twofactor: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enforceTwofactor").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
        }
    }
}
pub mod account_member {
    //! Provides a resource which manages Cloudflare account members.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = account_member::create(
    //!         "example",
    //!         AccountMemberArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .email_address("user@example.com")
    //!             .role_ids(
    //!                 vec![
    //!                     "68b329da9893e34099c7d8ad5cb9c940",
    //!                     "d784fa8b6d98d27699781bd9a7cf19f0",
    //!                 ],
    //!             )
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/accountMember:AccountMember example <account_id>/<member_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct AccountMemberArgs {
        /// Account ID to create the account member in.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The email address of the user who you wish to manage. Following creation, this field becomes read only via the API and cannot be updated.
        #[builder(into)]
        pub email_address: pulumi_wasm_rust::Output<String>,
        /// List of account role IDs that you want to assign to a member.
        #[builder(into)]
        pub role_ids: pulumi_wasm_rust::Output<Vec<String>>,
        /// A member's status in the account. Available values: `accepted`, `pending`.
        #[builder(into, default)]
        pub status: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct AccountMemberResult {
        /// Account ID to create the account member in.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The email address of the user who you wish to manage. Following creation, this field becomes read only via the API and cannot be updated.
        pub email_address: pulumi_wasm_rust::Output<String>,
        /// List of account role IDs that you want to assign to a member.
        pub role_ids: pulumi_wasm_rust::Output<Vec<String>>,
        /// A member's status in the account. Available values: `accepted`, `pending`.
        pub status: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: AccountMemberArgs) -> AccountMemberResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let email_address_binding = args.email_address.get_inner();
        let role_ids_binding = args.role_ids.get_inner();
        let status_binding = args.status.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/accountMember:AccountMember".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "emailAddress".into(),
                    value: &email_address_binding,
                },
                register_interface::ObjectField {
                    name: "roleIds".into(),
                    value: &role_ids_binding,
                },
                register_interface::ObjectField {
                    name: "status".into(),
                    value: &status_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "emailAddress".into(),
                },
                register_interface::ResultField {
                    name: "roleIds".into(),
                },
                register_interface::ResultField {
                    name: "status".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        AccountMemberResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            email_address: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("emailAddress").unwrap(),
            ),
            role_ids: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("roleIds").unwrap(),
            ),
            status: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("status").unwrap(),
            ),
        }
    }
}
pub mod address_map {
    //! Provides the ability to manage IP addresses that can be used by DNS records when
    //! they are proxied through Cloudflare.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = address_map::create(
    //!         "example",
    //!         AddressMapArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .default_sni("*.example.com")
    //!             .description("My address map")
    //!             .enabled(true)
    //!             .ips(
    //!                 vec![
    //!                     AddressMapIp::builder().ip("192.0.2.1").build_struct(),
    //!                     AddressMapIp::builder().ip("203.0.113.1").build_struct(),
    //!                 ],
    //!             )
    //!             .memberships(
    //!                 vec![
    //!                     AddressMapMembership::builder()
    //!                     .identifier("92f17202ed8bd63d69a66b86a49a8f6b").kind("account")
    //!                     .build_struct(), AddressMapMembership::builder()
    //!                     .identifier("023e105f4ecef8ad9ca31a8372d0c353").kind("zone")
    //!                     .build_struct(),
    //!                 ],
    //!             )
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/addressMap:AddressMap example <account_id>/<address_map_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct AddressMapArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map.
        #[builder(into, default)]
        pub default_sni: pulumi_wasm_rust::Output<Option<String>>,
        /// Description of the address map.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether the Address Map is enabled or not.
        #[builder(into)]
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The set of IPs on the Address Map.
        #[builder(into, default)]
        pub ips: pulumi_wasm_rust::Output<Option<Vec<super::types::AddressMapIp>>>,
        /// Zones and Accounts which will be assigned IPs on this Address Map.
        #[builder(into, default)]
        pub memberships: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AddressMapMembership>>,
        >,
    }
    #[allow(dead_code)]
    pub struct AddressMapResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// If set to false, then the Address Map cannot be deleted via API. This is true for Cloudflare-managed maps.
        pub can_delete: pulumi_wasm_rust::Output<bool>,
        /// If set to false, then the IPs on the Address Map cannot be modified via the API. This is true for Cloudflare-managed maps.
        pub can_modify_ips: pulumi_wasm_rust::Output<bool>,
        /// If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map.
        pub default_sni: pulumi_wasm_rust::Output<Option<String>>,
        /// Description of the address map.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether the Address Map is enabled or not.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The set of IPs on the Address Map.
        pub ips: pulumi_wasm_rust::Output<Option<Vec<super::types::AddressMapIp>>>,
        /// Zones and Accounts which will be assigned IPs on this Address Map.
        pub memberships: pulumi_wasm_rust::Output<
            Option<Vec<super::types::AddressMapMembership>>,
        >,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: AddressMapArgs) -> AddressMapResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let default_sni_binding = args.default_sni.get_inner();
        let description_binding = args.description.get_inner();
        let enabled_binding = args.enabled.get_inner();
        let ips_binding = args.ips.get_inner();
        let memberships_binding = args.memberships.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/addressMap:AddressMap".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "defaultSni".into(),
                    value: &default_sni_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "enabled".into(),
                    value: &enabled_binding,
                },
                register_interface::ObjectField {
                    name: "ips".into(),
                    value: &ips_binding,
                },
                register_interface::ObjectField {
                    name: "memberships".into(),
                    value: &memberships_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "canDelete".into(),
                },
                register_interface::ResultField {
                    name: "canModifyIps".into(),
                },
                register_interface::ResultField {
                    name: "defaultSni".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "enabled".into(),
                },
                register_interface::ResultField {
                    name: "ips".into(),
                },
                register_interface::ResultField {
                    name: "memberships".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        AddressMapResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            can_delete: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("canDelete").unwrap(),
            ),
            can_modify_ips: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("canModifyIps").unwrap(),
            ),
            default_sni: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("defaultSni").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enabled").unwrap(),
            ),
            ips: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("ips").unwrap(),
            ),
            memberships: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("memberships").unwrap(),
            ),
        }
    }
}
pub mod api_shield {
    //! Provides a resource to manage API Shield configurations.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = api_shield::create(
    //!         "example",
    //!         ApiShieldArgs::builder()
    //!             .auth_id_characteristics(
    //!                 vec![
    //!                     ApiShieldAuthIdCharacteristic::builder().name("my-example-header").
    //!                     type ("header").build_struct(),
    //!                 ],
    //!             )
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ApiShieldArgs {
        /// Characteristics define properties across which auth-ids can be computed in a privacy-preserving manner.
        #[builder(into, default)]
        pub auth_id_characteristics: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ApiShieldAuthIdCharacteristic>>,
        >,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ApiShieldResult {
        /// Characteristics define properties across which auth-ids can be computed in a privacy-preserving manner.
        pub auth_id_characteristics: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ApiShieldAuthIdCharacteristic>>,
        >,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: ApiShieldArgs) -> ApiShieldResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let auth_id_characteristics_binding = args.auth_id_characteristics.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/apiShield:ApiShield".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "authIdCharacteristics".into(),
                    value: &auth_id_characteristics_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "authIdCharacteristics".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ApiShieldResult {
            auth_id_characteristics: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("authIdCharacteristics").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod api_shield_operation {
    //! Provides a resource to manage an operation in API Shield Endpoint Management.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = api_shield_operation::create(
    //!         "example",
    //!         ApiShieldOperationArgs::builder()
    //!             .endpoint("/path")
    //!             .host("api.example.com")
    //!             .method("GET")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ApiShieldOperationArgs {
        /// The endpoint which can contain path parameter templates in curly braces, each will be replaced from left to right with `{varN}`, starting with `{var1}`. This will then be [Cloudflare-normalized](https://developers.cloudflare.com/rules/normalization/how-it-works/). **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub endpoint: pulumi_wasm_rust::Output<String>,
        /// RFC3986-compliant host. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub host: pulumi_wasm_rust::Output<String>,
        /// The HTTP method used to access the endpoint. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub method: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ApiShieldOperationResult {
        /// The endpoint which can contain path parameter templates in curly braces, each will be replaced from left to right with `{varN}`, starting with `{var1}`. This will then be [Cloudflare-normalized](https://developers.cloudflare.com/rules/normalization/how-it-works/). **Modifying this attribute will force creation of a new resource.**
        pub endpoint: pulumi_wasm_rust::Output<String>,
        /// RFC3986-compliant host. **Modifying this attribute will force creation of a new resource.**
        pub host: pulumi_wasm_rust::Output<String>,
        /// The HTTP method used to access the endpoint. **Modifying this attribute will force creation of a new resource.**
        pub method: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: ApiShieldOperationArgs) -> ApiShieldOperationResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let endpoint_binding = args.endpoint.get_inner();
        let host_binding = args.host.get_inner();
        let method_binding = args.method.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/apiShieldOperation:ApiShieldOperation".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "endpoint".into(),
                    value: &endpoint_binding,
                },
                register_interface::ObjectField {
                    name: "host".into(),
                    value: &host_binding,
                },
                register_interface::ObjectField {
                    name: "method".into(),
                    value: &method_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "endpoint".into(),
                },
                register_interface::ResultField {
                    name: "host".into(),
                },
                register_interface::ResultField {
                    name: "method".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ApiShieldOperationResult {
            endpoint: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("endpoint").unwrap(),
            ),
            host: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("host").unwrap(),
            ),
            method: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("method").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod api_shield_operation_schema_validation_settings {
    //! Provides a resource to manage operation-level settings in API Shield Schema Validation 2.0.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = api_shield_operation::create(
    //!         "example",
    //!         ApiShieldOperationArgs::builder()
    //!             .endpoint("/path")
    //!             .host("api.example.com")
    //!             .method("GET")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //!     let exampleApiShieldOperationSchemaValidationSettings = api_shield_operation_schema_validation_settings::create(
    //!         "exampleApiShieldOperationSchemaValidationSettings",
    //!         ApiShieldOperationSchemaValidationSettingsArgs::builder()
    //!             .mitigation_action("block")
    //!             .operation_id("${example.id}")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ApiShieldOperationSchemaValidationSettingsArgs {
        /// The mitigation action to apply to this operation.
        #[builder(into, default)]
        pub mitigation_action: pulumi_wasm_rust::Output<Option<String>>,
        /// Operation ID these settings should apply to. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub operation_id: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ApiShieldOperationSchemaValidationSettingsResult {
        /// The mitigation action to apply to this operation.
        pub mitigation_action: pulumi_wasm_rust::Output<Option<String>>,
        /// Operation ID these settings should apply to. **Modifying this attribute will force creation of a new resource.**
        pub operation_id: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ApiShieldOperationSchemaValidationSettingsArgs,
    ) -> ApiShieldOperationSchemaValidationSettingsResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let mitigation_action_binding = args.mitigation_action.get_inner();
        let operation_id_binding = args.operation_id.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/apiShieldOperationSchemaValidationSettings:ApiShieldOperationSchemaValidationSettings"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "mitigationAction".into(),
                    value: &mitigation_action_binding,
                },
                register_interface::ObjectField {
                    name: "operationId".into(),
                    value: &operation_id_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "mitigationAction".into(),
                },
                register_interface::ResultField {
                    name: "operationId".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ApiShieldOperationSchemaValidationSettingsResult {
            mitigation_action: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("mitigationAction").unwrap(),
            ),
            operation_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("operationId").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod api_shield_schema {
    //! Provides a resource to manage a schema in API Shield Schema Validation 2.0.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   petstoreSchema:
    //!     type: cloudflare:ApiShieldSchema
    //!     name: petstore_schema
    //!     properties:
    //!       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
    //!       name: myschema
    //!       kind: openapi_v3
    //!       validationEnabled: true # optional, default false
    //!       source:
    //!         fn::invoke:
    //!           Function: std:file
    //!           Arguments:
    //!             input: ./schemas/petstore.json
    //!           Return: result
    //! ```
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ApiShieldSchemaArgs {
        /// Kind of schema. Defaults to `openapi_v3`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub kind: pulumi_wasm_rust::Output<Option<String>>,
        /// Name of the schema. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// Schema file bytes. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub source: pulumi_wasm_rust::Output<String>,
        /// Flag whether schema is enabled for validation.
        #[builder(into, default)]
        pub validation_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ApiShieldSchemaResult {
        /// Kind of schema. Defaults to `openapi_v3`. **Modifying this attribute will force creation of a new resource.**
        pub kind: pulumi_wasm_rust::Output<Option<String>>,
        /// Name of the schema. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
        /// Schema file bytes. **Modifying this attribute will force creation of a new resource.**
        pub source: pulumi_wasm_rust::Output<String>,
        /// Flag whether schema is enabled for validation.
        pub validation_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: ApiShieldSchemaArgs) -> ApiShieldSchemaResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let kind_binding = args.kind.get_inner();
        let name_binding = args.name.get_inner();
        let source_binding = args.source.get_inner();
        let validation_enabled_binding = args.validation_enabled.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/apiShieldSchema:ApiShieldSchema".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "kind".into(),
                    value: &kind_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "source".into(),
                    value: &source_binding,
                },
                register_interface::ObjectField {
                    name: "validationEnabled".into(),
                    value: &validation_enabled_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "kind".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "source".into(),
                },
                register_interface::ResultField {
                    name: "validationEnabled".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ApiShieldSchemaResult {
            kind: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("kind").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            source: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("source").unwrap(),
            ),
            validation_enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("validationEnabled").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod api_shield_schema_validation_settings {
    //! Provides a resource to manage settings in API Shield Schema Validation 2.0.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = api_shield_schema_validation_settings::create(
    //!         "example",
    //!         ApiShieldSchemaValidationSettingsArgs::builder()
    //!             .validation_default_mitigation_action("log")
    //!             .validation_override_mitigation_action("none")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ApiShieldSchemaValidationSettingsArgs {
        /// The default mitigation action used when there is no mitigation action defined on the operation.
        #[builder(into)]
        pub validation_default_mitigation_action: pulumi_wasm_rust::Output<String>,
        /// When set, this overrides both zone level and operation level mitigation actions.
        #[builder(into, default)]
        pub validation_override_mitigation_action: pulumi_wasm_rust::Output<
            Option<String>,
        >,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ApiShieldSchemaValidationSettingsResult {
        /// The default mitigation action used when there is no mitigation action defined on the operation.
        pub validation_default_mitigation_action: pulumi_wasm_rust::Output<String>,
        /// When set, this overrides both zone level and operation level mitigation actions.
        pub validation_override_mitigation_action: pulumi_wasm_rust::Output<
            Option<String>,
        >,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ApiShieldSchemaValidationSettingsArgs,
    ) -> ApiShieldSchemaValidationSettingsResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let validation_default_mitigation_action_binding = args
            .validation_default_mitigation_action
            .get_inner();
        let validation_override_mitigation_action_binding = args
            .validation_override_mitigation_action
            .get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/apiShieldSchemaValidationSettings:ApiShieldSchemaValidationSettings"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "validationDefaultMitigationAction".into(),
                    value: &validation_default_mitigation_action_binding,
                },
                register_interface::ObjectField {
                    name: "validationOverrideMitigationAction".into(),
                    value: &validation_override_mitigation_action_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "validationDefaultMitigationAction".into(),
                },
                register_interface::ResultField {
                    name: "validationOverrideMitigationAction".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ApiShieldSchemaValidationSettingsResult {
            validation_default_mitigation_action: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("validationDefaultMitigationAction").unwrap(),
            ),
            validation_override_mitigation_action: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("validationOverrideMitigationAction").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod api_token {
    //! Provides a resource which manages Cloudflare API tokens.
    //!
    //! Read more about permission groups and their applicable scopes in the
    //! [developer documentation](https://developers.cloudflare.com/api/tokens/create/permissions).
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ApiTokenArgs {
        /// Conditions under which the token should be considered valid.
        #[builder(into, default)]
        pub condition: pulumi_wasm_rust::Output<Option<super::types::ApiTokenCondition>>,
        /// The expiration time on or after which the token MUST NOT be accepted for processing.
        #[builder(into, default)]
        pub expires_on: pulumi_wasm_rust::Output<Option<String>>,
        /// Name of the API Token.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The time before which the token MUST NOT be accepted for processing.
        #[builder(into, default)]
        pub not_before: pulumi_wasm_rust::Output<Option<String>>,
        /// Permissions policy. Multiple policy blocks can be defined.
        #[builder(into)]
        pub policies: pulumi_wasm_rust::Output<Vec<super::types::ApiTokenPolicy>>,
    }
    #[allow(dead_code)]
    pub struct ApiTokenResult {
        /// Conditions under which the token should be considered valid.
        pub condition: pulumi_wasm_rust::Output<Option<super::types::ApiTokenCondition>>,
        /// The expiration time on or after which the token MUST NOT be accepted for processing.
        pub expires_on: pulumi_wasm_rust::Output<Option<String>>,
        /// Timestamp of when the token was issued.
        pub issued_on: pulumi_wasm_rust::Output<String>,
        /// Timestamp of when the token was last modified.
        pub modified_on: pulumi_wasm_rust::Output<String>,
        /// Name of the API Token.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The time before which the token MUST NOT be accepted for processing.
        pub not_before: pulumi_wasm_rust::Output<Option<String>>,
        /// Permissions policy. Multiple policy blocks can be defined.
        pub policies: pulumi_wasm_rust::Output<Vec<super::types::ApiTokenPolicy>>,
        pub status: pulumi_wasm_rust::Output<String>,
        /// The value of the API Token.
        pub value: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: ApiTokenArgs) -> ApiTokenResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let condition_binding = args.condition.get_inner();
        let expires_on_binding = args.expires_on.get_inner();
        let name_binding = args.name.get_inner();
        let not_before_binding = args.not_before.get_inner();
        let policies_binding = args.policies.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/apiToken:ApiToken".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "condition".into(),
                    value: &condition_binding,
                },
                register_interface::ObjectField {
                    name: "expiresOn".into(),
                    value: &expires_on_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "notBefore".into(),
                    value: &not_before_binding,
                },
                register_interface::ObjectField {
                    name: "policies".into(),
                    value: &policies_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "condition".into(),
                },
                register_interface::ResultField {
                    name: "expiresOn".into(),
                },
                register_interface::ResultField {
                    name: "issuedOn".into(),
                },
                register_interface::ResultField {
                    name: "modifiedOn".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "notBefore".into(),
                },
                register_interface::ResultField {
                    name: "policies".into(),
                },
                register_interface::ResultField {
                    name: "status".into(),
                },
                register_interface::ResultField {
                    name: "value".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ApiTokenResult {
            condition: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("condition").unwrap(),
            ),
            expires_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("expiresOn").unwrap(),
            ),
            issued_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("issuedOn").unwrap(),
            ),
            modified_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("modifiedOn").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            not_before: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("notBefore").unwrap(),
            ),
            policies: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("policies").unwrap(),
            ),
            status: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("status").unwrap(),
            ),
            value: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("value").unwrap(),
            ),
        }
    }
}
pub mod argo {
    //! Cloudflare Argo controls the routing to your origin and tiered
    //! caching options to speed up your website browsing experience.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = argo::create(
    //!         "example",
    //!         ArgoArgs::builder()
    //!             .smart_routing("on")
    //!             .tiered_caching("on")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/argo:Argo example <zone_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ArgoArgs {
        /// Whether smart routing is enabled. Available values: `on`, `off`.
        #[builder(into, default)]
        pub smart_routing: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether tiered caching is enabled. Available values: `on`, `off`.
        #[builder(into, default)]
        pub tiered_caching: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource.
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ArgoResult {
        /// Whether smart routing is enabled. Available values: `on`, `off`.
        pub smart_routing: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether tiered caching is enabled. Available values: `on`, `off`.
        pub tiered_caching: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: ArgoArgs) -> ArgoResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let smart_routing_binding = args.smart_routing.get_inner();
        let tiered_caching_binding = args.tiered_caching.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/argo:Argo".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "smartRouting".into(),
                    value: &smart_routing_binding,
                },
                register_interface::ObjectField {
                    name: "tieredCaching".into(),
                    value: &tiered_caching_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "smartRouting".into(),
                },
                register_interface::ResultField {
                    name: "tieredCaching".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ArgoResult {
            smart_routing: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("smartRouting").unwrap(),
            ),
            tiered_caching: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tieredCaching").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod authenticated_origin_pulls {
    //! Provides a Cloudflare Authenticated Origin Pulls resource. A `cloudflare.AuthenticatedOriginPulls`
    //! resource is required to use Per-Zone or Per-Hostname Authenticated
    //! Origin Pulls.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let myAop = authenticated_origin_pulls::create(
    //!         "myAop",
    //!         AuthenticatedOriginPullsArgs::builder()
    //!             .enabled(true)
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //!     let myPerHostnameAop = authenticated_origin_pulls::create(
    //!         "myPerHostnameAop",
    //!         AuthenticatedOriginPullsArgs::builder()
    //!             .authenticated_origin_pulls_certificate("${myPerHostnameAopCert.id}")
    //!             .enabled(true)
    //!             .hostname("aop.example.com")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //!     let myPerHostnameAopCert = authenticated_origin_pulls_certificate::create(
    //!         "myPerHostnameAopCert",
    //!         AuthenticatedOriginPullsCertificateArgs::builder()
    //!             .certificate("-----INSERT CERTIFICATE-----")
    //!             .private_key("-----INSERT PRIVATE KEY-----")
    //!             .type_("per-hostname")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //!     let myPerZoneAop = authenticated_origin_pulls::create(
    //!         "myPerZoneAop",
    //!         AuthenticatedOriginPullsArgs::builder()
    //!             .authenticated_origin_pulls_certificate("${myPerZoneAopCert.id}")
    //!             .enabled(true)
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //!     let myPerZoneAopCert = authenticated_origin_pulls_certificate::create(
    //!         "myPerZoneAopCert",
    //!         AuthenticatedOriginPullsCertificateArgs::builder()
    //!             .certificate("-----INSERT CERTIFICATE-----")
    //!             .private_key("-----INSERT PRIVATE KEY-----")
    //!             .type_("per-zone")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! global
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/authenticatedOriginPulls:AuthenticatedOriginPulls example <zone_id>
    //! ```
    //!
    //! per zone
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/authenticatedOriginPulls:AuthenticatedOriginPulls example <zone_id>/<certificate_id>
    //! ```
    //!
    //! per hostname
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/authenticatedOriginPulls:AuthenticatedOriginPulls example <zone_id>/<certificate_id>/<hostname>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct AuthenticatedOriginPullsArgs {
        /// The ID of an uploaded Authenticated Origin Pulls certificate. If no hostname is provided, this certificate will be used zone wide as Per-Zone Authenticated Origin Pulls.
        #[builder(into, default)]
        pub authenticated_origin_pulls_certificate: pulumi_wasm_rust::Output<
            Option<String>,
        >,
        /// Whether to enable Authenticated Origin Pulls on the given zone or hostname.
        #[builder(into)]
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// Specify a hostname to enable Per-Hostname Authenticated Origin Pulls on, using the provided certificate.
        #[builder(into, default)]
        pub hostname: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct AuthenticatedOriginPullsResult {
        /// The ID of an uploaded Authenticated Origin Pulls certificate. If no hostname is provided, this certificate will be used zone wide as Per-Zone Authenticated Origin Pulls.
        pub authenticated_origin_pulls_certificate: pulumi_wasm_rust::Output<
            Option<String>,
        >,
        /// Whether to enable Authenticated Origin Pulls on the given zone or hostname.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// Specify a hostname to enable Per-Hostname Authenticated Origin Pulls on, using the provided certificate.
        pub hostname: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: AuthenticatedOriginPullsArgs,
    ) -> AuthenticatedOriginPullsResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let authenticated_origin_pulls_certificate_binding = args
            .authenticated_origin_pulls_certificate
            .get_inner();
        let enabled_binding = args.enabled.get_inner();
        let hostname_binding = args.hostname.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/authenticatedOriginPulls:AuthenticatedOriginPulls"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "authenticatedOriginPullsCertificate".into(),
                    value: &authenticated_origin_pulls_certificate_binding,
                },
                register_interface::ObjectField {
                    name: "enabled".into(),
                    value: &enabled_binding,
                },
                register_interface::ObjectField {
                    name: "hostname".into(),
                    value: &hostname_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "authenticatedOriginPullsCertificate".into(),
                },
                register_interface::ResultField {
                    name: "enabled".into(),
                },
                register_interface::ResultField {
                    name: "hostname".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        AuthenticatedOriginPullsResult {
            authenticated_origin_pulls_certificate: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("authenticatedOriginPullsCertificate").unwrap(),
            ),
            enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enabled").unwrap(),
            ),
            hostname: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("hostname").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod authenticated_origin_pulls_certificate {
    //! Provides a Cloudflare Authenticated Origin Pulls certificate
    //! resource. An uploaded client certificate is required to use Per-Zone
    //!  or Per-Hostname Authenticated Origin Pulls.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let myPerHostnameAopCert = authenticated_origin_pulls_certificate::create(
    //!         "myPerHostnameAopCert",
    //!         AuthenticatedOriginPullsCertificateArgs::builder()
    //!             .certificate("-----INSERT CERTIFICATE-----")
    //!             .private_key("-----INSERT PRIVATE KEY-----")
    //!             .type_("per-hostname")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //!     let myPerZoneAopCert = authenticated_origin_pulls_certificate::create(
    //!         "myPerZoneAopCert",
    //!         AuthenticatedOriginPullsCertificateArgs::builder()
    //!             .certificate("-----INSERT CERTIFICATE-----")
    //!             .private_key("-----INSERT PRIVATE KEY-----")
    //!             .type_("per-zone")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/authenticatedOriginPullsCertificate:AuthenticatedOriginPullsCertificate example <zone_id>/<certificate_type>/<certificate_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct AuthenticatedOriginPullsCertificateArgs {
        /// The public client certificate. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub certificate: pulumi_wasm_rust::Output<String>,
        /// The private key of the client certificate. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub private_key: pulumi_wasm_rust::Output<String>,
        /// The form of Authenticated Origin Pulls to upload the certificate to. Available values: `per-zone`, `per-hostname`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct AuthenticatedOriginPullsCertificateResult {
        /// The public client certificate. **Modifying this attribute will force creation of a new resource.**
        pub certificate: pulumi_wasm_rust::Output<String>,
        /// **Modifying this attribute will force creation of a new resource.**
        pub expires_on: pulumi_wasm_rust::Output<String>,
        /// **Modifying this attribute will force creation of a new resource.**
        pub issuer: pulumi_wasm_rust::Output<String>,
        /// The private key of the client certificate. **Modifying this attribute will force creation of a new resource.**
        pub private_key: pulumi_wasm_rust::Output<String>,
        /// **Modifying this attribute will force creation of a new resource.**
        pub serial_number: pulumi_wasm_rust::Output<String>,
        /// **Modifying this attribute will force creation of a new resource.**
        pub signature: pulumi_wasm_rust::Output<String>,
        /// **Modifying this attribute will force creation of a new resource.**
        pub status: pulumi_wasm_rust::Output<String>,
        /// The form of Authenticated Origin Pulls to upload the certificate to. Available values: `per-zone`, `per-hostname`. **Modifying this attribute will force creation of a new resource.**
        pub type_: pulumi_wasm_rust::Output<String>,
        /// **Modifying this attribute will force creation of a new resource.**
        pub uploaded_on: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: AuthenticatedOriginPullsCertificateArgs,
    ) -> AuthenticatedOriginPullsCertificateResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let certificate_binding = args.certificate.get_inner();
        let private_key_binding = args.private_key.get_inner();
        let type__binding = args.type_.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/authenticatedOriginPullsCertificate:AuthenticatedOriginPullsCertificate"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "certificate".into(),
                    value: &certificate_binding,
                },
                register_interface::ObjectField {
                    name: "privateKey".into(),
                    value: &private_key_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "certificate".into(),
                },
                register_interface::ResultField {
                    name: "expiresOn".into(),
                },
                register_interface::ResultField {
                    name: "issuer".into(),
                },
                register_interface::ResultField {
                    name: "privateKey".into(),
                },
                register_interface::ResultField {
                    name: "serialNumber".into(),
                },
                register_interface::ResultField {
                    name: "signature".into(),
                },
                register_interface::ResultField {
                    name: "status".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
                register_interface::ResultField {
                    name: "uploadedOn".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        AuthenticatedOriginPullsCertificateResult {
            certificate: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("certificate").unwrap(),
            ),
            expires_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("expiresOn").unwrap(),
            ),
            issuer: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("issuer").unwrap(),
            ),
            private_key: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("privateKey").unwrap(),
            ),
            serial_number: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("serialNumber").unwrap(),
            ),
            signature: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("signature").unwrap(),
            ),
            status: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("status").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
            uploaded_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("uploadedOn").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod bot_management {
    //! Provides a resource to configure Bot Management.
    //!
    //! Specifically, this resource can be used to manage:
    //!
    //! - **Bot Fight Mode**
    //! - **Super Bot Fight Mode**
    //! - **Bot Management for Enterprise**
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = bot_management::create(
    //!         "example",
    //!         BotManagementArgs::builder()
    //!             .enable_js(true)
    //!             .optimize_wordpress(true)
    //!             .sbfm_definitely_automated("block")
    //!             .sbfm_likely_automated("managed_challenge")
    //!             .sbfm_static_resource_protection(false)
    //!             .sbfm_verified_bots("allow")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/botManagement:BotManagement example <zone_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct BotManagementArgs {
        /// Enable rule to block AI Scrapers and Crawlers.
        #[builder(into, default)]
        pub ai_bots_protection: pulumi_wasm_rust::Output<Option<String>>,
        /// Automatically update to the newest bot detection models created by Cloudflare as they are released. [Learn more.](https://developers.cloudflare.com/bots/reference/machine-learning-models#model-versions-and-release-notes).
        #[builder(into, default)]
        pub auto_update_model: pulumi_wasm_rust::Output<Option<bool>>,
        /// Use lightweight, invisible JavaScript detections to improve Bot Management. [Learn more about JavaScript Detections](https://developers.cloudflare.com/bots/reference/javascript-detections/).
        #[builder(into, default)]
        pub enable_js: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to enable Bot Fight Mode.
        #[builder(into, default)]
        pub fight_mode: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to optimize Super Bot Fight Mode protections for Wordpress.
        #[builder(into, default)]
        pub optimize_wordpress: pulumi_wasm_rust::Output<Option<bool>>,
        /// Super Bot Fight Mode (SBFM) action to take on definitely automated requests.
        #[builder(into, default)]
        pub sbfm_definitely_automated: pulumi_wasm_rust::Output<Option<String>>,
        /// Super Bot Fight Mode (SBFM) action to take on likely automated requests.
        #[builder(into, default)]
        pub sbfm_likely_automated: pulumi_wasm_rust::Output<Option<String>>,
        /// Super Bot Fight Mode (SBFM) to enable static resource protection. Enable if static resources on your application need bot protection. Note: Static resource protection can also result in legitimate traffic being blocked.
        #[builder(into, default)]
        pub sbfm_static_resource_protection: pulumi_wasm_rust::Output<Option<bool>>,
        /// Super Bot Fight Mode (SBFM) action to take on verified bots requests.
        #[builder(into, default)]
        pub sbfm_verified_bots: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether to disable tracking the highest bot score for a session in the Bot Management cookie.
        #[builder(into, default)]
        pub suppress_session_score: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct BotManagementResult {
        /// Enable rule to block AI Scrapers and Crawlers.
        pub ai_bots_protection: pulumi_wasm_rust::Output<String>,
        /// Automatically update to the newest bot detection models created by Cloudflare as they are released. [Learn more.](https://developers.cloudflare.com/bots/reference/machine-learning-models#model-versions-and-release-notes).
        pub auto_update_model: pulumi_wasm_rust::Output<Option<bool>>,
        /// Use lightweight, invisible JavaScript detections to improve Bot Management. [Learn more about JavaScript Detections](https://developers.cloudflare.com/bots/reference/javascript-detections/).
        pub enable_js: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to enable Bot Fight Mode.
        pub fight_mode: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to optimize Super Bot Fight Mode protections for Wordpress.
        pub optimize_wordpress: pulumi_wasm_rust::Output<Option<bool>>,
        /// Super Bot Fight Mode (SBFM) action to take on definitely automated requests.
        pub sbfm_definitely_automated: pulumi_wasm_rust::Output<Option<String>>,
        /// Super Bot Fight Mode (SBFM) action to take on likely automated requests.
        pub sbfm_likely_automated: pulumi_wasm_rust::Output<Option<String>>,
        /// Super Bot Fight Mode (SBFM) to enable static resource protection. Enable if static resources on your application need bot protection. Note: Static resource protection can also result in legitimate traffic being blocked.
        pub sbfm_static_resource_protection: pulumi_wasm_rust::Output<Option<bool>>,
        /// Super Bot Fight Mode (SBFM) action to take on verified bots requests.
        pub sbfm_verified_bots: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether to disable tracking the highest bot score for a session in the Bot Management cookie.
        pub suppress_session_score: pulumi_wasm_rust::Output<Option<bool>>,
        /// A read-only field that indicates whether the zone currently is running the latest ML model.
        pub using_latest_model: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: BotManagementArgs) -> BotManagementResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let ai_bots_protection_binding = args.ai_bots_protection.get_inner();
        let auto_update_model_binding = args.auto_update_model.get_inner();
        let enable_js_binding = args.enable_js.get_inner();
        let fight_mode_binding = args.fight_mode.get_inner();
        let optimize_wordpress_binding = args.optimize_wordpress.get_inner();
        let sbfm_definitely_automated_binding = args
            .sbfm_definitely_automated
            .get_inner();
        let sbfm_likely_automated_binding = args.sbfm_likely_automated.get_inner();
        let sbfm_static_resource_protection_binding = args
            .sbfm_static_resource_protection
            .get_inner();
        let sbfm_verified_bots_binding = args.sbfm_verified_bots.get_inner();
        let suppress_session_score_binding = args.suppress_session_score.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/botManagement:BotManagement".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "aiBotsProtection".into(),
                    value: &ai_bots_protection_binding,
                },
                register_interface::ObjectField {
                    name: "autoUpdateModel".into(),
                    value: &auto_update_model_binding,
                },
                register_interface::ObjectField {
                    name: "enableJs".into(),
                    value: &enable_js_binding,
                },
                register_interface::ObjectField {
                    name: "fightMode".into(),
                    value: &fight_mode_binding,
                },
                register_interface::ObjectField {
                    name: "optimizeWordpress".into(),
                    value: &optimize_wordpress_binding,
                },
                register_interface::ObjectField {
                    name: "sbfmDefinitelyAutomated".into(),
                    value: &sbfm_definitely_automated_binding,
                },
                register_interface::ObjectField {
                    name: "sbfmLikelyAutomated".into(),
                    value: &sbfm_likely_automated_binding,
                },
                register_interface::ObjectField {
                    name: "sbfmStaticResourceProtection".into(),
                    value: &sbfm_static_resource_protection_binding,
                },
                register_interface::ObjectField {
                    name: "sbfmVerifiedBots".into(),
                    value: &sbfm_verified_bots_binding,
                },
                register_interface::ObjectField {
                    name: "suppressSessionScore".into(),
                    value: &suppress_session_score_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "aiBotsProtection".into(),
                },
                register_interface::ResultField {
                    name: "autoUpdateModel".into(),
                },
                register_interface::ResultField {
                    name: "enableJs".into(),
                },
                register_interface::ResultField {
                    name: "fightMode".into(),
                },
                register_interface::ResultField {
                    name: "optimizeWordpress".into(),
                },
                register_interface::ResultField {
                    name: "sbfmDefinitelyAutomated".into(),
                },
                register_interface::ResultField {
                    name: "sbfmLikelyAutomated".into(),
                },
                register_interface::ResultField {
                    name: "sbfmStaticResourceProtection".into(),
                },
                register_interface::ResultField {
                    name: "sbfmVerifiedBots".into(),
                },
                register_interface::ResultField {
                    name: "suppressSessionScore".into(),
                },
                register_interface::ResultField {
                    name: "usingLatestModel".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        BotManagementResult {
            ai_bots_protection: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("aiBotsProtection").unwrap(),
            ),
            auto_update_model: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("autoUpdateModel").unwrap(),
            ),
            enable_js: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enableJs").unwrap(),
            ),
            fight_mode: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("fightMode").unwrap(),
            ),
            optimize_wordpress: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("optimizeWordpress").unwrap(),
            ),
            sbfm_definitely_automated: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("sbfmDefinitelyAutomated").unwrap(),
            ),
            sbfm_likely_automated: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("sbfmLikelyAutomated").unwrap(),
            ),
            sbfm_static_resource_protection: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("sbfmStaticResourceProtection").unwrap(),
            ),
            sbfm_verified_bots: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("sbfmVerifiedBots").unwrap(),
            ),
            suppress_session_score: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("suppressSessionScore").unwrap(),
            ),
            using_latest_model: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("usingLatestModel").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod byo_ip_prefix {
    //! Provides the ability to manage Bring-Your-Own-IP prefixes (BYOIP)
    //! which are used with or without Magic Transit.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = byo_ip_prefix::create(
    //!         "example",
    //!         ByoIpPrefixArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .advertisement("on")
    //!             .description("Example IP Prefix")
    //!             .prefix_id("d41d8cd98f00b204e9800998ecf8427e")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/byoIpPrefix:ByoIpPrefix example <account_id>/<prefix_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ByoIpPrefixArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether or not the prefix shall be announced. A prefix can be activated or deactivated once every 15 minutes (attempting more regular updates will trigger rate limiting). Available values: `on`, `off`.
        #[builder(into, default)]
        pub advertisement: pulumi_wasm_rust::Output<Option<String>>,
        /// Description of the BYO IP prefix.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The assigned Bring-Your-Own-IP prefix ID. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub prefix_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ByoIpPrefixResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether or not the prefix shall be announced. A prefix can be activated or deactivated once every 15 minutes (attempting more regular updates will trigger rate limiting). Available values: `on`, `off`.
        pub advertisement: pulumi_wasm_rust::Output<String>,
        /// Description of the BYO IP prefix.
        pub description: pulumi_wasm_rust::Output<String>,
        /// The assigned Bring-Your-Own-IP prefix ID. **Modifying this attribute will force creation of a new resource.**
        pub prefix_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: ByoIpPrefixArgs) -> ByoIpPrefixResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let advertisement_binding = args.advertisement.get_inner();
        let description_binding = args.description.get_inner();
        let prefix_id_binding = args.prefix_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/byoIpPrefix:ByoIpPrefix".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "advertisement".into(),
                    value: &advertisement_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "prefixId".into(),
                    value: &prefix_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "advertisement".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "prefixId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ByoIpPrefixResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            advertisement: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("advertisement").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            prefix_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("prefixId").unwrap(),
            ),
        }
    }
}
pub mod certificate_pack {
    //! ## Example Usage
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/certificatePack:CertificatePack example <zone_id>/<certificate_pack_id>
    //! ```
    //!
    //! While supported, importing isn't recommended and it is advised to replace the
    //!
    //! certificate entirely instead.
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct CertificatePackArgs {
        /// Which certificate authority to issue the certificate pack. Available values: `digicert`, `lets_encrypt`, `google`, `ssl_com`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub certificate_authority: pulumi_wasm_rust::Output<String>,
        /// Whether or not to include Cloudflare branding. This will add `sni.cloudflaressl.com` as the Common Name if set to `true`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub cloudflare_branding: pulumi_wasm_rust::Output<Option<bool>>,
        /// List of hostnames to provision the certificate pack for. The zone name must be included as a host. Note: If using Let's Encrypt, you cannot use individual subdomains and only a wildcard for subdomain is available. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub hosts: pulumi_wasm_rust::Output<Vec<String>>,
        /// Certificate pack configuration type. Available values: `advanced`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub type_: pulumi_wasm_rust::Output<String>,
        #[builder(into, default)]
        pub validation_errors: pulumi_wasm_rust::Output<
            Option<Vec<super::types::CertificatePackValidationError>>,
        >,
        /// Which validation method to use in order to prove domain ownership. Available values: `txt`, `http`, `email`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub validation_method: pulumi_wasm_rust::Output<String>,
        #[builder(into, default)]
        pub validation_records: pulumi_wasm_rust::Output<
            Option<Vec<super::types::CertificatePackValidationRecord>>,
        >,
        /// How long the certificate is valid for. Note: If using Let's Encrypt, this value can only be 90 days. Available values: `14`, `30`, `90`, `365`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub validity_days: pulumi_wasm_rust::Output<i32>,
        /// Whether or not to wait for a certificate pack to reach status `active` during creation. Defaults to `false`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub wait_for_active_status: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct CertificatePackResult {
        /// Which certificate authority to issue the certificate pack. Available values: `digicert`, `lets_encrypt`, `google`, `ssl_com`. **Modifying this attribute will force creation of a new resource.**
        pub certificate_authority: pulumi_wasm_rust::Output<String>,
        /// Whether or not to include Cloudflare branding. This will add `sni.cloudflaressl.com` as the Common Name if set to `true`. **Modifying this attribute will force creation of a new resource.**
        pub cloudflare_branding: pulumi_wasm_rust::Output<Option<bool>>,
        /// List of hostnames to provision the certificate pack for. The zone name must be included as a host. Note: If using Let's Encrypt, you cannot use individual subdomains and only a wildcard for subdomain is available. **Modifying this attribute will force creation of a new resource.**
        pub hosts: pulumi_wasm_rust::Output<Vec<String>>,
        /// Certificate pack configuration type. Available values: `advanced`. **Modifying this attribute will force creation of a new resource.**
        pub type_: pulumi_wasm_rust::Output<String>,
        pub validation_errors: pulumi_wasm_rust::Output<
            Vec<super::types::CertificatePackValidationError>,
        >,
        /// Which validation method to use in order to prove domain ownership. Available values: `txt`, `http`, `email`. **Modifying this attribute will force creation of a new resource.**
        pub validation_method: pulumi_wasm_rust::Output<String>,
        pub validation_records: pulumi_wasm_rust::Output<
            Vec<super::types::CertificatePackValidationRecord>,
        >,
        /// How long the certificate is valid for. Note: If using Let's Encrypt, this value can only be 90 days. Available values: `14`, `30`, `90`, `365`. **Modifying this attribute will force creation of a new resource.**
        pub validity_days: pulumi_wasm_rust::Output<i32>,
        /// Whether or not to wait for a certificate pack to reach status `active` during creation. Defaults to `false`. **Modifying this attribute will force creation of a new resource.**
        pub wait_for_active_status: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: CertificatePackArgs) -> CertificatePackResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let certificate_authority_binding = args.certificate_authority.get_inner();
        let cloudflare_branding_binding = args.cloudflare_branding.get_inner();
        let hosts_binding = args.hosts.get_inner();
        let type__binding = args.type_.get_inner();
        let validation_errors_binding = args.validation_errors.get_inner();
        let validation_method_binding = args.validation_method.get_inner();
        let validation_records_binding = args.validation_records.get_inner();
        let validity_days_binding = args.validity_days.get_inner();
        let wait_for_active_status_binding = args.wait_for_active_status.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/certificatePack:CertificatePack".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "certificateAuthority".into(),
                    value: &certificate_authority_binding,
                },
                register_interface::ObjectField {
                    name: "cloudflareBranding".into(),
                    value: &cloudflare_branding_binding,
                },
                register_interface::ObjectField {
                    name: "hosts".into(),
                    value: &hosts_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
                register_interface::ObjectField {
                    name: "validationErrors".into(),
                    value: &validation_errors_binding,
                },
                register_interface::ObjectField {
                    name: "validationMethod".into(),
                    value: &validation_method_binding,
                },
                register_interface::ObjectField {
                    name: "validationRecords".into(),
                    value: &validation_records_binding,
                },
                register_interface::ObjectField {
                    name: "validityDays".into(),
                    value: &validity_days_binding,
                },
                register_interface::ObjectField {
                    name: "waitForActiveStatus".into(),
                    value: &wait_for_active_status_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "certificateAuthority".into(),
                },
                register_interface::ResultField {
                    name: "cloudflareBranding".into(),
                },
                register_interface::ResultField {
                    name: "hosts".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
                register_interface::ResultField {
                    name: "validationErrors".into(),
                },
                register_interface::ResultField {
                    name: "validationMethod".into(),
                },
                register_interface::ResultField {
                    name: "validationRecords".into(),
                },
                register_interface::ResultField {
                    name: "validityDays".into(),
                },
                register_interface::ResultField {
                    name: "waitForActiveStatus".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        CertificatePackResult {
            certificate_authority: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("certificateAuthority").unwrap(),
            ),
            cloudflare_branding: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("cloudflareBranding").unwrap(),
            ),
            hosts: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("hosts").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
            validation_errors: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("validationErrors").unwrap(),
            ),
            validation_method: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("validationMethod").unwrap(),
            ),
            validation_records: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("validationRecords").unwrap(),
            ),
            validity_days: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("validityDays").unwrap(),
            ),
            wait_for_active_status: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("waitForActiveStatus").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod cloud_connector_rules {
    //! The Cloud Connector Rules resource allows you to create and manage cloud connector rules for a zone.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   example:
    //!     type: cloudflare:CloudConnectorRules
    //!     properties:
    //!       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
    //!       rules:
    //!         - description: connect aws bucket
    //!           enabled: true
    //!           expression: http.uri
    //!           provider: aws_s3
    //!           parameters:
    //!             - host: mystorage.s3.ams.amazonaws.com
    //! ```
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct CloudConnectorRulesArgs {
        /// List of Cloud Connector Rules
        #[builder(into, default)]
        pub rules: pulumi_wasm_rust::Output<
            Option<Vec<super::types::CloudConnectorRulesRule>>,
        >,
        /// The zone identifier to target for the resource.
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct CloudConnectorRulesResult {
        /// List of Cloud Connector Rules
        pub rules: pulumi_wasm_rust::Output<
            Option<Vec<super::types::CloudConnectorRulesRule>>,
        >,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: CloudConnectorRulesArgs,
    ) -> CloudConnectorRulesResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let rules_binding = args.rules.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/cloudConnectorRules:CloudConnectorRules".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "rules".into(),
                    value: &rules_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "rules".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        CloudConnectorRulesResult {
            rules: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("rules").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod custom_hostname {
    //! Provides a Cloudflare custom hostname (also known as SSL for SaaS) resource.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = custom_hostname::create(
    //!         "example",
    //!         CustomHostnameArgs::builder()
    //!             .hostname("hostname.example.com")
    //!             .ssls(vec![CustomHostnameSsl::builder().method("txt").build_struct(),])
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/customHostname:CustomHostname example 1d5fdc9e88c8a8c4518b068cd94331fe/0d89c70d-ad9f-4843-b99f-6cc0252067e9
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct CustomHostnameArgs {
        /// Custom metadata associated with custom hostname. Only supports primitive string values, all other values are accessible via the API directly.
        #[builder(into, default)]
        pub custom_metadata: pulumi_wasm_rust::Output<
            Option<std::collections::HashMap<String, String>>,
        >,
        /// The custom origin server used for certificates.
        #[builder(into, default)]
        pub custom_origin_server: pulumi_wasm_rust::Output<Option<String>>,
        /// The [custom origin SNI](https://developers.cloudflare.com/ssl/ssl-for-saas/hostname-specific-behavior/custom-origin) used for certificates.
        #[builder(into, default)]
        pub custom_origin_sni: pulumi_wasm_rust::Output<Option<String>>,
        /// Hostname you intend to request a certificate for. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// SSL properties used when creating the custom hostname.
        #[builder(into, default)]
        pub ssls: pulumi_wasm_rust::Output<Option<Vec<super::types::CustomHostnameSsl>>>,
        /// Whether to wait for a custom hostname SSL sub-object to reach status `pending_validation` during creation. Defaults to `false`.
        #[builder(into, default)]
        pub wait_for_ssl_pending_validation: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct CustomHostnameResult {
        /// Custom metadata associated with custom hostname. Only supports primitive string values, all other values are accessible via the API directly.
        pub custom_metadata: pulumi_wasm_rust::Output<
            Option<std::collections::HashMap<String, String>>,
        >,
        /// The custom origin server used for certificates.
        pub custom_origin_server: pulumi_wasm_rust::Output<Option<String>>,
        /// The [custom origin SNI](https://developers.cloudflare.com/ssl/ssl-for-saas/hostname-specific-behavior/custom-origin) used for certificates.
        pub custom_origin_sni: pulumi_wasm_rust::Output<Option<String>>,
        /// Hostname you intend to request a certificate for. **Modifying this attribute will force creation of a new resource.**
        pub hostname: pulumi_wasm_rust::Output<String>,
        pub ownership_verification: pulumi_wasm_rust::Output<
            std::collections::HashMap<String, String>,
        >,
        pub ownership_verification_http: pulumi_wasm_rust::Output<
            std::collections::HashMap<String, String>,
        >,
        /// SSL properties used when creating the custom hostname.
        pub ssls: pulumi_wasm_rust::Output<Option<Vec<super::types::CustomHostnameSsl>>>,
        /// Status of the certificate.
        pub status: pulumi_wasm_rust::Output<String>,
        /// Whether to wait for a custom hostname SSL sub-object to reach status `pending_validation` during creation. Defaults to `false`.
        pub wait_for_ssl_pending_validation: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: CustomHostnameArgs) -> CustomHostnameResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let custom_metadata_binding = args.custom_metadata.get_inner();
        let custom_origin_server_binding = args.custom_origin_server.get_inner();
        let custom_origin_sni_binding = args.custom_origin_sni.get_inner();
        let hostname_binding = args.hostname.get_inner();
        let ssls_binding = args.ssls.get_inner();
        let wait_for_ssl_pending_validation_binding = args
            .wait_for_ssl_pending_validation
            .get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/customHostname:CustomHostname".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "customMetadata".into(),
                    value: &custom_metadata_binding,
                },
                register_interface::ObjectField {
                    name: "customOriginServer".into(),
                    value: &custom_origin_server_binding,
                },
                register_interface::ObjectField {
                    name: "customOriginSni".into(),
                    value: &custom_origin_sni_binding,
                },
                register_interface::ObjectField {
                    name: "hostname".into(),
                    value: &hostname_binding,
                },
                register_interface::ObjectField {
                    name: "ssls".into(),
                    value: &ssls_binding,
                },
                register_interface::ObjectField {
                    name: "waitForSslPendingValidation".into(),
                    value: &wait_for_ssl_pending_validation_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "customMetadata".into(),
                },
                register_interface::ResultField {
                    name: "customOriginServer".into(),
                },
                register_interface::ResultField {
                    name: "customOriginSni".into(),
                },
                register_interface::ResultField {
                    name: "hostname".into(),
                },
                register_interface::ResultField {
                    name: "ownershipVerification".into(),
                },
                register_interface::ResultField {
                    name: "ownershipVerificationHttp".into(),
                },
                register_interface::ResultField {
                    name: "ssls".into(),
                },
                register_interface::ResultField {
                    name: "status".into(),
                },
                register_interface::ResultField {
                    name: "waitForSslPendingValidation".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        CustomHostnameResult {
            custom_metadata: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customMetadata").unwrap(),
            ),
            custom_origin_server: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customOriginServer").unwrap(),
            ),
            custom_origin_sni: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customOriginSni").unwrap(),
            ),
            hostname: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("hostname").unwrap(),
            ),
            ownership_verification: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("ownershipVerification").unwrap(),
            ),
            ownership_verification_http: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("ownershipVerificationHttp").unwrap(),
            ),
            ssls: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("ssls").unwrap(),
            ),
            status: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("status").unwrap(),
            ),
            wait_for_ssl_pending_validation: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("waitForSslPendingValidation").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod custom_hostname_fallback_origin {
    //! Provides a Cloudflare custom hostname fallback origin resource.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = custom_hostname_fallback_origin::create(
    //!         "example",
    //!         CustomHostnameFallbackOriginArgs::builder()
    //!             .origin("fallback.example.com")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/customHostnameFallbackOrigin:CustomHostnameFallbackOrigin example <zone_id>/<fallback_hostname>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct CustomHostnameFallbackOriginArgs {
        /// Hostname you intend to fallback requests to. Origin must be a proxied A/AAAA/CNAME DNS record within Clouldflare.
        #[builder(into)]
        pub origin: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct CustomHostnameFallbackOriginResult {
        /// Hostname you intend to fallback requests to. Origin must be a proxied A/AAAA/CNAME DNS record within Clouldflare.
        pub origin: pulumi_wasm_rust::Output<String>,
        /// Status of the fallback origin's activation.
        pub status: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: CustomHostnameFallbackOriginArgs,
    ) -> CustomHostnameFallbackOriginResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let origin_binding = args.origin.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/customHostnameFallbackOrigin:CustomHostnameFallbackOrigin"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "origin".into(),
                    value: &origin_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "origin".into(),
                },
                register_interface::ResultField {
                    name: "status".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        CustomHostnameFallbackOriginResult {
            origin: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("origin").unwrap(),
            ),
            status: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("status").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod custom_pages {
    //! Provides a resource which manages Cloudflare custom error pages.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = custom_pages::create(
    //!         "example",
    //!         CustomPagesArgs::builder()
    //!             .state("customized")
    //!             .type_("basic_challenge")
    //!             .url("https://example.com/challenge.html")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/customPages:CustomPages example <resource_level>/<resource_id>/<custom_page_type>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct CustomPagesArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Managed state of the custom page. Available values: `default`, `customized`.
        #[builder(into, default)]
        pub state: pulumi_wasm_rust::Output<Option<String>>,
        /// The type of custom page you wish to update. Available values: `basic_challenge`, `waf_challenge`, `waf_block`, `ratelimit_block`, `country_challenge`, `ip_block`, `under_attack`, `500_errors`, `1000_errors`, `managed_challenge`.
        #[builder(into)]
        pub type_: pulumi_wasm_rust::Output<String>,
        /// URL of where the custom page source is located.
        #[builder(into)]
        pub url: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct CustomPagesResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Managed state of the custom page. Available values: `default`, `customized`.
        pub state: pulumi_wasm_rust::Output<Option<String>>,
        /// The type of custom page you wish to update. Available values: `basic_challenge`, `waf_challenge`, `waf_block`, `ratelimit_block`, `country_challenge`, `ip_block`, `under_attack`, `500_errors`, `1000_errors`, `managed_challenge`.
        pub type_: pulumi_wasm_rust::Output<String>,
        /// URL of where the custom page source is located.
        pub url: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: CustomPagesArgs) -> CustomPagesResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let state_binding = args.state.get_inner();
        let type__binding = args.type_.get_inner();
        let url_binding = args.url.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/customPages:CustomPages".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "state".into(),
                    value: &state_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
                register_interface::ObjectField {
                    name: "url".into(),
                    value: &url_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "state".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
                register_interface::ResultField {
                    name: "url".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        CustomPagesResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            state: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("state").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
            url: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("url").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod custom_ssl {
    //! Provides a Cloudflare custom SSL resource.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   example:
    //!     type: cloudflare:CustomSsl
    //!     properties:
    //!       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
    //!       customSslOptions:
    //!         certificate: '-----INSERT CERTIFICATE-----'
    //!         privateKey: '-----INSERT PRIVATE KEY-----'
    //!         bundleMethod: ubiquitous
    //!         geoRestrictions: us
    //!         type: legacy_custom
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/customSsl:CustomSsl example <zone_id>/<certificate_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct CustomSslArgs {
        /// The certificate associated parameters. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub custom_ssl_options: pulumi_wasm_rust::Output<
            Option<super::types::CustomSslCustomSslOptions>,
        >,
        #[builder(into, default)]
        pub custom_ssl_priorities: pulumi_wasm_rust::Output<
            Option<Vec<super::types::CustomSslCustomSslPriority>>,
        >,
        /// The zone identifier to target for the resource.
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct CustomSslResult {
        /// The certificate associated parameters. **Modifying this attribute will force creation of a new resource.**
        pub custom_ssl_options: pulumi_wasm_rust::Output<
            Option<super::types::CustomSslCustomSslOptions>,
        >,
        pub custom_ssl_priorities: pulumi_wasm_rust::Output<
            Option<Vec<super::types::CustomSslCustomSslPriority>>,
        >,
        pub expires_on: pulumi_wasm_rust::Output<String>,
        pub hosts: pulumi_wasm_rust::Output<Vec<String>>,
        pub issuer: pulumi_wasm_rust::Output<String>,
        pub modified_on: pulumi_wasm_rust::Output<String>,
        pub priority: pulumi_wasm_rust::Output<i32>,
        pub signature: pulumi_wasm_rust::Output<String>,
        pub status: pulumi_wasm_rust::Output<String>,
        pub uploaded_on: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: CustomSslArgs) -> CustomSslResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let custom_ssl_options_binding = args.custom_ssl_options.get_inner();
        let custom_ssl_priorities_binding = args.custom_ssl_priorities.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/customSsl:CustomSsl".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "customSslOptions".into(),
                    value: &custom_ssl_options_binding,
                },
                register_interface::ObjectField {
                    name: "customSslPriorities".into(),
                    value: &custom_ssl_priorities_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "customSslOptions".into(),
                },
                register_interface::ResultField {
                    name: "customSslPriorities".into(),
                },
                register_interface::ResultField {
                    name: "expiresOn".into(),
                },
                register_interface::ResultField {
                    name: "hosts".into(),
                },
                register_interface::ResultField {
                    name: "issuer".into(),
                },
                register_interface::ResultField {
                    name: "modifiedOn".into(),
                },
                register_interface::ResultField {
                    name: "priority".into(),
                },
                register_interface::ResultField {
                    name: "signature".into(),
                },
                register_interface::ResultField {
                    name: "status".into(),
                },
                register_interface::ResultField {
                    name: "uploadedOn".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        CustomSslResult {
            custom_ssl_options: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customSslOptions").unwrap(),
            ),
            custom_ssl_priorities: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customSslPriorities").unwrap(),
            ),
            expires_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("expiresOn").unwrap(),
            ),
            hosts: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("hosts").unwrap(),
            ),
            issuer: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("issuer").unwrap(),
            ),
            modified_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("modifiedOn").unwrap(),
            ),
            priority: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("priority").unwrap(),
            ),
            signature: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("signature").unwrap(),
            ),
            status: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("status").unwrap(),
            ),
            uploaded_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("uploadedOn").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod d_1_database {
    //! The [D1 Database](https://developers.cloudflare.com/d1/) resource allows you to manage Cloudflare D1 databases.
    //!
    //! !> When a D1 Database is replaced all the data is lost. Please ensure you have a
    //!    backup of your data before replacing a D1 Database.
    //!
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = d_1_database::create(
    //!         "example",
    //!         D1DatabaseArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .name("terraform-database")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/d1Database:D1Database example <account id>/<database id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct D1DatabaseArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the D1 Database.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct D1DatabaseResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the D1 Database.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The backend version of the database.
        pub version: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: D1DatabaseArgs) -> D1DatabaseResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let name_binding = args.name.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/d1Database:D1Database".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "version".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        D1DatabaseResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            version: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("version").unwrap(),
            ),
        }
    }
}
pub mod device_dex_test {
    //! Provides a Cloudflare Device Dex Test resource. Device Dex Tests allow for building location-aware device settings policies.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = device_dex_test::create(
    //!         "example",
    //!         DeviceDexTestArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .data(
    //!                 DeviceDexTestData::builder()
    //!                     .host("https://example.com/home")
    //!                     .kind("http")
    //!                     .method("GET")
    //!                     .build_struct(),
    //!             )
    //!             .description("Send a HTTP GET request to the home endpoint every half hour.")
    //!             .enabled(true)
    //!             .interval("0h30m0s")
    //!             .name("GET homepage")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/deviceDexTest:DeviceDexTest example <account_id>/<device_dex_test_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct DeviceDexTestArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The configuration object which contains the details for the WARP client to conduct the test.
        #[builder(into)]
        pub data: pulumi_wasm_rust::Output<super::types::DeviceDexTestData>,
        /// Additional details about the test.
        #[builder(into)]
        pub description: pulumi_wasm_rust::Output<String>,
        /// Determines whether or not the test is active.
        #[builder(into)]
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// How often the test will run.
        #[builder(into)]
        pub interval: pulumi_wasm_rust::Output<String>,
        /// The name of the Device Dex Test. Must be unique.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct DeviceDexTestResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Timestamp of when the Dex Test was created.
        pub created: pulumi_wasm_rust::Output<String>,
        /// The configuration object which contains the details for the WARP client to conduct the test.
        pub data: pulumi_wasm_rust::Output<super::types::DeviceDexTestData>,
        /// Additional details about the test.
        pub description: pulumi_wasm_rust::Output<String>,
        /// Determines whether or not the test is active.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// How often the test will run.
        pub interval: pulumi_wasm_rust::Output<String>,
        /// The name of the Device Dex Test. Must be unique.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Timestamp of when the Dex Test was last updated.
        pub updated: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: DeviceDexTestArgs) -> DeviceDexTestResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let data_binding = args.data.get_inner();
        let description_binding = args.description.get_inner();
        let enabled_binding = args.enabled.get_inner();
        let interval_binding = args.interval.get_inner();
        let name_binding = args.name.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/deviceDexTest:DeviceDexTest".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "data".into(),
                    value: &data_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "enabled".into(),
                    value: &enabled_binding,
                },
                register_interface::ObjectField {
                    name: "interval".into(),
                    value: &interval_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "created".into(),
                },
                register_interface::ResultField {
                    name: "data".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "enabled".into(),
                },
                register_interface::ResultField {
                    name: "interval".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "updated".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        DeviceDexTestResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            created: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("created").unwrap(),
            ),
            data: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("data").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enabled").unwrap(),
            ),
            interval: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("interval").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            updated: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("updated").unwrap(),
            ),
        }
    }
}
pub mod device_managed_networks {
    //! Provides a Cloudflare Device Managed Network resource. Device managed networks allow for building location-aware device settings policies.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let managedNetworks = device_managed_networks::create(
    //!         "managedNetworks",
    //!         DeviceManagedNetworksArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .config(
    //!                 DeviceManagedNetworksConfig::builder()
    //!                     .sha256(
    //!                         "b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c",
    //!                     )
    //!                     .tlsSockaddr("foobar:1234")
    //!                     .build_struct(),
    //!             )
    //!             .name("managed-network-1")
    //!             .type_("tls")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/deviceManagedNetworks:DeviceManagedNetworks example <account_id>/<device_managed_networks_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct DeviceManagedNetworksArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The configuration containing information for the WARP client to detect the managed network.
        #[builder(into)]
        pub config: pulumi_wasm_rust::Output<super::types::DeviceManagedNetworksConfig>,
        /// The name of the Device Managed Network. Must be unique.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The type of Device Managed Network. Available values: `tls`.
        #[builder(into)]
        pub type_: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct DeviceManagedNetworksResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The configuration containing information for the WARP client to detect the managed network.
        pub config: pulumi_wasm_rust::Output<super::types::DeviceManagedNetworksConfig>,
        /// The name of the Device Managed Network. Must be unique.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The type of Device Managed Network. Available values: `tls`.
        pub type_: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: DeviceManagedNetworksArgs,
    ) -> DeviceManagedNetworksResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let config_binding = args.config.get_inner();
        let name_binding = args.name.get_inner();
        let type__binding = args.type_.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/deviceManagedNetworks:DeviceManagedNetworks".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "config".into(),
                    value: &config_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "config".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        DeviceManagedNetworksResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            config: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("config").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
        }
    }
}
pub mod device_policy_certificates {
    //! Provides a Cloudflare device policy certificates resource. Device
    //! policy certificate resources enable client device certificate
    //! generation.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = device_policy_certificates::create(
    //!         "example",
    //!         DevicePolicyCertificatesArgs::builder()
    //!             .enabled(true)
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/devicePolicyCertificates:DevicePolicyCertificates example <zone_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct DevicePolicyCertificatesArgs {
        /// `true` if certificate generation is enabled.
        #[builder(into)]
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource.
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct DevicePolicyCertificatesResult {
        /// `true` if certificate generation is enabled.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: DevicePolicyCertificatesArgs,
    ) -> DevicePolicyCertificatesResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let enabled_binding = args.enabled.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/devicePolicyCertificates:DevicePolicyCertificates"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "enabled".into(),
                    value: &enabled_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "enabled".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        DevicePolicyCertificatesResult {
            enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enabled").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod device_posture_integration {
    //! Provides a Cloudflare Device Posture Integration resource. Device
    //! posture integrations configure third-party data providers for device
    //! posture rules.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = device_posture_integration::create(
    //!         "example",
    //!         DevicePostureIntegrationArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .configs(
    //!                 vec![
    //!                     DevicePostureIntegrationConfig::builder()
    //!                     .apiUrl("https://example.com/api")
    //!                     .authUrl("https://example.com/connect/token").clientId("client-id")
    //!                     .clientSecret("client-secret").build_struct(),
    //!                 ],
    //!             )
    //!             .interval("24h")
    //!             .name("Device posture integration")
    //!             .type_("workspace_one")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/devicePostureIntegration:DevicePostureIntegration example <account_id>/<device_posture_integration_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct DevicePostureIntegrationArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The device posture integration's connection authorization parameters.
        #[builder(into, default)]
        pub configs: pulumi_wasm_rust::Output<
            Option<Vec<super::types::DevicePostureIntegrationConfig>>,
        >,
        #[builder(into, default)]
        pub identifier: pulumi_wasm_rust::Output<Option<String>>,
        /// Indicates the frequency with which to poll the third-party API. Must be in the format `1h` or `30m`.
        #[builder(into, default)]
        pub interval: pulumi_wasm_rust::Output<Option<String>>,
        /// Name of the device posture integration.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The device posture integration type. Available values: `workspace_one`, `uptycs`, `crowdstrike_s2s`, `intune`, `kolide`, `sentinelone_s2s`, `tanium_s2s`, `custom_s2s`.
        #[builder(into)]
        pub type_: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct DevicePostureIntegrationResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The device posture integration's connection authorization parameters.
        pub configs: pulumi_wasm_rust::Output<
            Option<Vec<super::types::DevicePostureIntegrationConfig>>,
        >,
        pub identifier: pulumi_wasm_rust::Output<Option<String>>,
        /// Indicates the frequency with which to poll the third-party API. Must be in the format `1h` or `30m`.
        pub interval: pulumi_wasm_rust::Output<Option<String>>,
        /// Name of the device posture integration.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The device posture integration type. Available values: `workspace_one`, `uptycs`, `crowdstrike_s2s`, `intune`, `kolide`, `sentinelone_s2s`, `tanium_s2s`, `custom_s2s`.
        pub type_: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: DevicePostureIntegrationArgs,
    ) -> DevicePostureIntegrationResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let configs_binding = args.configs.get_inner();
        let identifier_binding = args.identifier.get_inner();
        let interval_binding = args.interval.get_inner();
        let name_binding = args.name.get_inner();
        let type__binding = args.type_.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/devicePostureIntegration:DevicePostureIntegration"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "configs".into(),
                    value: &configs_binding,
                },
                register_interface::ObjectField {
                    name: "identifier".into(),
                    value: &identifier_binding,
                },
                register_interface::ObjectField {
                    name: "interval".into(),
                    value: &interval_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "configs".into(),
                },
                register_interface::ResultField {
                    name: "identifier".into(),
                },
                register_interface::ResultField {
                    name: "interval".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        DevicePostureIntegrationResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            configs: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("configs").unwrap(),
            ),
            identifier: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("identifier").unwrap(),
            ),
            interval: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("interval").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
        }
    }
}
pub mod device_posture_rule {
    //! Provides a Cloudflare Device Posture Rule resource. Device posture rules configure security policies for device posture checks.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let eaxmple = device_posture_rule::create(
    //!         "eaxmple",
    //!         DevicePostureRuleArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .description("Device posture rule for corporate devices.")
    //!             .expiration("24h")
    //!             .inputs(
    //!                 vec![
    //!                     DevicePostureRuleInput::builder().id("${corporateDevices.id}")
    //!                     .operator("<").osDistroName("ubuntu").osDistroRevision("1.0.0")
    //!                     .osVersionExtra("(a)").version("1.0.0").build_struct(),
    //!                 ],
    //!             )
    //!             .matches(
    //!                 vec![DevicePostureRuleMatch::builder().platform("linux").build_struct(),],
    //!             )
    //!             .name("Corporate devices posture rule")
    //!             .schedule("24h")
    //!             .type_("os_version")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/devicePostureRule:DevicePostureRule example <account_id>/<device_posture_rule_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct DevicePostureRuleArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Expire posture results after the specified amount of time. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.
        #[builder(into, default)]
        pub expiration: pulumi_wasm_rust::Output<Option<String>>,
        /// Required for all rule types except `warp`, `gateway`, and `tanium`.
        #[builder(into, default)]
        pub inputs: pulumi_wasm_rust::Output<
            Option<Vec<super::types::DevicePostureRuleInput>>,
        >,
        /// The conditions that the client must match to run the rule.
        #[builder(into, default)]
        pub matches: pulumi_wasm_rust::Output<
            Option<Vec<super::types::DevicePostureRuleMatch>>,
        >,
        /// Name of the device posture rule.
        #[builder(into, default)]
        pub name: pulumi_wasm_rust::Output<Option<String>>,
        /// Tells the client when to run the device posture check. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.
        #[builder(into, default)]
        pub schedule: pulumi_wasm_rust::Output<Option<String>>,
        /// The device posture rule type. Available values: `serial_number`, `file`, `application`, `gateway`, `warp`, `domain_joined`, `os_version`, `disk_encryption`, `firewall`, `client_certificate`, `client_certificate_v2`, `workspace_one`, `unique_client_id`, `crowdstrike_s2s`, `sentinelone`, `kolide`, `tanium_s2s`, `intune`, `sentinelone_s2s`, `custom_s2s`.
        #[builder(into)]
        pub type_: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct DevicePostureRuleResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Expire posture results after the specified amount of time. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.
        pub expiration: pulumi_wasm_rust::Output<Option<String>>,
        /// Required for all rule types except `warp`, `gateway`, and `tanium`.
        pub inputs: pulumi_wasm_rust::Output<Vec<super::types::DevicePostureRuleInput>>,
        /// The conditions that the client must match to run the rule.
        pub matches: pulumi_wasm_rust::Output<
            Option<Vec<super::types::DevicePostureRuleMatch>>,
        >,
        /// Name of the device posture rule.
        pub name: pulumi_wasm_rust::Output<Option<String>>,
        /// Tells the client when to run the device posture check. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.
        pub schedule: pulumi_wasm_rust::Output<Option<String>>,
        /// The device posture rule type. Available values: `serial_number`, `file`, `application`, `gateway`, `warp`, `domain_joined`, `os_version`, `disk_encryption`, `firewall`, `client_certificate`, `client_certificate_v2`, `workspace_one`, `unique_client_id`, `crowdstrike_s2s`, `sentinelone`, `kolide`, `tanium_s2s`, `intune`, `sentinelone_s2s`, `custom_s2s`.
        pub type_: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: DevicePostureRuleArgs) -> DevicePostureRuleResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let description_binding = args.description.get_inner();
        let expiration_binding = args.expiration.get_inner();
        let inputs_binding = args.inputs.get_inner();
        let matches_binding = args.matches.get_inner();
        let name_binding = args.name.get_inner();
        let schedule_binding = args.schedule.get_inner();
        let type__binding = args.type_.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/devicePostureRule:DevicePostureRule".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "expiration".into(),
                    value: &expiration_binding,
                },
                register_interface::ObjectField {
                    name: "inputs".into(),
                    value: &inputs_binding,
                },
                register_interface::ObjectField {
                    name: "matches".into(),
                    value: &matches_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "schedule".into(),
                    value: &schedule_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "expiration".into(),
                },
                register_interface::ResultField {
                    name: "inputs".into(),
                },
                register_interface::ResultField {
                    name: "matches".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "schedule".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        DevicePostureRuleResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            expiration: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("expiration").unwrap(),
            ),
            inputs: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("inputs").unwrap(),
            ),
            matches: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("matches").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            schedule: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("schedule").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
        }
    }
}
pub mod device_settings_policy {
    //! Provides a Cloudflare Device Settings Policy resource. Device policies configure settings applied to WARP devices.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let developerWarpPolicy = device_settings_policy::create(
    //!         "developerWarpPolicy",
    //!         DeviceSettingsPolicyArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .allow_mode_switch(true)
    //!             .allow_updates(true)
    //!             .allowed_to_leave(true)
    //!             .auto_connect(0)
    //!             .captive_portal(5)
    //!             .default(false)
    //!             .description("Developers WARP settings policy description")
    //!             .disable_auto_fallback(true)
    //!             .enabled(true)
    //!             .exclude_office_ips(false)
    //!             .match_("any(identity.groups.name[*] in {\"Developers\"})")
    //!             .name("Developers WARP settings policy")
    //!             .precedence(10)
    //!             .service_mode_v_2_mode("warp")
    //!             .service_mode_v_2_port(3000)
    //!             .support_url("https://cloudflare.com")
    //!             .switch_locked(true)
    //!             .tunnel_protocol("wireguard")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! For default device settings policies you must use "default" as the policy ID.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/deviceSettingsPolicy:DeviceSettingsPolicy example <account_id>/<device_policy_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct DeviceSettingsPolicyArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether to allow mode switch for this policy.
        #[builder(into, default)]
        pub allow_mode_switch: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to allow updates under this policy.
        #[builder(into, default)]
        pub allow_updates: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to allow devices to leave the organization. Defaults to `true`.
        #[builder(into, default)]
        pub allowed_to_leave: pulumi_wasm_rust::Output<Option<bool>>,
        /// The amount of time in seconds to reconnect after having been disabled.
        #[builder(into, default)]
        pub auto_connect: pulumi_wasm_rust::Output<Option<i32>>,
        /// The captive portal value for this policy. Defaults to `180`.
        #[builder(into, default)]
        pub captive_portal: pulumi_wasm_rust::Output<Option<i32>>,
        /// Whether the policy refers to the default account policy.
        #[builder(into, default)]
        pub default: pulumi_wasm_rust::Output<Option<bool>>,
        /// Description of Policy.
        #[builder(into)]
        pub description: pulumi_wasm_rust::Output<String>,
        /// Whether to disable auto fallback for this policy.
        #[builder(into, default)]
        pub disable_auto_fallback: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether the policy is enabled (cannot be set for default policies). Defaults to `true`.
        #[builder(into, default)]
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to add Microsoft IPs to split tunnel exclusions.
        #[builder(into, default)]
        pub exclude_office_ips: pulumi_wasm_rust::Output<Option<bool>>,
        /// Wirefilter expression to match a device against when evaluating whether this policy should take effect for that device.
        #[builder(into, default)]
        pub match_: pulumi_wasm_rust::Output<Option<String>>,
        /// Name of the policy.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The precedence of the policy. Lower values indicate higher precedence.
        #[builder(into, default)]
        pub precedence: pulumi_wasm_rust::Output<Option<i32>>,
        /// The service mode. Available values: `1dot1`, `warp`, `proxy`, `posture_only`, `warp_tunnel_only`. Defaults to `warp`.
        #[builder(into, default)]
        pub service_mode_v2_mode: pulumi_wasm_rust::Output<Option<String>>,
        /// The port to use for the proxy service mode. Required when using `service_mode_v2_mode`.
        #[builder(into, default)]
        pub service_mode_v2_port: pulumi_wasm_rust::Output<Option<i32>>,
        /// The support URL that will be opened when sending feedback.
        #[builder(into, default)]
        pub support_url: pulumi_wasm_rust::Output<Option<String>>,
        /// Enablement of the ZT client switch lock.
        #[builder(into, default)]
        pub switch_locked: pulumi_wasm_rust::Output<Option<bool>>,
        /// Determines which tunnel protocol to use. Available values: `""`, `wireguard`, `masque`. Defaults to `wireguard`.
        #[builder(into, default)]
        pub tunnel_protocol: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct DeviceSettingsPolicyResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether to allow mode switch for this policy.
        pub allow_mode_switch: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to allow updates under this policy.
        pub allow_updates: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to allow devices to leave the organization. Defaults to `true`.
        pub allowed_to_leave: pulumi_wasm_rust::Output<Option<bool>>,
        /// The amount of time in seconds to reconnect after having been disabled.
        pub auto_connect: pulumi_wasm_rust::Output<Option<i32>>,
        /// The captive portal value for this policy. Defaults to `180`.
        pub captive_portal: pulumi_wasm_rust::Output<Option<i32>>,
        /// Whether the policy refers to the default account policy.
        pub default: pulumi_wasm_rust::Output<Option<bool>>,
        /// Description of Policy.
        pub description: pulumi_wasm_rust::Output<String>,
        /// Whether to disable auto fallback for this policy.
        pub disable_auto_fallback: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether the policy is enabled (cannot be set for default policies). Defaults to `true`.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to add Microsoft IPs to split tunnel exclusions.
        pub exclude_office_ips: pulumi_wasm_rust::Output<Option<bool>>,
        /// Wirefilter expression to match a device against when evaluating whether this policy should take effect for that device.
        pub match_: pulumi_wasm_rust::Output<Option<String>>,
        /// Name of the policy.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The precedence of the policy. Lower values indicate higher precedence.
        pub precedence: pulumi_wasm_rust::Output<Option<i32>>,
        /// The service mode. Available values: `1dot1`, `warp`, `proxy`, `posture_only`, `warp_tunnel_only`. Defaults to `warp`.
        pub service_mode_v2_mode: pulumi_wasm_rust::Output<Option<String>>,
        /// The port to use for the proxy service mode. Required when using `service_mode_v2_mode`.
        pub service_mode_v2_port: pulumi_wasm_rust::Output<Option<i32>>,
        /// The support URL that will be opened when sending feedback.
        pub support_url: pulumi_wasm_rust::Output<Option<String>>,
        /// Enablement of the ZT client switch lock.
        pub switch_locked: pulumi_wasm_rust::Output<Option<bool>>,
        /// Determines which tunnel protocol to use. Available values: `""`, `wireguard`, `masque`. Defaults to `wireguard`.
        pub tunnel_protocol: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: DeviceSettingsPolicyArgs,
    ) -> DeviceSettingsPolicyResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let allow_mode_switch_binding = args.allow_mode_switch.get_inner();
        let allow_updates_binding = args.allow_updates.get_inner();
        let allowed_to_leave_binding = args.allowed_to_leave.get_inner();
        let auto_connect_binding = args.auto_connect.get_inner();
        let captive_portal_binding = args.captive_portal.get_inner();
        let default_binding = args.default.get_inner();
        let description_binding = args.description.get_inner();
        let disable_auto_fallback_binding = args.disable_auto_fallback.get_inner();
        let enabled_binding = args.enabled.get_inner();
        let exclude_office_ips_binding = args.exclude_office_ips.get_inner();
        let match__binding = args.match_.get_inner();
        let name_binding = args.name.get_inner();
        let precedence_binding = args.precedence.get_inner();
        let service_mode_v2_mode_binding = args.service_mode_v2_mode.get_inner();
        let service_mode_v2_port_binding = args.service_mode_v2_port.get_inner();
        let support_url_binding = args.support_url.get_inner();
        let switch_locked_binding = args.switch_locked.get_inner();
        let tunnel_protocol_binding = args.tunnel_protocol.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/deviceSettingsPolicy:DeviceSettingsPolicy".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "allowModeSwitch".into(),
                    value: &allow_mode_switch_binding,
                },
                register_interface::ObjectField {
                    name: "allowUpdates".into(),
                    value: &allow_updates_binding,
                },
                register_interface::ObjectField {
                    name: "allowedToLeave".into(),
                    value: &allowed_to_leave_binding,
                },
                register_interface::ObjectField {
                    name: "autoConnect".into(),
                    value: &auto_connect_binding,
                },
                register_interface::ObjectField {
                    name: "captivePortal".into(),
                    value: &captive_portal_binding,
                },
                register_interface::ObjectField {
                    name: "default".into(),
                    value: &default_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "disableAutoFallback".into(),
                    value: &disable_auto_fallback_binding,
                },
                register_interface::ObjectField {
                    name: "enabled".into(),
                    value: &enabled_binding,
                },
                register_interface::ObjectField {
                    name: "excludeOfficeIps".into(),
                    value: &exclude_office_ips_binding,
                },
                register_interface::ObjectField {
                    name: "match".into(),
                    value: &match__binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "precedence".into(),
                    value: &precedence_binding,
                },
                register_interface::ObjectField {
                    name: "serviceModeV2Mode".into(),
                    value: &service_mode_v2_mode_binding,
                },
                register_interface::ObjectField {
                    name: "serviceModeV2Port".into(),
                    value: &service_mode_v2_port_binding,
                },
                register_interface::ObjectField {
                    name: "supportUrl".into(),
                    value: &support_url_binding,
                },
                register_interface::ObjectField {
                    name: "switchLocked".into(),
                    value: &switch_locked_binding,
                },
                register_interface::ObjectField {
                    name: "tunnelProtocol".into(),
                    value: &tunnel_protocol_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "allowModeSwitch".into(),
                },
                register_interface::ResultField {
                    name: "allowUpdates".into(),
                },
                register_interface::ResultField {
                    name: "allowedToLeave".into(),
                },
                register_interface::ResultField {
                    name: "autoConnect".into(),
                },
                register_interface::ResultField {
                    name: "captivePortal".into(),
                },
                register_interface::ResultField {
                    name: "default".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "disableAutoFallback".into(),
                },
                register_interface::ResultField {
                    name: "enabled".into(),
                },
                register_interface::ResultField {
                    name: "excludeOfficeIps".into(),
                },
                register_interface::ResultField {
                    name: "match".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "precedence".into(),
                },
                register_interface::ResultField {
                    name: "serviceModeV2Mode".into(),
                },
                register_interface::ResultField {
                    name: "serviceModeV2Port".into(),
                },
                register_interface::ResultField {
                    name: "supportUrl".into(),
                },
                register_interface::ResultField {
                    name: "switchLocked".into(),
                },
                register_interface::ResultField {
                    name: "tunnelProtocol".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        DeviceSettingsPolicyResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            allow_mode_switch: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("allowModeSwitch").unwrap(),
            ),
            allow_updates: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("allowUpdates").unwrap(),
            ),
            allowed_to_leave: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("allowedToLeave").unwrap(),
            ),
            auto_connect: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("autoConnect").unwrap(),
            ),
            captive_portal: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("captivePortal").unwrap(),
            ),
            default: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("default").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            disable_auto_fallback: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("disableAutoFallback").unwrap(),
            ),
            enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enabled").unwrap(),
            ),
            exclude_office_ips: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("excludeOfficeIps").unwrap(),
            ),
            match_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("match").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            precedence: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("precedence").unwrap(),
            ),
            service_mode_v2_mode: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("serviceModeV2Mode").unwrap(),
            ),
            service_mode_v2_port: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("serviceModeV2Port").unwrap(),
            ),
            support_url: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("supportUrl").unwrap(),
            ),
            switch_locked: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("switchLocked").unwrap(),
            ),
            tunnel_protocol: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tunnelProtocol").unwrap(),
            ),
        }
    }
}
pub mod dlp_profile {
    //! Provides a Cloudflare DLP Profile resource. Data Loss Prevention profiles
    //! are a set of entries that can be matched in HTTP bodies or files.
    //! They are referenced in Zero Trust Gateway rules.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let creds = dlp_profile::create(
    //!         "creds",
    //!         DlpProfileArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .allowed_match_count(3)
    //!             .entries(
    //!                 vec![
    //!                     DlpProfileEntry::builder().enabled(true)
    //!                     .id("d8fcfc9c-773c-405e-8426-21ecbb67ba93")
    //!                     .name("Amazon AWS Access Key ID").build_struct(),
    //!                     DlpProfileEntry::builder().enabled(false)
    //!                     .id("2c0e33e1-71da-40c8-aad3-32e674ad3d96")
    //!                     .name("Amazon AWS Secret Access Key").build_struct(),
    //!                     DlpProfileEntry::builder().enabled(true)
    //!                     .id("4e92c006-3802-4dff-bbe1-8e1513b1c92a")
    //!                     .name("Microsoft Azure Client Secret").build_struct(),
    //!                     DlpProfileEntry::builder().enabled(false)
    //!                     .id("5c713294-2375-4904-abcf-e4a15be4d592").name("SSH Private Key")
    //!                     .build_struct(), DlpProfileEntry::builder().enabled(true)
    //!                     .id("6c6579e4-d832-42d5-905c-8e53340930f2")
    //!                     .name("Google GCP API Key").build_struct(),
    //!                 ],
    //!             )
    //!             .name("Credentials and Secrets")
    //!             .type_("predefined")
    //!             .build_struct(),
    //!     );
    //!     let exampleCustom = dlp_profile::create(
    //!         "exampleCustom",
    //!         DlpProfileArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .allowed_match_count(0)
    //!             .description("A profile with example entries")
    //!             .entries(
    //!                 vec![
    //!                     DlpProfileEntry::builder().enabled(true)
    //!                     .name("Matches visa credit cards")
    //!                     .pattern(DlpProfileEntryPattern::builder()
    //!                     .regex("4\\d{3}([-\\. ])?\\d{4}([-\\. ])?\\d{4}([-\\. ])?\\d{4}")
    //!                     .validation("luhn").build_struct()).build_struct(),
    //!                     DlpProfileEntry::builder().enabled(true)
    //!                     .name("Matches diners club card")
    //!                     .pattern(DlpProfileEntryPattern::builder()
    //!                     .regex("(?:0[0-5]|[68][0-9])[0-9]{11}").validation("luhn")
    //!                     .build_struct()).build_struct(),
    //!                 ],
    //!             )
    //!             .name("Example Custom Profile")
    //!             .type_("custom")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/dlpProfile:DlpProfile example <account_id>/<dlp_profile_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct DlpProfileArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Related DLP policies will trigger when the match count exceeds the number set.
        #[builder(into)]
        pub allowed_match_count: pulumi_wasm_rust::Output<i32>,
        /// Scan the context of predefined entries to only return matches surrounded by keywords.
        #[builder(into, default)]
        pub context_awareness: pulumi_wasm_rust::Output<
            Option<super::types::DlpProfileContextAwareness>,
        >,
        /// Brief summary of the profile and its intended use.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// List of entries to apply to the profile.
        #[builder(into)]
        pub entries: pulumi_wasm_rust::Output<Vec<super::types::DlpProfileEntry>>,
        /// Name of the profile. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// If true, scan images via OCR to determine if any text present matches filters.
        #[builder(into, default)]
        pub ocr_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The type of the profile. Available values: `custom`, `predefined`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub type_: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct DlpProfileResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Related DLP policies will trigger when the match count exceeds the number set.
        pub allowed_match_count: pulumi_wasm_rust::Output<i32>,
        /// Scan the context of predefined entries to only return matches surrounded by keywords.
        pub context_awareness: pulumi_wasm_rust::Output<
            super::types::DlpProfileContextAwareness,
        >,
        /// Brief summary of the profile and its intended use.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// List of entries to apply to the profile.
        pub entries: pulumi_wasm_rust::Output<Vec<super::types::DlpProfileEntry>>,
        /// Name of the profile. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
        /// If true, scan images via OCR to determine if any text present matches filters.
        pub ocr_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The type of the profile. Available values: `custom`, `predefined`. **Modifying this attribute will force creation of a new resource.**
        pub type_: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: DlpProfileArgs) -> DlpProfileResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let allowed_match_count_binding = args.allowed_match_count.get_inner();
        let context_awareness_binding = args.context_awareness.get_inner();
        let description_binding = args.description.get_inner();
        let entries_binding = args.entries.get_inner();
        let name_binding = args.name.get_inner();
        let ocr_enabled_binding = args.ocr_enabled.get_inner();
        let type__binding = args.type_.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/dlpProfile:DlpProfile".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "allowedMatchCount".into(),
                    value: &allowed_match_count_binding,
                },
                register_interface::ObjectField {
                    name: "contextAwareness".into(),
                    value: &context_awareness_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "entries".into(),
                    value: &entries_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "ocrEnabled".into(),
                    value: &ocr_enabled_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "allowedMatchCount".into(),
                },
                register_interface::ResultField {
                    name: "contextAwareness".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "entries".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "ocrEnabled".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        DlpProfileResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            allowed_match_count: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("allowedMatchCount").unwrap(),
            ),
            context_awareness: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("contextAwareness").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            entries: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("entries").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            ocr_enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("ocrEnabled").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
        }
    }
}
pub mod email_routing_address {
    //! The [Email Routing Address](https://developers.cloudflare.com/email-routing/setup/email-routing-addresses/#destination-addresses) resource allows you to manage Cloudflare Email Routing Destination Addresses.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = email_routing_address::create(
    //!         "example",
    //!         EmailRoutingAddressArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .email("user@example.com")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/emailRoutingAddress:EmailRoutingAddress example <account_id>/<email_routing_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct EmailRoutingAddressArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The contact email address of the user.
        #[builder(into)]
        pub email: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct EmailRoutingAddressResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The date and time the destination address has been created.
        pub created: pulumi_wasm_rust::Output<String>,
        /// The contact email address of the user.
        pub email: pulumi_wasm_rust::Output<String>,
        /// The date and time the destination address has been modified.
        pub modified: pulumi_wasm_rust::Output<String>,
        /// Destination address identifier.
        pub tag: pulumi_wasm_rust::Output<String>,
        /// The date and time the destination address has been verified. Null means not verified yet.
        pub verified: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: EmailRoutingAddressArgs,
    ) -> EmailRoutingAddressResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let email_binding = args.email.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/emailRoutingAddress:EmailRoutingAddress".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "email".into(),
                    value: &email_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "created".into(),
                },
                register_interface::ResultField {
                    name: "email".into(),
                },
                register_interface::ResultField {
                    name: "modified".into(),
                },
                register_interface::ResultField {
                    name: "tag".into(),
                },
                register_interface::ResultField {
                    name: "verified".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        EmailRoutingAddressResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            created: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("created").unwrap(),
            ),
            email: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("email").unwrap(),
            ),
            modified: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("modified").unwrap(),
            ),
            tag: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tag").unwrap(),
            ),
            verified: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("verified").unwrap(),
            ),
        }
    }
}
pub mod email_routing_catch_all {
    //! Provides a resource for managing Email Routing Addresses catch all behaviour.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = email_routing_catch_all::create(
    //!         "example",
    //!         EmailRoutingCatchAllArgs::builder()
    //!             .actions(
    //!                 vec![
    //!                     EmailRoutingCatchAllAction::builder(). type ("forward")
    //!                     .values(vec!["destinationaddress@example.net",]).build_struct(),
    //!                 ],
    //!             )
    //!             .enabled(true)
    //!             .matchers(
    //!                 vec![
    //!                     EmailRoutingCatchAllMatcher::builder(). type ("all").build_struct(),
    //!                 ],
    //!             )
    //!             .name("example catch all")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct EmailRoutingCatchAllArgs {
        /// List actions patterns.
        #[builder(into)]
        pub actions: pulumi_wasm_rust::Output<
            Vec<super::types::EmailRoutingCatchAllAction>,
        >,
        /// Routing rule status.
        #[builder(into, default)]
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Matching patterns to forward to your actions.
        #[builder(into)]
        pub matchers: pulumi_wasm_rust::Output<
            Vec<super::types::EmailRoutingCatchAllMatcher>,
        >,
        /// Routing rule name.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct EmailRoutingCatchAllResult {
        /// List actions patterns.
        pub actions: pulumi_wasm_rust::Output<
            Vec<super::types::EmailRoutingCatchAllAction>,
        >,
        /// Routing rule status.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Matching patterns to forward to your actions.
        pub matchers: pulumi_wasm_rust::Output<
            Vec<super::types::EmailRoutingCatchAllMatcher>,
        >,
        /// Routing rule name.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Routing rule identifier.
        pub tag: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: EmailRoutingCatchAllArgs,
    ) -> EmailRoutingCatchAllResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let actions_binding = args.actions.get_inner();
        let enabled_binding = args.enabled.get_inner();
        let matchers_binding = args.matchers.get_inner();
        let name_binding = args.name.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/emailRoutingCatchAll:EmailRoutingCatchAll".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "actions".into(),
                    value: &actions_binding,
                },
                register_interface::ObjectField {
                    name: "enabled".into(),
                    value: &enabled_binding,
                },
                register_interface::ObjectField {
                    name: "matchers".into(),
                    value: &matchers_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "actions".into(),
                },
                register_interface::ResultField {
                    name: "enabled".into(),
                },
                register_interface::ResultField {
                    name: "matchers".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "tag".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        EmailRoutingCatchAllResult {
            actions: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("actions").unwrap(),
            ),
            enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enabled").unwrap(),
            ),
            matchers: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("matchers").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            tag: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tag").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod email_routing_rule {
    //! The [Email Routing Rule](https://developers.cloudflare.com/email-routing/setup/email-routing-addresses/#email-rule-actions) resource allows you to create and manage email routing rules for a zone.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let main = email_routing_rule::create(
    //!         "main",
    //!         EmailRoutingRuleArgs::builder()
    //!             .actions(
    //!                 vec![
    //!                     EmailRoutingRuleAction::builder(). type ("forward")
    //!                     .values(vec!["destinationaddress@example.net",]).build_struct(),
    //!                 ],
    //!             )
    //!             .enabled(true)
    //!             .matchers(
    //!                 vec![
    //!                     EmailRoutingRuleMatcher::builder().field("to"). type ("literal")
    //!                     .value("test@example.com").build_struct(),
    //!                 ],
    //!             )
    //!             .name("terraform rule")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/emailRoutingRule:EmailRoutingRule example <zone_id>/<email_routing_rule_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct EmailRoutingRuleArgs {
        /// Actions to take when a match is found.
        #[builder(into, default)]
        pub actions: pulumi_wasm_rust::Output<
            Option<Vec<super::types::EmailRoutingRuleAction>>,
        >,
        /// Whether the email routing rule is enabled.
        #[builder(into, default)]
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Matching patterns to forward to your actions.
        #[builder(into, default)]
        pub matchers: pulumi_wasm_rust::Output<
            Option<Vec<super::types::EmailRoutingRuleMatcher>>,
        >,
        /// Routing rule name.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The priority of the email routing rule.
        #[builder(into, default)]
        pub priority: pulumi_wasm_rust::Output<Option<i32>>,
        /// The zone identifier to target for the resource.
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct EmailRoutingRuleResult {
        /// Actions to take when a match is found.
        pub actions: pulumi_wasm_rust::Output<
            Option<Vec<super::types::EmailRoutingRuleAction>>,
        >,
        /// Whether the email routing rule is enabled.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Matching patterns to forward to your actions.
        pub matchers: pulumi_wasm_rust::Output<
            Option<Vec<super::types::EmailRoutingRuleMatcher>>,
        >,
        /// Routing rule name.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The priority of the email routing rule.
        pub priority: pulumi_wasm_rust::Output<i32>,
        /// The tag of the email routing rule.
        pub tag: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: EmailRoutingRuleArgs) -> EmailRoutingRuleResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let actions_binding = args.actions.get_inner();
        let enabled_binding = args.enabled.get_inner();
        let matchers_binding = args.matchers.get_inner();
        let name_binding = args.name.get_inner();
        let priority_binding = args.priority.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/emailRoutingRule:EmailRoutingRule".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "actions".into(),
                    value: &actions_binding,
                },
                register_interface::ObjectField {
                    name: "enabled".into(),
                    value: &enabled_binding,
                },
                register_interface::ObjectField {
                    name: "matchers".into(),
                    value: &matchers_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "priority".into(),
                    value: &priority_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "actions".into(),
                },
                register_interface::ResultField {
                    name: "enabled".into(),
                },
                register_interface::ResultField {
                    name: "matchers".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "priority".into(),
                },
                register_interface::ResultField {
                    name: "tag".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        EmailRoutingRuleResult {
            actions: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("actions").unwrap(),
            ),
            enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enabled").unwrap(),
            ),
            matchers: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("matchers").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            priority: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("priority").unwrap(),
            ),
            tag: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tag").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod email_routing_settings {
    //! Provides a resource for managing Email Routing settings.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   myZone:
    //!     type: cloudflare:EmailRoutingSettings
    //!     name: my_zone
    //!     properties:
    //!       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
    //!       enabled: 'true'
    //! ```
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct EmailRoutingSettingsArgs {
        /// State of the zone settings for Email Routing. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// Flag to check if the user skipped the configuration wizard.
        #[builder(into, default)]
        pub skip_wizard: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct EmailRoutingSettingsResult {
        /// The date and time the settings have been created.
        pub created: pulumi_wasm_rust::Output<String>,
        /// State of the zone settings for Email Routing. **Modifying this attribute will force creation of a new resource.**
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The date and time the settings have been modified.
        pub modified: pulumi_wasm_rust::Output<String>,
        /// Domain of your zone.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Flag to check if the user skipped the configuration wizard.
        pub skip_wizard: pulumi_wasm_rust::Output<bool>,
        /// Show the state of your account, and the type or configuration error.
        pub status: pulumi_wasm_rust::Output<String>,
        /// Email Routing settings identifier.
        pub tag: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: EmailRoutingSettingsArgs,
    ) -> EmailRoutingSettingsResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let enabled_binding = args.enabled.get_inner();
        let skip_wizard_binding = args.skip_wizard.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/emailRoutingSettings:EmailRoutingSettings".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "enabled".into(),
                    value: &enabled_binding,
                },
                register_interface::ObjectField {
                    name: "skipWizard".into(),
                    value: &skip_wizard_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "created".into(),
                },
                register_interface::ResultField {
                    name: "enabled".into(),
                },
                register_interface::ResultField {
                    name: "modified".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "skipWizard".into(),
                },
                register_interface::ResultField {
                    name: "status".into(),
                },
                register_interface::ResultField {
                    name: "tag".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        EmailRoutingSettingsResult {
            created: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("created").unwrap(),
            ),
            enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enabled").unwrap(),
            ),
            modified: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("modified").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            skip_wizard: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("skipWizard").unwrap(),
            ),
            status: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("status").unwrap(),
            ),
            tag: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tag").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod fallback_domain {
    //! Provides a Cloudflare Fallback Domain resource. Fallback domains are
    //! used to ignore DNS requests to a given list of domains. These DNS
    //! requests will be passed back to other DNS servers configured on
    //! existing network interfaces on the device.
    //!
    //! ## Import
    //!
    //! Fallback Domains for default device policies must use "default" as the policy ID.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/fallbackDomain:FallbackDomain example <account_id>/<policy_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct FallbackDomainArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        #[builder(into)]
        pub domains: pulumi_wasm_rust::Output<Vec<super::types::FallbackDomainDomain>>,
        /// The settings policy for which to configure this fallback domain policy.
        #[builder(into, default)]
        pub policy_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct FallbackDomainResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        pub domains: pulumi_wasm_rust::Output<Vec<super::types::FallbackDomainDomain>>,
        /// The settings policy for which to configure this fallback domain policy.
        pub policy_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: FallbackDomainArgs) -> FallbackDomainResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let domains_binding = args.domains.get_inner();
        let policy_id_binding = args.policy_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/fallbackDomain:FallbackDomain".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "domains".into(),
                    value: &domains_binding,
                },
                register_interface::ObjectField {
                    name: "policyId".into(),
                    value: &policy_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "domains".into(),
                },
                register_interface::ResultField {
                    name: "policyId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        FallbackDomainResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            domains: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("domains").unwrap(),
            ),
            policy_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("policyId").unwrap(),
            ),
        }
    }
}
pub mod filter {
    //! Filter expressions that can be referenced across multiple features,
    //! e.g. Firewall Rules. See [what is a filter](https://developers.cloudflare.com/firewall/api/cf-filters/what-is-a-filter/)
    //! for more details and available fields and operators.
    //!
    //! > `cloudflare.Filter` is in a deprecation phase until January 15th, 2025.
    //!   During this time period, this resource is still fully
    //!   supported but you are strongly advised to move to the
    //!   `cloudflare.Ruleset` resource. Full details can be found in the
    //!   developer documentation.
    //!
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let wordpress = filter::create(
    //!         "wordpress",
    //!         FilterArgs::builder()
    //!             .description("Wordpress break-in attempts that are outside of the office")
    //!             .expression(
    //!                 "(http.request.uri.path ~ \".*wp-login.php\" or http.request.uri.path ~ \".*xmlrpc.php\") and ip.src ne 192.0.2.1",
    //!             )
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/filter:Filter example <zone_id>/<filter_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct FilterArgs {
        /// A note that you can use to describe the purpose of the filter.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The filter expression to be used.
        #[builder(into)]
        pub expression: pulumi_wasm_rust::Output<String>,
        /// Whether this filter is currently paused.
        #[builder(into, default)]
        pub paused: pulumi_wasm_rust::Output<Option<bool>>,
        /// Short reference tag to quickly select related rules.
        #[builder(into, default)]
        pub ref_: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct FilterResult {
        /// A note that you can use to describe the purpose of the filter.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The filter expression to be used.
        pub expression: pulumi_wasm_rust::Output<String>,
        /// Whether this filter is currently paused.
        pub paused: pulumi_wasm_rust::Output<Option<bool>>,
        /// Short reference tag to quickly select related rules.
        pub ref_: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: FilterArgs) -> FilterResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let description_binding = args.description.get_inner();
        let expression_binding = args.expression.get_inner();
        let paused_binding = args.paused.get_inner();
        let ref__binding = args.ref_.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/filter:Filter".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "expression".into(),
                    value: &expression_binding,
                },
                register_interface::ObjectField {
                    name: "paused".into(),
                    value: &paused_binding,
                },
                register_interface::ObjectField {
                    name: "ref".into(),
                    value: &ref__binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "expression".into(),
                },
                register_interface::ResultField {
                    name: "paused".into(),
                },
                register_interface::ResultField {
                    name: "ref".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        FilterResult {
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            expression: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("expression").unwrap(),
            ),
            paused: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("paused").unwrap(),
            ),
            ref_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("ref").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod firewall_rule {
    //! Define Firewall rules using filter expressions for more control over
    //! how traffic is matched to the rule. A filter expression permits
    //! selecting traffic by multiple criteria allowing greater freedom in
    //! rule creation.
    //!
    //! Filter expressions needs to be created first before using Firewall
    //! Rule.
    //!
    //! > `cloudflare.FirewallRule` is in a deprecation phase until January 15th, 2025.
    //!   During this time period, this resource is still
    //!   fully supported but you are strongly advised  to move to the
    //!   `cloudflare.Ruleset` resource. Full details can be found in the
    //!   developer documentation.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let wordpress = filter::create(
    //!         "wordpress",
    //!         FilterArgs::builder()
    //!             .description("Wordpress break-in attempts that are outside of the office")
    //!             .expression(
    //!                 "(http.request.uri.path ~ \".*wp-login.php\" or http.request.uri.path ~ \".*xmlrpc.php\") and ip.src ne 192.0.2.1",
    //!             )
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //!     let wordpressFirewallRule = firewall_rule::create(
    //!         "wordpressFirewallRule",
    //!         FirewallRuleArgs::builder()
    //!             .action("block")
    //!             .description("Block wordpress break-in attempts")
    //!             .filter_id("${wordpress.id}")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/firewallRule:FirewallRule example <zone_id>/<firewall_rule_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct FirewallRuleArgs {
        /// The action to apply to a matched request. Available values: `block`, `challenge`, `allow`, `js_challenge`, `managed_challenge`, `log`, `bypass`.
        #[builder(into)]
        pub action: pulumi_wasm_rust::Output<String>,
        /// A description of the rule to help identify it.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The identifier of the Filter to use for determining if the Firewall Rule should be triggered.
        #[builder(into)]
        pub filter_id: pulumi_wasm_rust::Output<String>,
        /// Whether this filter based firewall rule is currently paused.
        #[builder(into, default)]
        pub paused: pulumi_wasm_rust::Output<Option<bool>>,
        /// The priority of the rule to allow control of processing order. A lower number indicates high priority. If not provided, any rules with a priority will be sequenced before those without.
        #[builder(into, default)]
        pub priority: pulumi_wasm_rust::Output<Option<i32>>,
        /// List of products to bypass for a request when the bypass action is used. Available values: `zoneLockdown`, `uaBlock`, `bic`, `hot`, `securityLevel`, `rateLimit`, `waf`.
        #[builder(into, default)]
        pub products: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct FirewallRuleResult {
        /// The action to apply to a matched request. Available values: `block`, `challenge`, `allow`, `js_challenge`, `managed_challenge`, `log`, `bypass`.
        pub action: pulumi_wasm_rust::Output<String>,
        /// A description of the rule to help identify it.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The identifier of the Filter to use for determining if the Firewall Rule should be triggered.
        pub filter_id: pulumi_wasm_rust::Output<String>,
        /// Whether this filter based firewall rule is currently paused.
        pub paused: pulumi_wasm_rust::Output<Option<bool>>,
        /// The priority of the rule to allow control of processing order. A lower number indicates high priority. If not provided, any rules with a priority will be sequenced before those without.
        pub priority: pulumi_wasm_rust::Output<Option<i32>>,
        /// List of products to bypass for a request when the bypass action is used. Available values: `zoneLockdown`, `uaBlock`, `bic`, `hot`, `securityLevel`, `rateLimit`, `waf`.
        pub products: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: FirewallRuleArgs) -> FirewallRuleResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let action_binding = args.action.get_inner();
        let description_binding = args.description.get_inner();
        let filter_id_binding = args.filter_id.get_inner();
        let paused_binding = args.paused.get_inner();
        let priority_binding = args.priority.get_inner();
        let products_binding = args.products.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/firewallRule:FirewallRule".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "action".into(),
                    value: &action_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "filterId".into(),
                    value: &filter_id_binding,
                },
                register_interface::ObjectField {
                    name: "paused".into(),
                    value: &paused_binding,
                },
                register_interface::ObjectField {
                    name: "priority".into(),
                    value: &priority_binding,
                },
                register_interface::ObjectField {
                    name: "products".into(),
                    value: &products_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "action".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "filterId".into(),
                },
                register_interface::ResultField {
                    name: "paused".into(),
                },
                register_interface::ResultField {
                    name: "priority".into(),
                },
                register_interface::ResultField {
                    name: "products".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        FirewallRuleResult {
            action: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("action").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            filter_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("filterId").unwrap(),
            ),
            paused: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("paused").unwrap(),
            ),
            priority: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("priority").unwrap(),
            ),
            products: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("products").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod gre_tunnel {
    //! Provides a resource, that manages GRE tunnels for Magic Transit.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = gre_tunnel::create(
    //!         "example",
    //!         GreTunnelArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .cloudflare_gre_endpoint("203.0.113.2")
    //!             .customer_gre_endpoint("203.0.113.1")
    //!             .description("Tunnel for ISP X")
    //!             .health_check_enabled(true)
    //!             .health_check_target("203.0.113.1")
    //!             .health_check_type("reply")
    //!             .interface_address("192.0.2.0/31")
    //!             .mtu(1476)
    //!             .name("GRE_1")
    //!             .ttl(64)
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/greTunnel:GreTunnel example <account_id>/<tunnel_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct GreTunnelArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The IP address assigned to the Cloudflare side of the GRE tunnel.
        #[builder(into)]
        pub cloudflare_gre_endpoint: pulumi_wasm_rust::Output<String>,
        /// The IP address assigned to the customer side of the GRE tunnel.
        #[builder(into)]
        pub customer_gre_endpoint: pulumi_wasm_rust::Output<String>,
        /// Description of the GRE tunnel intent.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies if ICMP tunnel health checks are enabled.
        #[builder(into, default)]
        pub health_check_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The IP address of the customer endpoint that will receive tunnel health checks.
        #[builder(into, default)]
        pub health_check_target: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies the ICMP echo type for the health check. Available values: `request`, `reply`.
        #[builder(into, default)]
        pub health_check_type: pulumi_wasm_rust::Output<Option<String>>,
        /// 31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.
        #[builder(into)]
        pub interface_address: pulumi_wasm_rust::Output<String>,
        /// Maximum Transmission Unit (MTU) in bytes for the GRE tunnel.
        #[builder(into, default)]
        pub mtu: pulumi_wasm_rust::Output<Option<i32>>,
        /// Name of the GRE tunnel.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// Time To Live (TTL) in number of hops of the GRE tunnel.
        #[builder(into, default)]
        pub ttl: pulumi_wasm_rust::Output<Option<i32>>,
    }
    #[allow(dead_code)]
    pub struct GreTunnelResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The IP address assigned to the Cloudflare side of the GRE tunnel.
        pub cloudflare_gre_endpoint: pulumi_wasm_rust::Output<String>,
        /// The IP address assigned to the customer side of the GRE tunnel.
        pub customer_gre_endpoint: pulumi_wasm_rust::Output<String>,
        /// Description of the GRE tunnel intent.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies if ICMP tunnel health checks are enabled.
        pub health_check_enabled: pulumi_wasm_rust::Output<bool>,
        /// The IP address of the customer endpoint that will receive tunnel health checks.
        pub health_check_target: pulumi_wasm_rust::Output<String>,
        /// Specifies the ICMP echo type for the health check. Available values: `request`, `reply`.
        pub health_check_type: pulumi_wasm_rust::Output<String>,
        /// 31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.
        pub interface_address: pulumi_wasm_rust::Output<String>,
        /// Maximum Transmission Unit (MTU) in bytes for the GRE tunnel.
        pub mtu: pulumi_wasm_rust::Output<i32>,
        /// Name of the GRE tunnel.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Time To Live (TTL) in number of hops of the GRE tunnel.
        pub ttl: pulumi_wasm_rust::Output<i32>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: GreTunnelArgs) -> GreTunnelResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let cloudflare_gre_endpoint_binding = args.cloudflare_gre_endpoint.get_inner();
        let customer_gre_endpoint_binding = args.customer_gre_endpoint.get_inner();
        let description_binding = args.description.get_inner();
        let health_check_enabled_binding = args.health_check_enabled.get_inner();
        let health_check_target_binding = args.health_check_target.get_inner();
        let health_check_type_binding = args.health_check_type.get_inner();
        let interface_address_binding = args.interface_address.get_inner();
        let mtu_binding = args.mtu.get_inner();
        let name_binding = args.name.get_inner();
        let ttl_binding = args.ttl.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/greTunnel:GreTunnel".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "cloudflareGreEndpoint".into(),
                    value: &cloudflare_gre_endpoint_binding,
                },
                register_interface::ObjectField {
                    name: "customerGreEndpoint".into(),
                    value: &customer_gre_endpoint_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "healthCheckEnabled".into(),
                    value: &health_check_enabled_binding,
                },
                register_interface::ObjectField {
                    name: "healthCheckTarget".into(),
                    value: &health_check_target_binding,
                },
                register_interface::ObjectField {
                    name: "healthCheckType".into(),
                    value: &health_check_type_binding,
                },
                register_interface::ObjectField {
                    name: "interfaceAddress".into(),
                    value: &interface_address_binding,
                },
                register_interface::ObjectField {
                    name: "mtu".into(),
                    value: &mtu_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "ttl".into(),
                    value: &ttl_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "cloudflareGreEndpoint".into(),
                },
                register_interface::ResultField {
                    name: "customerGreEndpoint".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "healthCheckEnabled".into(),
                },
                register_interface::ResultField {
                    name: "healthCheckTarget".into(),
                },
                register_interface::ResultField {
                    name: "healthCheckType".into(),
                },
                register_interface::ResultField {
                    name: "interfaceAddress".into(),
                },
                register_interface::ResultField {
                    name: "mtu".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "ttl".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        GreTunnelResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            cloudflare_gre_endpoint: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("cloudflareGreEndpoint").unwrap(),
            ),
            customer_gre_endpoint: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customerGreEndpoint").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            health_check_enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("healthCheckEnabled").unwrap(),
            ),
            health_check_target: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("healthCheckTarget").unwrap(),
            ),
            health_check_type: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("healthCheckType").unwrap(),
            ),
            interface_address: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("interfaceAddress").unwrap(),
            ),
            mtu: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("mtu").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            ttl: pulumi_wasm_rust::__private::into_domain(hashmap.remove("ttl").unwrap()),
        }
    }
}
pub mod healthcheck {
    //! Standalone Health Checks provide a way to monitor origin servers
    //! without needing a Cloudflare Load Balancer.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let httpHealthCheck = healthcheck::create(
    //!         "httpHealthCheck",
    //!         HealthcheckArgs::builder()
    //!             .address("example.com")
    //!             .allow_insecure(false)
    //!             .check_regions(vec!["WEU", "EEU",])
    //!             .consecutive_fails(3)
    //!             .consecutive_successes(2)
    //!             .description("example http health check")
    //!             .expected_body("alive")
    //!             .expected_codes(vec!["2xx", "301",])
    //!             .follow_redirects(true)
    //!             .headers(
    //!                 vec![
    //!                     HealthcheckHeader::builder().header("Host")
    //!                     .values(vec!["example.com",]).build_struct(),
    //!                 ],
    //!             )
    //!             .interval(60)
    //!             .method("GET")
    //!             .name("http-health-check")
    //!             .path("/health")
    //!             .port(443)
    //!             .retries(2)
    //!             .suspended(false)
    //!             .timeout(10)
    //!             .type_("HTTPS")
    //!             .zone_id("${cloudflareZoneId}")
    //!             .build_struct(),
    //!     );
    //!     let tcpHealthCheck = healthcheck::create(
    //!         "tcpHealthCheck",
    //!         HealthcheckArgs::builder()
    //!             .address("example.com")
    //!             .check_regions(vec!["WEU", "EEU",])
    //!             .consecutive_fails(3)
    //!             .consecutive_successes(2)
    //!             .description("example tcp health check")
    //!             .interval(60)
    //!             .method("connection_established")
    //!             .name("tcp-health-check")
    //!             .port(22)
    //!             .retries(2)
    //!             .suspended(false)
    //!             .timeout(10)
    //!             .type_("TCP")
    //!             .zone_id("${cloudflareZoneId}")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! Use the Zone ID and Healthcheck ID to import.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/healthcheck:Healthcheck example <zone_id>/<healthcheck_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct HealthcheckArgs {
        /// The hostname or IP address of the origin server to run health checks on.
        #[builder(into)]
        pub address: pulumi_wasm_rust::Output<String>,
        /// Do not validate the certificate when the health check uses HTTPS. Defaults to `false`.
        #[builder(into, default)]
        pub allow_insecure: pulumi_wasm_rust::Output<Option<bool>>,
        /// A list of regions from which to run health checks. If not set, Cloudflare will pick a default region. Available values: `WNAM`, `ENAM`, `WEU`, `EEU`, `NSAM`, `SSAM`, `OC`, `ME`, `NAF`, `SAF`, `IN`, `SEAS`, `NEAS`, `ALL_REGIONS`.
        #[builder(into, default)]
        pub check_regions: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The number of consecutive fails required from a health check before changing the health to unhealthy. Defaults to `1`.
        #[builder(into, default)]
        pub consecutive_fails: pulumi_wasm_rust::Output<Option<i32>>,
        /// The number of consecutive successes required from a health check before changing the health to healthy. Defaults to `1`.
        #[builder(into, default)]
        pub consecutive_successes: pulumi_wasm_rust::Output<Option<i32>>,
        /// A human-readable description of the health check.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// A case-insensitive sub-string to look for in the response body. If this string is not found the origin will be marked as unhealthy.
        #[builder(into, default)]
        pub expected_body: pulumi_wasm_rust::Output<Option<String>>,
        /// The expected HTTP response codes (e.g. '200') or code ranges (e.g. '2xx' for all codes starting with 2) of the health check.
        #[builder(into, default)]
        pub expected_codes: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Follow redirects if the origin returns a 3xx status code. Defaults to `false`.
        #[builder(into, default)]
        pub follow_redirects: pulumi_wasm_rust::Output<Option<bool>>,
        /// The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
        #[builder(into, default)]
        pub headers: pulumi_wasm_rust::Output<
            Option<Vec<super::types::HealthcheckHeader>>,
        >,
        /// The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase the load on the origin as we check from multiple locations. Defaults to `60`.
        #[builder(into, default)]
        pub interval: pulumi_wasm_rust::Output<Option<i32>>,
        /// The HTTP method to use for the health check. Available values: `connection_established`, `GET`, `HEAD`.
        #[builder(into, default)]
        pub method: pulumi_wasm_rust::Output<Option<String>>,
        /// A short name to identify the health check. Only alphanumeric characters, hyphens, and underscores are allowed.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The endpoint path to health check against. Defaults to `/`.
        #[builder(into, default)]
        pub path: pulumi_wasm_rust::Output<Option<String>>,
        /// Port number to connect to for the health check. Defaults to `80`.
        #[builder(into, default)]
        pub port: pulumi_wasm_rust::Output<Option<i32>>,
        /// The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Defaults to `2`.
        #[builder(into, default)]
        pub retries: pulumi_wasm_rust::Output<Option<i32>>,
        /// If suspended, no health checks are sent to the origin. Defaults to `false`.
        #[builder(into, default)]
        pub suspended: pulumi_wasm_rust::Output<Option<bool>>,
        /// The timeout (in seconds) before marking the health check as failed. Defaults to `5`.
        #[builder(into, default)]
        pub timeout: pulumi_wasm_rust::Output<Option<i32>>,
        /// The protocol to use for the health check. Available values: `TCP`, `HTTP`, `HTTPS`.
        #[builder(into)]
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct HealthcheckResult {
        /// The hostname or IP address of the origin server to run health checks on.
        pub address: pulumi_wasm_rust::Output<String>,
        /// Do not validate the certificate when the health check uses HTTPS. Defaults to `false`.
        pub allow_insecure: pulumi_wasm_rust::Output<Option<bool>>,
        /// A list of regions from which to run health checks. If not set, Cloudflare will pick a default region. Available values: `WNAM`, `ENAM`, `WEU`, `EEU`, `NSAM`, `SSAM`, `OC`, `ME`, `NAF`, `SAF`, `IN`, `SEAS`, `NEAS`, `ALL_REGIONS`.
        pub check_regions: pulumi_wasm_rust::Output<Vec<String>>,
        /// The number of consecutive fails required from a health check before changing the health to unhealthy. Defaults to `1`.
        pub consecutive_fails: pulumi_wasm_rust::Output<Option<i32>>,
        /// The number of consecutive successes required from a health check before changing the health to healthy. Defaults to `1`.
        pub consecutive_successes: pulumi_wasm_rust::Output<Option<i32>>,
        /// Creation time.
        pub created_on: pulumi_wasm_rust::Output<String>,
        /// A human-readable description of the health check.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// A case-insensitive sub-string to look for in the response body. If this string is not found the origin will be marked as unhealthy.
        pub expected_body: pulumi_wasm_rust::Output<Option<String>>,
        /// The expected HTTP response codes (e.g. '200') or code ranges (e.g. '2xx' for all codes starting with 2) of the health check.
        pub expected_codes: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Follow redirects if the origin returns a 3xx status code. Defaults to `false`.
        pub follow_redirects: pulumi_wasm_rust::Output<Option<bool>>,
        /// The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
        pub headers: pulumi_wasm_rust::Output<
            Option<Vec<super::types::HealthcheckHeader>>,
        >,
        /// The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase the load on the origin as we check from multiple locations. Defaults to `60`.
        pub interval: pulumi_wasm_rust::Output<Option<i32>>,
        /// The HTTP method to use for the health check. Available values: `connection_established`, `GET`, `HEAD`.
        pub method: pulumi_wasm_rust::Output<String>,
        /// Last modified time.
        pub modified_on: pulumi_wasm_rust::Output<String>,
        /// A short name to identify the health check. Only alphanumeric characters, hyphens, and underscores are allowed.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The endpoint path to health check against. Defaults to `/`.
        pub path: pulumi_wasm_rust::Output<Option<String>>,
        /// Port number to connect to for the health check. Defaults to `80`.
        pub port: pulumi_wasm_rust::Output<Option<i32>>,
        /// The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Defaults to `2`.
        pub retries: pulumi_wasm_rust::Output<Option<i32>>,
        /// If suspended, no health checks are sent to the origin. Defaults to `false`.
        pub suspended: pulumi_wasm_rust::Output<Option<bool>>,
        /// The timeout (in seconds) before marking the health check as failed. Defaults to `5`.
        pub timeout: pulumi_wasm_rust::Output<Option<i32>>,
        /// The protocol to use for the health check. Available values: `TCP`, `HTTP`, `HTTPS`.
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: HealthcheckArgs) -> HealthcheckResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let address_binding = args.address.get_inner();
        let allow_insecure_binding = args.allow_insecure.get_inner();
        let check_regions_binding = args.check_regions.get_inner();
        let consecutive_fails_binding = args.consecutive_fails.get_inner();
        let consecutive_successes_binding = args.consecutive_successes.get_inner();
        let description_binding = args.description.get_inner();
        let expected_body_binding = args.expected_body.get_inner();
        let expected_codes_binding = args.expected_codes.get_inner();
        let follow_redirects_binding = args.follow_redirects.get_inner();
        let headers_binding = args.headers.get_inner();
        let interval_binding = args.interval.get_inner();
        let method_binding = args.method.get_inner();
        let name_binding = args.name.get_inner();
        let path_binding = args.path.get_inner();
        let port_binding = args.port.get_inner();
        let retries_binding = args.retries.get_inner();
        let suspended_binding = args.suspended.get_inner();
        let timeout_binding = args.timeout.get_inner();
        let type__binding = args.type_.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/healthcheck:Healthcheck".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "address".into(),
                    value: &address_binding,
                },
                register_interface::ObjectField {
                    name: "allowInsecure".into(),
                    value: &allow_insecure_binding,
                },
                register_interface::ObjectField {
                    name: "checkRegions".into(),
                    value: &check_regions_binding,
                },
                register_interface::ObjectField {
                    name: "consecutiveFails".into(),
                    value: &consecutive_fails_binding,
                },
                register_interface::ObjectField {
                    name: "consecutiveSuccesses".into(),
                    value: &consecutive_successes_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "expectedBody".into(),
                    value: &expected_body_binding,
                },
                register_interface::ObjectField {
                    name: "expectedCodes".into(),
                    value: &expected_codes_binding,
                },
                register_interface::ObjectField {
                    name: "followRedirects".into(),
                    value: &follow_redirects_binding,
                },
                register_interface::ObjectField {
                    name: "headers".into(),
                    value: &headers_binding,
                },
                register_interface::ObjectField {
                    name: "interval".into(),
                    value: &interval_binding,
                },
                register_interface::ObjectField {
                    name: "method".into(),
                    value: &method_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "path".into(),
                    value: &path_binding,
                },
                register_interface::ObjectField {
                    name: "port".into(),
                    value: &port_binding,
                },
                register_interface::ObjectField {
                    name: "retries".into(),
                    value: &retries_binding,
                },
                register_interface::ObjectField {
                    name: "suspended".into(),
                    value: &suspended_binding,
                },
                register_interface::ObjectField {
                    name: "timeout".into(),
                    value: &timeout_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "address".into(),
                },
                register_interface::ResultField {
                    name: "allowInsecure".into(),
                },
                register_interface::ResultField {
                    name: "checkRegions".into(),
                },
                register_interface::ResultField {
                    name: "consecutiveFails".into(),
                },
                register_interface::ResultField {
                    name: "consecutiveSuccesses".into(),
                },
                register_interface::ResultField {
                    name: "createdOn".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "expectedBody".into(),
                },
                register_interface::ResultField {
                    name: "expectedCodes".into(),
                },
                register_interface::ResultField {
                    name: "followRedirects".into(),
                },
                register_interface::ResultField {
                    name: "headers".into(),
                },
                register_interface::ResultField {
                    name: "interval".into(),
                },
                register_interface::ResultField {
                    name: "method".into(),
                },
                register_interface::ResultField {
                    name: "modifiedOn".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "path".into(),
                },
                register_interface::ResultField {
                    name: "port".into(),
                },
                register_interface::ResultField {
                    name: "retries".into(),
                },
                register_interface::ResultField {
                    name: "suspended".into(),
                },
                register_interface::ResultField {
                    name: "timeout".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        HealthcheckResult {
            address: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("address").unwrap(),
            ),
            allow_insecure: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("allowInsecure").unwrap(),
            ),
            check_regions: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("checkRegions").unwrap(),
            ),
            consecutive_fails: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("consecutiveFails").unwrap(),
            ),
            consecutive_successes: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("consecutiveSuccesses").unwrap(),
            ),
            created_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("createdOn").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            expected_body: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("expectedBody").unwrap(),
            ),
            expected_codes: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("expectedCodes").unwrap(),
            ),
            follow_redirects: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("followRedirects").unwrap(),
            ),
            headers: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("headers").unwrap(),
            ),
            interval: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("interval").unwrap(),
            ),
            method: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("method").unwrap(),
            ),
            modified_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("modifiedOn").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            path: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("path").unwrap(),
            ),
            port: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("port").unwrap(),
            ),
            retries: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("retries").unwrap(),
            ),
            suspended: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("suspended").unwrap(),
            ),
            timeout: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("timeout").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod hostname_tls_setting {
    //! Provides a Cloudflare per-hostname TLS setting resource. Used to set TLS settings for hostnames under the specified zone.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = hostname_tls_setting::create(
    //!         "example",
    //!         HostnameTlsSettingArgs::builder()
    //!             .hostname("sub.example.com")
    //!             .setting("min_tls_version")
    //!             .value("1.2")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/hostnameTlsSetting:HostnameTlsSetting example <zone_id>/<hostname>/<setting_name>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct HostnameTlsSettingArgs {
        /// Hostname that belongs to this zone name. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// TLS setting name. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub setting: pulumi_wasm_rust::Output<String>,
        /// TLS setting value.
        #[builder(into)]
        pub value: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct HostnameTlsSettingResult {
        pub created_at: pulumi_wasm_rust::Output<String>,
        /// Hostname that belongs to this zone name. **Modifying this attribute will force creation of a new resource.**
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// TLS setting name. **Modifying this attribute will force creation of a new resource.**
        pub setting: pulumi_wasm_rust::Output<String>,
        pub updated_at: pulumi_wasm_rust::Output<String>,
        /// TLS setting value.
        pub value: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: HostnameTlsSettingArgs) -> HostnameTlsSettingResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let hostname_binding = args.hostname.get_inner();
        let setting_binding = args.setting.get_inner();
        let value_binding = args.value.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/hostnameTlsSetting:HostnameTlsSetting".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "hostname".into(),
                    value: &hostname_binding,
                },
                register_interface::ObjectField {
                    name: "setting".into(),
                    value: &setting_binding,
                },
                register_interface::ObjectField {
                    name: "value".into(),
                    value: &value_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "createdAt".into(),
                },
                register_interface::ResultField {
                    name: "hostname".into(),
                },
                register_interface::ResultField {
                    name: "setting".into(),
                },
                register_interface::ResultField {
                    name: "updatedAt".into(),
                },
                register_interface::ResultField {
                    name: "value".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        HostnameTlsSettingResult {
            created_at: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("createdAt").unwrap(),
            ),
            hostname: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("hostname").unwrap(),
            ),
            setting: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("setting").unwrap(),
            ),
            updated_at: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("updatedAt").unwrap(),
            ),
            value: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("value").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod hostname_tls_setting_ciphers {
    //! Provides a Cloudflare per-hostname TLS setting resource, specifically for ciphers suites. Used to set ciphers suites for hostnames under the specified zone.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = hostname_tls_setting_ciphers::create(
    //!         "example",
    //!         HostnameTlsSettingCiphersArgs::builder()
    //!             .hostname("sub.example.com")
    //!             .values(vec!["ECDHE-RSA-AES128-GCM-SHA256",])
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/hostnameTlsSettingCiphers:HostnameTlsSettingCiphers example <zone_id>/<hostname>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct HostnameTlsSettingCiphersArgs {
        /// Hostname that belongs to this zone name. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// Ports to use within the IP rule.
        #[builder(into, default)]
        pub ports: pulumi_wasm_rust::Output<Option<Vec<i32>>>,
        /// Ciphers suites value.
        #[builder(into)]
        pub values: pulumi_wasm_rust::Output<Vec<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct HostnameTlsSettingCiphersResult {
        pub created_at: pulumi_wasm_rust::Output<String>,
        /// Hostname that belongs to this zone name. **Modifying this attribute will force creation of a new resource.**
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// Ports to use within the IP rule.
        pub ports: pulumi_wasm_rust::Output<Option<Vec<i32>>>,
        pub updated_at: pulumi_wasm_rust::Output<String>,
        /// Ciphers suites value.
        pub values: pulumi_wasm_rust::Output<Vec<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: HostnameTlsSettingCiphersArgs,
    ) -> HostnameTlsSettingCiphersResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let hostname_binding = args.hostname.get_inner();
        let ports_binding = args.ports.get_inner();
        let values_binding = args.values.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/hostnameTlsSettingCiphers:HostnameTlsSettingCiphers"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "hostname".into(),
                    value: &hostname_binding,
                },
                register_interface::ObjectField {
                    name: "ports".into(),
                    value: &ports_binding,
                },
                register_interface::ObjectField {
                    name: "values".into(),
                    value: &values_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "createdAt".into(),
                },
                register_interface::ResultField {
                    name: "hostname".into(),
                },
                register_interface::ResultField {
                    name: "ports".into(),
                },
                register_interface::ResultField {
                    name: "updatedAt".into(),
                },
                register_interface::ResultField {
                    name: "values".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        HostnameTlsSettingCiphersResult {
            created_at: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("createdAt").unwrap(),
            ),
            hostname: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("hostname").unwrap(),
            ),
            ports: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("ports").unwrap(),
            ),
            updated_at: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("updatedAt").unwrap(),
            ),
            values: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("values").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod hyperdrive_config {
    //! The [Hyperdrive Config](https://developers.cloudflare.com/hyperdrive/) resource allows you to manage Cloudflare Hyperdrive Configs.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let noDefaults = hyperdrive_config::create(
    //!         "noDefaults",
    //!         HyperdriveConfigArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .name("my-hyperdrive-config")
    //!             .origin(
    //!                 HyperdriveConfigOrigin::builder()
    //!                     .database("postgres")
    //!                     .host("my-database.example.com")
    //!                     .password("my-password")
    //!                     .port(5432)
    //!                     .scheme("postgres")
    //!                     .user("my-user")
    //!                     .build_struct(),
    //!             )
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/hyperdriveConfig:HyperdriveConfig example <account_id>/<hyperdrive_config_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct HyperdriveConfigArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The caching details for the Hyperdrive configuration.
        #[builder(into, default)]
        pub caching: pulumi_wasm_rust::Output<
            Option<super::types::HyperdriveConfigCaching>,
        >,
        /// The name of the Hyperdrive configuration.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The origin details for the Hyperdrive configuration.
        #[builder(into)]
        pub origin: pulumi_wasm_rust::Output<super::types::HyperdriveConfigOrigin>,
        /// The identifier of this resource. This is the hyperdrive config value.
        #[builder(into, default)]
        pub resource_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct HyperdriveConfigResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The caching details for the Hyperdrive configuration.
        pub caching: pulumi_wasm_rust::Output<super::types::HyperdriveConfigCaching>,
        /// The name of the Hyperdrive configuration.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The origin details for the Hyperdrive configuration.
        pub origin: pulumi_wasm_rust::Output<super::types::HyperdriveConfigOrigin>,
        /// The identifier of this resource. This is the hyperdrive config value.
        pub resource_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: HyperdriveConfigArgs) -> HyperdriveConfigResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let caching_binding = args.caching.get_inner();
        let name_binding = args.name.get_inner();
        let origin_binding = args.origin.get_inner();
        let resource_id_binding = args.resource_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/hyperdriveConfig:HyperdriveConfig".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "caching".into(),
                    value: &caching_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "origin".into(),
                    value: &origin_binding,
                },
                register_interface::ObjectField {
                    name: "resourceId".into(),
                    value: &resource_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "caching".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "origin".into(),
                },
                register_interface::ResultField {
                    name: "resourceId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        HyperdriveConfigResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            caching: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("caching").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            origin: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("origin").unwrap(),
            ),
            resource_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("resourceId").unwrap(),
            ),
        }
    }
}
pub mod infrastructure_access_target {
    //! The [Infrastructure Access Target](https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/use-cases/ssh/ssh-infrastructure-access/#4-add-a-target) resource allows you to configure Infrastructure Access Targets for an account.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = infrastructure_access_target::create(
    //!         "example",
    //!         InfrastructureAccessTargetArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .hostname("example-target")
    //!             .ip(
    //!                 InfrastructureAccessTargetIp::builder()
    //!                     .ipv4(
    //!                         InfrastructureAccessTargetIpIpv4::builder()
    //!                             .ipAddr("198.51.100.1")
    //!                             .virtualNetworkId("238dccd1-149b-463d-8228-560ab83a54fd")
    //!                             .build_struct(),
    //!                     )
    //!                     .ipv6(
    //!                         InfrastructureAccessTargetIpIpv6::builder()
    //!                             .ipAddr("2001:db8::")
    //!                             .virtualNetworkId("238dccd1-149b-463d-8228-560ab83a54fd")
    //!                             .build_struct(),
    //!                     )
    //!                     .build_struct(),
    //!             )
    //!             .build_struct(),
    //!     );
    //!     let ipv4OnlyExample = infrastructure_access_target::create(
    //!         "ipv4OnlyExample",
    //!         InfrastructureAccessTargetArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .hostname("example-ipv4-only")
    //!             .ip(
    //!                 InfrastructureAccessTargetIp::builder()
    //!                     .ipv4(
    //!                         InfrastructureAccessTargetIpIpv4::builder()
    //!                             .ipAddr("198.51.100.1")
    //!                             .virtualNetworkId("238dccd1-149b-463d-8228-560ab83a54fd")
    //!                             .build_struct(),
    //!                     )
    //!                     .build_struct(),
    //!             )
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/infrastructureAccessTarget:InfrastructureAccessTarget example <account_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct InfrastructureAccessTargetArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// A non-unique field that refers to a target.
        #[builder(into)]
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// The IPv4/IPv6 address that identifies where to reach a target.
        #[builder(into)]
        pub ip: pulumi_wasm_rust::Output<super::types::InfrastructureAccessTargetIp>,
    }
    #[allow(dead_code)]
    pub struct InfrastructureAccessTargetResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The date and time at which the target was created.
        pub created_at: pulumi_wasm_rust::Output<String>,
        /// A non-unique field that refers to a target.
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// The IPv4/IPv6 address that identifies where to reach a target.
        pub ip: pulumi_wasm_rust::Output<super::types::InfrastructureAccessTargetIp>,
        /// The date and time at which the target was last modified.
        pub modified_at: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: InfrastructureAccessTargetArgs,
    ) -> InfrastructureAccessTargetResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let hostname_binding = args.hostname.get_inner();
        let ip_binding = args.ip.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/infrastructureAccessTarget:InfrastructureAccessTarget"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "hostname".into(),
                    value: &hostname_binding,
                },
                register_interface::ObjectField {
                    name: "ip".into(),
                    value: &ip_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "createdAt".into(),
                },
                register_interface::ResultField {
                    name: "hostname".into(),
                },
                register_interface::ResultField {
                    name: "ip".into(),
                },
                register_interface::ResultField {
                    name: "modifiedAt".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        InfrastructureAccessTargetResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            created_at: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("createdAt").unwrap(),
            ),
            hostname: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("hostname").unwrap(),
            ),
            ip: pulumi_wasm_rust::__private::into_domain(hashmap.remove("ip").unwrap()),
            modified_at: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("modifiedAt").unwrap(),
            ),
        }
    }
}
pub mod ipsec_tunnel {
    //! Provides a resource, that manages IPsec tunnels for Magic Transit.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = ipsec_tunnel::create(
    //!         "example",
    //!         IpsecTunnelArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .allow_null_cipher(false)
    //!             .cloudflare_endpoint("203.0.113.1")
    //!             .customer_endpoint("203.0.113.1")
    //!             .description("Tunnel for ISP X")
    //!             .health_check_enabled(true)
    //!             .health_check_target("203.0.113.1")
    //!             .health_check_type("reply")
    //!             .interface_address("192.0.2.0/31")
    //!             .name("IPsec_1")
    //!             .psk("asdf12341234")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/ipsecTunnel:IpsecTunnel example <account_id>/<tunnel_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct IpsecTunnelArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies if this tunnel may use a null cipher (ENCR_NULL) in Phase 2. Defaults to `false`.
        #[builder(into, default)]
        pub allow_null_cipher: pulumi_wasm_rust::Output<Option<bool>>,
        /// IP address assigned to the Cloudflare side of the IPsec tunnel.
        #[builder(into)]
        pub cloudflare_endpoint: pulumi_wasm_rust::Output<String>,
        /// IP address assigned to the customer side of the IPsec tunnel.
        #[builder(into)]
        pub customer_endpoint: pulumi_wasm_rust::Output<String>,
        /// An optional description of the IPsec tunnel.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// `remote_id` in the form of a fqdn. This value is generated by cloudflare.
        #[builder(into, default)]
        pub fqdn_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies the direction for the health check. Available values: `unidirectional`, `bidirectional` Default: `unidirectional`.
        #[builder(into, default)]
        pub health_check_direction: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies if ICMP tunnel health checks are enabled. Default: `true`.
        #[builder(into, default)]
        pub health_check_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Specifies the ICMP rate for the health check. Available values: `low`, `mid`, `high` Default: `mid`.
        #[builder(into, default)]
        pub health_check_rate: pulumi_wasm_rust::Output<Option<String>>,
        /// The IP address of the customer endpoint that will receive tunnel health checks. Default: `<customer_gre_endpoint>`.
        #[builder(into, default)]
        pub health_check_target: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies the ICMP echo type for the health check (`request` or `reply`). Available values: `request`, `reply` Default: `reply`.
        #[builder(into, default)]
        pub health_check_type: pulumi_wasm_rust::Output<Option<String>>,
        /// `remote_id` as a hex string. This value is generated by cloudflare.
        #[builder(into, default)]
        pub hex_id: pulumi_wasm_rust::Output<Option<String>>,
        /// 31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.
        #[builder(into)]
        pub interface_address: pulumi_wasm_rust::Output<String>,
        /// Name of the IPsec tunnel.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// Pre shared key to be used with the IPsec tunnel. If left unset, it will be autogenerated.
        #[builder(into, default)]
        pub psk: pulumi_wasm_rust::Output<Option<String>>,
        /// ID to be used while setting up the IPsec tunnel. This value is generated by cloudflare.
        #[builder(into, default)]
        pub remote_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies if replay protection is enabled. Defaults to `false`.
        #[builder(into, default)]
        pub replay_protection: pulumi_wasm_rust::Output<Option<bool>>,
        /// `remote_id` in the form of an email address. This value is generated by cloudflare.
        #[builder(into, default)]
        pub user_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct IpsecTunnelResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies if this tunnel may use a null cipher (ENCR_NULL) in Phase 2. Defaults to `false`.
        pub allow_null_cipher: pulumi_wasm_rust::Output<Option<bool>>,
        /// IP address assigned to the Cloudflare side of the IPsec tunnel.
        pub cloudflare_endpoint: pulumi_wasm_rust::Output<String>,
        /// IP address assigned to the customer side of the IPsec tunnel.
        pub customer_endpoint: pulumi_wasm_rust::Output<String>,
        /// An optional description of the IPsec tunnel.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// `remote_id` in the form of a fqdn. This value is generated by cloudflare.
        pub fqdn_id: pulumi_wasm_rust::Output<String>,
        /// Specifies the direction for the health check. Available values: `unidirectional`, `bidirectional` Default: `unidirectional`.
        pub health_check_direction: pulumi_wasm_rust::Output<String>,
        /// Specifies if ICMP tunnel health checks are enabled. Default: `true`.
        pub health_check_enabled: pulumi_wasm_rust::Output<bool>,
        /// Specifies the ICMP rate for the health check. Available values: `low`, `mid`, `high` Default: `mid`.
        pub health_check_rate: pulumi_wasm_rust::Output<String>,
        /// The IP address of the customer endpoint that will receive tunnel health checks. Default: `<customer_gre_endpoint>`.
        pub health_check_target: pulumi_wasm_rust::Output<String>,
        /// Specifies the ICMP echo type for the health check (`request` or `reply`). Available values: `request`, `reply` Default: `reply`.
        pub health_check_type: pulumi_wasm_rust::Output<String>,
        /// `remote_id` as a hex string. This value is generated by cloudflare.
        pub hex_id: pulumi_wasm_rust::Output<String>,
        /// 31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.
        pub interface_address: pulumi_wasm_rust::Output<String>,
        /// Name of the IPsec tunnel.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Pre shared key to be used with the IPsec tunnel. If left unset, it will be autogenerated.
        pub psk: pulumi_wasm_rust::Output<String>,
        /// ID to be used while setting up the IPsec tunnel. This value is generated by cloudflare.
        pub remote_id: pulumi_wasm_rust::Output<String>,
        /// Specifies if replay protection is enabled. Defaults to `false`.
        pub replay_protection: pulumi_wasm_rust::Output<Option<bool>>,
        /// `remote_id` in the form of an email address. This value is generated by cloudflare.
        pub user_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: IpsecTunnelArgs) -> IpsecTunnelResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let allow_null_cipher_binding = args.allow_null_cipher.get_inner();
        let cloudflare_endpoint_binding = args.cloudflare_endpoint.get_inner();
        let customer_endpoint_binding = args.customer_endpoint.get_inner();
        let description_binding = args.description.get_inner();
        let fqdn_id_binding = args.fqdn_id.get_inner();
        let health_check_direction_binding = args.health_check_direction.get_inner();
        let health_check_enabled_binding = args.health_check_enabled.get_inner();
        let health_check_rate_binding = args.health_check_rate.get_inner();
        let health_check_target_binding = args.health_check_target.get_inner();
        let health_check_type_binding = args.health_check_type.get_inner();
        let hex_id_binding = args.hex_id.get_inner();
        let interface_address_binding = args.interface_address.get_inner();
        let name_binding = args.name.get_inner();
        let psk_binding = args.psk.get_inner();
        let remote_id_binding = args.remote_id.get_inner();
        let replay_protection_binding = args.replay_protection.get_inner();
        let user_id_binding = args.user_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/ipsecTunnel:IpsecTunnel".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "allowNullCipher".into(),
                    value: &allow_null_cipher_binding,
                },
                register_interface::ObjectField {
                    name: "cloudflareEndpoint".into(),
                    value: &cloudflare_endpoint_binding,
                },
                register_interface::ObjectField {
                    name: "customerEndpoint".into(),
                    value: &customer_endpoint_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "fqdnId".into(),
                    value: &fqdn_id_binding,
                },
                register_interface::ObjectField {
                    name: "healthCheckDirection".into(),
                    value: &health_check_direction_binding,
                },
                register_interface::ObjectField {
                    name: "healthCheckEnabled".into(),
                    value: &health_check_enabled_binding,
                },
                register_interface::ObjectField {
                    name: "healthCheckRate".into(),
                    value: &health_check_rate_binding,
                },
                register_interface::ObjectField {
                    name: "healthCheckTarget".into(),
                    value: &health_check_target_binding,
                },
                register_interface::ObjectField {
                    name: "healthCheckType".into(),
                    value: &health_check_type_binding,
                },
                register_interface::ObjectField {
                    name: "hexId".into(),
                    value: &hex_id_binding,
                },
                register_interface::ObjectField {
                    name: "interfaceAddress".into(),
                    value: &interface_address_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "psk".into(),
                    value: &psk_binding,
                },
                register_interface::ObjectField {
                    name: "remoteId".into(),
                    value: &remote_id_binding,
                },
                register_interface::ObjectField {
                    name: "replayProtection".into(),
                    value: &replay_protection_binding,
                },
                register_interface::ObjectField {
                    name: "userId".into(),
                    value: &user_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "allowNullCipher".into(),
                },
                register_interface::ResultField {
                    name: "cloudflareEndpoint".into(),
                },
                register_interface::ResultField {
                    name: "customerEndpoint".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "fqdnId".into(),
                },
                register_interface::ResultField {
                    name: "healthCheckDirection".into(),
                },
                register_interface::ResultField {
                    name: "healthCheckEnabled".into(),
                },
                register_interface::ResultField {
                    name: "healthCheckRate".into(),
                },
                register_interface::ResultField {
                    name: "healthCheckTarget".into(),
                },
                register_interface::ResultField {
                    name: "healthCheckType".into(),
                },
                register_interface::ResultField {
                    name: "hexId".into(),
                },
                register_interface::ResultField {
                    name: "interfaceAddress".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "psk".into(),
                },
                register_interface::ResultField {
                    name: "remoteId".into(),
                },
                register_interface::ResultField {
                    name: "replayProtection".into(),
                },
                register_interface::ResultField {
                    name: "userId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        IpsecTunnelResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            allow_null_cipher: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("allowNullCipher").unwrap(),
            ),
            cloudflare_endpoint: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("cloudflareEndpoint").unwrap(),
            ),
            customer_endpoint: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customerEndpoint").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            fqdn_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("fqdnId").unwrap(),
            ),
            health_check_direction: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("healthCheckDirection").unwrap(),
            ),
            health_check_enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("healthCheckEnabled").unwrap(),
            ),
            health_check_rate: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("healthCheckRate").unwrap(),
            ),
            health_check_target: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("healthCheckTarget").unwrap(),
            ),
            health_check_type: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("healthCheckType").unwrap(),
            ),
            hex_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("hexId").unwrap(),
            ),
            interface_address: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("interfaceAddress").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            psk: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("psk").unwrap(),
            ),
            remote_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("remoteId").unwrap(),
            ),
            replay_protection: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("replayProtection").unwrap(),
            ),
            user_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("userId").unwrap(),
            ),
        }
    }
}
pub mod keyless_certificate {
    //! Provides a resource, that manages Keyless certificates.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = keyless_certificate::create(
    //!         "example",
    //!         KeylessCertificateArgs::builder()
    //!             .bundle_method("ubiquitous")
    //!             .certificate("-----INSERT CERTIFICATE-----")
    //!             .enabled(true)
    //!             .host("example.com")
    //!             .name("example.com Keyless SSL")
    //!             .port(24008)
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/keylessCertificate:KeylessCertificate example <zone_id>/<keyless_certificate_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct KeylessCertificateArgs {
        /// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`. Defaults to `ubiquitous`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub bundle_method: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone's SSL certificate or SSL certificate and intermediate(s). **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub certificate: pulumi_wasm_rust::Output<String>,
        /// Whether the KeyLess SSL is on.
        #[builder(into, default)]
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The KeyLess SSL host.
        #[builder(into)]
        pub host: pulumi_wasm_rust::Output<String>,
        /// The KeyLess SSL name.
        #[builder(into, default)]
        pub name: pulumi_wasm_rust::Output<Option<String>>,
        /// The KeyLess SSL port used to communicate between Cloudflare and the client's KeyLess SSL server. Defaults to `24008`.
        #[builder(into, default)]
        pub port: pulumi_wasm_rust::Output<Option<i32>>,
        /// The zone identifier to target for the resource.
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct KeylessCertificateResult {
        /// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`. Defaults to `ubiquitous`. **Modifying this attribute will force creation of a new resource.**
        pub bundle_method: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone's SSL certificate or SSL certificate and intermediate(s). **Modifying this attribute will force creation of a new resource.**
        pub certificate: pulumi_wasm_rust::Output<String>,
        /// Whether the KeyLess SSL is on.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The KeyLess SSL host.
        pub host: pulumi_wasm_rust::Output<String>,
        /// The KeyLess SSL name.
        pub name: pulumi_wasm_rust::Output<Option<String>>,
        /// The KeyLess SSL port used to communicate between Cloudflare and the client's KeyLess SSL server. Defaults to `24008`.
        pub port: pulumi_wasm_rust::Output<Option<i32>>,
        /// Status of the KeyLess SSL.
        pub status: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: KeylessCertificateArgs) -> KeylessCertificateResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let bundle_method_binding = args.bundle_method.get_inner();
        let certificate_binding = args.certificate.get_inner();
        let enabled_binding = args.enabled.get_inner();
        let host_binding = args.host.get_inner();
        let name_binding = args.name.get_inner();
        let port_binding = args.port.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/keylessCertificate:KeylessCertificate".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "bundleMethod".into(),
                    value: &bundle_method_binding,
                },
                register_interface::ObjectField {
                    name: "certificate".into(),
                    value: &certificate_binding,
                },
                register_interface::ObjectField {
                    name: "enabled".into(),
                    value: &enabled_binding,
                },
                register_interface::ObjectField {
                    name: "host".into(),
                    value: &host_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "port".into(),
                    value: &port_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "bundleMethod".into(),
                },
                register_interface::ResultField {
                    name: "certificate".into(),
                },
                register_interface::ResultField {
                    name: "enabled".into(),
                },
                register_interface::ResultField {
                    name: "host".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "port".into(),
                },
                register_interface::ResultField {
                    name: "status".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        KeylessCertificateResult {
            bundle_method: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("bundleMethod").unwrap(),
            ),
            certificate: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("certificate").unwrap(),
            ),
            enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enabled").unwrap(),
            ),
            host: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("host").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            port: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("port").unwrap(),
            ),
            status: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("status").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod list {
    //! ## Example Usage
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/list:List example <account_id>/<list_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ListArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// An optional description of the list.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The items in the list.
        #[builder(into, default)]
        pub items: pulumi_wasm_rust::Output<Option<Vec<super::types::ListItem>>>,
        /// The type of items the list will contain. Must provide only one of: `ip`, `redirect`, `hostname`, `asn`..
        #[builder(into)]
        pub kind: pulumi_wasm_rust::Output<String>,
        /// The name of the list.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ListResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// An optional description of the list.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The items in the list.
        pub items: pulumi_wasm_rust::Output<Option<Vec<super::types::ListItem>>>,
        /// The type of items the list will contain. Must provide only one of: `ip`, `redirect`, `hostname`, `asn`..
        pub kind: pulumi_wasm_rust::Output<String>,
        /// The name of the list.
        pub name: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: ListArgs) -> ListResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let description_binding = args.description.get_inner();
        let items_binding = args.items.get_inner();
        let kind_binding = args.kind.get_inner();
        let name_binding = args.name.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/list:List".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "items".into(),
                    value: &items_binding,
                },
                register_interface::ObjectField {
                    name: "kind".into(),
                    value: &kind_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "items".into(),
                },
                register_interface::ResultField {
                    name: "kind".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ListResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            items: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("items").unwrap(),
            ),
            kind: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("kind").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
        }
    }
}
pub mod list_item {
    //! Provides individual list items (IPs, Redirects, ASNs, Hostnames) to be used in Edge Rules Engine
    //! across all zones within the same account.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let exampleAsnItem = list_item::create(
    //!         "exampleAsnItem",
    //!         ListItemArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .asn(6789)
    //!             .comment("List Item Comment")
    //!             .list_id("${exampleAsnList.id}")
    //!             .build_struct(),
    //!     );
    //!     let exampleAsnList = list::create(
    //!         "exampleAsnList",
    //!         ListArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .description("example ASNs for a list")
    //!             .kind("asn")
    //!             .name("example_asn_list")
    //!             .build_struct(),
    //!     );
    //!     let exampleHostnameItem = list_item::create(
    //!         "exampleHostnameItem",
    //!         ListItemArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .comment("List Item Comment")
    //!             .hostname(
    //!                 ListItemHostname::builder().urlHostname("example.com").build_struct(),
    //!             )
    //!             .list_id("${exampleHostnameList.id}")
    //!             .build_struct(),
    //!     );
    //!     let exampleHostnameList = list::create(
    //!         "exampleHostnameList",
    //!         ListArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .description("example Hostnames for a list")
    //!             .kind("hostname")
    //!             .name("example_hostname_list")
    //!             .build_struct(),
    //!     );
    //!     let exampleIpItem = list_item::create(
    //!         "exampleIpItem",
    //!         ListItemArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .comment("List Item Comment")
    //!             .ip("192.0.2.0")
    //!             .list_id("${exampleIpList.id}")
    //!             .build_struct(),
    //!     );
    //!     let exampleIpList = list::create(
    //!         "exampleIpList",
    //!         ListArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .description("example IPs for a list")
    //!             .kind("ip")
    //!             .name("example_list")
    //!             .build_struct(),
    //!     );
    //!     let exampleRedirectItem = list_item::create(
    //!         "exampleRedirectItem",
    //!         ListItemArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .list_id("${exampleIpList.id}")
    //!             .redirect(
    //!                 ListItemRedirect::builder()
    //!                     .sourceUrl("https://source.tld/")
    //!                     .statusCode(302)
    //!                     .subpathMatching(true)
    //!                     .targetUrl("https://target.tld")
    //!                     .build_struct(),
    //!             )
    //!             .build_struct(),
    //!     );
    //!     let exampleRedirectList = list::create(
    //!         "exampleRedirectList",
    //!         ListArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .description("example Redirects for a list")
    //!             .kind("redirect")
    //!             .name("example_list")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/listItem:ListItem example <account_id>/<list_id>/<item_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ListItemArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Autonomous system number to include in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.
        #[builder(into, default)]
        pub asn: pulumi_wasm_rust::Output<Option<i32>>,
        /// An optional comment for the item.
        #[builder(into, default)]
        pub comment: pulumi_wasm_rust::Output<Option<String>>,
        /// Hostname to store in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.
        #[builder(into, default)]
        pub hostname: pulumi_wasm_rust::Output<Option<super::types::ListItemHostname>>,
        /// IP address to include in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.
        #[builder(into, default)]
        pub ip: pulumi_wasm_rust::Output<Option<String>>,
        /// The list identifier to target for the resource.
        #[builder(into)]
        pub list_id: pulumi_wasm_rust::Output<String>,
        /// Redirect configuration to store in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.
        #[builder(into, default)]
        pub redirect: pulumi_wasm_rust::Output<Option<super::types::ListItemRedirect>>,
    }
    #[allow(dead_code)]
    pub struct ListItemResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Autonomous system number to include in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.
        pub asn: pulumi_wasm_rust::Output<Option<i32>>,
        /// An optional comment for the item.
        pub comment: pulumi_wasm_rust::Output<Option<String>>,
        /// Hostname to store in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.
        pub hostname: pulumi_wasm_rust::Output<Option<super::types::ListItemHostname>>,
        /// IP address to include in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.
        pub ip: pulumi_wasm_rust::Output<Option<String>>,
        /// The list identifier to target for the resource.
        pub list_id: pulumi_wasm_rust::Output<String>,
        /// Redirect configuration to store in the list. Must provide only one of: `ip`, `asn`, `redirect`, `hostname`.
        pub redirect: pulumi_wasm_rust::Output<Option<super::types::ListItemRedirect>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: ListItemArgs) -> ListItemResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let asn_binding = args.asn.get_inner();
        let comment_binding = args.comment.get_inner();
        let hostname_binding = args.hostname.get_inner();
        let ip_binding = args.ip.get_inner();
        let list_id_binding = args.list_id.get_inner();
        let redirect_binding = args.redirect.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/listItem:ListItem".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "asn".into(),
                    value: &asn_binding,
                },
                register_interface::ObjectField {
                    name: "comment".into(),
                    value: &comment_binding,
                },
                register_interface::ObjectField {
                    name: "hostname".into(),
                    value: &hostname_binding,
                },
                register_interface::ObjectField {
                    name: "ip".into(),
                    value: &ip_binding,
                },
                register_interface::ObjectField {
                    name: "listId".into(),
                    value: &list_id_binding,
                },
                register_interface::ObjectField {
                    name: "redirect".into(),
                    value: &redirect_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "asn".into(),
                },
                register_interface::ResultField {
                    name: "comment".into(),
                },
                register_interface::ResultField {
                    name: "hostname".into(),
                },
                register_interface::ResultField {
                    name: "ip".into(),
                },
                register_interface::ResultField {
                    name: "listId".into(),
                },
                register_interface::ResultField {
                    name: "redirect".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ListItemResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            asn: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("asn").unwrap(),
            ),
            comment: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("comment").unwrap(),
            ),
            hostname: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("hostname").unwrap(),
            ),
            ip: pulumi_wasm_rust::__private::into_domain(hashmap.remove("ip").unwrap()),
            list_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("listId").unwrap(),
            ),
            redirect: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("redirect").unwrap(),
            ),
        }
    }
}
pub mod load_balancer {
    //! Provides a Cloudflare Load Balancer resource. This sits in front of
    //! a number of defined pools of origins and provides various options
    //! for geographically-aware load balancing. Note that the load balancing
    //! feature must be enabled in your Cloudflare account before you can use
    //! this resource.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = load_balancer::create(
    //!         "example",
    //!         LoadBalancerArgs::builder()
    //!             .country_pools(
    //!                 vec![
    //!                     LoadBalancerCountryPool::builder().country("US")
    //!                     .poolIds(vec!["${exampleLoadBalancerPool.id}",]).build_struct(),
    //!                 ],
    //!             )
    //!             .default_pool_ids(vec!["${exampleLoadBalancerPool.id}",])
    //!             .description("example load balancer using geo-balancing")
    //!             .fallback_pool_id("${exampleLoadBalancerPool.id}")
    //!             .name("example-load-balancer.example.com")
    //!             .pop_pools(
    //!                 vec![
    //!                     LoadBalancerPopPool::builder()
    //!                     .poolIds(vec!["${exampleLoadBalancerPool.id}",]).pop("LAX")
    //!                     .build_struct(),
    //!                 ],
    //!             )
    //!             .proxied(true)
    //!             .region_pools(
    //!                 vec![
    //!                     LoadBalancerRegionPool::builder()
    //!                     .poolIds(vec!["${exampleLoadBalancerPool.id}",]).region("WNAM")
    //!                     .build_struct(),
    //!                 ],
    //!             )
    //!             .rules(
    //!                 vec![
    //!                     LoadBalancerRule::builder()
    //!                     .condition("http.request.uri.path contains \"testing\"")
    //!                     .fixedResponse(LoadBalancerRuleFixedResponse::builder()
    //!                     .contentType("html").location("www.example.com").messageBody("hello")
    //!                     .statusCode(200).build_struct()).name("example rule").build_struct(),
    //!                 ],
    //!             )
    //!             .steering_policy("geo")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //!     let exampleLoadBalancerPool = load_balancer_pool::create(
    //!         "exampleLoadBalancerPool",
    //!         LoadBalancerPoolArgs::builder()
    //!             .name("example-lb-pool")
    //!             .origins(
    //!                 vec![
    //!                     LoadBalancerPoolOrigin::builder().address("192.0.2.1").enabled(false)
    //!                     .name("example-1").build_struct(),
    //!                 ],
    //!             )
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/loadBalancer:LoadBalancer example <zone_id>/<load_balancer_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct LoadBalancerArgs {
        /// Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.
        #[builder(into, default)]
        pub adaptive_routings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::LoadBalancerAdaptiveRouting>>,
        >,
        /// A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.
        #[builder(into, default)]
        pub country_pools: pulumi_wasm_rust::Output<
            Option<Vec<super::types::LoadBalancerCountryPool>>,
        >,
        /// A list of pool IDs ordered by their failover priority. Used whenever `pop_pools`/`country_pools`/`region_pools` are not defined.
        #[builder(into)]
        pub default_pool_ids: pulumi_wasm_rust::Output<Vec<String>>,
        /// Free text description.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Enable or disable the load balancer. Defaults to `true`.
        #[builder(into, default)]
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The pool ID to use when all other pools are detected as unhealthy.
        #[builder(into)]
        pub fallback_pool_id: pulumi_wasm_rust::Output<String>,
        /// Controls location-based steering for non-proxied requests.
        #[builder(into, default)]
        pub location_strategies: pulumi_wasm_rust::Output<
            Option<Vec<super::types::LoadBalancerLocationStrategy>>,
        >,
        /// The DNS hostname to associate with your load balancer. If this hostname already exists as a DNS record in Cloudflare's DNS, the load balancer will take precedence and the DNS record will not be used.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.
        #[builder(into, default)]
        pub pop_pools: pulumi_wasm_rust::Output<
            Option<Vec<super::types::LoadBalancerPopPool>>,
        >,
        /// Whether the hostname gets Cloudflare's origin protection. Defaults to `false`. Conflicts with `ttl`.
        #[builder(into, default)]
        pub proxied: pulumi_wasm_rust::Output<Option<bool>>,
        /// Configures pool weights. When `steering_policy="random"`, a random pool is selected with probability proportional to pool weights. When `steering_policy="least_outstanding_requests"`, pool weights are used to scale each pool's outstanding requests. When `steering_policy="least_connections"`, pool weights are used to scale each pool's open connections.
        #[builder(into, default)]
        pub random_steerings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::LoadBalancerRandomSteering>>,
        >,
        /// A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.
        #[builder(into, default)]
        pub region_pools: pulumi_wasm_rust::Output<
            Option<Vec<super::types::LoadBalancerRegionPool>>,
        >,
        /// A list of rules for this load balancer to execute.
        #[builder(into, default)]
        pub rules: pulumi_wasm_rust::Output<Option<Vec<super::types::LoadBalancerRule>>>,
        /// Specifies the type of session affinity the load balancer should use unless specified as `none` or `""` (default). With value `cookie`, on the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy then a new origin server is calculated and used. Value `ip_cookie` behaves the same as `cookie` except the initial origin selection is stable and based on the client's IP address. Available values: `""`, `none`, `cookie`, `ip_cookie`, `header`. Defaults to `none`.
        #[builder(into, default)]
        pub session_affinity: pulumi_wasm_rust::Output<Option<String>>,
        /// Configure attributes for session affinity.
        #[builder(into, default)]
        pub session_affinity_attributes: pulumi_wasm_rust::Output<
            Option<Vec<super::types::LoadBalancerSessionAffinityAttribute>>,
        >,
        /// Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.
        #[builder(into, default)]
        pub session_affinity_ttl: pulumi_wasm_rust::Output<Option<i32>>,
        /// The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `least_outstanding_requests` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of outstanding requests. Pools with more pending requests are weighted proportionately less relative to others. Value `least_connections` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of open connections. Pools with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Value `""` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `least_outstanding_requests`, `least_connections`, `""` Defaults to `""`.
        #[builder(into, default)]
        pub steering_policy: pulumi_wasm_rust::Output<Option<String>>,
        /// Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`. Conflicts with `proxied`.
        #[builder(into, default)]
        pub ttl: pulumi_wasm_rust::Output<Option<i32>>,
        /// The zone ID to add the load balancer to. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct LoadBalancerResult {
        /// Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.
        pub adaptive_routings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::LoadBalancerAdaptiveRouting>>,
        >,
        /// A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.
        pub country_pools: pulumi_wasm_rust::Output<
            Option<Vec<super::types::LoadBalancerCountryPool>>,
        >,
        /// The RFC3339 timestamp of when the load balancer was created.
        pub created_on: pulumi_wasm_rust::Output<String>,
        /// A list of pool IDs ordered by their failover priority. Used whenever `pop_pools`/`country_pools`/`region_pools` are not defined.
        pub default_pool_ids: pulumi_wasm_rust::Output<Vec<String>>,
        /// Free text description.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Enable or disable the load balancer. Defaults to `true`.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The pool ID to use when all other pools are detected as unhealthy.
        pub fallback_pool_id: pulumi_wasm_rust::Output<String>,
        /// Controls location-based steering for non-proxied requests.
        pub location_strategies: pulumi_wasm_rust::Output<
            Option<Vec<super::types::LoadBalancerLocationStrategy>>,
        >,
        /// The RFC3339 timestamp of when the load balancer was last modified.
        pub modified_on: pulumi_wasm_rust::Output<String>,
        /// The DNS hostname to associate with your load balancer. If this hostname already exists as a DNS record in Cloudflare's DNS, the load balancer will take precedence and the DNS record will not be used.
        pub name: pulumi_wasm_rust::Output<String>,
        /// A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.
        pub pop_pools: pulumi_wasm_rust::Output<
            Option<Vec<super::types::LoadBalancerPopPool>>,
        >,
        /// Whether the hostname gets Cloudflare's origin protection. Defaults to `false`. Conflicts with `ttl`.
        pub proxied: pulumi_wasm_rust::Output<Option<bool>>,
        /// Configures pool weights. When `steering_policy="random"`, a random pool is selected with probability proportional to pool weights. When `steering_policy="least_outstanding_requests"`, pool weights are used to scale each pool's outstanding requests. When `steering_policy="least_connections"`, pool weights are used to scale each pool's open connections.
        pub random_steerings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::LoadBalancerRandomSteering>>,
        >,
        /// A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.
        pub region_pools: pulumi_wasm_rust::Output<
            Option<Vec<super::types::LoadBalancerRegionPool>>,
        >,
        /// A list of rules for this load balancer to execute.
        pub rules: pulumi_wasm_rust::Output<Option<Vec<super::types::LoadBalancerRule>>>,
        /// Specifies the type of session affinity the load balancer should use unless specified as `none` or `""` (default). With value `cookie`, on the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy then a new origin server is calculated and used. Value `ip_cookie` behaves the same as `cookie` except the initial origin selection is stable and based on the client's IP address. Available values: `""`, `none`, `cookie`, `ip_cookie`, `header`. Defaults to `none`.
        pub session_affinity: pulumi_wasm_rust::Output<Option<String>>,
        /// Configure attributes for session affinity.
        pub session_affinity_attributes: pulumi_wasm_rust::Output<
            Option<Vec<super::types::LoadBalancerSessionAffinityAttribute>>,
        >,
        /// Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.
        pub session_affinity_ttl: pulumi_wasm_rust::Output<Option<i32>>,
        /// The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `least_outstanding_requests` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of outstanding requests. Pools with more pending requests are weighted proportionately less relative to others. Value `least_connections` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of open connections. Pools with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Value `""` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `least_outstanding_requests`, `least_connections`, `""` Defaults to `""`.
        pub steering_policy: pulumi_wasm_rust::Output<String>,
        /// Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`. Conflicts with `proxied`.
        pub ttl: pulumi_wasm_rust::Output<i32>,
        /// The zone ID to add the load balancer to. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: LoadBalancerArgs) -> LoadBalancerResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let adaptive_routings_binding = args.adaptive_routings.get_inner();
        let country_pools_binding = args.country_pools.get_inner();
        let default_pool_ids_binding = args.default_pool_ids.get_inner();
        let description_binding = args.description.get_inner();
        let enabled_binding = args.enabled.get_inner();
        let fallback_pool_id_binding = args.fallback_pool_id.get_inner();
        let location_strategies_binding = args.location_strategies.get_inner();
        let name_binding = args.name.get_inner();
        let pop_pools_binding = args.pop_pools.get_inner();
        let proxied_binding = args.proxied.get_inner();
        let random_steerings_binding = args.random_steerings.get_inner();
        let region_pools_binding = args.region_pools.get_inner();
        let rules_binding = args.rules.get_inner();
        let session_affinity_binding = args.session_affinity.get_inner();
        let session_affinity_attributes_binding = args
            .session_affinity_attributes
            .get_inner();
        let session_affinity_ttl_binding = args.session_affinity_ttl.get_inner();
        let steering_policy_binding = args.steering_policy.get_inner();
        let ttl_binding = args.ttl.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/loadBalancer:LoadBalancer".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "adaptiveRoutings".into(),
                    value: &adaptive_routings_binding,
                },
                register_interface::ObjectField {
                    name: "countryPools".into(),
                    value: &country_pools_binding,
                },
                register_interface::ObjectField {
                    name: "defaultPoolIds".into(),
                    value: &default_pool_ids_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "enabled".into(),
                    value: &enabled_binding,
                },
                register_interface::ObjectField {
                    name: "fallbackPoolId".into(),
                    value: &fallback_pool_id_binding,
                },
                register_interface::ObjectField {
                    name: "locationStrategies".into(),
                    value: &location_strategies_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "popPools".into(),
                    value: &pop_pools_binding,
                },
                register_interface::ObjectField {
                    name: "proxied".into(),
                    value: &proxied_binding,
                },
                register_interface::ObjectField {
                    name: "randomSteerings".into(),
                    value: &random_steerings_binding,
                },
                register_interface::ObjectField {
                    name: "regionPools".into(),
                    value: &region_pools_binding,
                },
                register_interface::ObjectField {
                    name: "rules".into(),
                    value: &rules_binding,
                },
                register_interface::ObjectField {
                    name: "sessionAffinity".into(),
                    value: &session_affinity_binding,
                },
                register_interface::ObjectField {
                    name: "sessionAffinityAttributes".into(),
                    value: &session_affinity_attributes_binding,
                },
                register_interface::ObjectField {
                    name: "sessionAffinityTtl".into(),
                    value: &session_affinity_ttl_binding,
                },
                register_interface::ObjectField {
                    name: "steeringPolicy".into(),
                    value: &steering_policy_binding,
                },
                register_interface::ObjectField {
                    name: "ttl".into(),
                    value: &ttl_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "adaptiveRoutings".into(),
                },
                register_interface::ResultField {
                    name: "countryPools".into(),
                },
                register_interface::ResultField {
                    name: "createdOn".into(),
                },
                register_interface::ResultField {
                    name: "defaultPoolIds".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "enabled".into(),
                },
                register_interface::ResultField {
                    name: "fallbackPoolId".into(),
                },
                register_interface::ResultField {
                    name: "locationStrategies".into(),
                },
                register_interface::ResultField {
                    name: "modifiedOn".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "popPools".into(),
                },
                register_interface::ResultField {
                    name: "proxied".into(),
                },
                register_interface::ResultField {
                    name: "randomSteerings".into(),
                },
                register_interface::ResultField {
                    name: "regionPools".into(),
                },
                register_interface::ResultField {
                    name: "rules".into(),
                },
                register_interface::ResultField {
                    name: "sessionAffinity".into(),
                },
                register_interface::ResultField {
                    name: "sessionAffinityAttributes".into(),
                },
                register_interface::ResultField {
                    name: "sessionAffinityTtl".into(),
                },
                register_interface::ResultField {
                    name: "steeringPolicy".into(),
                },
                register_interface::ResultField {
                    name: "ttl".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        LoadBalancerResult {
            adaptive_routings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("adaptiveRoutings").unwrap(),
            ),
            country_pools: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("countryPools").unwrap(),
            ),
            created_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("createdOn").unwrap(),
            ),
            default_pool_ids: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("defaultPoolIds").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enabled").unwrap(),
            ),
            fallback_pool_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("fallbackPoolId").unwrap(),
            ),
            location_strategies: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("locationStrategies").unwrap(),
            ),
            modified_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("modifiedOn").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            pop_pools: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("popPools").unwrap(),
            ),
            proxied: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("proxied").unwrap(),
            ),
            random_steerings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("randomSteerings").unwrap(),
            ),
            region_pools: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("regionPools").unwrap(),
            ),
            rules: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("rules").unwrap(),
            ),
            session_affinity: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("sessionAffinity").unwrap(),
            ),
            session_affinity_attributes: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("sessionAffinityAttributes").unwrap(),
            ),
            session_affinity_ttl: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("sessionAffinityTtl").unwrap(),
            ),
            steering_policy: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("steeringPolicy").unwrap(),
            ),
            ttl: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("ttl").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod load_balancer_monitor {
    //! If Cloudflare's Load Balancing to load-balance across multiple
    //! origin servers or data centers, you configure one of these Monitors
    //! to actively check the availability of those servers over HTTP(S) or
    //! TCP.
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/loadBalancerMonitor:LoadBalancerMonitor example <account_id>/<load_balancer_monitor_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct LoadBalancerMonitorArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Do not validate the certificate when monitor use HTTPS.  Only valid if `type` is "http" or "https".
        #[builder(into, default)]
        pub allow_insecure: pulumi_wasm_rust::Output<Option<bool>>,
        /// To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times. Defaults to `0`.
        #[builder(into, default)]
        pub consecutive_down: pulumi_wasm_rust::Output<Option<i32>>,
        /// To be marked healthy the monitored origin must pass this healthcheck N consecutive times. Defaults to `0`.
        #[builder(into, default)]
        pub consecutive_up: pulumi_wasm_rust::Output<Option<i32>>,
        /// Free text description.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. Only valid if `type` is "http" or "https".
        #[builder(into, default)]
        pub expected_body: pulumi_wasm_rust::Output<Option<String>>,
        /// The expected HTTP response code or code range of the health check. Eg `2xx`. Only valid and required if `type` is "http" or "https".
        #[builder(into, default)]
        pub expected_codes: pulumi_wasm_rust::Output<Option<String>>,
        /// Follow redirects if returned by the origin. Only valid if `type` is "http" or "https".
        #[builder(into, default)]
        pub follow_redirects: pulumi_wasm_rust::Output<Option<bool>>,
        /// The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
        #[builder(into, default)]
        pub headers: pulumi_wasm_rust::Output<
            Option<Vec<super::types::LoadBalancerMonitorHeader>>,
        >,
        /// The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations. Defaults to `60`.
        #[builder(into, default)]
        pub interval: pulumi_wasm_rust::Output<Option<i32>>,
        /// The method to use for the health check.
        #[builder(into, default)]
        pub method: pulumi_wasm_rust::Output<Option<String>>,
        /// The endpoint path to health check against.
        #[builder(into, default)]
        pub path: pulumi_wasm_rust::Output<Option<String>>,
        /// The port number to use for the healthcheck, required when creating a TCP monitor.
        #[builder(into, default)]
        pub port: pulumi_wasm_rust::Output<Option<i32>>,
        /// Assign this monitor to emulate the specified zone while probing. Only valid if `type` is "http" or "https".
        #[builder(into, default)]
        pub probe_zone: pulumi_wasm_rust::Output<Option<String>>,
        /// The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Defaults to `2`.
        #[builder(into, default)]
        pub retries: pulumi_wasm_rust::Output<Option<i32>>,
        /// The timeout (in seconds) before marking the health check as failed. Defaults to `5`.
        #[builder(into, default)]
        pub timeout: pulumi_wasm_rust::Output<Option<i32>>,
        /// The protocol to use for the healthcheck. Available values: `http`, `https`, `tcp`, `udp_icmp`, `icmp_ping`, `smtp`. Defaults to `http`.
        #[builder(into, default)]
        pub type_: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct LoadBalancerMonitorResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Do not validate the certificate when monitor use HTTPS.  Only valid if `type` is "http" or "https".
        pub allow_insecure: pulumi_wasm_rust::Output<Option<bool>>,
        /// To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times. Defaults to `0`.
        pub consecutive_down: pulumi_wasm_rust::Output<Option<i32>>,
        /// To be marked healthy the monitored origin must pass this healthcheck N consecutive times. Defaults to `0`.
        pub consecutive_up: pulumi_wasm_rust::Output<Option<i32>>,
        /// The RFC3339 timestamp of when the load balancer monitor was created.
        pub created_on: pulumi_wasm_rust::Output<String>,
        /// Free text description.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. Only valid if `type` is "http" or "https".
        pub expected_body: pulumi_wasm_rust::Output<Option<String>>,
        /// The expected HTTP response code or code range of the health check. Eg `2xx`. Only valid and required if `type` is "http" or "https".
        pub expected_codes: pulumi_wasm_rust::Output<Option<String>>,
        /// Follow redirects if returned by the origin. Only valid if `type` is "http" or "https".
        pub follow_redirects: pulumi_wasm_rust::Output<Option<bool>>,
        /// The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
        pub headers: pulumi_wasm_rust::Output<
            Option<Vec<super::types::LoadBalancerMonitorHeader>>,
        >,
        /// The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations. Defaults to `60`.
        pub interval: pulumi_wasm_rust::Output<Option<i32>>,
        /// The method to use for the health check.
        pub method: pulumi_wasm_rust::Output<String>,
        /// The RFC3339 timestamp of when the load balancer monitor was last modified.
        pub modified_on: pulumi_wasm_rust::Output<String>,
        /// The endpoint path to health check against.
        pub path: pulumi_wasm_rust::Output<String>,
        /// The port number to use for the healthcheck, required when creating a TCP monitor.
        pub port: pulumi_wasm_rust::Output<Option<i32>>,
        /// Assign this monitor to emulate the specified zone while probing. Only valid if `type` is "http" or "https".
        pub probe_zone: pulumi_wasm_rust::Output<Option<String>>,
        /// The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately. Defaults to `2`.
        pub retries: pulumi_wasm_rust::Output<Option<i32>>,
        /// The timeout (in seconds) before marking the health check as failed. Defaults to `5`.
        pub timeout: pulumi_wasm_rust::Output<Option<i32>>,
        /// The protocol to use for the healthcheck. Available values: `http`, `https`, `tcp`, `udp_icmp`, `icmp_ping`, `smtp`. Defaults to `http`.
        pub type_: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: LoadBalancerMonitorArgs,
    ) -> LoadBalancerMonitorResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let allow_insecure_binding = args.allow_insecure.get_inner();
        let consecutive_down_binding = args.consecutive_down.get_inner();
        let consecutive_up_binding = args.consecutive_up.get_inner();
        let description_binding = args.description.get_inner();
        let expected_body_binding = args.expected_body.get_inner();
        let expected_codes_binding = args.expected_codes.get_inner();
        let follow_redirects_binding = args.follow_redirects.get_inner();
        let headers_binding = args.headers.get_inner();
        let interval_binding = args.interval.get_inner();
        let method_binding = args.method.get_inner();
        let path_binding = args.path.get_inner();
        let port_binding = args.port.get_inner();
        let probe_zone_binding = args.probe_zone.get_inner();
        let retries_binding = args.retries.get_inner();
        let timeout_binding = args.timeout.get_inner();
        let type__binding = args.type_.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/loadBalancerMonitor:LoadBalancerMonitor".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "allowInsecure".into(),
                    value: &allow_insecure_binding,
                },
                register_interface::ObjectField {
                    name: "consecutiveDown".into(),
                    value: &consecutive_down_binding,
                },
                register_interface::ObjectField {
                    name: "consecutiveUp".into(),
                    value: &consecutive_up_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "expectedBody".into(),
                    value: &expected_body_binding,
                },
                register_interface::ObjectField {
                    name: "expectedCodes".into(),
                    value: &expected_codes_binding,
                },
                register_interface::ObjectField {
                    name: "followRedirects".into(),
                    value: &follow_redirects_binding,
                },
                register_interface::ObjectField {
                    name: "headers".into(),
                    value: &headers_binding,
                },
                register_interface::ObjectField {
                    name: "interval".into(),
                    value: &interval_binding,
                },
                register_interface::ObjectField {
                    name: "method".into(),
                    value: &method_binding,
                },
                register_interface::ObjectField {
                    name: "path".into(),
                    value: &path_binding,
                },
                register_interface::ObjectField {
                    name: "port".into(),
                    value: &port_binding,
                },
                register_interface::ObjectField {
                    name: "probeZone".into(),
                    value: &probe_zone_binding,
                },
                register_interface::ObjectField {
                    name: "retries".into(),
                    value: &retries_binding,
                },
                register_interface::ObjectField {
                    name: "timeout".into(),
                    value: &timeout_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "allowInsecure".into(),
                },
                register_interface::ResultField {
                    name: "consecutiveDown".into(),
                },
                register_interface::ResultField {
                    name: "consecutiveUp".into(),
                },
                register_interface::ResultField {
                    name: "createdOn".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "expectedBody".into(),
                },
                register_interface::ResultField {
                    name: "expectedCodes".into(),
                },
                register_interface::ResultField {
                    name: "followRedirects".into(),
                },
                register_interface::ResultField {
                    name: "headers".into(),
                },
                register_interface::ResultField {
                    name: "interval".into(),
                },
                register_interface::ResultField {
                    name: "method".into(),
                },
                register_interface::ResultField {
                    name: "modifiedOn".into(),
                },
                register_interface::ResultField {
                    name: "path".into(),
                },
                register_interface::ResultField {
                    name: "port".into(),
                },
                register_interface::ResultField {
                    name: "probeZone".into(),
                },
                register_interface::ResultField {
                    name: "retries".into(),
                },
                register_interface::ResultField {
                    name: "timeout".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        LoadBalancerMonitorResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            allow_insecure: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("allowInsecure").unwrap(),
            ),
            consecutive_down: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("consecutiveDown").unwrap(),
            ),
            consecutive_up: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("consecutiveUp").unwrap(),
            ),
            created_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("createdOn").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            expected_body: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("expectedBody").unwrap(),
            ),
            expected_codes: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("expectedCodes").unwrap(),
            ),
            follow_redirects: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("followRedirects").unwrap(),
            ),
            headers: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("headers").unwrap(),
            ),
            interval: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("interval").unwrap(),
            ),
            method: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("method").unwrap(),
            ),
            modified_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("modifiedOn").unwrap(),
            ),
            path: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("path").unwrap(),
            ),
            port: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("port").unwrap(),
            ),
            probe_zone: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("probeZone").unwrap(),
            ),
            retries: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("retries").unwrap(),
            ),
            timeout: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("timeout").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
        }
    }
}
pub mod load_balancer_pool {
    //! Provides a Cloudflare Load Balancer pool resource. This provides a
    //! pool of origins that can be used by a Cloudflare Load Balancer.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = load_balancer_pool::create(
    //!         "example",
    //!         LoadBalancerPoolArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .description("example load balancer pool")
    //!             .enabled(false)
    //!             .latitude(55)
    //!             .load_sheddings(
    //!                 vec![
    //!                     LoadBalancerPoolLoadShedding::builder().defaultPercent(55)
    //!                     .defaultPolicy("random").sessionPercent(12).sessionPolicy("hash")
    //!                     .build_struct(),
    //!                 ],
    //!             )
    //!             .longitude(-12)
    //!             .minimum_origins(1)
    //!             .name("example-pool")
    //!             .notification_email("someone@example.com")
    //!             .origin_steerings(
    //!                 vec![
    //!                     LoadBalancerPoolOriginSteering::builder().policy("random")
    //!                     .build_struct(),
    //!                 ],
    //!             )
    //!             .origins(
    //!                 vec![
    //!                     LoadBalancerPoolOrigin::builder().address("192.0.2.1").enabled(false)
    //!                     .headers(vec![LoadBalancerPoolOriginHeader::builder().header("Host")
    //!                     .values(vec!["example-1",]).build_struct(),]).name("example-1")
    //!                     .build_struct(), LoadBalancerPoolOrigin::builder()
    //!                     .address("192.0.2.2")
    //!                     .headers(vec![LoadBalancerPoolOriginHeader::builder().header("Host")
    //!                     .values(vec!["example-2",]).build_struct(),]).name("example-2")
    //!                     .build_struct(),
    //!                 ],
    //!             )
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/loadBalancerPool:LoadBalancerPool example <account_id>/<load_balancer_pool_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct LoadBalancerPoolArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// A list of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api).
        #[builder(into, default)]
        pub check_regions: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Free text description.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether to enable (the default) this pool. Disabled pools will not receive traffic and are excluded from health checks. Disabling a pool will cause any load balancers using it to failover to the next pool (if any). Defaults to `true`.
        #[builder(into, default)]
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The latitude this pool is physically located at; used for proximity steering.
        #[builder(into, default)]
        pub latitude: pulumi_wasm_rust::Output<Option<f64>>,
        /// Setting for controlling load shedding for this pool.
        #[builder(into, default)]
        pub load_sheddings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::LoadBalancerPoolLoadShedding>>,
        >,
        /// The longitude this pool is physically located at; used for proximity steering.
        #[builder(into, default)]
        pub longitude: pulumi_wasm_rust::Output<Option<f64>>,
        /// The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and we will failover to the next available pool. Defaults to `1`.
        #[builder(into, default)]
        pub minimum_origins: pulumi_wasm_rust::Output<Option<i32>>,
        /// The ID of the Monitor to use for health checking origins within this pool.
        #[builder(into, default)]
        pub monitor: pulumi_wasm_rust::Output<Option<String>>,
        /// A short name (tag) for the pool.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list.
        #[builder(into, default)]
        pub notification_email: pulumi_wasm_rust::Output<Option<String>>,
        /// Set an origin steering policy to control origin selection within a pool.
        #[builder(into, default)]
        pub origin_steerings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::LoadBalancerPoolOriginSteering>>,
        >,
        /// The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy.
        #[builder(into)]
        pub origins: pulumi_wasm_rust::Output<Vec<super::types::LoadBalancerPoolOrigin>>,
    }
    #[allow(dead_code)]
    pub struct LoadBalancerPoolResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// A list of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api).
        pub check_regions: pulumi_wasm_rust::Output<Vec<String>>,
        /// The RFC3339 timestamp of when the load balancer was created.
        pub created_on: pulumi_wasm_rust::Output<String>,
        /// Free text description.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether to enable (the default) this pool. Disabled pools will not receive traffic and are excluded from health checks. Disabling a pool will cause any load balancers using it to failover to the next pool (if any). Defaults to `true`.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The latitude this pool is physically located at; used for proximity steering.
        pub latitude: pulumi_wasm_rust::Output<Option<f64>>,
        /// Setting for controlling load shedding for this pool.
        pub load_sheddings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::LoadBalancerPoolLoadShedding>>,
        >,
        /// The longitude this pool is physically located at; used for proximity steering.
        pub longitude: pulumi_wasm_rust::Output<Option<f64>>,
        /// The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and we will failover to the next available pool. Defaults to `1`.
        pub minimum_origins: pulumi_wasm_rust::Output<Option<i32>>,
        /// The RFC3339 timestamp of when the load balancer was last modified.
        pub modified_on: pulumi_wasm_rust::Output<String>,
        /// The ID of the Monitor to use for health checking origins within this pool.
        pub monitor: pulumi_wasm_rust::Output<Option<String>>,
        /// A short name (tag) for the pool.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list.
        pub notification_email: pulumi_wasm_rust::Output<Option<String>>,
        /// Set an origin steering policy to control origin selection within a pool.
        pub origin_steerings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::LoadBalancerPoolOriginSteering>>,
        >,
        /// The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy.
        pub origins: pulumi_wasm_rust::Output<Vec<super::types::LoadBalancerPoolOrigin>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: LoadBalancerPoolArgs) -> LoadBalancerPoolResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let check_regions_binding = args.check_regions.get_inner();
        let description_binding = args.description.get_inner();
        let enabled_binding = args.enabled.get_inner();
        let latitude_binding = args.latitude.get_inner();
        let load_sheddings_binding = args.load_sheddings.get_inner();
        let longitude_binding = args.longitude.get_inner();
        let minimum_origins_binding = args.minimum_origins.get_inner();
        let monitor_binding = args.monitor.get_inner();
        let name_binding = args.name.get_inner();
        let notification_email_binding = args.notification_email.get_inner();
        let origin_steerings_binding = args.origin_steerings.get_inner();
        let origins_binding = args.origins.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/loadBalancerPool:LoadBalancerPool".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "checkRegions".into(),
                    value: &check_regions_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "enabled".into(),
                    value: &enabled_binding,
                },
                register_interface::ObjectField {
                    name: "latitude".into(),
                    value: &latitude_binding,
                },
                register_interface::ObjectField {
                    name: "loadSheddings".into(),
                    value: &load_sheddings_binding,
                },
                register_interface::ObjectField {
                    name: "longitude".into(),
                    value: &longitude_binding,
                },
                register_interface::ObjectField {
                    name: "minimumOrigins".into(),
                    value: &minimum_origins_binding,
                },
                register_interface::ObjectField {
                    name: "monitor".into(),
                    value: &monitor_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "notificationEmail".into(),
                    value: &notification_email_binding,
                },
                register_interface::ObjectField {
                    name: "originSteerings".into(),
                    value: &origin_steerings_binding,
                },
                register_interface::ObjectField {
                    name: "origins".into(),
                    value: &origins_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "checkRegions".into(),
                },
                register_interface::ResultField {
                    name: "createdOn".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "enabled".into(),
                },
                register_interface::ResultField {
                    name: "latitude".into(),
                },
                register_interface::ResultField {
                    name: "loadSheddings".into(),
                },
                register_interface::ResultField {
                    name: "longitude".into(),
                },
                register_interface::ResultField {
                    name: "minimumOrigins".into(),
                },
                register_interface::ResultField {
                    name: "modifiedOn".into(),
                },
                register_interface::ResultField {
                    name: "monitor".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "notificationEmail".into(),
                },
                register_interface::ResultField {
                    name: "originSteerings".into(),
                },
                register_interface::ResultField {
                    name: "origins".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        LoadBalancerPoolResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            check_regions: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("checkRegions").unwrap(),
            ),
            created_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("createdOn").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enabled").unwrap(),
            ),
            latitude: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("latitude").unwrap(),
            ),
            load_sheddings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("loadSheddings").unwrap(),
            ),
            longitude: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("longitude").unwrap(),
            ),
            minimum_origins: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("minimumOrigins").unwrap(),
            ),
            modified_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("modifiedOn").unwrap(),
            ),
            monitor: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("monitor").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            notification_email: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("notificationEmail").unwrap(),
            ),
            origin_steerings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("originSteerings").unwrap(),
            ),
            origins: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("origins").unwrap(),
            ),
        }
    }
}
pub mod logpull_retention {
    //! Allows management of the Logpull Retention settings used to control whether or not to retain HTTP request logs.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   example:
    //!     type: cloudflare:LogpullRetention
    //!     properties:
    //!       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
    //!       enabled: 'true'
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/logpullRetention:LogpullRetention example <zone_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct LogpullRetentionArgs {
        /// Whether you wish to retain logs or not.
        #[builder(into)]
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct LogpullRetentionResult {
        /// Whether you wish to retain logs or not.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: LogpullRetentionArgs) -> LogpullRetentionResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let enabled_binding = args.enabled.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/logpullRetention:LogpullRetention".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "enabled".into(),
                    value: &enabled_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "enabled".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        LogpullRetentionResult {
            enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enabled").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod logpush_job {
    //! ## Example Usage
    //!
    //! ## Import
    //!
    //! Import an account-scoped job.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/logpushJob:LogpushJob example account/<account_id>/<job_id>
    //! ```
    //!
    //! Import a zone-scoped job.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/logpushJob:LogpushJob example zone/<zone_id>/<job_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct LogpushJobArgs {
        /// The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The kind of the dataset to use with the logpush job. Available values: `access_requests`, `casb_findings`, `firewall_events`, `http_requests`, `spectrum_events`, `nel_reports`, `audit_logs`, `gateway_dns`, `gateway_http`, `gateway_network`, `dns_logs`, `network_analytics_logs`, `workers_trace_events`, `device_posture_results`, `zero_trust_network_sessions`, `magic_ids_detections`, `page_shield_events`.
        #[builder(into)]
        pub dataset: pulumi_wasm_rust::Output<String>,
        /// Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/reference/logpush-api-configuration#destination).
        #[builder(into)]
        pub destination_conf: pulumi_wasm_rust::Output<String>,
        /// Whether to enable the job.
        #[builder(into, default)]
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Use filters to select the events to include and/or remove from your logs. For more information, refer to [Filters](https://developers.cloudflare.com/logs/reference/logpush-api-configuration/filters/).
        #[builder(into, default)]
        pub filter: pulumi_wasm_rust::Output<Option<String>>,
        /// A higher frequency will result in logs being pushed on faster with smaller files. `low` frequency will push logs less often with larger files. Available values: `high`, `low`. Defaults to `high`.
        #[builder(into, default)]
        pub frequency: pulumi_wasm_rust::Output<Option<String>>,
        /// The kind of logpush job to create. Available values: `edge`, `instant-logs`, `""`.
        #[builder(into, default)]
        pub kind: pulumi_wasm_rust::Output<Option<String>>,
        /// Configuration string for the Logshare API. It specifies things like requested fields and timestamp formats. See [Logpush options documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#options).
        #[builder(into, default)]
        pub logpull_options: pulumi_wasm_rust::Output<Option<String>>,
        /// The maximum uncompressed file size of a batch of logs. Value must be between 5MB and 1GB.
        #[builder(into, default)]
        pub max_upload_bytes: pulumi_wasm_rust::Output<Option<i32>>,
        /// The maximum interval in seconds for log batches. Value must be between 30 and 300.
        #[builder(into, default)]
        pub max_upload_interval_seconds: pulumi_wasm_rust::Output<Option<i32>>,
        /// The maximum number of log lines per batch. Value must be between 1000 and 1,000,000.
        #[builder(into, default)]
        pub max_upload_records: pulumi_wasm_rust::Output<Option<i32>>,
        /// The name of the logpush job to create.
        #[builder(into, default)]
        pub name: pulumi_wasm_rust::Output<Option<String>>,
        /// Structured replacement for logpull*options. When including this field, the logpull*option field will be ignored.
        #[builder(into, default)]
        pub output_options: pulumi_wasm_rust::Output<
            Option<super::types::LogpushJobOutputOptions>,
        >,
        /// Ownership challenge token to prove destination ownership, required when destination is Amazon S3, Google Cloud Storage, Microsoft Azure or Sumo Logic. See [Developer documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#usage).
        #[builder(into, default)]
        pub ownership_challenge: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct LogpushJobResult {
        /// The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The kind of the dataset to use with the logpush job. Available values: `access_requests`, `casb_findings`, `firewall_events`, `http_requests`, `spectrum_events`, `nel_reports`, `audit_logs`, `gateway_dns`, `gateway_http`, `gateway_network`, `dns_logs`, `network_analytics_logs`, `workers_trace_events`, `device_posture_results`, `zero_trust_network_sessions`, `magic_ids_detections`, `page_shield_events`.
        pub dataset: pulumi_wasm_rust::Output<String>,
        /// Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/reference/logpush-api-configuration#destination).
        pub destination_conf: pulumi_wasm_rust::Output<String>,
        /// Whether to enable the job.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Use filters to select the events to include and/or remove from your logs. For more information, refer to [Filters](https://developers.cloudflare.com/logs/reference/logpush-api-configuration/filters/).
        pub filter: pulumi_wasm_rust::Output<Option<String>>,
        /// A higher frequency will result in logs being pushed on faster with smaller files. `low` frequency will push logs less often with larger files. Available values: `high`, `low`. Defaults to `high`.
        pub frequency: pulumi_wasm_rust::Output<Option<String>>,
        /// The kind of logpush job to create. Available values: `edge`, `instant-logs`, `""`.
        pub kind: pulumi_wasm_rust::Output<Option<String>>,
        /// Configuration string for the Logshare API. It specifies things like requested fields and timestamp formats. See [Logpush options documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#options).
        pub logpull_options: pulumi_wasm_rust::Output<Option<String>>,
        /// The maximum uncompressed file size of a batch of logs. Value must be between 5MB and 1GB.
        pub max_upload_bytes: pulumi_wasm_rust::Output<Option<i32>>,
        /// The maximum interval in seconds for log batches. Value must be between 30 and 300.
        pub max_upload_interval_seconds: pulumi_wasm_rust::Output<Option<i32>>,
        /// The maximum number of log lines per batch. Value must be between 1000 and 1,000,000.
        pub max_upload_records: pulumi_wasm_rust::Output<Option<i32>>,
        /// The name of the logpush job to create.
        pub name: pulumi_wasm_rust::Output<Option<String>>,
        /// Structured replacement for logpull*options. When including this field, the logpull*option field will be ignored.
        pub output_options: pulumi_wasm_rust::Output<
            Option<super::types::LogpushJobOutputOptions>,
        >,
        /// Ownership challenge token to prove destination ownership, required when destination is Amazon S3, Google Cloud Storage, Microsoft Azure or Sumo Logic. See [Developer documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#usage).
        pub ownership_challenge: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: LogpushJobArgs) -> LogpushJobResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let dataset_binding = args.dataset.get_inner();
        let destination_conf_binding = args.destination_conf.get_inner();
        let enabled_binding = args.enabled.get_inner();
        let filter_binding = args.filter.get_inner();
        let frequency_binding = args.frequency.get_inner();
        let kind_binding = args.kind.get_inner();
        let logpull_options_binding = args.logpull_options.get_inner();
        let max_upload_bytes_binding = args.max_upload_bytes.get_inner();
        let max_upload_interval_seconds_binding = args
            .max_upload_interval_seconds
            .get_inner();
        let max_upload_records_binding = args.max_upload_records.get_inner();
        let name_binding = args.name.get_inner();
        let output_options_binding = args.output_options.get_inner();
        let ownership_challenge_binding = args.ownership_challenge.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/logpushJob:LogpushJob".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "dataset".into(),
                    value: &dataset_binding,
                },
                register_interface::ObjectField {
                    name: "destinationConf".into(),
                    value: &destination_conf_binding,
                },
                register_interface::ObjectField {
                    name: "enabled".into(),
                    value: &enabled_binding,
                },
                register_interface::ObjectField {
                    name: "filter".into(),
                    value: &filter_binding,
                },
                register_interface::ObjectField {
                    name: "frequency".into(),
                    value: &frequency_binding,
                },
                register_interface::ObjectField {
                    name: "kind".into(),
                    value: &kind_binding,
                },
                register_interface::ObjectField {
                    name: "logpullOptions".into(),
                    value: &logpull_options_binding,
                },
                register_interface::ObjectField {
                    name: "maxUploadBytes".into(),
                    value: &max_upload_bytes_binding,
                },
                register_interface::ObjectField {
                    name: "maxUploadIntervalSeconds".into(),
                    value: &max_upload_interval_seconds_binding,
                },
                register_interface::ObjectField {
                    name: "maxUploadRecords".into(),
                    value: &max_upload_records_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "outputOptions".into(),
                    value: &output_options_binding,
                },
                register_interface::ObjectField {
                    name: "ownershipChallenge".into(),
                    value: &ownership_challenge_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "dataset".into(),
                },
                register_interface::ResultField {
                    name: "destinationConf".into(),
                },
                register_interface::ResultField {
                    name: "enabled".into(),
                },
                register_interface::ResultField {
                    name: "filter".into(),
                },
                register_interface::ResultField {
                    name: "frequency".into(),
                },
                register_interface::ResultField {
                    name: "kind".into(),
                },
                register_interface::ResultField {
                    name: "logpullOptions".into(),
                },
                register_interface::ResultField {
                    name: "maxUploadBytes".into(),
                },
                register_interface::ResultField {
                    name: "maxUploadIntervalSeconds".into(),
                },
                register_interface::ResultField {
                    name: "maxUploadRecords".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "outputOptions".into(),
                },
                register_interface::ResultField {
                    name: "ownershipChallenge".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        LogpushJobResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            dataset: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("dataset").unwrap(),
            ),
            destination_conf: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("destinationConf").unwrap(),
            ),
            enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enabled").unwrap(),
            ),
            filter: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("filter").unwrap(),
            ),
            frequency: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("frequency").unwrap(),
            ),
            kind: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("kind").unwrap(),
            ),
            logpull_options: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("logpullOptions").unwrap(),
            ),
            max_upload_bytes: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("maxUploadBytes").unwrap(),
            ),
            max_upload_interval_seconds: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("maxUploadIntervalSeconds").unwrap(),
            ),
            max_upload_records: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("maxUploadRecords").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            output_options: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("outputOptions").unwrap(),
            ),
            ownership_challenge: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("ownershipChallenge").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod logpush_ownership_challenge {
    //! Provides a resource which manages Cloudflare Logpush ownership
    //! challenges to use in a Logpush Job. On it's own, doesn't do much
    //! however this resource should be used in conjunction to create
    //! Logpush jobs.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = logpush_ownership_challenge::create(
    //!         "example",
    //!         LogpushOwnershipChallengeArgs::builder()
    //!             .destination_conf("s3://my-bucket-path?region=us-west-2")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct LogpushOwnershipChallengeArgs {
        /// The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#destination). **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub destination_conf: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct LogpushOwnershipChallengeResult {
        /// The account identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included. See [Logpush destination documentation](https://developers.cloudflare.com/logs/logpush/logpush-configuration-api/understanding-logpush-api/#destination). **Modifying this attribute will force creation of a new resource.**
        pub destination_conf: pulumi_wasm_rust::Output<String>,
        /// The filename of the ownership challenge which	contains the contents required for Logpush Job creation.
        pub ownership_challenge_filename: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Must provide only one of `account_id`, `zone_id`.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: LogpushOwnershipChallengeArgs,
    ) -> LogpushOwnershipChallengeResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let destination_conf_binding = args.destination_conf.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/logpushOwnershipChallenge:LogpushOwnershipChallenge"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "destinationConf".into(),
                    value: &destination_conf_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "destinationConf".into(),
                },
                register_interface::ResultField {
                    name: "ownershipChallengeFilename".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        LogpushOwnershipChallengeResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            destination_conf: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("destinationConf").unwrap(),
            ),
            ownership_challenge_filename: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("ownershipChallengeFilename").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod magic_firewall_ruleset {
    //! Magic Firewall is a network-level firewall to protect networks that are onboarded to Cloudflare's Magic Transit. This resource
    //! creates a root ruleset on the account level and contains one or more rules. Rules can be crafted in Wireshark syntax and
    //! are evaluated in order, with the first rule having the highest priority.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   example:
    //!     type: cloudflare:MagicFirewallRuleset
    //!     properties:
    //!       accountId: d41d8cd98f00b204e9800998ecf8427e
    //!       name: Magic Transit Ruleset
    //!       description: Global mitigations
    //!       rules:
    //!         - action: allow
    //!           expression: tcp.dstport in { 32768..65535 }
    //!           description: Allow TCP Ephemeral Ports
    //!           enabled: 'true'
    //!         - action: block
    //!           expression: ip.len >= 0
    //!           description: Block all
    //!           enabled: 'true'
    //! ```
    //!
    //! ## Import
    //!
    //! An existing Magic Firewall Ruleset can be imported using the account ID and ruleset ID
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/magicFirewallRuleset:MagicFirewallRuleset example d41d8cd98f00b204e9800998ecf8427e/cb029e245cfdd66dc8d2e570d5dd3322
    //! ```
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct MagicFirewallRulesetArgs {
        /// The ID of the account where the ruleset is being created.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// A note that can be used to annotate the rule.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The name of the ruleset.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        #[builder(into, default)]
        pub rules: pulumi_wasm_rust::Output<
            Option<Vec<std::collections::HashMap<String, String>>>,
        >,
    }
    #[allow(dead_code)]
    pub struct MagicFirewallRulesetResult {
        /// The ID of the account where the ruleset is being created.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// A note that can be used to annotate the rule.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The name of the ruleset.
        pub name: pulumi_wasm_rust::Output<String>,
        pub rules: pulumi_wasm_rust::Output<
            Option<Vec<std::collections::HashMap<String, String>>>,
        >,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: MagicFirewallRulesetArgs,
    ) -> MagicFirewallRulesetResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let description_binding = args.description.get_inner();
        let name_binding = args.name.get_inner();
        let rules_binding = args.rules.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/magicFirewallRuleset:MagicFirewallRuleset".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "rules".into(),
                    value: &rules_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "rules".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        MagicFirewallRulesetResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            rules: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("rules").unwrap(),
            ),
        }
    }
}
pub mod magic_wan_gre_tunnel {
    //! Provides a resource, that manages GRE tunnels for Magic Transit.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = magic_wan_gre_tunnel::create(
    //!         "example",
    //!         MagicWanGreTunnelArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .cloudflare_gre_endpoint("203.0.113.2")
    //!             .customer_gre_endpoint("203.0.113.1")
    //!             .description("Tunnel for ISP X")
    //!             .health_check_enabled(true)
    //!             .health_check_target("203.0.113.1")
    //!             .health_check_type("reply")
    //!             .interface_address("192.0.2.0/31")
    //!             .mtu(1476)
    //!             .name("GRE_1")
    //!             .ttl(64)
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/magicWanGreTunnel:MagicWanGreTunnel example <account_id>/<tunnel_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct MagicWanGreTunnelArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The IP address assigned to the Cloudflare side of the GRE tunnel.
        #[builder(into)]
        pub cloudflare_gre_endpoint: pulumi_wasm_rust::Output<String>,
        /// The IP address assigned to the customer side of the GRE tunnel.
        #[builder(into)]
        pub customer_gre_endpoint: pulumi_wasm_rust::Output<String>,
        /// Description of the GRE tunnel intent.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies if ICMP tunnel health checks are enabled.
        #[builder(into, default)]
        pub health_check_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The IP address of the customer endpoint that will receive tunnel health checks.
        #[builder(into, default)]
        pub health_check_target: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies the ICMP echo type for the health check. Available values: `request`, `reply`.
        #[builder(into, default)]
        pub health_check_type: pulumi_wasm_rust::Output<Option<String>>,
        /// 31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.
        #[builder(into)]
        pub interface_address: pulumi_wasm_rust::Output<String>,
        /// Maximum Transmission Unit (MTU) in bytes for the GRE tunnel.
        #[builder(into, default)]
        pub mtu: pulumi_wasm_rust::Output<Option<i32>>,
        /// Name of the GRE tunnel.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// Time To Live (TTL) in number of hops of the GRE tunnel.
        #[builder(into, default)]
        pub ttl: pulumi_wasm_rust::Output<Option<i32>>,
    }
    #[allow(dead_code)]
    pub struct MagicWanGreTunnelResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The IP address assigned to the Cloudflare side of the GRE tunnel.
        pub cloudflare_gre_endpoint: pulumi_wasm_rust::Output<String>,
        /// The IP address assigned to the customer side of the GRE tunnel.
        pub customer_gre_endpoint: pulumi_wasm_rust::Output<String>,
        /// Description of the GRE tunnel intent.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies if ICMP tunnel health checks are enabled.
        pub health_check_enabled: pulumi_wasm_rust::Output<bool>,
        /// The IP address of the customer endpoint that will receive tunnel health checks.
        pub health_check_target: pulumi_wasm_rust::Output<String>,
        /// Specifies the ICMP echo type for the health check. Available values: `request`, `reply`.
        pub health_check_type: pulumi_wasm_rust::Output<String>,
        /// 31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.
        pub interface_address: pulumi_wasm_rust::Output<String>,
        /// Maximum Transmission Unit (MTU) in bytes for the GRE tunnel.
        pub mtu: pulumi_wasm_rust::Output<i32>,
        /// Name of the GRE tunnel.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Time To Live (TTL) in number of hops of the GRE tunnel.
        pub ttl: pulumi_wasm_rust::Output<i32>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: MagicWanGreTunnelArgs) -> MagicWanGreTunnelResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let cloudflare_gre_endpoint_binding = args.cloudflare_gre_endpoint.get_inner();
        let customer_gre_endpoint_binding = args.customer_gre_endpoint.get_inner();
        let description_binding = args.description.get_inner();
        let health_check_enabled_binding = args.health_check_enabled.get_inner();
        let health_check_target_binding = args.health_check_target.get_inner();
        let health_check_type_binding = args.health_check_type.get_inner();
        let interface_address_binding = args.interface_address.get_inner();
        let mtu_binding = args.mtu.get_inner();
        let name_binding = args.name.get_inner();
        let ttl_binding = args.ttl.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/magicWanGreTunnel:MagicWanGreTunnel".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "cloudflareGreEndpoint".into(),
                    value: &cloudflare_gre_endpoint_binding,
                },
                register_interface::ObjectField {
                    name: "customerGreEndpoint".into(),
                    value: &customer_gre_endpoint_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "healthCheckEnabled".into(),
                    value: &health_check_enabled_binding,
                },
                register_interface::ObjectField {
                    name: "healthCheckTarget".into(),
                    value: &health_check_target_binding,
                },
                register_interface::ObjectField {
                    name: "healthCheckType".into(),
                    value: &health_check_type_binding,
                },
                register_interface::ObjectField {
                    name: "interfaceAddress".into(),
                    value: &interface_address_binding,
                },
                register_interface::ObjectField {
                    name: "mtu".into(),
                    value: &mtu_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "ttl".into(),
                    value: &ttl_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "cloudflareGreEndpoint".into(),
                },
                register_interface::ResultField {
                    name: "customerGreEndpoint".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "healthCheckEnabled".into(),
                },
                register_interface::ResultField {
                    name: "healthCheckTarget".into(),
                },
                register_interface::ResultField {
                    name: "healthCheckType".into(),
                },
                register_interface::ResultField {
                    name: "interfaceAddress".into(),
                },
                register_interface::ResultField {
                    name: "mtu".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "ttl".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        MagicWanGreTunnelResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            cloudflare_gre_endpoint: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("cloudflareGreEndpoint").unwrap(),
            ),
            customer_gre_endpoint: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customerGreEndpoint").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            health_check_enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("healthCheckEnabled").unwrap(),
            ),
            health_check_target: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("healthCheckTarget").unwrap(),
            ),
            health_check_type: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("healthCheckType").unwrap(),
            ),
            interface_address: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("interfaceAddress").unwrap(),
            ),
            mtu: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("mtu").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            ttl: pulumi_wasm_rust::__private::into_domain(hashmap.remove("ttl").unwrap()),
        }
    }
}
pub mod magic_wan_ipsec_tunnel {
    //! Provides a resource, that manages IPsec tunnels for Magic Transit.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = magic_wan_ipsec_tunnel::create(
    //!         "example",
    //!         MagicWanIpsecTunnelArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .allow_null_cipher(false)
    //!             .cloudflare_endpoint("203.0.113.1")
    //!             .customer_endpoint("203.0.113.1")
    //!             .description("Tunnel for ISP X")
    //!             .health_check_enabled(true)
    //!             .health_check_target("203.0.113.1")
    //!             .health_check_type("reply")
    //!             .interface_address("192.0.2.0/31")
    //!             .name("IPsec_1")
    //!             .psk("asdf12341234")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/magicWanIpsecTunnel:MagicWanIpsecTunnel example <account_id>/<tunnel_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct MagicWanIpsecTunnelArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies if this tunnel may use a null cipher (ENCR_NULL) in Phase 2. Defaults to `false`.
        #[builder(into, default)]
        pub allow_null_cipher: pulumi_wasm_rust::Output<Option<bool>>,
        /// IP address assigned to the Cloudflare side of the IPsec tunnel.
        #[builder(into)]
        pub cloudflare_endpoint: pulumi_wasm_rust::Output<String>,
        /// IP address assigned to the customer side of the IPsec tunnel.
        #[builder(into)]
        pub customer_endpoint: pulumi_wasm_rust::Output<String>,
        /// An optional description of the IPsec tunnel.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// `remote_id` in the form of a fqdn. This value is generated by cloudflare.
        #[builder(into, default)]
        pub fqdn_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies the direction for the health check. Available values: `unidirectional`, `bidirectional` Default: `unidirectional`.
        #[builder(into, default)]
        pub health_check_direction: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies if ICMP tunnel health checks are enabled. Default: `true`.
        #[builder(into, default)]
        pub health_check_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Specifies the ICMP rate for the health check. Available values: `low`, `mid`, `high` Default: `mid`.
        #[builder(into, default)]
        pub health_check_rate: pulumi_wasm_rust::Output<Option<String>>,
        /// The IP address of the customer endpoint that will receive tunnel health checks. Default: `<customer_gre_endpoint>`.
        #[builder(into, default)]
        pub health_check_target: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies the ICMP echo type for the health check (`request` or `reply`). Available values: `request`, `reply` Default: `reply`.
        #[builder(into, default)]
        pub health_check_type: pulumi_wasm_rust::Output<Option<String>>,
        /// `remote_id` as a hex string. This value is generated by cloudflare.
        #[builder(into, default)]
        pub hex_id: pulumi_wasm_rust::Output<Option<String>>,
        /// 31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.
        #[builder(into)]
        pub interface_address: pulumi_wasm_rust::Output<String>,
        /// Name of the IPsec tunnel.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// Pre shared key to be used with the IPsec tunnel. If left unset, it will be autogenerated.
        #[builder(into, default)]
        pub psk: pulumi_wasm_rust::Output<Option<String>>,
        /// ID to be used while setting up the IPsec tunnel. This value is generated by cloudflare.
        #[builder(into, default)]
        pub remote_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies if replay protection is enabled. Defaults to `false`.
        #[builder(into, default)]
        pub replay_protection: pulumi_wasm_rust::Output<Option<bool>>,
        /// `remote_id` in the form of an email address. This value is generated by cloudflare.
        #[builder(into, default)]
        pub user_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct MagicWanIpsecTunnelResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Specifies if this tunnel may use a null cipher (ENCR_NULL) in Phase 2. Defaults to `false`.
        pub allow_null_cipher: pulumi_wasm_rust::Output<Option<bool>>,
        /// IP address assigned to the Cloudflare side of the IPsec tunnel.
        pub cloudflare_endpoint: pulumi_wasm_rust::Output<String>,
        /// IP address assigned to the customer side of the IPsec tunnel.
        pub customer_endpoint: pulumi_wasm_rust::Output<String>,
        /// An optional description of the IPsec tunnel.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// `remote_id` in the form of a fqdn. This value is generated by cloudflare.
        pub fqdn_id: pulumi_wasm_rust::Output<String>,
        /// Specifies the direction for the health check. Available values: `unidirectional`, `bidirectional` Default: `unidirectional`.
        pub health_check_direction: pulumi_wasm_rust::Output<String>,
        /// Specifies if ICMP tunnel health checks are enabled. Default: `true`.
        pub health_check_enabled: pulumi_wasm_rust::Output<bool>,
        /// Specifies the ICMP rate for the health check. Available values: `low`, `mid`, `high` Default: `mid`.
        pub health_check_rate: pulumi_wasm_rust::Output<String>,
        /// The IP address of the customer endpoint that will receive tunnel health checks. Default: `<customer_gre_endpoint>`.
        pub health_check_target: pulumi_wasm_rust::Output<String>,
        /// Specifies the ICMP echo type for the health check (`request` or `reply`). Available values: `request`, `reply` Default: `reply`.
        pub health_check_type: pulumi_wasm_rust::Output<String>,
        /// `remote_id` as a hex string. This value is generated by cloudflare.
        pub hex_id: pulumi_wasm_rust::Output<String>,
        /// 31-bit prefix (/31 in CIDR notation) supporting 2 hosts, one for each side of the tunnel.
        pub interface_address: pulumi_wasm_rust::Output<String>,
        /// Name of the IPsec tunnel.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Pre shared key to be used with the IPsec tunnel. If left unset, it will be autogenerated.
        pub psk: pulumi_wasm_rust::Output<String>,
        /// ID to be used while setting up the IPsec tunnel. This value is generated by cloudflare.
        pub remote_id: pulumi_wasm_rust::Output<String>,
        /// Specifies if replay protection is enabled. Defaults to `false`.
        pub replay_protection: pulumi_wasm_rust::Output<Option<bool>>,
        /// `remote_id` in the form of an email address. This value is generated by cloudflare.
        pub user_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: MagicWanIpsecTunnelArgs,
    ) -> MagicWanIpsecTunnelResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let allow_null_cipher_binding = args.allow_null_cipher.get_inner();
        let cloudflare_endpoint_binding = args.cloudflare_endpoint.get_inner();
        let customer_endpoint_binding = args.customer_endpoint.get_inner();
        let description_binding = args.description.get_inner();
        let fqdn_id_binding = args.fqdn_id.get_inner();
        let health_check_direction_binding = args.health_check_direction.get_inner();
        let health_check_enabled_binding = args.health_check_enabled.get_inner();
        let health_check_rate_binding = args.health_check_rate.get_inner();
        let health_check_target_binding = args.health_check_target.get_inner();
        let health_check_type_binding = args.health_check_type.get_inner();
        let hex_id_binding = args.hex_id.get_inner();
        let interface_address_binding = args.interface_address.get_inner();
        let name_binding = args.name.get_inner();
        let psk_binding = args.psk.get_inner();
        let remote_id_binding = args.remote_id.get_inner();
        let replay_protection_binding = args.replay_protection.get_inner();
        let user_id_binding = args.user_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/magicWanIpsecTunnel:MagicWanIpsecTunnel".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "allowNullCipher".into(),
                    value: &allow_null_cipher_binding,
                },
                register_interface::ObjectField {
                    name: "cloudflareEndpoint".into(),
                    value: &cloudflare_endpoint_binding,
                },
                register_interface::ObjectField {
                    name: "customerEndpoint".into(),
                    value: &customer_endpoint_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "fqdnId".into(),
                    value: &fqdn_id_binding,
                },
                register_interface::ObjectField {
                    name: "healthCheckDirection".into(),
                    value: &health_check_direction_binding,
                },
                register_interface::ObjectField {
                    name: "healthCheckEnabled".into(),
                    value: &health_check_enabled_binding,
                },
                register_interface::ObjectField {
                    name: "healthCheckRate".into(),
                    value: &health_check_rate_binding,
                },
                register_interface::ObjectField {
                    name: "healthCheckTarget".into(),
                    value: &health_check_target_binding,
                },
                register_interface::ObjectField {
                    name: "healthCheckType".into(),
                    value: &health_check_type_binding,
                },
                register_interface::ObjectField {
                    name: "hexId".into(),
                    value: &hex_id_binding,
                },
                register_interface::ObjectField {
                    name: "interfaceAddress".into(),
                    value: &interface_address_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "psk".into(),
                    value: &psk_binding,
                },
                register_interface::ObjectField {
                    name: "remoteId".into(),
                    value: &remote_id_binding,
                },
                register_interface::ObjectField {
                    name: "replayProtection".into(),
                    value: &replay_protection_binding,
                },
                register_interface::ObjectField {
                    name: "userId".into(),
                    value: &user_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "allowNullCipher".into(),
                },
                register_interface::ResultField {
                    name: "cloudflareEndpoint".into(),
                },
                register_interface::ResultField {
                    name: "customerEndpoint".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "fqdnId".into(),
                },
                register_interface::ResultField {
                    name: "healthCheckDirection".into(),
                },
                register_interface::ResultField {
                    name: "healthCheckEnabled".into(),
                },
                register_interface::ResultField {
                    name: "healthCheckRate".into(),
                },
                register_interface::ResultField {
                    name: "healthCheckTarget".into(),
                },
                register_interface::ResultField {
                    name: "healthCheckType".into(),
                },
                register_interface::ResultField {
                    name: "hexId".into(),
                },
                register_interface::ResultField {
                    name: "interfaceAddress".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "psk".into(),
                },
                register_interface::ResultField {
                    name: "remoteId".into(),
                },
                register_interface::ResultField {
                    name: "replayProtection".into(),
                },
                register_interface::ResultField {
                    name: "userId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        MagicWanIpsecTunnelResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            allow_null_cipher: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("allowNullCipher").unwrap(),
            ),
            cloudflare_endpoint: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("cloudflareEndpoint").unwrap(),
            ),
            customer_endpoint: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customerEndpoint").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            fqdn_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("fqdnId").unwrap(),
            ),
            health_check_direction: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("healthCheckDirection").unwrap(),
            ),
            health_check_enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("healthCheckEnabled").unwrap(),
            ),
            health_check_rate: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("healthCheckRate").unwrap(),
            ),
            health_check_target: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("healthCheckTarget").unwrap(),
            ),
            health_check_type: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("healthCheckType").unwrap(),
            ),
            hex_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("hexId").unwrap(),
            ),
            interface_address: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("interfaceAddress").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            psk: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("psk").unwrap(),
            ),
            remote_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("remoteId").unwrap(),
            ),
            replay_protection: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("replayProtection").unwrap(),
            ),
            user_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("userId").unwrap(),
            ),
        }
    }
}
pub mod magic_wan_static_route {
    //! Provides a resource, that manages Cloudflare static routes for Magic
    //! Transit or Magic WAN. Static routes are used to route traffic
    //! through GRE tunnels.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = magic_wan_static_route::create(
    //!         "example",
    //!         MagicWanStaticRouteArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .colo_names(vec!["den01",])
    //!             .colo_regions(vec!["APAC",])
    //!             .description("New route for new prefix 192.0.2.0/24")
    //!             .nexthop("10.0.0.0")
    //!             .prefix("192.0.2.0/24")
    //!             .priority(100)
    //!             .weight(10)
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/magicWanStaticRoute:MagicWanStaticRoute example <account_id>/<static_route_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct MagicWanStaticRouteArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// List of Cloudflare colocation regions for this static route.
        #[builder(into, default)]
        pub colo_names: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of Cloudflare colocation names for this static route.
        #[builder(into, default)]
        pub colo_regions: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Description of the static route.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The nexthop IP address where traffic will be routed to.
        #[builder(into)]
        pub nexthop: pulumi_wasm_rust::Output<String>,
        /// Your network prefix using CIDR notation.
        #[builder(into)]
        pub prefix: pulumi_wasm_rust::Output<String>,
        /// The priority for the static route.
        #[builder(into)]
        pub priority: pulumi_wasm_rust::Output<i32>,
        /// The optional weight for ECMP routes. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub weight: pulumi_wasm_rust::Output<Option<i32>>,
    }
    #[allow(dead_code)]
    pub struct MagicWanStaticRouteResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// List of Cloudflare colocation regions for this static route.
        pub colo_names: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of Cloudflare colocation names for this static route.
        pub colo_regions: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Description of the static route.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The nexthop IP address where traffic will be routed to.
        pub nexthop: pulumi_wasm_rust::Output<String>,
        /// Your network prefix using CIDR notation.
        pub prefix: pulumi_wasm_rust::Output<String>,
        /// The priority for the static route.
        pub priority: pulumi_wasm_rust::Output<i32>,
        /// The optional weight for ECMP routes. **Modifying this attribute will force creation of a new resource.**
        pub weight: pulumi_wasm_rust::Output<Option<i32>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: MagicWanStaticRouteArgs,
    ) -> MagicWanStaticRouteResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let colo_names_binding = args.colo_names.get_inner();
        let colo_regions_binding = args.colo_regions.get_inner();
        let description_binding = args.description.get_inner();
        let nexthop_binding = args.nexthop.get_inner();
        let prefix_binding = args.prefix.get_inner();
        let priority_binding = args.priority.get_inner();
        let weight_binding = args.weight.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/magicWanStaticRoute:MagicWanStaticRoute".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "coloNames".into(),
                    value: &colo_names_binding,
                },
                register_interface::ObjectField {
                    name: "coloRegions".into(),
                    value: &colo_regions_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "nexthop".into(),
                    value: &nexthop_binding,
                },
                register_interface::ObjectField {
                    name: "prefix".into(),
                    value: &prefix_binding,
                },
                register_interface::ObjectField {
                    name: "priority".into(),
                    value: &priority_binding,
                },
                register_interface::ObjectField {
                    name: "weight".into(),
                    value: &weight_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "coloNames".into(),
                },
                register_interface::ResultField {
                    name: "coloRegions".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "nexthop".into(),
                },
                register_interface::ResultField {
                    name: "prefix".into(),
                },
                register_interface::ResultField {
                    name: "priority".into(),
                },
                register_interface::ResultField {
                    name: "weight".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        MagicWanStaticRouteResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            colo_names: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("coloNames").unwrap(),
            ),
            colo_regions: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("coloRegions").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            nexthop: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("nexthop").unwrap(),
            ),
            prefix: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("prefix").unwrap(),
            ),
            priority: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("priority").unwrap(),
            ),
            weight: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("weight").unwrap(),
            ),
        }
    }
}
pub mod managed_headers {
    //! The [Cloudflare Managed Headers](https://developers.cloudflare.com/rules/transform/managed-transforms/)
    //! allows you to add or remove some predefined headers to one's
    //! requests or origin responses.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = managed_headers::create(
    //!         "example",
    //!         ManagedHeadersArgs::builder()
    //!             .managed_request_headers(
    //!                 vec![
    //!                     ManagedHeadersManagedRequestHeader::builder().enabled(true)
    //!                     .id("add_true_client_ip_headers").build_struct(),
    //!                 ],
    //!             )
    //!             .managed_response_headers(
    //!                 vec![
    //!                     ManagedHeadersManagedResponseHeader::builder().enabled(true)
    //!                     .id("remove_x-powered-by_header").build_struct(),
    //!                 ],
    //!             )
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ManagedHeadersArgs {
        /// The list of managed request headers.
        #[builder(into, default)]
        pub managed_request_headers: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ManagedHeadersManagedRequestHeader>>,
        >,
        /// The list of managed response headers.
        #[builder(into, default)]
        pub managed_response_headers: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ManagedHeadersManagedResponseHeader>>,
        >,
        /// The zone identifier to target for the resource.
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ManagedHeadersResult {
        /// The list of managed request headers.
        pub managed_request_headers: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ManagedHeadersManagedRequestHeader>>,
        >,
        /// The list of managed response headers.
        pub managed_response_headers: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ManagedHeadersManagedResponseHeader>>,
        >,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: ManagedHeadersArgs) -> ManagedHeadersResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let managed_request_headers_binding = args.managed_request_headers.get_inner();
        let managed_response_headers_binding = args.managed_response_headers.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/managedHeaders:ManagedHeaders".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "managedRequestHeaders".into(),
                    value: &managed_request_headers_binding,
                },
                register_interface::ObjectField {
                    name: "managedResponseHeaders".into(),
                    value: &managed_response_headers_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "managedRequestHeaders".into(),
                },
                register_interface::ResultField {
                    name: "managedResponseHeaders".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ManagedHeadersResult {
            managed_request_headers: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("managedRequestHeaders").unwrap(),
            ),
            managed_response_headers: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("managedResponseHeaders").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod mtls_certificate {
    //! Provides a Cloudflare mTLS certificate resource. These certificates may be used with mTLS enabled Cloudflare services.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = mtls_certificate::create(
    //!         "example",
    //!         MtlsCertificateArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .ca(true)
    //!             .certificates(
    //!                 "-----BEGIN CERTIFICATE-----\nMIIDmDCCAoCgAwIBAgIUKTOAZNj...i4JhqeoTewsxndhDDE\n-----END CERTIFICATE-----",
    //!             )
    //!             .name("example")
    //!             .private_key(
    //!                 "-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQE...1IS3EnQRrz6WMYA=\n-----END PRIVATE KEY-----",
    //!             )
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/mtlsCertificate:MtlsCertificate example <account_id>/<mtls_certificate_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct MtlsCertificateArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether this is a CA or leaf certificate. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub ca: pulumi_wasm_rust::Output<bool>,
        /// Certificate you intend to use with mTLS-enabled services. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub certificates: pulumi_wasm_rust::Output<String>,
        /// Optional unique name for the certificate. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub name: pulumi_wasm_rust::Output<Option<String>>,
        /// The certificate's private key. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub private_key: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct MtlsCertificateResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether this is a CA or leaf certificate. **Modifying this attribute will force creation of a new resource.**
        pub ca: pulumi_wasm_rust::Output<bool>,
        /// Certificate you intend to use with mTLS-enabled services. **Modifying this attribute will force creation of a new resource.**
        pub certificates: pulumi_wasm_rust::Output<String>,
        /// **Modifying this attribute will force creation of a new resource.**
        pub expires_on: pulumi_wasm_rust::Output<String>,
        /// **Modifying this attribute will force creation of a new resource.**
        pub issuer: pulumi_wasm_rust::Output<String>,
        /// Optional unique name for the certificate. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<Option<String>>,
        /// The certificate's private key. **Modifying this attribute will force creation of a new resource.**
        pub private_key: pulumi_wasm_rust::Output<Option<String>>,
        /// **Modifying this attribute will force creation of a new resource.**
        pub serial_number: pulumi_wasm_rust::Output<String>,
        /// **Modifying this attribute will force creation of a new resource.**
        pub signature: pulumi_wasm_rust::Output<String>,
        /// **Modifying this attribute will force creation of a new resource.**
        pub uploaded_on: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: MtlsCertificateArgs) -> MtlsCertificateResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let ca_binding = args.ca.get_inner();
        let certificates_binding = args.certificates.get_inner();
        let name_binding = args.name.get_inner();
        let private_key_binding = args.private_key.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/mtlsCertificate:MtlsCertificate".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "ca".into(),
                    value: &ca_binding,
                },
                register_interface::ObjectField {
                    name: "certificates".into(),
                    value: &certificates_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "privateKey".into(),
                    value: &private_key_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "ca".into(),
                },
                register_interface::ResultField {
                    name: "certificates".into(),
                },
                register_interface::ResultField {
                    name: "expiresOn".into(),
                },
                register_interface::ResultField {
                    name: "issuer".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "privateKey".into(),
                },
                register_interface::ResultField {
                    name: "serialNumber".into(),
                },
                register_interface::ResultField {
                    name: "signature".into(),
                },
                register_interface::ResultField {
                    name: "uploadedOn".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        MtlsCertificateResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            ca: pulumi_wasm_rust::__private::into_domain(hashmap.remove("ca").unwrap()),
            certificates: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("certificates").unwrap(),
            ),
            expires_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("expiresOn").unwrap(),
            ),
            issuer: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("issuer").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            private_key: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("privateKey").unwrap(),
            ),
            serial_number: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("serialNumber").unwrap(),
            ),
            signature: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("signature").unwrap(),
            ),
            uploaded_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("uploadedOn").unwrap(),
            ),
        }
    }
}
pub mod notification_policy {
    //! Provides a resource, that manages a notification policy for
    //! Cloudflare's products. The delivery mechanisms supported are email,
    //! webhooks, and PagerDuty.
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/notificationPolicy:NotificationPolicy example <account_id>/<policy_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct NotificationPolicyArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The event type that will trigger the dispatch of a notification. See the developer documentation for descriptions of [available alert types](https://developers.cloudflare.com/fundamentals/notifications/notification-available/). Available values: `advanced_http_alert_error`, `access_custom_certificate_expiration_type`, `advanced_ddos_attack_l4_alert`, `advanced_ddos_attack_l7_alert`, `bgp_hijack_notification`, `billing_usage_alert`, `block_notification_block_removed`, `block_notification_new_block`, `block_notification_review_rejected`, `brand_protection_alert`, `brand_protection_digest`, `clickhouse_alert_fw_anomaly`, `clickhouse_alert_fw_ent_anomaly`, `custom_ssl_certificate_event_type`, `dedicated_ssl_certificate_event_type`, `dos_attack_l4`, `dos_attack_l7`, `expiring_service_token_alert`, `failing_logpush_job_disabled_alert`, `fbm_auto_advertisement`, `fbm_dosd_attack`, `fbm_volumetric_attack`, `health_check_status_notification`, `hostname_aop_custom_certificate_expiration_type`, `http_alert_edge_error`, `http_alert_origin_error`, `image_notification`, `incident_alert`, `load_balancing_health_alert`, `load_balancing_pool_enablement_alert`, `logo_match_alert`, `magic_tunnel_health_check_event`, `maintenance_event_notification`, `mtls_certificate_store_certificate_expiration_type`, `pages_event_alert`, `radar_notification`, `real_origin_monitoring`, `scriptmonitor_alert_new_code_change_detections`, `scriptmonitor_alert_new_hosts`, `scriptmonitor_alert_new_malicious_hosts`, `scriptmonitor_alert_new_malicious_scripts`, `scriptmonitor_alert_new_malicious_url`, `scriptmonitor_alert_new_max_length_resource_url`, `scriptmonitor_alert_new_resources`, `secondary_dns_all_primaries_failing`, `secondary_dns_primaries_failing`, `secondary_dns_zone_successfully_updated`, `secondary_dns_zone_validation_warning`, `sentinel_alert`, `stream_live_notifications`, `traffic_anomalies_alert`, `tunnel_health_event`, `tunnel_update_event`, `universal_ssl_event_type`, `web_analytics_metrics_update`, `weekly_account_overview`, `workers_alert`, `zone_aop_custom_certificate_expiration_type`.
        #[builder(into)]
        pub alert_type: pulumi_wasm_rust::Output<String>,
        /// Description of the notification policy.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The email ID to which the notification should be dispatched.
        #[builder(into, default)]
        pub email_integrations: pulumi_wasm_rust::Output<
            Option<Vec<super::types::NotificationPolicyEmailIntegration>>,
        >,
        /// The status of the notification policy.
        #[builder(into)]
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// An optional nested block of filters that applies to the selected `alert_type`. A key-value map that specifies the type of filter and the values to match against (refer to the alert type block for available fields).
        #[builder(into, default)]
        pub filters: pulumi_wasm_rust::Output<
            Option<super::types::NotificationPolicyFilters>,
        >,
        /// The name of the notification policy.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The unique ID of a configured pagerduty endpoint to which the notification should be dispatched.
        #[builder(into, default)]
        pub pagerduty_integrations: pulumi_wasm_rust::Output<
            Option<Vec<super::types::NotificationPolicyPagerdutyIntegration>>,
        >,
        /// The unique ID of a configured webhooks endpoint to which the notification should be dispatched.
        #[builder(into, default)]
        pub webhooks_integrations: pulumi_wasm_rust::Output<
            Option<Vec<super::types::NotificationPolicyWebhooksIntegration>>,
        >,
    }
    #[allow(dead_code)]
    pub struct NotificationPolicyResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The event type that will trigger the dispatch of a notification. See the developer documentation for descriptions of [available alert types](https://developers.cloudflare.com/fundamentals/notifications/notification-available/). Available values: `advanced_http_alert_error`, `access_custom_certificate_expiration_type`, `advanced_ddos_attack_l4_alert`, `advanced_ddos_attack_l7_alert`, `bgp_hijack_notification`, `billing_usage_alert`, `block_notification_block_removed`, `block_notification_new_block`, `block_notification_review_rejected`, `brand_protection_alert`, `brand_protection_digest`, `clickhouse_alert_fw_anomaly`, `clickhouse_alert_fw_ent_anomaly`, `custom_ssl_certificate_event_type`, `dedicated_ssl_certificate_event_type`, `dos_attack_l4`, `dos_attack_l7`, `expiring_service_token_alert`, `failing_logpush_job_disabled_alert`, `fbm_auto_advertisement`, `fbm_dosd_attack`, `fbm_volumetric_attack`, `health_check_status_notification`, `hostname_aop_custom_certificate_expiration_type`, `http_alert_edge_error`, `http_alert_origin_error`, `image_notification`, `incident_alert`, `load_balancing_health_alert`, `load_balancing_pool_enablement_alert`, `logo_match_alert`, `magic_tunnel_health_check_event`, `maintenance_event_notification`, `mtls_certificate_store_certificate_expiration_type`, `pages_event_alert`, `radar_notification`, `real_origin_monitoring`, `scriptmonitor_alert_new_code_change_detections`, `scriptmonitor_alert_new_hosts`, `scriptmonitor_alert_new_malicious_hosts`, `scriptmonitor_alert_new_malicious_scripts`, `scriptmonitor_alert_new_malicious_url`, `scriptmonitor_alert_new_max_length_resource_url`, `scriptmonitor_alert_new_resources`, `secondary_dns_all_primaries_failing`, `secondary_dns_primaries_failing`, `secondary_dns_zone_successfully_updated`, `secondary_dns_zone_validation_warning`, `sentinel_alert`, `stream_live_notifications`, `traffic_anomalies_alert`, `tunnel_health_event`, `tunnel_update_event`, `universal_ssl_event_type`, `web_analytics_metrics_update`, `weekly_account_overview`, `workers_alert`, `zone_aop_custom_certificate_expiration_type`.
        pub alert_type: pulumi_wasm_rust::Output<String>,
        /// When the notification policy was created.
        pub created: pulumi_wasm_rust::Output<String>,
        /// Description of the notification policy.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The email ID to which the notification should be dispatched.
        pub email_integrations: pulumi_wasm_rust::Output<
            Option<Vec<super::types::NotificationPolicyEmailIntegration>>,
        >,
        /// The status of the notification policy.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// An optional nested block of filters that applies to the selected `alert_type`. A key-value map that specifies the type of filter and the values to match against (refer to the alert type block for available fields).
        pub filters: pulumi_wasm_rust::Output<
            Option<super::types::NotificationPolicyFilters>,
        >,
        /// When the notification policy was last modified.
        pub modified: pulumi_wasm_rust::Output<String>,
        /// The name of the notification policy.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The unique ID of a configured pagerduty endpoint to which the notification should be dispatched.
        pub pagerduty_integrations: pulumi_wasm_rust::Output<
            Option<Vec<super::types::NotificationPolicyPagerdutyIntegration>>,
        >,
        /// The unique ID of a configured webhooks endpoint to which the notification should be dispatched.
        pub webhooks_integrations: pulumi_wasm_rust::Output<
            Option<Vec<super::types::NotificationPolicyWebhooksIntegration>>,
        >,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: NotificationPolicyArgs) -> NotificationPolicyResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let alert_type_binding = args.alert_type.get_inner();
        let description_binding = args.description.get_inner();
        let email_integrations_binding = args.email_integrations.get_inner();
        let enabled_binding = args.enabled.get_inner();
        let filters_binding = args.filters.get_inner();
        let name_binding = args.name.get_inner();
        let pagerduty_integrations_binding = args.pagerduty_integrations.get_inner();
        let webhooks_integrations_binding = args.webhooks_integrations.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/notificationPolicy:NotificationPolicy".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "alertType".into(),
                    value: &alert_type_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "emailIntegrations".into(),
                    value: &email_integrations_binding,
                },
                register_interface::ObjectField {
                    name: "enabled".into(),
                    value: &enabled_binding,
                },
                register_interface::ObjectField {
                    name: "filters".into(),
                    value: &filters_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "pagerdutyIntegrations".into(),
                    value: &pagerduty_integrations_binding,
                },
                register_interface::ObjectField {
                    name: "webhooksIntegrations".into(),
                    value: &webhooks_integrations_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "alertType".into(),
                },
                register_interface::ResultField {
                    name: "created".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "emailIntegrations".into(),
                },
                register_interface::ResultField {
                    name: "enabled".into(),
                },
                register_interface::ResultField {
                    name: "filters".into(),
                },
                register_interface::ResultField {
                    name: "modified".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "pagerdutyIntegrations".into(),
                },
                register_interface::ResultField {
                    name: "webhooksIntegrations".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        NotificationPolicyResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            alert_type: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("alertType").unwrap(),
            ),
            created: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("created").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            email_integrations: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("emailIntegrations").unwrap(),
            ),
            enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enabled").unwrap(),
            ),
            filters: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("filters").unwrap(),
            ),
            modified: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("modified").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            pagerduty_integrations: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("pagerdutyIntegrations").unwrap(),
            ),
            webhooks_integrations: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("webhooksIntegrations").unwrap(),
            ),
        }
    }
}
pub mod notification_policy_webhooks {
    //! Provides a resource, that manages a webhook destination. These destinations can be tied to the notification policies created for Cloudflare's products.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = notification_policy_webhooks::create(
    //!         "example",
    //!         NotificationPolicyWebhooksArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .name("Webhooks destination")
    //!             .secret("my-secret")
    //!             .url("https://example.com")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/notificationPolicyWebhooks:NotificationPolicyWebhooks example <account_id>/<notification_webhook_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct NotificationPolicyWebhooksArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the webhook destination.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// An optional secret can be provided that will be passed in the `cf-webhook-auth` header when dispatching a webhook notification. Secrets are not returned in any API response body. Refer to the [documentation](https://api.cloudflare.com/#notification-webhooks-create-webhook) for more details.
        #[builder(into, default)]
        pub secret: pulumi_wasm_rust::Output<Option<String>>,
        /// The URL of the webhook destinations. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub url: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct NotificationPolicyWebhooksResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Timestamp of when the notification webhook was created.
        pub created_at: pulumi_wasm_rust::Output<String>,
        /// Timestamp of when the notification webhook last failed.
        pub last_failure: pulumi_wasm_rust::Output<String>,
        /// Timestamp of when the notification webhook was last successful.
        pub last_success: pulumi_wasm_rust::Output<String>,
        /// The name of the webhook destination.
        pub name: pulumi_wasm_rust::Output<String>,
        /// An optional secret can be provided that will be passed in the `cf-webhook-auth` header when dispatching a webhook notification. Secrets are not returned in any API response body. Refer to the [documentation](https://api.cloudflare.com/#notification-webhooks-create-webhook) for more details.
        pub secret: pulumi_wasm_rust::Output<Option<String>>,
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The URL of the webhook destinations. **Modifying this attribute will force creation of a new resource.**
        pub url: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: NotificationPolicyWebhooksArgs,
    ) -> NotificationPolicyWebhooksResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let name_binding = args.name.get_inner();
        let secret_binding = args.secret.get_inner();
        let url_binding = args.url.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/notificationPolicyWebhooks:NotificationPolicyWebhooks"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "secret".into(),
                    value: &secret_binding,
                },
                register_interface::ObjectField {
                    name: "url".into(),
                    value: &url_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "createdAt".into(),
                },
                register_interface::ResultField {
                    name: "lastFailure".into(),
                },
                register_interface::ResultField {
                    name: "lastSuccess".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "secret".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
                register_interface::ResultField {
                    name: "url".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        NotificationPolicyWebhooksResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            created_at: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("createdAt").unwrap(),
            ),
            last_failure: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("lastFailure").unwrap(),
            ),
            last_success: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("lastSuccess").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            secret: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("secret").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
            url: pulumi_wasm_rust::__private::into_domain(hashmap.remove("url").unwrap()),
        }
    }
}
pub mod observatory_scheduled_test {
    //! Provides a Cloudflare Observatory Scheduled Test resource.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = observatory_scheduled_test::create(
    //!         "example",
    //!         ObservatoryScheduledTestArgs::builder()
    //!             .frequency("WEEKLY")
    //!             .region("us-central1")
    //!             .url("example.com")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/observatoryScheduledTest:ObservatoryScheduledTest example <zone_id>:<url>:<region>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ObservatoryScheduledTestArgs {
        /// The frequency to run the test. Available values: `DAILY`, `WEEKLY`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub frequency: pulumi_wasm_rust::Output<String>,
        /// The region to run the test in. Available values: `us-central1`, `us-east1`, `us-east4`, `us-south1`, `us-west1`, `southamerica-east1`, `europe-north1`, `europe-southwest1`, `europe-west1`, `europe-west2`, `europe-west3`, `europe-west4`, `europe-west8`, `europe-west9`, `asia-east1`, `asia-south1`, `asia-southeast1`, `me-west1`, `australia-southeast1`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub region: pulumi_wasm_rust::Output<String>,
        /// The page to run the test on. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub url: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ObservatoryScheduledTestResult {
        /// The frequency to run the test. Available values: `DAILY`, `WEEKLY`. **Modifying this attribute will force creation of a new resource.**
        pub frequency: pulumi_wasm_rust::Output<String>,
        /// The region to run the test in. Available values: `us-central1`, `us-east1`, `us-east4`, `us-south1`, `us-west1`, `southamerica-east1`, `europe-north1`, `europe-southwest1`, `europe-west1`, `europe-west2`, `europe-west3`, `europe-west4`, `europe-west8`, `europe-west9`, `asia-east1`, `asia-south1`, `asia-southeast1`, `me-west1`, `australia-southeast1`. **Modifying this attribute will force creation of a new resource.**
        pub region: pulumi_wasm_rust::Output<String>,
        /// The page to run the test on. **Modifying this attribute will force creation of a new resource.**
        pub url: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ObservatoryScheduledTestArgs,
    ) -> ObservatoryScheduledTestResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let frequency_binding = args.frequency.get_inner();
        let region_binding = args.region.get_inner();
        let url_binding = args.url.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/observatoryScheduledTest:ObservatoryScheduledTest"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "frequency".into(),
                    value: &frequency_binding,
                },
                register_interface::ObjectField {
                    name: "region".into(),
                    value: &region_binding,
                },
                register_interface::ObjectField {
                    name: "url".into(),
                    value: &url_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "frequency".into(),
                },
                register_interface::ResultField {
                    name: "region".into(),
                },
                register_interface::ResultField {
                    name: "url".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ObservatoryScheduledTestResult {
            frequency: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("frequency").unwrap(),
            ),
            region: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("region").unwrap(),
            ),
            url: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("url").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod origin_ca_certificate {
    //! Provides a Cloudflare Origin CA certificate used to protect traffic to your origin without involving a third party Certificate Authority.
    //!
    //! > Since v3.32.0
    //!    all authentication schemes are supported for managing Origin CA certificates.
    //!    Versions prior to v3.32.0 will still need to use `api_user_service_key`.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   example:
    //!     type: tls:privateKey
    //!     properties:
    //!       algorithm: RSA
    //!   exampleCertRequest:
    //!     type: tls:certRequest
    //!     name: example
    //!     properties:
    //!       privateKeyPem: ${example.privateKeyPem}
    //!       subject:
    //!         - commonName:
    //!           organization: Terraform Test
    //!   exampleOriginCaCertificate:
    //!     type: cloudflare:OriginCaCertificate
    //!     name: example
    //!     properties:
    //!       csr: ${exampleCertRequest.certRequestPem}
    //!       hostnames:
    //!         - example.com
    //!       requestType: origin-rsa
    //!       requestedValidity: 7
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/originCaCertificate:OriginCaCertificate example <certificate_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct OriginCaCertificateArgs {
        /// The Certificate Signing Request. Must be newline-encoded. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub csr: pulumi_wasm_rust::Output<String>,
        /// A list of hostnames or wildcard names bound to the certificate. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub hostnames: pulumi_wasm_rust::Output<Vec<String>>,
        #[builder(into, default)]
        pub min_days_for_renewal: pulumi_wasm_rust::Output<Option<i32>>,
        /// The signature type desired on the certificate. Available values: `origin-rsa`, `origin-ecc`, `keyless-certificate`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub request_type: pulumi_wasm_rust::Output<String>,
        /// The number of days for which the certificate should be valid. Available values: `7`, `30`, `90`, `365`, `730`, `1095`, `5475`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub requested_validity: pulumi_wasm_rust::Output<Option<i32>>,
    }
    #[allow(dead_code)]
    pub struct OriginCaCertificateResult {
        /// The Origin CA certificate.
        pub certificate: pulumi_wasm_rust::Output<String>,
        /// The Certificate Signing Request. Must be newline-encoded. **Modifying this attribute will force creation of a new resource.**
        pub csr: pulumi_wasm_rust::Output<String>,
        /// The datetime when the certificate will expire.
        pub expires_on: pulumi_wasm_rust::Output<String>,
        /// A list of hostnames or wildcard names bound to the certificate. **Modifying this attribute will force creation of a new resource.**
        pub hostnames: pulumi_wasm_rust::Output<Vec<String>>,
        pub min_days_for_renewal: pulumi_wasm_rust::Output<Option<i32>>,
        /// The signature type desired on the certificate. Available values: `origin-rsa`, `origin-ecc`, `keyless-certificate`. **Modifying this attribute will force creation of a new resource.**
        pub request_type: pulumi_wasm_rust::Output<String>,
        /// The number of days for which the certificate should be valid. Available values: `7`, `30`, `90`, `365`, `730`, `1095`, `5475`. **Modifying this attribute will force creation of a new resource.**
        pub requested_validity: pulumi_wasm_rust::Output<i32>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: OriginCaCertificateArgs,
    ) -> OriginCaCertificateResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let csr_binding = args.csr.get_inner();
        let hostnames_binding = args.hostnames.get_inner();
        let min_days_for_renewal_binding = args.min_days_for_renewal.get_inner();
        let request_type_binding = args.request_type.get_inner();
        let requested_validity_binding = args.requested_validity.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/originCaCertificate:OriginCaCertificate".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "csr".into(),
                    value: &csr_binding,
                },
                register_interface::ObjectField {
                    name: "hostnames".into(),
                    value: &hostnames_binding,
                },
                register_interface::ObjectField {
                    name: "minDaysForRenewal".into(),
                    value: &min_days_for_renewal_binding,
                },
                register_interface::ObjectField {
                    name: "requestType".into(),
                    value: &request_type_binding,
                },
                register_interface::ObjectField {
                    name: "requestedValidity".into(),
                    value: &requested_validity_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "certificate".into(),
                },
                register_interface::ResultField {
                    name: "csr".into(),
                },
                register_interface::ResultField {
                    name: "expiresOn".into(),
                },
                register_interface::ResultField {
                    name: "hostnames".into(),
                },
                register_interface::ResultField {
                    name: "minDaysForRenewal".into(),
                },
                register_interface::ResultField {
                    name: "requestType".into(),
                },
                register_interface::ResultField {
                    name: "requestedValidity".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        OriginCaCertificateResult {
            certificate: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("certificate").unwrap(),
            ),
            csr: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("csr").unwrap(),
            ),
            expires_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("expiresOn").unwrap(),
            ),
            hostnames: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("hostnames").unwrap(),
            ),
            min_days_for_renewal: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("minDaysForRenewal").unwrap(),
            ),
            request_type: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("requestType").unwrap(),
            ),
            requested_validity: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("requestedValidity").unwrap(),
            ),
        }
    }
}
pub mod page_rule {
    //! Provides a Cloudflare page rule resource.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let foobar = page_rule::create(
    //!         "foobar",
    //!         PageRuleArgs::builder()
    //!             .actions(
    //!                 PageRuleActions::builder()
    //!                     .emailObfuscation("on")
    //!                     .minifies(
    //!                         vec![
    //!                             PageRuleActionsMinify::builder().css("on").html("off")
    //!                             .js("on").build_struct(),
    //!                         ],
    //!                     )
    //!                     .ssl("flexible")
    //!                     .build_struct(),
    //!             )
    //!             .priority(1)
    //!             .target("sub.${cloudflareZone}/page")
    //!             .zone_id("${cloudflareZoneId}")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! Page rules can be imported using a composite ID formed of zone ID and page rule ID, e.g.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/pageRule:PageRule default d41d8cd98f00b204e9800998ecf8427e/ch8374ftwdghsif43
    //! ```
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct PageRuleArgs {
        /// The actions taken by the page rule, options given below.
        #[builder(into)]
        pub actions: pulumi_wasm_rust::Output<super::types::PageRuleActions>,
        /// The priority of the page rule among others for this target, the higher the number the higher the priority as per [API documentation](https://api.cloudflare.com/#page-rules-for-a-zone-create-page-rule).
        #[builder(into, default)]
        pub priority: pulumi_wasm_rust::Output<Option<i32>>,
        /// Whether the page rule is active or disabled.
        #[builder(into, default)]
        pub status: pulumi_wasm_rust::Output<Option<String>>,
        /// The URL pattern to target with the page rule.
        #[builder(into)]
        pub target: pulumi_wasm_rust::Output<String>,
        /// The DNS zone ID to which the page rule should be added.
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct PageRuleResult {
        /// The actions taken by the page rule, options given below.
        pub actions: pulumi_wasm_rust::Output<super::types::PageRuleActions>,
        /// The priority of the page rule among others for this target, the higher the number the higher the priority as per [API documentation](https://api.cloudflare.com/#page-rules-for-a-zone-create-page-rule).
        pub priority: pulumi_wasm_rust::Output<Option<i32>>,
        /// Whether the page rule is active or disabled.
        pub status: pulumi_wasm_rust::Output<Option<String>>,
        /// The URL pattern to target with the page rule.
        pub target: pulumi_wasm_rust::Output<String>,
        /// The DNS zone ID to which the page rule should be added.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: PageRuleArgs) -> PageRuleResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let actions_binding = args.actions.get_inner();
        let priority_binding = args.priority.get_inner();
        let status_binding = args.status.get_inner();
        let target_binding = args.target.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/pageRule:PageRule".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "actions".into(),
                    value: &actions_binding,
                },
                register_interface::ObjectField {
                    name: "priority".into(),
                    value: &priority_binding,
                },
                register_interface::ObjectField {
                    name: "status".into(),
                    value: &status_binding,
                },
                register_interface::ObjectField {
                    name: "target".into(),
                    value: &target_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "actions".into(),
                },
                register_interface::ResultField {
                    name: "priority".into(),
                },
                register_interface::ResultField {
                    name: "status".into(),
                },
                register_interface::ResultField {
                    name: "target".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        PageRuleResult {
            actions: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("actions").unwrap(),
            ),
            priority: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("priority").unwrap(),
            ),
            status: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("status").unwrap(),
            ),
            target: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("target").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod pages_domain {
    //! Provides a resource for managing Cloudflare Pages domains.
    //!
    //! > A DNS record for the domain is not automatically created. You need to create
    //!    a `cloudflare.Record` resource for the domain you want to use.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   my-domain:
    //!     type: cloudflare:PagesDomain
    //!     properties:
    //!       accountId: f037e56e89293a057740de681ac9abbe
    //!       projectName: my-example-project
    //!       domain: example.com
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/pagesDomain:PagesDomain example <account_id>/<project_name>/<domain-name>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct PagesDomainArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Custom domain. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub domain: pulumi_wasm_rust::Output<String>,
        /// Name of the Pages Project. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub project_name: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct PagesDomainResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Custom domain. **Modifying this attribute will force creation of a new resource.**
        pub domain: pulumi_wasm_rust::Output<String>,
        /// Name of the Pages Project. **Modifying this attribute will force creation of a new resource.**
        pub project_name: pulumi_wasm_rust::Output<String>,
        /// Status of the custom domain.
        pub status: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: PagesDomainArgs) -> PagesDomainResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let domain_binding = args.domain.get_inner();
        let project_name_binding = args.project_name.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/pagesDomain:PagesDomain".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "domain".into(),
                    value: &domain_binding,
                },
                register_interface::ObjectField {
                    name: "projectName".into(),
                    value: &project_name_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "domain".into(),
                },
                register_interface::ResultField {
                    name: "projectName".into(),
                },
                register_interface::ResultField {
                    name: "status".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        PagesDomainResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            domain: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("domain").unwrap(),
            ),
            project_name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("projectName").unwrap(),
            ),
            status: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("status").unwrap(),
            ),
        }
    }
}
pub mod pages_project {
    //! Provides a resource which manages Cloudflare Pages projects.
    //!
    //! > If you are using a `source` block configuration, you must first have a
    //!    connected GitHub or GitLab account connected to Cloudflare. See the
    //!    [Getting Started with Pages] documentation on how to link your accounts.
    //!
    //! ## Import
    //!
    //! !> It is not possible to import a pages project with secret environment variables. If you have a secret environment variable, you must remove it from your project before importing it.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/pagesProject:PagesProject example <account_id>/<project_name>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct PagesProjectArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Configuration for the project build process. Read more about the build configuration in the [developer documentation](https://developers.cloudflare.com/pages/platform/build-configuration).
        #[builder(into, default)]
        pub build_config: pulumi_wasm_rust::Output<
            Option<super::types::PagesProjectBuildConfig>,
        >,
        /// Configuration for deployments in a project.
        #[builder(into, default)]
        pub deployment_configs: pulumi_wasm_rust::Output<
            Option<super::types::PagesProjectDeploymentConfigs>,
        >,
        /// Name of the project.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The name of the branch that is used for the production environment.
        #[builder(into)]
        pub production_branch: pulumi_wasm_rust::Output<String>,
        /// Configuration for the project source. Read more about the source configuration in the [developer documentation](https://developers.cloudflare.com/pages/platform/branch-build-controls/).
        #[builder(into, default)]
        pub source: pulumi_wasm_rust::Output<Option<super::types::PagesProjectSource>>,
    }
    #[allow(dead_code)]
    pub struct PagesProjectResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Configuration for the project build process. Read more about the build configuration in the [developer documentation](https://developers.cloudflare.com/pages/platform/build-configuration).
        pub build_config: pulumi_wasm_rust::Output<
            Option<super::types::PagesProjectBuildConfig>,
        >,
        /// When the project was created.
        pub created_on: pulumi_wasm_rust::Output<String>,
        /// Configuration for deployments in a project.
        pub deployment_configs: pulumi_wasm_rust::Output<
            super::types::PagesProjectDeploymentConfigs,
        >,
        /// A list of associated custom domains for the project.
        pub domains: pulumi_wasm_rust::Output<Vec<String>>,
        /// Name of the project.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The name of the branch that is used for the production environment.
        pub production_branch: pulumi_wasm_rust::Output<String>,
        /// Configuration for the project source. Read more about the source configuration in the [developer documentation](https://developers.cloudflare.com/pages/platform/branch-build-controls/).
        pub source: pulumi_wasm_rust::Output<Option<super::types::PagesProjectSource>>,
        /// The Cloudflare subdomain associated with the project.
        pub subdomain: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: PagesProjectArgs) -> PagesProjectResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let build_config_binding = args.build_config.get_inner();
        let deployment_configs_binding = args.deployment_configs.get_inner();
        let name_binding = args.name.get_inner();
        let production_branch_binding = args.production_branch.get_inner();
        let source_binding = args.source.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/pagesProject:PagesProject".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "buildConfig".into(),
                    value: &build_config_binding,
                },
                register_interface::ObjectField {
                    name: "deploymentConfigs".into(),
                    value: &deployment_configs_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "productionBranch".into(),
                    value: &production_branch_binding,
                },
                register_interface::ObjectField {
                    name: "source".into(),
                    value: &source_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "buildConfig".into(),
                },
                register_interface::ResultField {
                    name: "createdOn".into(),
                },
                register_interface::ResultField {
                    name: "deploymentConfigs".into(),
                },
                register_interface::ResultField {
                    name: "domains".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "productionBranch".into(),
                },
                register_interface::ResultField {
                    name: "source".into(),
                },
                register_interface::ResultField {
                    name: "subdomain".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        PagesProjectResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            build_config: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("buildConfig").unwrap(),
            ),
            created_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("createdOn").unwrap(),
            ),
            deployment_configs: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("deploymentConfigs").unwrap(),
            ),
            domains: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("domains").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            production_branch: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("productionBranch").unwrap(),
            ),
            source: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("source").unwrap(),
            ),
            subdomain: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("subdomain").unwrap(),
            ),
        }
    }
}
pub mod queue {
    //! Provides the ability to manage Cloudflare Workers Queue features.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = queue::create(
    //!         "example",
    //!         QueueArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .name("my-queue")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/queue:Queue example <account_id>/<queue_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct QueueArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the queue.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct QueueResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the queue.
        pub name: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: QueueArgs) -> QueueResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let name_binding = args.name.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/queue:Queue".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        QueueResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
        }
    }
}
pub mod r_2_bucket {
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = r_2_bucket::create(
    //!         "example",
    //!         R2BucketArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .location("enam")
    //!             .name("terraform-bucket")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! > Available location values can be found in the [R2 documentation](https://developers.cloudflare.com/r2/reference/data-location/#available-hints).
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/r2Bucket:R2Bucket default <account id>/<bucket name>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct R2BucketArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The location hint of the R2 bucket. Available values: `WNAM`, `ENAM`, `WEUR`, `EEUR`, `APAC`
        #[builder(into, default)]
        pub location: pulumi_wasm_rust::Output<Option<String>>,
        /// The name of the R2 bucket.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct R2BucketResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The location hint of the R2 bucket. Available values: `WNAM`, `ENAM`, `WEUR`, `EEUR`, `APAC`
        pub location: pulumi_wasm_rust::Output<String>,
        /// The name of the R2 bucket.
        pub name: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: R2BucketArgs) -> R2BucketResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let location_binding = args.location.get_inner();
        let name_binding = args.name.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/r2Bucket:R2Bucket".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "location".into(),
                    value: &location_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "location".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        R2BucketResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            location: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("location").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
        }
    }
}
pub mod rate_limit {
    //! Provides a Cloudflare rate limit resource for a given zone. This can
    //! be used to limit the traffic you receive zone-wide, or matching more
    //! specific types of requests/responses.
    //!
    //! > `cloudflare.RateLimit` is in a deprecation phase until January 15th, 2025.
    //!   During this time period, this resource is still
    //!   fully supported but you are strongly advised to move to the
    //!   `cloudflare.Ruleset` resource. Full details can be found in the
    //!   developer documentation.
    //!
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   example:
    //!     type: cloudflare:RateLimit
    //!     properties:
    //!       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
    //!       threshold: 2000
    //!       period: 2
    //!       match:
    //!         request:
    //!           urlPattern: ${cloudflareZone}/*
    //!           schemes:
    //!             - HTTP
    //!             - HTTPS
    //!           methods:
    //!             - GET
    //!             - POST
    //!             - PUT
    //!             - DELETE
    //!             - PATCH
    //!             - HEAD
    //!         response:
    //!           statuses:
    //!             - 200
    //!             - 201
    //!             - 202
    //!             - 301
    //!             - 429
    //!           originTraffic: false
    //!           headers:
    //!             - name: Host
    //!               op: eq
    //!               value: localhost
    //!             - name: X-Example
    //!               op: ne
    //!               value: my-example
    //!       action:
    //!         mode: simulate
    //!         timeout: 43200
    //!         response:
    //!           contentType: text/plain
    //!           body: custom response body
    //!       correlate:
    //!         by: nat
    //!       disabled: false
    //!       description: example rate limit for a zone
    //!       bypassUrlPatterns:
    //!         - example.com/bypass1
    //!         - example.com/bypass2
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/rateLimit:RateLimit example <zone_id>/<rate_limit_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct RateLimitArgs {
        /// The action to be performed when the threshold of matched traffic within the period defined is exceeded.
        #[builder(into)]
        pub action: pulumi_wasm_rust::Output<super::types::RateLimitAction>,
        #[builder(into, default)]
        pub bypass_url_patterns: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Determines how rate limiting is applied. By default if not specified, rate limiting applies to the clients IP address.
        #[builder(into, default)]
        pub correlate: pulumi_wasm_rust::Output<
            Option<super::types::RateLimitCorrelate>,
        >,
        /// A note that you can use to describe the reason for a rate limit. This value is sanitized and all tags are removed.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether this ratelimit is currently disabled. Defaults to `false`.
        #[builder(into, default)]
        pub disabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Determines which traffic the rate limit counts towards the threshold. By default matches all traffic in the zone.
        #[builder(into, default)]
        pub match_: pulumi_wasm_rust::Output<Option<super::types::RateLimitMatch>>,
        /// The time in seconds to count matching traffic. If the count exceeds threshold within this period the action will be performed.
        #[builder(into)]
        pub period: pulumi_wasm_rust::Output<i32>,
        /// The threshold that triggers the rate limit mitigations, combine with period.
        #[builder(into)]
        pub threshold: pulumi_wasm_rust::Output<i32>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct RateLimitResult {
        /// The action to be performed when the threshold of matched traffic within the period defined is exceeded.
        pub action: pulumi_wasm_rust::Output<super::types::RateLimitAction>,
        pub bypass_url_patterns: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Determines how rate limiting is applied. By default if not specified, rate limiting applies to the clients IP address.
        pub correlate: pulumi_wasm_rust::Output<
            Option<super::types::RateLimitCorrelate>,
        >,
        /// A note that you can use to describe the reason for a rate limit. This value is sanitized and all tags are removed.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether this ratelimit is currently disabled. Defaults to `false`.
        pub disabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Determines which traffic the rate limit counts towards the threshold. By default matches all traffic in the zone.
        pub match_: pulumi_wasm_rust::Output<super::types::RateLimitMatch>,
        /// The time in seconds to count matching traffic. If the count exceeds threshold within this period the action will be performed.
        pub period: pulumi_wasm_rust::Output<i32>,
        /// The threshold that triggers the rate limit mitigations, combine with period.
        pub threshold: pulumi_wasm_rust::Output<i32>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: RateLimitArgs) -> RateLimitResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let action_binding = args.action.get_inner();
        let bypass_url_patterns_binding = args.bypass_url_patterns.get_inner();
        let correlate_binding = args.correlate.get_inner();
        let description_binding = args.description.get_inner();
        let disabled_binding = args.disabled.get_inner();
        let match__binding = args.match_.get_inner();
        let period_binding = args.period.get_inner();
        let threshold_binding = args.threshold.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/rateLimit:RateLimit".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "action".into(),
                    value: &action_binding,
                },
                register_interface::ObjectField {
                    name: "bypassUrlPatterns".into(),
                    value: &bypass_url_patterns_binding,
                },
                register_interface::ObjectField {
                    name: "correlate".into(),
                    value: &correlate_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "disabled".into(),
                    value: &disabled_binding,
                },
                register_interface::ObjectField {
                    name: "match".into(),
                    value: &match__binding,
                },
                register_interface::ObjectField {
                    name: "period".into(),
                    value: &period_binding,
                },
                register_interface::ObjectField {
                    name: "threshold".into(),
                    value: &threshold_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "action".into(),
                },
                register_interface::ResultField {
                    name: "bypassUrlPatterns".into(),
                },
                register_interface::ResultField {
                    name: "correlate".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "disabled".into(),
                },
                register_interface::ResultField {
                    name: "match".into(),
                },
                register_interface::ResultField {
                    name: "period".into(),
                },
                register_interface::ResultField {
                    name: "threshold".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        RateLimitResult {
            action: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("action").unwrap(),
            ),
            bypass_url_patterns: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("bypassUrlPatterns").unwrap(),
            ),
            correlate: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("correlate").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            disabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("disabled").unwrap(),
            ),
            match_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("match").unwrap(),
            ),
            period: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("period").unwrap(),
            ),
            threshold: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("threshold").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod record {
    //! Provides a Cloudflare record resource.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let _sipTls = record::create(
    //!         "_sipTls",
    //!         RecordArgs::builder()
    //!             .data(
    //!                 RecordData::builder()
    //!                     .name("terraform-srv")
    //!                     .port(443)
    //!                     .priority(0)
    //!                     .proto("_tls")
    //!                     .service("_sip")
    //!                     .target("example.com")
    //!                     .weight(0)
    //!                     .build_struct(),
    //!             )
    //!             .name("_sip._tls")
    //!             .type_("SRV")
    //!             .zone_id("${cloudflareZoneId}")
    //!             .build_struct(),
    //!     );
    //!     let example = record::create(
    //!         "example",
    //!         RecordArgs::builder()
    //!             .content("192.0.2.1")
    //!             .name("terraform")
    //!             .ttl(3600)
    //!             .type_("A")
    //!             .zone_id("${cloudflareZoneId}")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/record:Record example <zone_id>/<record_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct RecordArgs {
        #[builder(into, default)]
        pub allow_overwrite: pulumi_wasm_rust::Output<Option<bool>>,
        /// Comments or notes about the DNS record. This field has no effect on DNS responses.
        #[builder(into, default)]
        pub comment: pulumi_wasm_rust::Output<Option<String>>,
        /// The content of the record. Must provide only one of `data`, `content`, `value`.
        #[builder(into, default)]
        pub content: pulumi_wasm_rust::Output<Option<String>>,
        /// Map of attributes that constitute the record value. Must provide only one of `data`, `content`, `value`.
        #[builder(into, default)]
        pub data: pulumi_wasm_rust::Output<Option<super::types::RecordData>>,
        /// The name of the record. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The priority of the record.
        #[builder(into, default)]
        pub priority: pulumi_wasm_rust::Output<Option<i32>>,
        /// Whether the record gets Cloudflare's origin protection.
        #[builder(into, default)]
        pub proxied: pulumi_wasm_rust::Output<Option<bool>>,
        /// Custom tags for the DNS record.
        #[builder(into, default)]
        pub tags: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The TTL of the record.
        #[builder(into, default)]
        pub ttl: pulumi_wasm_rust::Output<Option<i32>>,
        /// The type of the record. Available values: `A`, `AAAA`, `CAA`, `CNAME`, `TXT`, `SRV`, `LOC`, `MX`, `NS`, `SPF`, `CERT`, `DNSKEY`, `DS`, `NAPTR`, `SMIMEA`, `SSHFP`, `TLSA`, `URI`, `PTR`, `HTTPS`, `SVCB`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The value of the record. Must provide only one of `data`, `content`, `value`.
        #[builder(into, default)]
        pub value: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct RecordResult {
        pub allow_overwrite: pulumi_wasm_rust::Output<Option<bool>>,
        /// Comments or notes about the DNS record. This field has no effect on DNS responses.
        pub comment: pulumi_wasm_rust::Output<Option<String>>,
        /// The content of the record. Must provide only one of `data`, `content`, `value`.
        pub content: pulumi_wasm_rust::Output<String>,
        /// The RFC3339 timestamp of when the record was created.
        pub created_on: pulumi_wasm_rust::Output<String>,
        /// Map of attributes that constitute the record value. Must provide only one of `data`, `content`, `value`.
        pub data: pulumi_wasm_rust::Output<Option<super::types::RecordData>>,
        /// The FQDN of the record.
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// A key-value map of string metadata Cloudflare associates with the record.
        pub metadata: pulumi_wasm_rust::Output<
            std::collections::HashMap<String, String>,
        >,
        /// The RFC3339 timestamp of when the record was last modified.
        pub modified_on: pulumi_wasm_rust::Output<String>,
        /// The name of the record. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
        /// The priority of the record.
        pub priority: pulumi_wasm_rust::Output<Option<i32>>,
        /// Shows whether this record can be proxied.
        pub proxiable: pulumi_wasm_rust::Output<bool>,
        /// Whether the record gets Cloudflare's origin protection.
        pub proxied: pulumi_wasm_rust::Output<Option<bool>>,
        /// Custom tags for the DNS record.
        pub tags: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The TTL of the record.
        pub ttl: pulumi_wasm_rust::Output<i32>,
        /// The type of the record. Available values: `A`, `AAAA`, `CAA`, `CNAME`, `TXT`, `SRV`, `LOC`, `MX`, `NS`, `SPF`, `CERT`, `DNSKEY`, `DS`, `NAPTR`, `SMIMEA`, `SSHFP`, `TLSA`, `URI`, `PTR`, `HTTPS`, `SVCB`. **Modifying this attribute will force creation of a new resource.**
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The value of the record. Must provide only one of `data`, `content`, `value`.
        pub value: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: RecordArgs) -> RecordResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let allow_overwrite_binding = args.allow_overwrite.get_inner();
        let comment_binding = args.comment.get_inner();
        let content_binding = args.content.get_inner();
        let data_binding = args.data.get_inner();
        let name_binding = args.name.get_inner();
        let priority_binding = args.priority.get_inner();
        let proxied_binding = args.proxied.get_inner();
        let tags_binding = args.tags.get_inner();
        let ttl_binding = args.ttl.get_inner();
        let type__binding = args.type_.get_inner();
        let value_binding = args.value.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/record:Record".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "allowOverwrite".into(),
                    value: &allow_overwrite_binding,
                },
                register_interface::ObjectField {
                    name: "comment".into(),
                    value: &comment_binding,
                },
                register_interface::ObjectField {
                    name: "content".into(),
                    value: &content_binding,
                },
                register_interface::ObjectField {
                    name: "data".into(),
                    value: &data_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "priority".into(),
                    value: &priority_binding,
                },
                register_interface::ObjectField {
                    name: "proxied".into(),
                    value: &proxied_binding,
                },
                register_interface::ObjectField {
                    name: "tags".into(),
                    value: &tags_binding,
                },
                register_interface::ObjectField {
                    name: "ttl".into(),
                    value: &ttl_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
                register_interface::ObjectField {
                    name: "value".into(),
                    value: &value_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "allowOverwrite".into(),
                },
                register_interface::ResultField {
                    name: "comment".into(),
                },
                register_interface::ResultField {
                    name: "content".into(),
                },
                register_interface::ResultField {
                    name: "createdOn".into(),
                },
                register_interface::ResultField {
                    name: "data".into(),
                },
                register_interface::ResultField {
                    name: "hostname".into(),
                },
                register_interface::ResultField {
                    name: "metadata".into(),
                },
                register_interface::ResultField {
                    name: "modifiedOn".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "priority".into(),
                },
                register_interface::ResultField {
                    name: "proxiable".into(),
                },
                register_interface::ResultField {
                    name: "proxied".into(),
                },
                register_interface::ResultField {
                    name: "tags".into(),
                },
                register_interface::ResultField {
                    name: "ttl".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
                register_interface::ResultField {
                    name: "value".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        RecordResult {
            allow_overwrite: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("allowOverwrite").unwrap(),
            ),
            comment: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("comment").unwrap(),
            ),
            content: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("content").unwrap(),
            ),
            created_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("createdOn").unwrap(),
            ),
            data: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("data").unwrap(),
            ),
            hostname: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("hostname").unwrap(),
            ),
            metadata: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("metadata").unwrap(),
            ),
            modified_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("modifiedOn").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            priority: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("priority").unwrap(),
            ),
            proxiable: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("proxiable").unwrap(),
            ),
            proxied: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("proxied").unwrap(),
            ),
            tags: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tags").unwrap(),
            ),
            ttl: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("ttl").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
            value: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("value").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod regional_hostname {
    //! Provides a Data Localization Suite Regional Hostname.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = record::create(
    //!         "example",
    //!         RecordArgs::builder()
    //!             .content("192.0.2.1")
    //!             .name("example.com")
    //!             .ttl(3600)
    //!             .type_("A")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //!     let exampleRegionalHostname = regional_hostname::create(
    //!         "exampleRegionalHostname",
    //!         RegionalHostnameArgs::builder()
    //!             .hostname("example.com")
    //!             .region_key("eu")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct RegionalHostnameArgs {
        /// The hostname to regionalize.
        #[builder(into)]
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// The region key. See [the full region list](https://developers.cloudflare.com/data-localization/regional-services/get-started/).
        #[builder(into)]
        pub region_key: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct RegionalHostnameResult {
        /// The RFC3339 timestamp of when the hostname was created.
        pub created_on: pulumi_wasm_rust::Output<String>,
        /// The hostname to regionalize.
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// The region key. See [the full region list](https://developers.cloudflare.com/data-localization/regional-services/get-started/).
        pub region_key: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: RegionalHostnameArgs) -> RegionalHostnameResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let hostname_binding = args.hostname.get_inner();
        let region_key_binding = args.region_key.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/regionalHostname:RegionalHostname".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "hostname".into(),
                    value: &hostname_binding,
                },
                register_interface::ObjectField {
                    name: "regionKey".into(),
                    value: &region_key_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "createdOn".into(),
                },
                register_interface::ResultField {
                    name: "hostname".into(),
                },
                register_interface::ResultField {
                    name: "regionKey".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        RegionalHostnameResult {
            created_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("createdOn").unwrap(),
            ),
            hostname: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("hostname").unwrap(),
            ),
            region_key: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("regionKey").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod regional_tiered_cache {
    //! Instructs Cloudflare to check a regional hub data center on the way to your upper tier.
    //! This can help improve performance for smart and custom tiered cache topologies.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = regional_tiered_cache::create(
    //!         "example",
    //!         RegionalTieredCacheArgs::builder()
    //!             .value("on")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/regionalTieredCache:RegionalTieredCache example <zone_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct RegionalTieredCacheArgs {
        /// Value of the Regional Tiered Cache zone setting.
        #[builder(into)]
        pub value: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct RegionalTieredCacheResult {
        /// Value of the Regional Tiered Cache zone setting.
        pub value: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: RegionalTieredCacheArgs,
    ) -> RegionalTieredCacheResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let value_binding = args.value.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/regionalTieredCache:RegionalTieredCache".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "value".into(),
                    value: &value_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "value".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        RegionalTieredCacheResult {
            value: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("value").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod risk_behavior {
    //! The [Risk Behavior](https://developers.cloudflare.com/cloudflare-one/insights/risk-score/) resource allows you to configure Cloudflare Risk Behaviors for an account.
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct RiskBehaviorArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Zero Trust risk behaviors configured on this account
        #[builder(into, default)]
        pub behaviors: pulumi_wasm_rust::Output<
            Option<Vec<super::types::RiskBehaviorBehavior>>,
        >,
    }
    #[allow(dead_code)]
    pub struct RiskBehaviorResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Zero Trust risk behaviors configured on this account
        pub behaviors: pulumi_wasm_rust::Output<
            Option<Vec<super::types::RiskBehaviorBehavior>>,
        >,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: RiskBehaviorArgs) -> RiskBehaviorResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let behaviors_binding = args.behaviors.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/riskBehavior:RiskBehavior".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "behaviors".into(),
                    value: &behaviors_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "behaviors".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        RiskBehaviorResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            behaviors: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("behaviors").unwrap(),
            ),
        }
    }
}
pub mod ruleset {
    //! The [Cloudflare Ruleset Engine](https://developers.cloudflare.com/firewall/cf-rulesets)
    //! allows you to create and deploy rules and rulesets.
    //!
    //! The engine syntax, inspired by the Wireshark Display Filter language, is the
    //! same syntax used in custom Firewall Rules. Cloudflare uses the Ruleset Engine
    //! in different products, allowing you to configure several products using the same
    //! basic syntax.
    //!
    //! ## Import
    //!
    //! Import an account scoped Ruleset configuration.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/ruleset:Ruleset example account/<account_id>/<ruleset_id>
    //! ```
    //!
    //! Import a zone scoped Ruleset configuration.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/ruleset:Ruleset example zone/<zone_id>/<ruleset_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct RulesetArgs {
        /// The account identifier to target for the resource.
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Brief summary of the ruleset and its intended use.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `zone`.
        #[builder(into)]
        pub kind: pulumi_wasm_rust::Output<String>,
        /// Name of the ruleset.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_sbfm`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.
        #[builder(into)]
        pub phase: pulumi_wasm_rust::Output<String>,
        /// List of rules to apply to the ruleset.
        #[builder(into, default)]
        pub rules: pulumi_wasm_rust::Output<Option<Vec<super::types::RulesetRule>>>,
        /// The zone identifier to target for the resource.
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct RulesetResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Brief summary of the ruleset and its intended use.
        pub description: pulumi_wasm_rust::Output<String>,
        /// Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `zone`.
        pub kind: pulumi_wasm_rust::Output<String>,
        /// Name of the ruleset.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_sbfm`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.
        pub phase: pulumi_wasm_rust::Output<String>,
        /// List of rules to apply to the ruleset.
        pub rules: pulumi_wasm_rust::Output<Option<Vec<super::types::RulesetRule>>>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: RulesetArgs) -> RulesetResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let description_binding = args.description.get_inner();
        let kind_binding = args.kind.get_inner();
        let name_binding = args.name.get_inner();
        let phase_binding = args.phase.get_inner();
        let rules_binding = args.rules.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/ruleset:Ruleset".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "kind".into(),
                    value: &kind_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "phase".into(),
                    value: &phase_binding,
                },
                register_interface::ObjectField {
                    name: "rules".into(),
                    value: &rules_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "kind".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "phase".into(),
                },
                register_interface::ResultField {
                    name: "rules".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        RulesetResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            kind: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("kind").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            phase: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("phase").unwrap(),
            ),
            rules: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("rules").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod spectrum_application {
    //! Provides a Cloudflare Spectrum Application. You can extend the power
    //! of Cloudflare's DDoS, TLS, and IP Firewall to your other TCP-based
    //! services.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   example:
    //!     type: cloudflare:SpectrumApplication
    //!     properties:
    //!       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
    //!       protocol: tcp/22
    //!       trafficType: direct
    //!       dns:
    //!         type: CNAME
    //!         name: ssh.example.com
    //!       originDirects:
    //!         - tcp://192.0.2.1:22
    //!       edgeIps:
    //!         type: static
    //!         ips:
    //!           - 203.0.113.1
    //!           - 203.0.113.2
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/spectrumApplication:SpectrumApplication example <zone_id>/<spectrum_application_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct SpectrumApplicationArgs {
        /// Enables Argo Smart Routing.
        #[builder(into, default)]
        pub argo_smart_routing: pulumi_wasm_rust::Output<Option<bool>>,
        /// The name and type of DNS record for the Spectrum application.
        #[builder(into)]
        pub dns: pulumi_wasm_rust::Output<super::types::SpectrumApplicationDns>,
        /// The anycast edge IP configuration for the hostname of this application.
        #[builder(into, default)]
        pub edge_ips: pulumi_wasm_rust::Output<
            Option<super::types::SpectrumApplicationEdgeIps>,
        >,
        /// Enables the IP Firewall for this application.
        #[builder(into, default)]
        pub ip_firewall: pulumi_wasm_rust::Output<Option<bool>>,
        /// A list of destination addresses to the origin. e.g. `tcp://192.0.2.1:22`.
        #[builder(into, default)]
        pub origin_directs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// A destination DNS addresses to the origin.
        #[builder(into, default)]
        pub origin_dns: pulumi_wasm_rust::Output<
            Option<super::types::SpectrumApplicationOriginDns>,
        >,
        /// Origin port to proxy traffice to. Conflicts with `origin_port_range`.
        #[builder(into, default)]
        pub origin_port: pulumi_wasm_rust::Output<Option<i32>>,
        /// Origin port range to proxy traffice to. When using a range, the protocol field must also specify a range, e.g. `tcp/22-23`. Conflicts with `origin_port`.
        #[builder(into, default)]
        pub origin_port_range: pulumi_wasm_rust::Output<
            Option<super::types::SpectrumApplicationOriginPortRange>,
        >,
        /// The port configuration at Cloudflare's edge. e.g. `tcp/22`.
        #[builder(into)]
        pub protocol: pulumi_wasm_rust::Output<String>,
        /// Enables a proxy protocol to the origin. Available values: `off`, `v1`, `v2`, `simple`.
        #[builder(into, default)]
        pub proxy_protocol: pulumi_wasm_rust::Output<Option<String>>,
        /// TLS configuration option for Cloudflare to connect to your origin. Available values: `off`, `flexible`, `full`, `strict`.
        #[builder(into, default)]
        pub tls: pulumi_wasm_rust::Output<Option<String>>,
        /// Sets application type. Available values: `direct`, `http`, `https`.
        #[builder(into, default)]
        pub traffic_type: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource.
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct SpectrumApplicationResult {
        /// Enables Argo Smart Routing.
        pub argo_smart_routing: pulumi_wasm_rust::Output<bool>,
        /// The name and type of DNS record for the Spectrum application.
        pub dns: pulumi_wasm_rust::Output<super::types::SpectrumApplicationDns>,
        /// The anycast edge IP configuration for the hostname of this application.
        pub edge_ips: pulumi_wasm_rust::Output<super::types::SpectrumApplicationEdgeIps>,
        /// Enables the IP Firewall for this application.
        pub ip_firewall: pulumi_wasm_rust::Output<bool>,
        /// A list of destination addresses to the origin. e.g. `tcp://192.0.2.1:22`.
        pub origin_directs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// A destination DNS addresses to the origin.
        pub origin_dns: pulumi_wasm_rust::Output<
            Option<super::types::SpectrumApplicationOriginDns>,
        >,
        /// Origin port to proxy traffice to. Conflicts with `origin_port_range`.
        pub origin_port: pulumi_wasm_rust::Output<Option<i32>>,
        /// Origin port range to proxy traffice to. When using a range, the protocol field must also specify a range, e.g. `tcp/22-23`. Conflicts with `origin_port`.
        pub origin_port_range: pulumi_wasm_rust::Output<
            Option<super::types::SpectrumApplicationOriginPortRange>,
        >,
        /// The port configuration at Cloudflare's edge. e.g. `tcp/22`.
        pub protocol: pulumi_wasm_rust::Output<String>,
        /// Enables a proxy protocol to the origin. Available values: `off`, `v1`, `v2`, `simple`.
        pub proxy_protocol: pulumi_wasm_rust::Output<String>,
        /// TLS configuration option for Cloudflare to connect to your origin. Available values: `off`, `flexible`, `full`, `strict`.
        pub tls: pulumi_wasm_rust::Output<String>,
        /// Sets application type. Available values: `direct`, `http`, `https`.
        pub traffic_type: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: SpectrumApplicationArgs,
    ) -> SpectrumApplicationResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let argo_smart_routing_binding = args.argo_smart_routing.get_inner();
        let dns_binding = args.dns.get_inner();
        let edge_ips_binding = args.edge_ips.get_inner();
        let ip_firewall_binding = args.ip_firewall.get_inner();
        let origin_directs_binding = args.origin_directs.get_inner();
        let origin_dns_binding = args.origin_dns.get_inner();
        let origin_port_binding = args.origin_port.get_inner();
        let origin_port_range_binding = args.origin_port_range.get_inner();
        let protocol_binding = args.protocol.get_inner();
        let proxy_protocol_binding = args.proxy_protocol.get_inner();
        let tls_binding = args.tls.get_inner();
        let traffic_type_binding = args.traffic_type.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/spectrumApplication:SpectrumApplication".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "argoSmartRouting".into(),
                    value: &argo_smart_routing_binding,
                },
                register_interface::ObjectField {
                    name: "dns".into(),
                    value: &dns_binding,
                },
                register_interface::ObjectField {
                    name: "edgeIps".into(),
                    value: &edge_ips_binding,
                },
                register_interface::ObjectField {
                    name: "ipFirewall".into(),
                    value: &ip_firewall_binding,
                },
                register_interface::ObjectField {
                    name: "originDirects".into(),
                    value: &origin_directs_binding,
                },
                register_interface::ObjectField {
                    name: "originDns".into(),
                    value: &origin_dns_binding,
                },
                register_interface::ObjectField {
                    name: "originPort".into(),
                    value: &origin_port_binding,
                },
                register_interface::ObjectField {
                    name: "originPortRange".into(),
                    value: &origin_port_range_binding,
                },
                register_interface::ObjectField {
                    name: "protocol".into(),
                    value: &protocol_binding,
                },
                register_interface::ObjectField {
                    name: "proxyProtocol".into(),
                    value: &proxy_protocol_binding,
                },
                register_interface::ObjectField {
                    name: "tls".into(),
                    value: &tls_binding,
                },
                register_interface::ObjectField {
                    name: "trafficType".into(),
                    value: &traffic_type_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "argoSmartRouting".into(),
                },
                register_interface::ResultField {
                    name: "dns".into(),
                },
                register_interface::ResultField {
                    name: "edgeIps".into(),
                },
                register_interface::ResultField {
                    name: "ipFirewall".into(),
                },
                register_interface::ResultField {
                    name: "originDirects".into(),
                },
                register_interface::ResultField {
                    name: "originDns".into(),
                },
                register_interface::ResultField {
                    name: "originPort".into(),
                },
                register_interface::ResultField {
                    name: "originPortRange".into(),
                },
                register_interface::ResultField {
                    name: "protocol".into(),
                },
                register_interface::ResultField {
                    name: "proxyProtocol".into(),
                },
                register_interface::ResultField {
                    name: "tls".into(),
                },
                register_interface::ResultField {
                    name: "trafficType".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        SpectrumApplicationResult {
            argo_smart_routing: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("argoSmartRouting").unwrap(),
            ),
            dns: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("dns").unwrap(),
            ),
            edge_ips: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("edgeIps").unwrap(),
            ),
            ip_firewall: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("ipFirewall").unwrap(),
            ),
            origin_directs: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("originDirects").unwrap(),
            ),
            origin_dns: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("originDns").unwrap(),
            ),
            origin_port: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("originPort").unwrap(),
            ),
            origin_port_range: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("originPortRange").unwrap(),
            ),
            protocol: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("protocol").unwrap(),
            ),
            proxy_protocol: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("proxyProtocol").unwrap(),
            ),
            tls: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tls").unwrap(),
            ),
            traffic_type: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("trafficType").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod split_tunnel {
    //! Provides a Cloudflare Split Tunnel resource. Split tunnels are used to either
    //! include or exclude lists of routes from the WARP client's tunnel.
    //!
    //! ## Import
    //!
    //! Split Tunnels for default device policies must use "default" as the policy ID.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/splitTunnel:SplitTunnel example <account_id>/<policy_id>/<mode>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct SplitTunnelArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The mode of the split tunnel policy. Available values: `include`, `exclude`.
        #[builder(into)]
        pub mode: pulumi_wasm_rust::Output<String>,
        /// The settings policy for which to configure this split tunnel policy.
        #[builder(into, default)]
        pub policy_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The value of the tunnel attributes.
        #[builder(into)]
        pub tunnels: pulumi_wasm_rust::Output<Vec<super::types::SplitTunnelTunnel>>,
    }
    #[allow(dead_code)]
    pub struct SplitTunnelResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The mode of the split tunnel policy. Available values: `include`, `exclude`.
        pub mode: pulumi_wasm_rust::Output<String>,
        /// The settings policy for which to configure this split tunnel policy.
        pub policy_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The value of the tunnel attributes.
        pub tunnels: pulumi_wasm_rust::Output<Vec<super::types::SplitTunnelTunnel>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: SplitTunnelArgs) -> SplitTunnelResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let mode_binding = args.mode.get_inner();
        let policy_id_binding = args.policy_id.get_inner();
        let tunnels_binding = args.tunnels.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/splitTunnel:SplitTunnel".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "mode".into(),
                    value: &mode_binding,
                },
                register_interface::ObjectField {
                    name: "policyId".into(),
                    value: &policy_id_binding,
                },
                register_interface::ObjectField {
                    name: "tunnels".into(),
                    value: &tunnels_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "mode".into(),
                },
                register_interface::ResultField {
                    name: "policyId".into(),
                },
                register_interface::ResultField {
                    name: "tunnels".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        SplitTunnelResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            mode: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("mode").unwrap(),
            ),
            policy_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("policyId").unwrap(),
            ),
            tunnels: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tunnels").unwrap(),
            ),
        }
    }
}
pub mod static_route {
    //! Provides a resource, that manages Cloudflare static routes for Magic
    //! Transit or Magic WAN. Static routes are used to route traffic
    //! through GRE tunnels.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = static_route::create(
    //!         "example",
    //!         StaticRouteArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .colo_names(vec!["den01",])
    //!             .colo_regions(vec!["APAC",])
    //!             .description("New route for new prefix 192.0.2.0/24")
    //!             .nexthop("10.0.0.0")
    //!             .prefix("192.0.2.0/24")
    //!             .priority(100)
    //!             .weight(10)
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/staticRoute:StaticRoute example <account_id>/<static_route_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct StaticRouteArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// List of Cloudflare colocation regions for this static route.
        #[builder(into, default)]
        pub colo_names: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of Cloudflare colocation names for this static route.
        #[builder(into, default)]
        pub colo_regions: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Description of the static route.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The nexthop IP address where traffic will be routed to.
        #[builder(into)]
        pub nexthop: pulumi_wasm_rust::Output<String>,
        /// Your network prefix using CIDR notation.
        #[builder(into)]
        pub prefix: pulumi_wasm_rust::Output<String>,
        /// The priority for the static route.
        #[builder(into)]
        pub priority: pulumi_wasm_rust::Output<i32>,
        /// The optional weight for ECMP routes. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub weight: pulumi_wasm_rust::Output<Option<i32>>,
    }
    #[allow(dead_code)]
    pub struct StaticRouteResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// List of Cloudflare colocation regions for this static route.
        pub colo_names: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of Cloudflare colocation names for this static route.
        pub colo_regions: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Description of the static route.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The nexthop IP address where traffic will be routed to.
        pub nexthop: pulumi_wasm_rust::Output<String>,
        /// Your network prefix using CIDR notation.
        pub prefix: pulumi_wasm_rust::Output<String>,
        /// The priority for the static route.
        pub priority: pulumi_wasm_rust::Output<i32>,
        /// The optional weight for ECMP routes. **Modifying this attribute will force creation of a new resource.**
        pub weight: pulumi_wasm_rust::Output<Option<i32>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: StaticRouteArgs) -> StaticRouteResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let colo_names_binding = args.colo_names.get_inner();
        let colo_regions_binding = args.colo_regions.get_inner();
        let description_binding = args.description.get_inner();
        let nexthop_binding = args.nexthop.get_inner();
        let prefix_binding = args.prefix.get_inner();
        let priority_binding = args.priority.get_inner();
        let weight_binding = args.weight.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/staticRoute:StaticRoute".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "coloNames".into(),
                    value: &colo_names_binding,
                },
                register_interface::ObjectField {
                    name: "coloRegions".into(),
                    value: &colo_regions_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "nexthop".into(),
                    value: &nexthop_binding,
                },
                register_interface::ObjectField {
                    name: "prefix".into(),
                    value: &prefix_binding,
                },
                register_interface::ObjectField {
                    name: "priority".into(),
                    value: &priority_binding,
                },
                register_interface::ObjectField {
                    name: "weight".into(),
                    value: &weight_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "coloNames".into(),
                },
                register_interface::ResultField {
                    name: "coloRegions".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "nexthop".into(),
                },
                register_interface::ResultField {
                    name: "prefix".into(),
                },
                register_interface::ResultField {
                    name: "priority".into(),
                },
                register_interface::ResultField {
                    name: "weight".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        StaticRouteResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            colo_names: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("coloNames").unwrap(),
            ),
            colo_regions: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("coloRegions").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            nexthop: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("nexthop").unwrap(),
            ),
            prefix: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("prefix").unwrap(),
            ),
            priority: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("priority").unwrap(),
            ),
            weight: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("weight").unwrap(),
            ),
        }
    }
}
pub mod teams_account {
    //! Provides a Cloudflare Teams Account resource. The Teams Account
    //! resource defines configuration for secure web gateway.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = teams_account::create(
    //!         "example",
    //!         TeamsAccountArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .antivirus(
    //!                 TeamsAccountAntivirus::builder()
    //!                     .enabledDownloadPhase(true)
    //!                     .enabledUploadPhase(false)
    //!                     .failClosed(true)
    //!                     .notificationSettings(
    //!                         TeamsAccountAntivirusNotificationSettings::builder()
    //!                             .enabled(true)
    //!                             .message("you are blocked")
    //!                             .supportUrl("https://example.com/blocked")
    //!                             .build_struct(),
    //!                     )
    //!                     .build_struct(),
    //!             )
    //!             .block_page(
    //!                 TeamsAccountBlockPage::builder()
    //!                     .backgroundColor("#000000")
    //!                     .footerText("hello")
    //!                     .headerText("hello")
    //!                     .logoPath("https://example.com/logo.jpg")
    //!                     .build_struct(),
    //!             )
    //!             .body_scanning(
    //!                 TeamsAccountBodyScanning::builder().inspectionMode("deep").build_struct(),
    //!             )
    //!             .extended_email_matching(
    //!                 TeamsAccountExtendedEmailMatching::builder().enabled(true).build_struct(),
    //!             )
    //!             .fips(TeamsAccountFips::builder().tls(true).build_struct())
    //!             .logging(
    //!                 TeamsAccountLogging::builder()
    //!                     .redactPii(true)
    //!                     .settingsByRuleType(
    //!                         TeamsAccountLoggingSettingsByRuleType::builder()
    //!                             .dns(
    //!                                 TeamsAccountLoggingSettingsByRuleTypeDns::builder()
    //!                                     .logAll(false)
    //!                                     .logBlocks(true)
    //!                                     .build_struct(),
    //!                             )
    //!                             .http(
    //!                                 TeamsAccountLoggingSettingsByRuleTypeHttp::builder()
    //!                                     .logAll(true)
    //!                                     .logBlocks(true)
    //!                                     .build_struct(),
    //!                             )
    //!                             .l4(
    //!                                 TeamsAccountLoggingSettingsByRuleTypeL4::builder()
    //!                                     .logAll(false)
    //!                                     .logBlocks(true)
    //!                                     .build_struct(),
    //!                             )
    //!                             .build_struct(),
    //!                     )
    //!                     .build_struct(),
    //!             )
    //!             .protocol_detection_enabled(true)
    //!             .proxy(
    //!                 TeamsAccountProxy::builder()
    //!                     .disableForTime(3600)
    //!                     .rootCa(true)
    //!                     .tcp(true)
    //!                     .udp(true)
    //!                     .virtualIp(false)
    //!                     .build_struct(),
    //!             )
    //!             .tls_decrypt_enabled(true)
    //!             .url_browser_isolation_enabled(true)
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/teamsAccount:TeamsAccount example <account_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct TeamsAccountArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether to enable the activity log.
        #[builder(into, default)]
        pub activity_log_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Configuration block for antivirus traffic scanning.
        #[builder(into, default)]
        pub antivirus: pulumi_wasm_rust::Output<
            Option<super::types::TeamsAccountAntivirus>,
        >,
        /// Configuration for a custom block page.
        #[builder(into, default)]
        pub block_page: pulumi_wasm_rust::Output<
            Option<super::types::TeamsAccountBlockPage>,
        >,
        /// Configuration for body scanning.
        #[builder(into, default)]
        pub body_scanning: pulumi_wasm_rust::Output<
            Option<super::types::TeamsAccountBodyScanning>,
        >,
        /// Configuration for TLS interception certificate. This will be required starting Feb 2025.
        #[builder(into, default)]
        pub certificate: pulumi_wasm_rust::Output<
            Option<super::types::TeamsAccountCertificate>,
        >,
        /// Configuration for custom certificates / BYO-PKI. Conflicts with `certificate`.
        #[builder(into, default)]
        pub custom_certificate: pulumi_wasm_rust::Output<
            Option<super::types::TeamsAccountCustomCertificate>,
        >,
        /// Configuration for extended e-mail matching.
        #[builder(into, default)]
        pub extended_email_matching: pulumi_wasm_rust::Output<
            Option<super::types::TeamsAccountExtendedEmailMatching>,
        >,
        /// Configure compliance with Federal Information Processing Standards.
        #[builder(into, default)]
        pub fips: pulumi_wasm_rust::Output<Option<super::types::TeamsAccountFips>>,
        #[builder(into, default)]
        pub logging: pulumi_wasm_rust::Output<Option<super::types::TeamsAccountLogging>>,
        /// Enable non-identity onramp for Browser Isolation. Defaults to `false`.
        #[builder(into, default)]
        pub non_identity_browser_isolation_enabled: pulumi_wasm_rust::Output<
            Option<bool>,
        >,
        /// Configuration for DLP Payload Logging.
        #[builder(into, default)]
        pub payload_log: pulumi_wasm_rust::Output<
            Option<super::types::TeamsAccountPayloadLog>,
        >,
        /// Indicator that protocol detection is enabled.
        #[builder(into, default)]
        pub protocol_detection_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Configuration block for specifying which protocols are proxied.
        #[builder(into, default)]
        pub proxy: pulumi_wasm_rust::Output<Option<super::types::TeamsAccountProxy>>,
        /// Configuration for SSH Session Logging.
        #[builder(into, default)]
        pub ssh_session_log: pulumi_wasm_rust::Output<
            Option<super::types::TeamsAccountSshSessionLog>,
        >,
        /// Indicator that decryption of TLS traffic is enabled.
        #[builder(into, default)]
        pub tls_decrypt_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Safely browse websites in Browser Isolation through a URL. Defaults to `false`.
        #[builder(into, default)]
        pub url_browser_isolation_enabled: pulumi_wasm_rust::Output<Option<bool>>,
    }
    #[allow(dead_code)]
    pub struct TeamsAccountResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether to enable the activity log.
        pub activity_log_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Configuration block for antivirus traffic scanning.
        pub antivirus: pulumi_wasm_rust::Output<
            Option<super::types::TeamsAccountAntivirus>,
        >,
        /// Configuration for a custom block page.
        pub block_page: pulumi_wasm_rust::Output<
            Option<super::types::TeamsAccountBlockPage>,
        >,
        /// Configuration for body scanning.
        pub body_scanning: pulumi_wasm_rust::Output<
            Option<super::types::TeamsAccountBodyScanning>,
        >,
        /// Configuration for TLS interception certificate. This will be required starting Feb 2025.
        pub certificate: pulumi_wasm_rust::Output<
            Option<super::types::TeamsAccountCertificate>,
        >,
        /// Configuration for custom certificates / BYO-PKI. Conflicts with `certificate`.
        pub custom_certificate: pulumi_wasm_rust::Output<
            Option<super::types::TeamsAccountCustomCertificate>,
        >,
        /// Configuration for extended e-mail matching.
        pub extended_email_matching: pulumi_wasm_rust::Output<
            super::types::TeamsAccountExtendedEmailMatching,
        >,
        /// Configure compliance with Federal Information Processing Standards.
        pub fips: pulumi_wasm_rust::Output<Option<super::types::TeamsAccountFips>>,
        pub logging: pulumi_wasm_rust::Output<Option<super::types::TeamsAccountLogging>>,
        /// Enable non-identity onramp for Browser Isolation. Defaults to `false`.
        pub non_identity_browser_isolation_enabled: pulumi_wasm_rust::Output<
            Option<bool>,
        >,
        /// Configuration for DLP Payload Logging.
        pub payload_log: pulumi_wasm_rust::Output<
            Option<super::types::TeamsAccountPayloadLog>,
        >,
        /// Indicator that protocol detection is enabled.
        pub protocol_detection_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Configuration block for specifying which protocols are proxied.
        pub proxy: pulumi_wasm_rust::Output<Option<super::types::TeamsAccountProxy>>,
        /// Configuration for SSH Session Logging.
        pub ssh_session_log: pulumi_wasm_rust::Output<
            Option<super::types::TeamsAccountSshSessionLog>,
        >,
        /// Indicator that decryption of TLS traffic is enabled.
        pub tls_decrypt_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Safely browse websites in Browser Isolation through a URL. Defaults to `false`.
        pub url_browser_isolation_enabled: pulumi_wasm_rust::Output<Option<bool>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: TeamsAccountArgs) -> TeamsAccountResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let activity_log_enabled_binding = args.activity_log_enabled.get_inner();
        let antivirus_binding = args.antivirus.get_inner();
        let block_page_binding = args.block_page.get_inner();
        let body_scanning_binding = args.body_scanning.get_inner();
        let certificate_binding = args.certificate.get_inner();
        let custom_certificate_binding = args.custom_certificate.get_inner();
        let extended_email_matching_binding = args.extended_email_matching.get_inner();
        let fips_binding = args.fips.get_inner();
        let logging_binding = args.logging.get_inner();
        let non_identity_browser_isolation_enabled_binding = args
            .non_identity_browser_isolation_enabled
            .get_inner();
        let payload_log_binding = args.payload_log.get_inner();
        let protocol_detection_enabled_binding = args
            .protocol_detection_enabled
            .get_inner();
        let proxy_binding = args.proxy.get_inner();
        let ssh_session_log_binding = args.ssh_session_log.get_inner();
        let tls_decrypt_enabled_binding = args.tls_decrypt_enabled.get_inner();
        let url_browser_isolation_enabled_binding = args
            .url_browser_isolation_enabled
            .get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/teamsAccount:TeamsAccount".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "activityLogEnabled".into(),
                    value: &activity_log_enabled_binding,
                },
                register_interface::ObjectField {
                    name: "antivirus".into(),
                    value: &antivirus_binding,
                },
                register_interface::ObjectField {
                    name: "blockPage".into(),
                    value: &block_page_binding,
                },
                register_interface::ObjectField {
                    name: "bodyScanning".into(),
                    value: &body_scanning_binding,
                },
                register_interface::ObjectField {
                    name: "certificate".into(),
                    value: &certificate_binding,
                },
                register_interface::ObjectField {
                    name: "customCertificate".into(),
                    value: &custom_certificate_binding,
                },
                register_interface::ObjectField {
                    name: "extendedEmailMatching".into(),
                    value: &extended_email_matching_binding,
                },
                register_interface::ObjectField {
                    name: "fips".into(),
                    value: &fips_binding,
                },
                register_interface::ObjectField {
                    name: "logging".into(),
                    value: &logging_binding,
                },
                register_interface::ObjectField {
                    name: "nonIdentityBrowserIsolationEnabled".into(),
                    value: &non_identity_browser_isolation_enabled_binding,
                },
                register_interface::ObjectField {
                    name: "payloadLog".into(),
                    value: &payload_log_binding,
                },
                register_interface::ObjectField {
                    name: "protocolDetectionEnabled".into(),
                    value: &protocol_detection_enabled_binding,
                },
                register_interface::ObjectField {
                    name: "proxy".into(),
                    value: &proxy_binding,
                },
                register_interface::ObjectField {
                    name: "sshSessionLog".into(),
                    value: &ssh_session_log_binding,
                },
                register_interface::ObjectField {
                    name: "tlsDecryptEnabled".into(),
                    value: &tls_decrypt_enabled_binding,
                },
                register_interface::ObjectField {
                    name: "urlBrowserIsolationEnabled".into(),
                    value: &url_browser_isolation_enabled_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "activityLogEnabled".into(),
                },
                register_interface::ResultField {
                    name: "antivirus".into(),
                },
                register_interface::ResultField {
                    name: "blockPage".into(),
                },
                register_interface::ResultField {
                    name: "bodyScanning".into(),
                },
                register_interface::ResultField {
                    name: "certificate".into(),
                },
                register_interface::ResultField {
                    name: "customCertificate".into(),
                },
                register_interface::ResultField {
                    name: "extendedEmailMatching".into(),
                },
                register_interface::ResultField {
                    name: "fips".into(),
                },
                register_interface::ResultField {
                    name: "logging".into(),
                },
                register_interface::ResultField {
                    name: "nonIdentityBrowserIsolationEnabled".into(),
                },
                register_interface::ResultField {
                    name: "payloadLog".into(),
                },
                register_interface::ResultField {
                    name: "protocolDetectionEnabled".into(),
                },
                register_interface::ResultField {
                    name: "proxy".into(),
                },
                register_interface::ResultField {
                    name: "sshSessionLog".into(),
                },
                register_interface::ResultField {
                    name: "tlsDecryptEnabled".into(),
                },
                register_interface::ResultField {
                    name: "urlBrowserIsolationEnabled".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        TeamsAccountResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            activity_log_enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("activityLogEnabled").unwrap(),
            ),
            antivirus: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("antivirus").unwrap(),
            ),
            block_page: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("blockPage").unwrap(),
            ),
            body_scanning: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("bodyScanning").unwrap(),
            ),
            certificate: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("certificate").unwrap(),
            ),
            custom_certificate: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customCertificate").unwrap(),
            ),
            extended_email_matching: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("extendedEmailMatching").unwrap(),
            ),
            fips: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("fips").unwrap(),
            ),
            logging: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("logging").unwrap(),
            ),
            non_identity_browser_isolation_enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("nonIdentityBrowserIsolationEnabled").unwrap(),
            ),
            payload_log: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("payloadLog").unwrap(),
            ),
            protocol_detection_enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("protocolDetectionEnabled").unwrap(),
            ),
            proxy: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("proxy").unwrap(),
            ),
            ssh_session_log: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("sshSessionLog").unwrap(),
            ),
            tls_decrypt_enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tlsDecryptEnabled").unwrap(),
            ),
            url_browser_isolation_enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("urlBrowserIsolationEnabled").unwrap(),
            ),
        }
    }
}
pub mod teams_list {
    //! Provides a Cloudflare Teams List resource. Teams lists are
    //! referenced when creating secure web gateway policies or device
    //! posture rules.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = teams_list::create(
    //!         "example",
    //!         TeamsListArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .description("Serial numbers for all corporate devices.")
    //!             .items(vec!["8GE8721REF", "5RE8543EGG", "1YE2880LNP",])
    //!             .name("Corporate devices")
    //!             .type_("SERIAL")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/teamsList:TeamsList example <account_id>/<teams_list_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct TeamsListArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The description of the teams list.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The items of the teams list.
        #[builder(into, default)]
        pub items: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The items of the teams list that has explicit description.
        #[builder(into, default)]
        pub items_with_descriptions: pulumi_wasm_rust::Output<
            Option<Vec<super::types::TeamsListItemsWithDescription>>,
        >,
        /// Name of the teams list.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The teams list type. Available values: `IP`, `SERIAL`, `URL`, `DOMAIN`, `EMAIL`.
        #[builder(into)]
        pub type_: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct TeamsListResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The description of the teams list.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The items of the teams list.
        pub items: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The items of the teams list that has explicit description.
        pub items_with_descriptions: pulumi_wasm_rust::Output<
            Option<Vec<super::types::TeamsListItemsWithDescription>>,
        >,
        /// Name of the teams list.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The teams list type. Available values: `IP`, `SERIAL`, `URL`, `DOMAIN`, `EMAIL`.
        pub type_: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: TeamsListArgs) -> TeamsListResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let description_binding = args.description.get_inner();
        let items_binding = args.items.get_inner();
        let items_with_descriptions_binding = args.items_with_descriptions.get_inner();
        let name_binding = args.name.get_inner();
        let type__binding = args.type_.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/teamsList:TeamsList".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "items".into(),
                    value: &items_binding,
                },
                register_interface::ObjectField {
                    name: "itemsWithDescriptions".into(),
                    value: &items_with_descriptions_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "items".into(),
                },
                register_interface::ResultField {
                    name: "itemsWithDescriptions".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        TeamsListResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            items: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("items").unwrap(),
            ),
            items_with_descriptions: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("itemsWithDescriptions").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
        }
    }
}
pub mod teams_location {
    //! Provides a Cloudflare Teams Location resource. Teams Locations are
    //! referenced when creating secure web gateway policies.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = teams_location::create(
    //!         "example",
    //!         TeamsLocationArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .client_default(true)
    //!             .ecs_support(false)
    //!             .name("office")
    //!             .networks(
    //!                 vec![
    //!                     TeamsLocationNetwork::builder().network("203.0.113.1/32")
    //!                     .build_struct(), TeamsLocationNetwork::builder()
    //!                     .network("203.0.113.2/32").build_struct(),
    //!                 ],
    //!             )
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/teamsLocation:TeamsLocation example <account_id>/<teams_location_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct TeamsLocationArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Indicator that this is the default location.
        #[builder(into, default)]
        pub client_default: pulumi_wasm_rust::Output<Option<bool>>,
        /// Indicator that this location needs to resolve EDNS queries.
        #[builder(into, default)]
        pub ecs_support: pulumi_wasm_rust::Output<Option<bool>>,
        /// Name of the teams location.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The networks CIDRs that comprise the location.
        #[builder(into, default)]
        pub networks: pulumi_wasm_rust::Output<
            Option<Vec<super::types::TeamsLocationNetwork>>,
        >,
    }
    #[allow(dead_code)]
    pub struct TeamsLocationResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Indicator that anonymized logs are enabled.
        pub anonymized_logs_enabled: pulumi_wasm_rust::Output<bool>,
        /// Indicator that this is the default location.
        pub client_default: pulumi_wasm_rust::Output<Option<bool>>,
        /// The FQDN that DoH clients should be pointed at.
        pub doh_subdomain: pulumi_wasm_rust::Output<String>,
        /// Indicator that this location needs to resolve EDNS queries.
        pub ecs_support: pulumi_wasm_rust::Output<Option<bool>>,
        /// Client IP address.
        pub ip: pulumi_wasm_rust::Output<String>,
        /// IP to direct all IPv4 DNS queries to.
        pub ipv4_destination: pulumi_wasm_rust::Output<String>,
        /// Name of the teams location.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The networks CIDRs that comprise the location.
        pub networks: pulumi_wasm_rust::Output<
            Option<Vec<super::types::TeamsLocationNetwork>>,
        >,
        pub policy_ids: pulumi_wasm_rust::Output<Vec<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: TeamsLocationArgs) -> TeamsLocationResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let client_default_binding = args.client_default.get_inner();
        let ecs_support_binding = args.ecs_support.get_inner();
        let name_binding = args.name.get_inner();
        let networks_binding = args.networks.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/teamsLocation:TeamsLocation".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "clientDefault".into(),
                    value: &client_default_binding,
                },
                register_interface::ObjectField {
                    name: "ecsSupport".into(),
                    value: &ecs_support_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "networks".into(),
                    value: &networks_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "anonymizedLogsEnabled".into(),
                },
                register_interface::ResultField {
                    name: "clientDefault".into(),
                },
                register_interface::ResultField {
                    name: "dohSubdomain".into(),
                },
                register_interface::ResultField {
                    name: "ecsSupport".into(),
                },
                register_interface::ResultField {
                    name: "ip".into(),
                },
                register_interface::ResultField {
                    name: "ipv4Destination".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "networks".into(),
                },
                register_interface::ResultField {
                    name: "policyIds".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        TeamsLocationResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            anonymized_logs_enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("anonymizedLogsEnabled").unwrap(),
            ),
            client_default: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("clientDefault").unwrap(),
            ),
            doh_subdomain: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("dohSubdomain").unwrap(),
            ),
            ecs_support: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("ecsSupport").unwrap(),
            ),
            ip: pulumi_wasm_rust::__private::into_domain(hashmap.remove("ip").unwrap()),
            ipv4_destination: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("ipv4Destination").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            networks: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("networks").unwrap(),
            ),
            policy_ids: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("policyIds").unwrap(),
            ),
        }
    }
}
pub mod teams_proxy_endpoint {
    //! Provides a Cloudflare Teams Proxy Endpoint resource. Teams Proxy
    //! Endpoints are used for pointing proxy clients at Cloudflare Secure
    //! Gateway.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = teams_proxy_endpoint::create(
    //!         "example",
    //!         TeamsProxyEndpointArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .ips(vec!["192.0.2.0/24",])
    //!             .name("office")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/teamsProxyEndpoint:TeamsProxyEndpoint example <account_id>/<proxy_endpoint_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct TeamsProxyEndpointArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The networks CIDRs that will be allowed to initiate proxy connections.
        #[builder(into)]
        pub ips: pulumi_wasm_rust::Output<Vec<String>>,
        /// Name of the teams proxy endpoint.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct TeamsProxyEndpointResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The networks CIDRs that will be allowed to initiate proxy connections.
        pub ips: pulumi_wasm_rust::Output<Vec<String>>,
        /// Name of the teams proxy endpoint.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The FQDN that proxy clients should be pointed at.
        pub subdomain: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: TeamsProxyEndpointArgs) -> TeamsProxyEndpointResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let ips_binding = args.ips.get_inner();
        let name_binding = args.name.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/teamsProxyEndpoint:TeamsProxyEndpoint".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "ips".into(),
                    value: &ips_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "ips".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "subdomain".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        TeamsProxyEndpointResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            ips: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("ips").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            subdomain: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("subdomain").unwrap(),
            ),
        }
    }
}
pub mod teams_rule {
    //! Provides a Cloudflare Teams rule resource. Teams rules comprise secure web gateway policies.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = teams_rule::create(
    //!         "example",
    //!         TeamsRuleArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .action("block")
    //!             .description("desc")
    //!             .filters(vec!["http",])
    //!             .name("office")
    //!             .precedence(1)
    //!             .rule_settings(
    //!                 TeamsRuleRuleSettings::builder()
    //!                     .blockPageEnabled(true)
    //!                     .blockPageReason("access not permitted")
    //!                     .build_struct(),
    //!             )
    //!             .traffic("http.request.uri == \"https://www.example.com/malicious\"")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/teamsRule:TeamsRule example <account_id>/<teams_rule_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct TeamsRuleArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The action executed by matched teams rule. Available values: `allow`, `block`, `safesearch`, `ytrestricted`, `on`, `off`, `scan`, `noscan`, `isolate`, `noisolate`, `override`, `l4_override`, `egress`, `audit_ssh`, `resolve`.
        #[builder(into)]
        pub action: pulumi_wasm_rust::Output<String>,
        /// The description of the teams rule.
        #[builder(into)]
        pub description: pulumi_wasm_rust::Output<String>,
        /// The wirefilter expression to be used for device_posture check matching.
        #[builder(into, default)]
        pub device_posture: pulumi_wasm_rust::Output<Option<String>>,
        /// Indicator of rule enablement.
        #[builder(into, default)]
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The protocol or layer to evaluate the traffic and identity expressions.
        #[builder(into, default)]
        pub filters: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The wirefilter expression to be used for identity matching.
        #[builder(into, default)]
        pub identity: pulumi_wasm_rust::Output<Option<String>>,
        /// The name of the teams rule.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The evaluation precedence of the teams rule.
        #[builder(into)]
        pub precedence: pulumi_wasm_rust::Output<i32>,
        /// Additional rule settings.
        #[builder(into, default)]
        pub rule_settings: pulumi_wasm_rust::Output<
            Option<super::types::TeamsRuleRuleSettings>,
        >,
        /// The wirefilter expression to be used for traffic matching.
        #[builder(into, default)]
        pub traffic: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct TeamsRuleResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The action executed by matched teams rule. Available values: `allow`, `block`, `safesearch`, `ytrestricted`, `on`, `off`, `scan`, `noscan`, `isolate`, `noisolate`, `override`, `l4_override`, `egress`, `audit_ssh`, `resolve`.
        pub action: pulumi_wasm_rust::Output<String>,
        /// The description of the teams rule.
        pub description: pulumi_wasm_rust::Output<String>,
        /// The wirefilter expression to be used for device_posture check matching.
        pub device_posture: pulumi_wasm_rust::Output<String>,
        /// Indicator of rule enablement.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The protocol or layer to evaluate the traffic and identity expressions.
        pub filters: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The wirefilter expression to be used for identity matching.
        pub identity: pulumi_wasm_rust::Output<String>,
        /// The name of the teams rule.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The evaluation precedence of the teams rule.
        pub precedence: pulumi_wasm_rust::Output<i32>,
        /// Additional rule settings.
        pub rule_settings: pulumi_wasm_rust::Output<super::types::TeamsRuleRuleSettings>,
        /// The wirefilter expression to be used for traffic matching.
        pub traffic: pulumi_wasm_rust::Output<String>,
        pub version: pulumi_wasm_rust::Output<i32>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: TeamsRuleArgs) -> TeamsRuleResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let action_binding = args.action.get_inner();
        let description_binding = args.description.get_inner();
        let device_posture_binding = args.device_posture.get_inner();
        let enabled_binding = args.enabled.get_inner();
        let filters_binding = args.filters.get_inner();
        let identity_binding = args.identity.get_inner();
        let name_binding = args.name.get_inner();
        let precedence_binding = args.precedence.get_inner();
        let rule_settings_binding = args.rule_settings.get_inner();
        let traffic_binding = args.traffic.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/teamsRule:TeamsRule".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "action".into(),
                    value: &action_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "devicePosture".into(),
                    value: &device_posture_binding,
                },
                register_interface::ObjectField {
                    name: "enabled".into(),
                    value: &enabled_binding,
                },
                register_interface::ObjectField {
                    name: "filters".into(),
                    value: &filters_binding,
                },
                register_interface::ObjectField {
                    name: "identity".into(),
                    value: &identity_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "precedence".into(),
                    value: &precedence_binding,
                },
                register_interface::ObjectField {
                    name: "ruleSettings".into(),
                    value: &rule_settings_binding,
                },
                register_interface::ObjectField {
                    name: "traffic".into(),
                    value: &traffic_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "action".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "devicePosture".into(),
                },
                register_interface::ResultField {
                    name: "enabled".into(),
                },
                register_interface::ResultField {
                    name: "filters".into(),
                },
                register_interface::ResultField {
                    name: "identity".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "precedence".into(),
                },
                register_interface::ResultField {
                    name: "ruleSettings".into(),
                },
                register_interface::ResultField {
                    name: "traffic".into(),
                },
                register_interface::ResultField {
                    name: "version".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        TeamsRuleResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            action: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("action").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            device_posture: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("devicePosture").unwrap(),
            ),
            enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enabled").unwrap(),
            ),
            filters: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("filters").unwrap(),
            ),
            identity: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("identity").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            precedence: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("precedence").unwrap(),
            ),
            rule_settings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("ruleSettings").unwrap(),
            ),
            traffic: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("traffic").unwrap(),
            ),
            version: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("version").unwrap(),
            ),
        }
    }
}
pub mod tiered_cache {
    //! Provides a resource, that manages Cloudflare Tiered Cache settings.
    //! This allows you to adjust topologies for your zone.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = tiered_cache::create(
    //!         "example",
    //!         TieredCacheArgs::builder()
    //!             .cache_type("smart")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct TieredCacheArgs {
        /// The typed of tiered cache to utilize on the zone. Available values: `generic`, `smart`, `off`.
        #[builder(into)]
        pub cache_type: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct TieredCacheResult {
        /// The typed of tiered cache to utilize on the zone. Available values: `generic`, `smart`, `off`.
        pub cache_type: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: TieredCacheArgs) -> TieredCacheResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let cache_type_binding = args.cache_type.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/tieredCache:TieredCache".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "cacheType".into(),
                    value: &cache_type_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "cacheType".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        TieredCacheResult {
            cache_type: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("cacheType").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod total_tls {
    //! Provides a resource which manages Total TLS for a zone.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = total_tls::create(
    //!         "example",
    //!         TotalTlsArgs::builder()
    //!             .certificate_authority("lets_encrypt")
    //!             .enabled(true)
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/totalTls:TotalTls example <zone_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct TotalTlsArgs {
        /// The Certificate Authority that Total TLS certificates will be issued through. Available values: `google`, `lets_encrypt`.
        #[builder(into, default)]
        pub certificate_authority: pulumi_wasm_rust::Output<Option<String>>,
        /// Enable Total TLS for the zone.
        #[builder(into)]
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct TotalTlsResult {
        /// The Certificate Authority that Total TLS certificates will be issued through. Available values: `google`, `lets_encrypt`.
        pub certificate_authority: pulumi_wasm_rust::Output<Option<String>>,
        /// Enable Total TLS for the zone.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: TotalTlsArgs) -> TotalTlsResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let certificate_authority_binding = args.certificate_authority.get_inner();
        let enabled_binding = args.enabled.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/totalTls:TotalTls".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "certificateAuthority".into(),
                    value: &certificate_authority_binding,
                },
                register_interface::ObjectField {
                    name: "enabled".into(),
                    value: &enabled_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "certificateAuthority".into(),
                },
                register_interface::ResultField {
                    name: "enabled".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        TotalTlsResult {
            certificate_authority: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("certificateAuthority").unwrap(),
            ),
            enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enabled").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod tunnel {
    //! Tunnel exposes applications running on your local web server on any
    //! network with an internet connection without manually adding DNS
    //! records or configuring a firewall or router.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = tunnel::create(
    //!         "example",
    //!         TunnelArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .name("my-tunnel")
    //!             .secret("AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/tunnel:Tunnel example <account_id>/<tunnel_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct TunnelArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel on the Zero Trust dashboard or using tunnel*config, tunnel*route or tunnel*virtual*network resources. Available values: `local`, `cloudflare`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub config_src: pulumi_wasm_rust::Output<Option<String>>,
        /// A user-friendly name chosen when the tunnel is created. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// 32 or more bytes, encoded as a base64 string. The Create Argo Tunnel endpoint sets this as the tunnel's password. Anyone wishing to run the tunnel needs this password. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub secret: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct TunnelResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Usable CNAME for accessing the Tunnel.
        pub cname: pulumi_wasm_rust::Output<String>,
        /// Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel on the Zero Trust dashboard or using tunnel*config, tunnel*route or tunnel*virtual*network resources. Available values: `local`, `cloudflare`. **Modifying this attribute will force creation of a new resource.**
        pub config_src: pulumi_wasm_rust::Output<Option<String>>,
        /// A user-friendly name chosen when the tunnel is created. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
        /// 32 or more bytes, encoded as a base64 string. The Create Argo Tunnel endpoint sets this as the tunnel's password. Anyone wishing to run the tunnel needs this password. **Modifying this attribute will force creation of a new resource.**
        pub secret: pulumi_wasm_rust::Output<String>,
        /// Token used by a connector to authenticate and run the tunnel.
        pub tunnel_token: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: TunnelArgs) -> TunnelResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let config_src_binding = args.config_src.get_inner();
        let name_binding = args.name.get_inner();
        let secret_binding = args.secret.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/tunnel:Tunnel".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "configSrc".into(),
                    value: &config_src_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "secret".into(),
                    value: &secret_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "cname".into(),
                },
                register_interface::ResultField {
                    name: "configSrc".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "secret".into(),
                },
                register_interface::ResultField {
                    name: "tunnelToken".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        TunnelResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            cname: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("cname").unwrap(),
            ),
            config_src: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("configSrc").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            secret: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("secret").unwrap(),
            ),
            tunnel_token: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tunnelToken").unwrap(),
            ),
        }
    }
}
pub mod tunnel_config {
    //! Provides a Cloudflare Tunnel configuration resource.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   exampleTunnel:
    //!     type: cloudflare:ZeroTrustTunnelCloudflared
    //!     name: example_tunnel
    //!     properties:
    //!       accountId: f037e56e89293a057740de681ac9abbe
    //!       name: example_tunnel
    //!       secret: <32 character secret>
    //!   exampleConfig:
    //!     type: cloudflare:TunnelConfig
    //!     name: example_config
    //!     properties:
    //!       accountId: f037e56e89293a057740de681ac9abbe
    //!       tunnelId: ${exampleTunnel.id}
    //!       config:
    //!         warpRouting:
    //!           enabled: true
    //!         originRequest:
    //!           connectTimeout: 1m0s
    //!           tlsTimeout: 1m0s
    //!           tcpKeepAlive: 1m0s
    //!           noHappyEyeballs: false
    //!           keepAliveConnections: 1024
    //!           keepAliveTimeout: 1m0s
    //!           httpHostHeader: baz
    //!           originServerName: foobar
    //!           caPool: /path/to/unsigned/ca/pool
    //!           noTlsVerify: false
    //!           disableChunkedEncoding: false
    //!           bastionMode: false
    //!           proxyAddress: 10.0.0.1
    //!           proxyPort: '8123'
    //!           proxyType: socks
    //!           ipRules:
    //!             - prefix: /web
    //!               ports:
    //!                 - 80
    //!                 - 443
    //!               allow: false
    //!         ingressRules:
    //!           - hostname: foo
    //!             path: /bar
    //!             service: http://10.0.0.2:8080
    //!             originRequest:
    //!               connectTimeout: 2m0s
    //!               access:
    //!                 required: true
    //!                 teamName: terraform
    //!                 audTags:
    //!                   - AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
    //!           - service: https://10.0.0.3:8081
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/tunnelConfig:TunnelConfig example <account_id>/<tunnel_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct TunnelConfigArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Configuration block for Tunnel Configuration.
        #[builder(into)]
        pub config: pulumi_wasm_rust::Output<super::types::TunnelConfigConfig>,
        /// Identifier of the Tunnel to target for this configuration.
        #[builder(into)]
        pub tunnel_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct TunnelConfigResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Configuration block for Tunnel Configuration.
        pub config: pulumi_wasm_rust::Output<super::types::TunnelConfigConfig>,
        /// Identifier of the Tunnel to target for this configuration.
        pub tunnel_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: TunnelConfigArgs) -> TunnelConfigResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let config_binding = args.config.get_inner();
        let tunnel_id_binding = args.tunnel_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/tunnelConfig:TunnelConfig".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "config".into(),
                    value: &config_binding,
                },
                register_interface::ObjectField {
                    name: "tunnelId".into(),
                    value: &tunnel_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "config".into(),
                },
                register_interface::ResultField {
                    name: "tunnelId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        TunnelConfigResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            config: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("config").unwrap(),
            ),
            tunnel_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tunnelId").unwrap(),
            ),
        }
    }
}
pub mod tunnel_route {
    //! Provides a resource, that manages Cloudflare tunnel routes for Zero
    //! Trust. Tunnel routes are used to direct IP traffic through
    //! Cloudflare Tunnels.
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/tunnelRoute:TunnelRoute example <account_id>/<network_cidr>/<virtual_network_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct TunnelRouteArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Description of the tunnel route.
        #[builder(into, default)]
        pub comment: pulumi_wasm_rust::Output<Option<String>>,
        /// The IPv4 or IPv6 network that should use this tunnel route, in CIDR notation.
        #[builder(into)]
        pub network: pulumi_wasm_rust::Output<String>,
        /// The ID of the tunnel that will service the tunnel route.
        #[builder(into)]
        pub tunnel_id: pulumi_wasm_rust::Output<String>,
        /// The ID of the virtual network for which this route is being added; uses the default virtual network of the account if none is provided. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub virtual_network_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct TunnelRouteResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Description of the tunnel route.
        pub comment: pulumi_wasm_rust::Output<Option<String>>,
        /// The IPv4 or IPv6 network that should use this tunnel route, in CIDR notation.
        pub network: pulumi_wasm_rust::Output<String>,
        /// The ID of the tunnel that will service the tunnel route.
        pub tunnel_id: pulumi_wasm_rust::Output<String>,
        /// The ID of the virtual network for which this route is being added; uses the default virtual network of the account if none is provided. **Modifying this attribute will force creation of a new resource.**
        pub virtual_network_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: TunnelRouteArgs) -> TunnelRouteResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let comment_binding = args.comment.get_inner();
        let network_binding = args.network.get_inner();
        let tunnel_id_binding = args.tunnel_id.get_inner();
        let virtual_network_id_binding = args.virtual_network_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/tunnelRoute:TunnelRoute".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "comment".into(),
                    value: &comment_binding,
                },
                register_interface::ObjectField {
                    name: "network".into(),
                    value: &network_binding,
                },
                register_interface::ObjectField {
                    name: "tunnelId".into(),
                    value: &tunnel_id_binding,
                },
                register_interface::ObjectField {
                    name: "virtualNetworkId".into(),
                    value: &virtual_network_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "comment".into(),
                },
                register_interface::ResultField {
                    name: "network".into(),
                },
                register_interface::ResultField {
                    name: "tunnelId".into(),
                },
                register_interface::ResultField {
                    name: "virtualNetworkId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        TunnelRouteResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            comment: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("comment").unwrap(),
            ),
            network: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("network").unwrap(),
            ),
            tunnel_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tunnelId").unwrap(),
            ),
            virtual_network_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("virtualNetworkId").unwrap(),
            ),
        }
    }
}
pub mod tunnel_virtual_network {
    //! Provides a resource, that manages Cloudflare tunnel virtual networks
    //! for Zero Trust. Tunnel virtual networks are used for segregation of
    //! Tunnel IP Routes via Virtualized Networks to handle overlapping
    //! private IPs in your origins.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = tunnel_virtual_network::create(
    //!         "example",
    //!         TunnelVirtualNetworkArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .comment("New tunnel virtual network for documentation")
    //!             .name("vnet-for-documentation")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/tunnelVirtualNetwork:TunnelVirtualNetwork example <account_id>/<vnet_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct TunnelVirtualNetworkArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Description of the tunnel virtual network.
        #[builder(into, default)]
        pub comment: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether this virtual network is the default one for the account. This means IP Routes belong to this virtual network and Teams Clients in the account route through this virtual network, unless specified otherwise for each case.
        #[builder(into, default)]
        pub is_default_network: pulumi_wasm_rust::Output<Option<bool>>,
        /// A user-friendly name chosen when the virtual network is created.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct TunnelVirtualNetworkResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Description of the tunnel virtual network.
        pub comment: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether this virtual network is the default one for the account. This means IP Routes belong to this virtual network and Teams Clients in the account route through this virtual network, unless specified otherwise for each case.
        pub is_default_network: pulumi_wasm_rust::Output<Option<bool>>,
        /// A user-friendly name chosen when the virtual network is created.
        pub name: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: TunnelVirtualNetworkArgs,
    ) -> TunnelVirtualNetworkResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let comment_binding = args.comment.get_inner();
        let is_default_network_binding = args.is_default_network.get_inner();
        let name_binding = args.name.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/tunnelVirtualNetwork:TunnelVirtualNetwork".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "comment".into(),
                    value: &comment_binding,
                },
                register_interface::ObjectField {
                    name: "isDefaultNetwork".into(),
                    value: &is_default_network_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "comment".into(),
                },
                register_interface::ResultField {
                    name: "isDefaultNetwork".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        TunnelVirtualNetworkResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            comment: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("comment").unwrap(),
            ),
            is_default_network: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("isDefaultNetwork").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
        }
    }
}
pub mod turnstile_widget {
    //! The [Turnstile Widget](https://developers.cloudflare.com/turnstile/) resource allows you to manage Cloudflare Turnstile Widgets.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = turnstile_widget::create(
    //!         "example",
    //!         TurnstileWidgetArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .bot_fight_mode(false)
    //!             .domains(vec!["example.com",])
    //!             .mode("invisible")
    //!             .name("example widget")
    //!             .region("world")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/turnstileWidget:TurnstileWidget example <account_id>/<site_key>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct TurnstileWidgetArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// If bot*fight*mode is set to true, Cloudflare issues computationally expensive challenges in response to malicious bots (Enterprise only).
        #[builder(into, default)]
        pub bot_fight_mode: pulumi_wasm_rust::Output<Option<bool>>,
        /// Domains where the widget is deployed
        #[builder(into)]
        pub domains: pulumi_wasm_rust::Output<Vec<String>>,
        /// Widget Mode. Available values: `non-interactive`, `invisible`, `managed`
        #[builder(into)]
        pub mode: pulumi_wasm_rust::Output<String>,
        /// Human readable widget name.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// Do not show any Cloudflare branding on the widget (Enterprise only).
        #[builder(into, default)]
        pub offlabel: pulumi_wasm_rust::Output<Option<bool>>,
        /// Region where this widget can be used.
        #[builder(into, default)]
        pub region: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct TurnstileWidgetResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// If bot*fight*mode is set to true, Cloudflare issues computationally expensive challenges in response to malicious bots (Enterprise only).
        pub bot_fight_mode: pulumi_wasm_rust::Output<bool>,
        /// Domains where the widget is deployed
        pub domains: pulumi_wasm_rust::Output<Vec<String>>,
        /// Widget Mode. Available values: `non-interactive`, `invisible`, `managed`
        pub mode: pulumi_wasm_rust::Output<String>,
        /// Human readable widget name.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Do not show any Cloudflare branding on the widget (Enterprise only).
        pub offlabel: pulumi_wasm_rust::Output<bool>,
        /// Region where this widget can be used.
        pub region: pulumi_wasm_rust::Output<String>,
        /// Secret key for this widget.
        pub secret: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: TurnstileWidgetArgs) -> TurnstileWidgetResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let bot_fight_mode_binding = args.bot_fight_mode.get_inner();
        let domains_binding = args.domains.get_inner();
        let mode_binding = args.mode.get_inner();
        let name_binding = args.name.get_inner();
        let offlabel_binding = args.offlabel.get_inner();
        let region_binding = args.region.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/turnstileWidget:TurnstileWidget".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "botFightMode".into(),
                    value: &bot_fight_mode_binding,
                },
                register_interface::ObjectField {
                    name: "domains".into(),
                    value: &domains_binding,
                },
                register_interface::ObjectField {
                    name: "mode".into(),
                    value: &mode_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "offlabel".into(),
                    value: &offlabel_binding,
                },
                register_interface::ObjectField {
                    name: "region".into(),
                    value: &region_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "botFightMode".into(),
                },
                register_interface::ResultField {
                    name: "domains".into(),
                },
                register_interface::ResultField {
                    name: "mode".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "offlabel".into(),
                },
                register_interface::ResultField {
                    name: "region".into(),
                },
                register_interface::ResultField {
                    name: "secret".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        TurnstileWidgetResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            bot_fight_mode: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("botFightMode").unwrap(),
            ),
            domains: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("domains").unwrap(),
            ),
            mode: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("mode").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            offlabel: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("offlabel").unwrap(),
            ),
            region: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("region").unwrap(),
            ),
            secret: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("secret").unwrap(),
            ),
        }
    }
}
pub mod url_normalization_settings {
    //! Provides a resource to manage URL Normalization Settings.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = url_normalization_settings::create(
    //!         "example",
    //!         UrlNormalizationSettingsArgs::builder()
    //!             .scope("incoming")
    //!             .type_("cloudflare")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct UrlNormalizationSettingsArgs {
        /// The scope of the URL normalization.
        #[builder(into)]
        pub scope: pulumi_wasm_rust::Output<String>,
        /// The type of URL normalization performed by Cloudflare.
        #[builder(into)]
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct UrlNormalizationSettingsResult {
        /// The scope of the URL normalization.
        pub scope: pulumi_wasm_rust::Output<String>,
        /// The type of URL normalization performed by Cloudflare.
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: UrlNormalizationSettingsArgs,
    ) -> UrlNormalizationSettingsResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let scope_binding = args.scope.get_inner();
        let type__binding = args.type_.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/urlNormalizationSettings:UrlNormalizationSettings"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "scope".into(),
                    value: &scope_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "scope".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        UrlNormalizationSettingsResult {
            scope: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("scope").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod user_agent_blocking_rule {
    //! Provides a resource to manage User Agent Blocking Rules.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example1 = user_agent_blocking_rule::create(
    //!         "example1",
    //!         UserAgentBlockingRuleArgs::builder()
    //!             .configuration(
    //!                 UserAgentBlockingRuleConfiguration::builder()
    //!                     .target("ua")
    //!                     .value("Chrome")
    //!                     .build_struct(),
    //!             )
    //!             .description("My description 1")
    //!             .mode("js_challenge")
    //!             .paused(false)
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //!     let example2 = user_agent_blocking_rule::create(
    //!         "example2",
    //!         UserAgentBlockingRuleArgs::builder()
    //!             .configuration(
    //!                 UserAgentBlockingRuleConfiguration::builder()
    //!                     .target("ua")
    //!                     .value("Mozilla")
    //!                     .build_struct(),
    //!             )
    //!             .description("My description 22")
    //!             .mode("challenge")
    //!             .paused(true)
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/userAgentBlockingRule:UserAgentBlockingRule example <zone_id>/<user_agent_blocking_rule_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct UserAgentBlockingRuleArgs {
        /// The configuration object for the current rule.
        #[builder(into)]
        pub configuration: pulumi_wasm_rust::Output<
            super::types::UserAgentBlockingRuleConfiguration,
        >,
        /// An informative summary of the rule.
        #[builder(into)]
        pub description: pulumi_wasm_rust::Output<String>,
        /// The action to apply to a matched request. Available values: `block`, `challenge`, `js_challenge`, `managed_challenge`.
        #[builder(into)]
        pub mode: pulumi_wasm_rust::Output<String>,
        /// When true, indicates that the rule is currently paused.
        #[builder(into)]
        pub paused: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct UserAgentBlockingRuleResult {
        /// The configuration object for the current rule.
        pub configuration: pulumi_wasm_rust::Output<
            super::types::UserAgentBlockingRuleConfiguration,
        >,
        /// An informative summary of the rule.
        pub description: pulumi_wasm_rust::Output<String>,
        /// The action to apply to a matched request. Available values: `block`, `challenge`, `js_challenge`, `managed_challenge`.
        pub mode: pulumi_wasm_rust::Output<String>,
        /// When true, indicates that the rule is currently paused.
        pub paused: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: UserAgentBlockingRuleArgs,
    ) -> UserAgentBlockingRuleResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let configuration_binding = args.configuration.get_inner();
        let description_binding = args.description.get_inner();
        let mode_binding = args.mode.get_inner();
        let paused_binding = args.paused.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/userAgentBlockingRule:UserAgentBlockingRule".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "configuration".into(),
                    value: &configuration_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "mode".into(),
                    value: &mode_binding,
                },
                register_interface::ObjectField {
                    name: "paused".into(),
                    value: &paused_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "configuration".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "mode".into(),
                },
                register_interface::ResultField {
                    name: "paused".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        UserAgentBlockingRuleResult {
            configuration: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("configuration").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            mode: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("mode").unwrap(),
            ),
            paused: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("paused").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod waiting_room {
    //! Provides a Cloudflare Waiting Room resource.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = waiting_room::create(
    //!         "example",
    //!         WaitingRoomArgs::builder()
    //!             .additional_routes(
    //!                 vec![
    //!                     WaitingRoomAdditionalRoute::builder().host("shop1.example.com")
    //!                     .path("/example-path").build_struct(),
    //!                     WaitingRoomAdditionalRoute::builder().host("shop2.example.com")
    //!                     .build_struct(),
    //!                 ],
    //!             )
    //!             .cookie_suffix("queue1")
    //!             .enabled_origin_commands(vec!["revoke",])
    //!             .host("foo.example.com")
    //!             .name("foo")
    //!             .new_users_per_minute(200)
    //!             .path("/")
    //!             .queueing_status_code(200)
    //!             .total_active_users(200)
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! Use the Zone ID and Waiting Room ID to import.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/waitingRoom:WaitingRoom default <zone_id>/<waiting_room_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct WaitingRoomArgs {
        /// A list of additional hostname and paths combination to be applied on the waiting room.
        #[builder(into, default)]
        pub additional_routes: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WaitingRoomAdditionalRoute>>,
        >,
        /// A cookie suffix to be appended to the Cloudflare waiting room cookie name.
        #[builder(into, default)]
        pub cookie_suffix: pulumi_wasm_rust::Output<Option<String>>,
        /// This is a templated html file that will be rendered at the edge.
        #[builder(into, default)]
        pub custom_page_html: pulumi_wasm_rust::Output<Option<String>>,
        /// The language to use for the default waiting room page. Available values: `de-DE`, `es-ES`, `en-US`, `fr-FR`, `id-ID`, `it-IT`, `ja-JP`, `ko-KR`, `nl-NL`, `pl-PL`, `pt-BR`, `tr-TR`, `zh-CN`, `zh-TW`, `ru-RU`, `fa-IR`, `bg-BG`, `hr-HR`, `cs-CZ`, `da-DK`, `fi-FI`, `lt-LT`, `ms-MY`, `nb-NO`, `ro-RO`, `el-GR`, `he-IL`, `hi-IN`, `hu-HU`, `sr-BA`, `sk-SK`, `sl-SI`, `sv-SE`, `tl-PH`, `th-TH`, `uk-UA`, `vi-VN`. Defaults to `en-US`.
        #[builder(into, default)]
        pub default_template_language: pulumi_wasm_rust::Output<Option<String>>,
        /// A description to add more details about the waiting room.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Disables automatic renewal of session cookies.
        #[builder(into, default)]
        pub disable_session_renewal: pulumi_wasm_rust::Output<Option<bool>>,
        /// The list of enabled origin commands for the waiting room. Available values: `revoke`.
        #[builder(into, default)]
        pub enabled_origin_commands: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Host name for which the waiting room will be applied (no wildcards).
        #[builder(into)]
        pub host: pulumi_wasm_rust::Output<String>,
        /// If true, requests to the waiting room with the header `Accept: application/json` will receive a JSON response object.
        #[builder(into, default)]
        pub json_response_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// A unique name to identify the waiting room. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The number of new users that will be let into the route every minute.
        #[builder(into)]
        pub new_users_per_minute: pulumi_wasm_rust::Output<i32>,
        /// The path within the host to enable the waiting room on. Defaults to `/`.
        #[builder(into, default)]
        pub path: pulumi_wasm_rust::Output<Option<String>>,
        /// If queue_all is true, then all traffic will be sent to the waiting room.
        #[builder(into, default)]
        pub queue_all: pulumi_wasm_rust::Output<Option<bool>>,
        /// The queueing method used by the waiting room. Available values: `fifo`, `random`, `passthrough`, `reject`. Defaults to `fifo`.
        #[builder(into, default)]
        pub queueing_method: pulumi_wasm_rust::Output<Option<String>>,
        /// HTTP status code returned to a user while in the queue. Defaults to `200`.
        #[builder(into, default)]
        pub queueing_status_code: pulumi_wasm_rust::Output<Option<i32>>,
        /// Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the origin. Defaults to `5`.
        #[builder(into, default)]
        pub session_duration: pulumi_wasm_rust::Output<Option<i32>>,
        /// Suspends the waiting room.
        #[builder(into, default)]
        pub suspended: pulumi_wasm_rust::Output<Option<bool>>,
        /// The total number of active user sessions on the route at a point in time.
        #[builder(into)]
        pub total_active_users: pulumi_wasm_rust::Output<i32>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct WaitingRoomResult {
        /// A list of additional hostname and paths combination to be applied on the waiting room.
        pub additional_routes: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WaitingRoomAdditionalRoute>>,
        >,
        /// A cookie suffix to be appended to the Cloudflare waiting room cookie name.
        pub cookie_suffix: pulumi_wasm_rust::Output<Option<String>>,
        /// This is a templated html file that will be rendered at the edge.
        pub custom_page_html: pulumi_wasm_rust::Output<Option<String>>,
        /// The language to use for the default waiting room page. Available values: `de-DE`, `es-ES`, `en-US`, `fr-FR`, `id-ID`, `it-IT`, `ja-JP`, `ko-KR`, `nl-NL`, `pl-PL`, `pt-BR`, `tr-TR`, `zh-CN`, `zh-TW`, `ru-RU`, `fa-IR`, `bg-BG`, `hr-HR`, `cs-CZ`, `da-DK`, `fi-FI`, `lt-LT`, `ms-MY`, `nb-NO`, `ro-RO`, `el-GR`, `he-IL`, `hi-IN`, `hu-HU`, `sr-BA`, `sk-SK`, `sl-SI`, `sv-SE`, `tl-PH`, `th-TH`, `uk-UA`, `vi-VN`. Defaults to `en-US`.
        pub default_template_language: pulumi_wasm_rust::Output<Option<String>>,
        /// A description to add more details about the waiting room.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Disables automatic renewal of session cookies.
        pub disable_session_renewal: pulumi_wasm_rust::Output<Option<bool>>,
        /// The list of enabled origin commands for the waiting room. Available values: `revoke`.
        pub enabled_origin_commands: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Host name for which the waiting room will be applied (no wildcards).
        pub host: pulumi_wasm_rust::Output<String>,
        /// If true, requests to the waiting room with the header `Accept: application/json` will receive a JSON response object.
        pub json_response_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// A unique name to identify the waiting room. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
        /// The number of new users that will be let into the route every minute.
        pub new_users_per_minute: pulumi_wasm_rust::Output<i32>,
        /// The path within the host to enable the waiting room on. Defaults to `/`.
        pub path: pulumi_wasm_rust::Output<Option<String>>,
        /// If queue_all is true, then all traffic will be sent to the waiting room.
        pub queue_all: pulumi_wasm_rust::Output<Option<bool>>,
        /// The queueing method used by the waiting room. Available values: `fifo`, `random`, `passthrough`, `reject`. Defaults to `fifo`.
        pub queueing_method: pulumi_wasm_rust::Output<Option<String>>,
        /// HTTP status code returned to a user while in the queue. Defaults to `200`.
        pub queueing_status_code: pulumi_wasm_rust::Output<Option<i32>>,
        /// Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the origin. Defaults to `5`.
        pub session_duration: pulumi_wasm_rust::Output<Option<i32>>,
        /// Suspends the waiting room.
        pub suspended: pulumi_wasm_rust::Output<Option<bool>>,
        /// The total number of active user sessions on the route at a point in time.
        pub total_active_users: pulumi_wasm_rust::Output<i32>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: WaitingRoomArgs) -> WaitingRoomResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let additional_routes_binding = args.additional_routes.get_inner();
        let cookie_suffix_binding = args.cookie_suffix.get_inner();
        let custom_page_html_binding = args.custom_page_html.get_inner();
        let default_template_language_binding = args
            .default_template_language
            .get_inner();
        let description_binding = args.description.get_inner();
        let disable_session_renewal_binding = args.disable_session_renewal.get_inner();
        let enabled_origin_commands_binding = args.enabled_origin_commands.get_inner();
        let host_binding = args.host.get_inner();
        let json_response_enabled_binding = args.json_response_enabled.get_inner();
        let name_binding = args.name.get_inner();
        let new_users_per_minute_binding = args.new_users_per_minute.get_inner();
        let path_binding = args.path.get_inner();
        let queue_all_binding = args.queue_all.get_inner();
        let queueing_method_binding = args.queueing_method.get_inner();
        let queueing_status_code_binding = args.queueing_status_code.get_inner();
        let session_duration_binding = args.session_duration.get_inner();
        let suspended_binding = args.suspended.get_inner();
        let total_active_users_binding = args.total_active_users.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/waitingRoom:WaitingRoom".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "additionalRoutes".into(),
                    value: &additional_routes_binding,
                },
                register_interface::ObjectField {
                    name: "cookieSuffix".into(),
                    value: &cookie_suffix_binding,
                },
                register_interface::ObjectField {
                    name: "customPageHtml".into(),
                    value: &custom_page_html_binding,
                },
                register_interface::ObjectField {
                    name: "defaultTemplateLanguage".into(),
                    value: &default_template_language_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "disableSessionRenewal".into(),
                    value: &disable_session_renewal_binding,
                },
                register_interface::ObjectField {
                    name: "enabledOriginCommands".into(),
                    value: &enabled_origin_commands_binding,
                },
                register_interface::ObjectField {
                    name: "host".into(),
                    value: &host_binding,
                },
                register_interface::ObjectField {
                    name: "jsonResponseEnabled".into(),
                    value: &json_response_enabled_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "newUsersPerMinute".into(),
                    value: &new_users_per_minute_binding,
                },
                register_interface::ObjectField {
                    name: "path".into(),
                    value: &path_binding,
                },
                register_interface::ObjectField {
                    name: "queueAll".into(),
                    value: &queue_all_binding,
                },
                register_interface::ObjectField {
                    name: "queueingMethod".into(),
                    value: &queueing_method_binding,
                },
                register_interface::ObjectField {
                    name: "queueingStatusCode".into(),
                    value: &queueing_status_code_binding,
                },
                register_interface::ObjectField {
                    name: "sessionDuration".into(),
                    value: &session_duration_binding,
                },
                register_interface::ObjectField {
                    name: "suspended".into(),
                    value: &suspended_binding,
                },
                register_interface::ObjectField {
                    name: "totalActiveUsers".into(),
                    value: &total_active_users_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "additionalRoutes".into(),
                },
                register_interface::ResultField {
                    name: "cookieSuffix".into(),
                },
                register_interface::ResultField {
                    name: "customPageHtml".into(),
                },
                register_interface::ResultField {
                    name: "defaultTemplateLanguage".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "disableSessionRenewal".into(),
                },
                register_interface::ResultField {
                    name: "enabledOriginCommands".into(),
                },
                register_interface::ResultField {
                    name: "host".into(),
                },
                register_interface::ResultField {
                    name: "jsonResponseEnabled".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "newUsersPerMinute".into(),
                },
                register_interface::ResultField {
                    name: "path".into(),
                },
                register_interface::ResultField {
                    name: "queueAll".into(),
                },
                register_interface::ResultField {
                    name: "queueingMethod".into(),
                },
                register_interface::ResultField {
                    name: "queueingStatusCode".into(),
                },
                register_interface::ResultField {
                    name: "sessionDuration".into(),
                },
                register_interface::ResultField {
                    name: "suspended".into(),
                },
                register_interface::ResultField {
                    name: "totalActiveUsers".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        WaitingRoomResult {
            additional_routes: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("additionalRoutes").unwrap(),
            ),
            cookie_suffix: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("cookieSuffix").unwrap(),
            ),
            custom_page_html: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customPageHtml").unwrap(),
            ),
            default_template_language: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("defaultTemplateLanguage").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            disable_session_renewal: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("disableSessionRenewal").unwrap(),
            ),
            enabled_origin_commands: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enabledOriginCommands").unwrap(),
            ),
            host: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("host").unwrap(),
            ),
            json_response_enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("jsonResponseEnabled").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            new_users_per_minute: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("newUsersPerMinute").unwrap(),
            ),
            path: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("path").unwrap(),
            ),
            queue_all: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("queueAll").unwrap(),
            ),
            queueing_method: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("queueingMethod").unwrap(),
            ),
            queueing_status_code: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("queueingStatusCode").unwrap(),
            ),
            session_duration: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("sessionDuration").unwrap(),
            ),
            suspended: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("suspended").unwrap(),
            ),
            total_active_users: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("totalActiveUsers").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod waiting_room_event {
    //! Provides a Cloudflare Waiting Room Event resource.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = waiting_room_event::create(
    //!         "example",
    //!         WaitingRoomEventArgs::builder()
    //!             .event_end_time("2006-01-02T20:04:05Z")
    //!             .event_start_time("2006-01-02T15:04:05Z")
    //!             .name("foo")
    //!             .waiting_room_id("d41d8cd98f00b204e9800998ecf8427e")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! Use the Zone ID, Waiting Room ID, and Event ID to import.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/waitingRoomEvent:WaitingRoomEvent default <zone_id>/<waiting_room_id>/<waiting_room_event_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct WaitingRoomEventArgs {
        /// This is a templated html file that will be rendered at the edge.
        #[builder(into, default)]
        pub custom_page_html: pulumi_wasm_rust::Output<Option<String>>,
        /// A description to let users add more details about the event.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Disables automatic renewal of session cookies.
        #[builder(into, default)]
        pub disable_session_renewal: pulumi_wasm_rust::Output<Option<bool>>,
        /// ISO 8601 timestamp that marks the end of the event. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub event_end_time: pulumi_wasm_rust::Output<String>,
        /// ISO 8601 timestamp that marks the start of the event. Must occur at least 1 minute before `event_end_time`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub event_start_time: pulumi_wasm_rust::Output<String>,
        /// A unique name to identify the event. Only alphanumeric characters, hyphens, and underscores are allowed. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The number of new users that will be let into the route every minute.
        #[builder(into, default)]
        pub new_users_per_minute: pulumi_wasm_rust::Output<Option<i32>>,
        /// ISO 8601 timestamp that marks when to begin queueing all users before the event starts. Must occur at least 5 minutes before `event_start_time`.
        #[builder(into, default)]
        pub prequeue_start_time: pulumi_wasm_rust::Output<Option<String>>,
        /// The queueing method used by the waiting room. Available values: `fifo`, `random`, `passthrough`, `reject`.
        #[builder(into, default)]
        pub queueing_method: pulumi_wasm_rust::Output<Option<String>>,
        /// Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the origin.
        #[builder(into, default)]
        pub session_duration: pulumi_wasm_rust::Output<Option<i32>>,
        /// Users in the prequeue will be shuffled randomly at the `event_start_time`. Requires that `prequeue_start_time` is not null. Defaults to `false`.
        #[builder(into, default)]
        pub shuffle_at_event_start: pulumi_wasm_rust::Output<Option<bool>>,
        /// If suspended, the event is ignored and traffic will be handled based on the waiting room configuration.
        #[builder(into, default)]
        pub suspended: pulumi_wasm_rust::Output<Option<bool>>,
        /// The total number of active user sessions on the route at a point in time.
        #[builder(into, default)]
        pub total_active_users: pulumi_wasm_rust::Output<Option<i32>>,
        /// The Waiting Room ID the event should apply to. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub waiting_room_id: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct WaitingRoomEventResult {
        /// Creation time.
        pub created_on: pulumi_wasm_rust::Output<String>,
        /// This is a templated html file that will be rendered at the edge.
        pub custom_page_html: pulumi_wasm_rust::Output<Option<String>>,
        /// A description to let users add more details about the event.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Disables automatic renewal of session cookies.
        pub disable_session_renewal: pulumi_wasm_rust::Output<Option<bool>>,
        /// ISO 8601 timestamp that marks the end of the event. **Modifying this attribute will force creation of a new resource.**
        pub event_end_time: pulumi_wasm_rust::Output<String>,
        /// ISO 8601 timestamp that marks the start of the event. Must occur at least 1 minute before `event_end_time`. **Modifying this attribute will force creation of a new resource.**
        pub event_start_time: pulumi_wasm_rust::Output<String>,
        /// Last modified time.
        pub modified_on: pulumi_wasm_rust::Output<String>,
        /// A unique name to identify the event. Only alphanumeric characters, hyphens, and underscores are allowed. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
        /// The number of new users that will be let into the route every minute.
        pub new_users_per_minute: pulumi_wasm_rust::Output<Option<i32>>,
        /// ISO 8601 timestamp that marks when to begin queueing all users before the event starts. Must occur at least 5 minutes before `event_start_time`.
        pub prequeue_start_time: pulumi_wasm_rust::Output<Option<String>>,
        /// The queueing method used by the waiting room. Available values: `fifo`, `random`, `passthrough`, `reject`.
        pub queueing_method: pulumi_wasm_rust::Output<Option<String>>,
        /// Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the origin.
        pub session_duration: pulumi_wasm_rust::Output<Option<i32>>,
        /// Users in the prequeue will be shuffled randomly at the `event_start_time`. Requires that `prequeue_start_time` is not null. Defaults to `false`.
        pub shuffle_at_event_start: pulumi_wasm_rust::Output<Option<bool>>,
        /// If suspended, the event is ignored and traffic will be handled based on the waiting room configuration.
        pub suspended: pulumi_wasm_rust::Output<Option<bool>>,
        /// The total number of active user sessions on the route at a point in time.
        pub total_active_users: pulumi_wasm_rust::Output<Option<i32>>,
        /// The Waiting Room ID the event should apply to. **Modifying this attribute will force creation of a new resource.**
        pub waiting_room_id: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: WaitingRoomEventArgs) -> WaitingRoomEventResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let custom_page_html_binding = args.custom_page_html.get_inner();
        let description_binding = args.description.get_inner();
        let disable_session_renewal_binding = args.disable_session_renewal.get_inner();
        let event_end_time_binding = args.event_end_time.get_inner();
        let event_start_time_binding = args.event_start_time.get_inner();
        let name_binding = args.name.get_inner();
        let new_users_per_minute_binding = args.new_users_per_minute.get_inner();
        let prequeue_start_time_binding = args.prequeue_start_time.get_inner();
        let queueing_method_binding = args.queueing_method.get_inner();
        let session_duration_binding = args.session_duration.get_inner();
        let shuffle_at_event_start_binding = args.shuffle_at_event_start.get_inner();
        let suspended_binding = args.suspended.get_inner();
        let total_active_users_binding = args.total_active_users.get_inner();
        let waiting_room_id_binding = args.waiting_room_id.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/waitingRoomEvent:WaitingRoomEvent".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "customPageHtml".into(),
                    value: &custom_page_html_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "disableSessionRenewal".into(),
                    value: &disable_session_renewal_binding,
                },
                register_interface::ObjectField {
                    name: "eventEndTime".into(),
                    value: &event_end_time_binding,
                },
                register_interface::ObjectField {
                    name: "eventStartTime".into(),
                    value: &event_start_time_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "newUsersPerMinute".into(),
                    value: &new_users_per_minute_binding,
                },
                register_interface::ObjectField {
                    name: "prequeueStartTime".into(),
                    value: &prequeue_start_time_binding,
                },
                register_interface::ObjectField {
                    name: "queueingMethod".into(),
                    value: &queueing_method_binding,
                },
                register_interface::ObjectField {
                    name: "sessionDuration".into(),
                    value: &session_duration_binding,
                },
                register_interface::ObjectField {
                    name: "shuffleAtEventStart".into(),
                    value: &shuffle_at_event_start_binding,
                },
                register_interface::ObjectField {
                    name: "suspended".into(),
                    value: &suspended_binding,
                },
                register_interface::ObjectField {
                    name: "totalActiveUsers".into(),
                    value: &total_active_users_binding,
                },
                register_interface::ObjectField {
                    name: "waitingRoomId".into(),
                    value: &waiting_room_id_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "createdOn".into(),
                },
                register_interface::ResultField {
                    name: "customPageHtml".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "disableSessionRenewal".into(),
                },
                register_interface::ResultField {
                    name: "eventEndTime".into(),
                },
                register_interface::ResultField {
                    name: "eventStartTime".into(),
                },
                register_interface::ResultField {
                    name: "modifiedOn".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "newUsersPerMinute".into(),
                },
                register_interface::ResultField {
                    name: "prequeueStartTime".into(),
                },
                register_interface::ResultField {
                    name: "queueingMethod".into(),
                },
                register_interface::ResultField {
                    name: "sessionDuration".into(),
                },
                register_interface::ResultField {
                    name: "shuffleAtEventStart".into(),
                },
                register_interface::ResultField {
                    name: "suspended".into(),
                },
                register_interface::ResultField {
                    name: "totalActiveUsers".into(),
                },
                register_interface::ResultField {
                    name: "waitingRoomId".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        WaitingRoomEventResult {
            created_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("createdOn").unwrap(),
            ),
            custom_page_html: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customPageHtml").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            disable_session_renewal: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("disableSessionRenewal").unwrap(),
            ),
            event_end_time: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("eventEndTime").unwrap(),
            ),
            event_start_time: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("eventStartTime").unwrap(),
            ),
            modified_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("modifiedOn").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            new_users_per_minute: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("newUsersPerMinute").unwrap(),
            ),
            prequeue_start_time: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("prequeueStartTime").unwrap(),
            ),
            queueing_method: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("queueingMethod").unwrap(),
            ),
            session_duration: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("sessionDuration").unwrap(),
            ),
            shuffle_at_event_start: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("shuffleAtEventStart").unwrap(),
            ),
            suspended: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("suspended").unwrap(),
            ),
            total_active_users: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("totalActiveUsers").unwrap(),
            ),
            waiting_room_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("waitingRoomId").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod waiting_room_rules {
    //! Provides a Cloudflare Waiting Room Rules resource.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = waiting_room_rules::create(
    //!         "example",
    //!         WaitingRoomRulesArgs::builder()
    //!             .rules(
    //!                 vec![
    //!                     WaitingRoomRulesRule::builder().action("bypass_waiting_room")
    //!                     .description("bypass ip list")
    //!                     .expression("src.ip in {192.0.2.0 192.0.2.1}").status("enabled")
    //!                     .build_struct(), WaitingRoomRulesRule::builder()
    //!                     .action("bypass_waiting_room").description("bypass query string")
    //!                     .expression("http.request.uri.query contains \"bypass=true\"")
    //!                     .status("enabled").build_struct(),
    //!                 ],
    //!             )
    //!             .waiting_room_id("d41d8cd98f00b204e9800998ecf8427e")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/waitingRoomRules:WaitingRoomRules default <zone_id>/<waiting_room_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct WaitingRoomRulesArgs {
        /// List of rules to apply to the ruleset.
        #[builder(into, default)]
        pub rules: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WaitingRoomRulesRule>>,
        >,
        /// The Waiting Room ID the rules should apply to. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub waiting_room_id: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct WaitingRoomRulesResult {
        /// List of rules to apply to the ruleset.
        pub rules: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WaitingRoomRulesRule>>,
        >,
        /// The Waiting Room ID the rules should apply to. **Modifying this attribute will force creation of a new resource.**
        pub waiting_room_id: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: WaitingRoomRulesArgs) -> WaitingRoomRulesResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let rules_binding = args.rules.get_inner();
        let waiting_room_id_binding = args.waiting_room_id.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/waitingRoomRules:WaitingRoomRules".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "rules".into(),
                    value: &rules_binding,
                },
                register_interface::ObjectField {
                    name: "waitingRoomId".into(),
                    value: &waiting_room_id_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "rules".into(),
                },
                register_interface::ResultField {
                    name: "waitingRoomId".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        WaitingRoomRulesResult {
            rules: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("rules").unwrap(),
            ),
            waiting_room_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("waitingRoomId").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod waiting_room_settings {
    //! Configure zone-wide settings for Cloudflare waiting rooms.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = waiting_room_settings::create(
    //!         "example",
    //!         WaitingRoomSettingsArgs::builder()
    //!             .search_engine_crawler_bypass(true)
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/waitingRoomSettings:WaitingRoomSettings example <zone_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct WaitingRoomSettingsArgs {
        /// Whether to allow verified search engine crawlers to bypass all waiting rooms on this zone. Defaults to `false`.
        #[builder(into, default)]
        pub search_engine_crawler_bypass: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct WaitingRoomSettingsResult {
        /// Whether to allow verified search engine crawlers to bypass all waiting rooms on this zone. Defaults to `false`.
        pub search_engine_crawler_bypass: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: WaitingRoomSettingsArgs,
    ) -> WaitingRoomSettingsResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let search_engine_crawler_bypass_binding = args
            .search_engine_crawler_bypass
            .get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/waitingRoomSettings:WaitingRoomSettings".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "searchEngineCrawlerBypass".into(),
                    value: &search_engine_crawler_bypass_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "searchEngineCrawlerBypass".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        WaitingRoomSettingsResult {
            search_engine_crawler_bypass: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("searchEngineCrawlerBypass").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod web_3_hostname {
    //! Manages Web3 hostnames for IPFS and Ethereum gateways.
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct Web3HostnameArgs {
        /// An optional description of the hostname.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// DNSLink value used if the target is ipfs.
        #[builder(into, default)]
        pub dnslink: pulumi_wasm_rust::Output<Option<String>>,
        /// The hostname that will point to the target gateway via CNAME.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// Target gateway of the hostname.
        #[builder(into)]
        pub target: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct Web3HostnameResult {
        /// Creation time.
        pub created_on: pulumi_wasm_rust::Output<String>,
        /// An optional description of the hostname.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// DNSLink value used if the target is ipfs.
        pub dnslink: pulumi_wasm_rust::Output<Option<String>>,
        /// Last modification time.
        pub modified_on: pulumi_wasm_rust::Output<String>,
        /// The hostname that will point to the target gateway via CNAME.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Status of the hostname's activation.
        pub status: pulumi_wasm_rust::Output<String>,
        /// Target gateway of the hostname.
        pub target: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: Web3HostnameArgs) -> Web3HostnameResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let description_binding = args.description.get_inner();
        let dnslink_binding = args.dnslink.get_inner();
        let name_binding = args.name.get_inner();
        let target_binding = args.target.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/web3Hostname:Web3Hostname".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "dnslink".into(),
                    value: &dnslink_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "target".into(),
                    value: &target_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "createdOn".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "dnslink".into(),
                },
                register_interface::ResultField {
                    name: "modifiedOn".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "status".into(),
                },
                register_interface::ResultField {
                    name: "target".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        Web3HostnameResult {
            created_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("createdOn").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            dnslink: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("dnslink").unwrap(),
            ),
            modified_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("modifiedOn").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            status: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("status").unwrap(),
            ),
            target: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("target").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod web_analytics_rule {
    //! Provides a Cloudflare Web Analytics Rule resource.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = web_analytics_site::create(
    //!         "example",
    //!         WebAnalyticsSiteArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .auto_install(true)
    //!             .zone_tag("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //!     let exampleWebAnalyticsRule = web_analytics_rule::create(
    //!         "exampleWebAnalyticsRule",
    //!         WebAnalyticsRuleArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .host("*")
    //!             .inclusive(false)
    //!             .is_paused(false)
    //!             .paths(vec!["/excluded",])
    //!             .ruleset_id("${example.rulesetId}")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/webAnalyticsRule:WebAnalyticsRule example <account_id>/<ruleset_id>/<rule_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct WebAnalyticsRuleArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The host to apply the rule to.
        #[builder(into)]
        pub host: pulumi_wasm_rust::Output<String>,
        /// Whether the rule includes or excludes the matched traffic from being measured in Web Analytics.
        #[builder(into)]
        pub inclusive: pulumi_wasm_rust::Output<bool>,
        /// Whether the rule is paused or not.
        #[builder(into)]
        pub is_paused: pulumi_wasm_rust::Output<bool>,
        /// A list of paths to apply the rule to.
        #[builder(into)]
        pub paths: pulumi_wasm_rust::Output<Vec<String>>,
        /// The Web Analytics ruleset id. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub ruleset_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct WebAnalyticsRuleResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The host to apply the rule to.
        pub host: pulumi_wasm_rust::Output<String>,
        /// Whether the rule includes or excludes the matched traffic from being measured in Web Analytics.
        pub inclusive: pulumi_wasm_rust::Output<bool>,
        /// Whether the rule is paused or not.
        pub is_paused: pulumi_wasm_rust::Output<bool>,
        /// A list of paths to apply the rule to.
        pub paths: pulumi_wasm_rust::Output<Vec<String>>,
        /// The Web Analytics ruleset id. **Modifying this attribute will force creation of a new resource.**
        pub ruleset_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: WebAnalyticsRuleArgs) -> WebAnalyticsRuleResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let host_binding = args.host.get_inner();
        let inclusive_binding = args.inclusive.get_inner();
        let is_paused_binding = args.is_paused.get_inner();
        let paths_binding = args.paths.get_inner();
        let ruleset_id_binding = args.ruleset_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/webAnalyticsRule:WebAnalyticsRule".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "host".into(),
                    value: &host_binding,
                },
                register_interface::ObjectField {
                    name: "inclusive".into(),
                    value: &inclusive_binding,
                },
                register_interface::ObjectField {
                    name: "isPaused".into(),
                    value: &is_paused_binding,
                },
                register_interface::ObjectField {
                    name: "paths".into(),
                    value: &paths_binding,
                },
                register_interface::ObjectField {
                    name: "rulesetId".into(),
                    value: &ruleset_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "host".into(),
                },
                register_interface::ResultField {
                    name: "inclusive".into(),
                },
                register_interface::ResultField {
                    name: "isPaused".into(),
                },
                register_interface::ResultField {
                    name: "paths".into(),
                },
                register_interface::ResultField {
                    name: "rulesetId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        WebAnalyticsRuleResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            host: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("host").unwrap(),
            ),
            inclusive: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("inclusive").unwrap(),
            ),
            is_paused: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("isPaused").unwrap(),
            ),
            paths: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("paths").unwrap(),
            ),
            ruleset_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("rulesetId").unwrap(),
            ),
        }
    }
}
pub mod web_analytics_site {
    //! Provides a Cloudflare Web Analytics Site resource.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = web_analytics_site::create(
    //!         "example",
    //!         WebAnalyticsSiteArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .auto_install(true)
    //!             .zone_tag("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/webAnalyticsSite:WebAnalyticsSite example <account_id>/<site_tag>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct WebAnalyticsSiteArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether Cloudflare will automatically inject the JavaScript snippet for orange-clouded sites. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub auto_install: pulumi_wasm_rust::Output<bool>,
        /// The hostname to use for gray-clouded sites. Must provide only one of `zone_tag`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub host: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier for orange-clouded sites. Must provide only one of `host`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub zone_tag: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct WebAnalyticsSiteResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether Cloudflare will automatically inject the JavaScript snippet for orange-clouded sites. **Modifying this attribute will force creation of a new resource.**
        pub auto_install: pulumi_wasm_rust::Output<bool>,
        /// The hostname to use for gray-clouded sites. Must provide only one of `zone_tag`. **Modifying this attribute will force creation of a new resource.**
        pub host: pulumi_wasm_rust::Output<Option<String>>,
        /// The ID for the ruleset associated to this Web Analytics Site.
        pub ruleset_id: pulumi_wasm_rust::Output<String>,
        /// The Web Analytics site tag.
        pub site_tag: pulumi_wasm_rust::Output<String>,
        /// The token for the Web Analytics site.
        pub site_token: pulumi_wasm_rust::Output<String>,
        /// The encoded JS snippet to add to your site's HTML page if auto_install is false.
        pub snippet: pulumi_wasm_rust::Output<String>,
        /// The zone identifier for orange-clouded sites. Must provide only one of `host`. **Modifying this attribute will force creation of a new resource.**
        pub zone_tag: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: WebAnalyticsSiteArgs) -> WebAnalyticsSiteResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let auto_install_binding = args.auto_install.get_inner();
        let host_binding = args.host.get_inner();
        let zone_tag_binding = args.zone_tag.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/webAnalyticsSite:WebAnalyticsSite".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "autoInstall".into(),
                    value: &auto_install_binding,
                },
                register_interface::ObjectField {
                    name: "host".into(),
                    value: &host_binding,
                },
                register_interface::ObjectField {
                    name: "zoneTag".into(),
                    value: &zone_tag_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "autoInstall".into(),
                },
                register_interface::ResultField {
                    name: "host".into(),
                },
                register_interface::ResultField {
                    name: "rulesetId".into(),
                },
                register_interface::ResultField {
                    name: "siteTag".into(),
                },
                register_interface::ResultField {
                    name: "siteToken".into(),
                },
                register_interface::ResultField {
                    name: "snippet".into(),
                },
                register_interface::ResultField {
                    name: "zoneTag".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        WebAnalyticsSiteResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            auto_install: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("autoInstall").unwrap(),
            ),
            host: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("host").unwrap(),
            ),
            ruleset_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("rulesetId").unwrap(),
            ),
            site_tag: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("siteTag").unwrap(),
            ),
            site_token: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("siteToken").unwrap(),
            ),
            snippet: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("snippet").unwrap(),
            ),
            zone_tag: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneTag").unwrap(),
            ),
        }
    }
}
pub mod worker_cron_trigger {
    //! Worker Cron Triggers allow users to map a cron expression to a Worker script
    //! using a `ScheduledEvent` listener that enables Workers to be executed on a
    //! schedule. Worker Cron Triggers are ideal for running periodic jobs for
    //! maintenance or calling third-party APIs to collect up-to-date data.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   exampleScript:
    //!     type: cloudflare:WorkersScript
    //!     name: example_script
    //!     properties:
    //!       accountId: f037e56e89293a057740de681ac9abbe
    //!       name: example-script
    //!       content:
    //!         fn::invoke:
    //!           Function: std:file
    //!           Arguments:
    //!             input: path/to/my.js
    //!           Return: result
    //!   exampleTrigger:
    //!     type: cloudflare:WorkerCronTrigger
    //!     name: example_trigger
    //!     properties:
    //!       accountId: f037e56e89293a057740de681ac9abbe
    //!       scriptName: ${exampleScript.name}
    //!       schedules:
    //!         - '*/5 * * * *'
    //!         - 10 7 * * mon-fri
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/workerCronTrigger:WorkerCronTrigger example <account_id>/<script_name>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct WorkerCronTriggerArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Cron expressions to execute the Worker script.
        #[builder(into)]
        pub schedules: pulumi_wasm_rust::Output<Vec<String>>,
        /// Worker script to target for the schedules.
        #[builder(into)]
        pub script_name: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct WorkerCronTriggerResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Cron expressions to execute the Worker script.
        pub schedules: pulumi_wasm_rust::Output<Vec<String>>,
        /// Worker script to target for the schedules.
        pub script_name: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: WorkerCronTriggerArgs) -> WorkerCronTriggerResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let schedules_binding = args.schedules.get_inner();
        let script_name_binding = args.script_name.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/workerCronTrigger:WorkerCronTrigger".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "schedules".into(),
                    value: &schedules_binding,
                },
                register_interface::ObjectField {
                    name: "scriptName".into(),
                    value: &script_name_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "schedules".into(),
                },
                register_interface::ResultField {
                    name: "scriptName".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        WorkerCronTriggerResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            schedules: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("schedules").unwrap(),
            ),
            script_name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("scriptName").unwrap(),
            ),
        }
    }
}
pub mod worker_domain {
    //! Creates a Worker Custom Domain.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = worker_domain::create(
    //!         "example",
    //!         WorkerDomainArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .hostname("subdomain.example.com")
    //!             .service("my-service")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/workerDomain:WorkerDomain example <account_id>/<worker_domain_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct WorkerDomainArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the Worker environment. Defaults to `production`.
        #[builder(into, default)]
        pub environment: pulumi_wasm_rust::Output<Option<String>>,
        /// Hostname of the Worker Domain.
        #[builder(into)]
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// Name of worker script to attach the domain to.
        #[builder(into)]
        pub service: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct WorkerDomainResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the Worker environment. Defaults to `production`.
        pub environment: pulumi_wasm_rust::Output<Option<String>>,
        /// Hostname of the Worker Domain.
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// Name of worker script to attach the domain to.
        pub service: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: WorkerDomainArgs) -> WorkerDomainResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let environment_binding = args.environment.get_inner();
        let hostname_binding = args.hostname.get_inner();
        let service_binding = args.service.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/workerDomain:WorkerDomain".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "environment".into(),
                    value: &environment_binding,
                },
                register_interface::ObjectField {
                    name: "hostname".into(),
                    value: &hostname_binding,
                },
                register_interface::ObjectField {
                    name: "service".into(),
                    value: &service_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "environment".into(),
                },
                register_interface::ResultField {
                    name: "hostname".into(),
                },
                register_interface::ResultField {
                    name: "service".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        WorkerDomainResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            environment: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("environment").unwrap(),
            ),
            hostname: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("hostname").unwrap(),
            ),
            service: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("service").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod worker_route {
    //! Provides a Cloudflare worker route resource. A route will also require a `cloudflare.WorkerScript`.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let myRoute = worker_route::create(
    //!         "myRoute",
    //!         WorkerRouteArgs::builder()
    //!             .pattern("example.com/*")
    //!             .script_name("${myScript.name}")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //!     let myScript = workers_script::create(
    //!         "myScript",
    //!         WorkersScriptArgs::builder().build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/workerRoute:WorkerRoute example <zone_id>/<route_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct WorkerRouteArgs {
        /// The [route pattern](https://developers.cloudflare.com/workers/about/routes/) to associate the Worker with.
        #[builder(into)]
        pub pattern: pulumi_wasm_rust::Output<String>,
        /// Worker script name to invoke for requests that match the route pattern.
        #[builder(into, default)]
        pub script_name: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct WorkerRouteResult {
        /// The [route pattern](https://developers.cloudflare.com/workers/about/routes/) to associate the Worker with.
        pub pattern: pulumi_wasm_rust::Output<String>,
        /// Worker script name to invoke for requests that match the route pattern.
        pub script_name: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: WorkerRouteArgs) -> WorkerRouteResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let pattern_binding = args.pattern.get_inner();
        let script_name_binding = args.script_name.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/workerRoute:WorkerRoute".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "pattern".into(),
                    value: &pattern_binding,
                },
                register_interface::ObjectField {
                    name: "scriptName".into(),
                    value: &script_name_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "pattern".into(),
                },
                register_interface::ResultField {
                    name: "scriptName".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        WorkerRouteResult {
            pattern: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("pattern").unwrap(),
            ),
            script_name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("scriptName").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod worker_script {
    //! Provides a Cloudflare worker script resource. In order for a script to be active, you'll also need to setup a `cloudflare.WorkerRoute`.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   myNamespace:
    //!     type: cloudflare:WorkersKvNamespace
    //!     name: my_namespace
    //!     properties:
    //!       accountId: f037e56e89293a057740de681ac9abbe
    //!       title: example
    //!   # Sets the script with the name "script_1"
    //!   myScript:
    //!     type: cloudflare:WorkerScript
    //!     name: my_script
    //!     properties:
    //!       accountId: f037e56e89293a057740de681ac9abbe
    //!       name: script_1
    //!       content:
    //!         fn::invoke:
    //!           Function: std:file
    //!           Arguments:
    //!             input: script.js
    //!           Return: result
    //!       kvNamespaceBindings:
    //!         - name: MY_EXAMPLE_KV_NAMESPACE
    //!           namespaceId: ${myNamespace.id}
    //!       plainTextBindings:
    //!         - name: MY_EXAMPLE_PLAIN_TEXT
    //!           text: foobar
    //!       secretTextBindings:
    //!         - name: MY_EXAMPLE_SECRET_TEXT
    //!           text: ${secretFooValue}
    //!       webassemblyBindings:
    //!         - name: MY_EXAMPLE_WASM
    //!           module:
    //!             fn::invoke:
    //!               Function: std:filebase64
    //!               Arguments:
    //!                 input: example.wasm
    //!               Return: result
    //!       serviceBindings:
    //!         - name: MY_SERVICE_BINDING
    //!           service: MY_SERVICE
    //!           environment: production
    //!       r2BucketBindings:
    //!         - name: MY_BUCKET
    //!           bucketName: MY_BUCKET_NAME
    //!       analyticsEngineBindings:
    //!         - name: MY_DATASET
    //!           dataset: dataset1
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/workerScript:WorkerScript example <account_id>/<script_name>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct WorkerScriptArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        #[builder(into, default)]
        pub analytics_engine_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkerScriptAnalyticsEngineBinding>>,
        >,
        /// The date to use for the compatibility flag.
        #[builder(into, default)]
        pub compatibility_date: pulumi_wasm_rust::Output<Option<String>>,
        /// Compatibility flags used for Worker Scripts.
        #[builder(into, default)]
        pub compatibility_flags: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The script content.
        #[builder(into)]
        pub content: pulumi_wasm_rust::Output<String>,
        #[builder(into, default)]
        pub d1_database_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkerScriptD1DatabaseBinding>>,
        >,
        /// Name of the Workers for Platforms dispatch namespace.
        #[builder(into, default)]
        pub dispatch_namespace: pulumi_wasm_rust::Output<Option<String>>,
        #[builder(into, default)]
        pub hyperdrive_config_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkerScriptHyperdriveConfigBinding>>,
        >,
        #[builder(into, default)]
        pub kv_namespace_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkerScriptKvNamespaceBinding>>,
        >,
        /// Enabling allows Worker events to be sent to a defined Logpush destination.
        #[builder(into, default)]
        pub logpush: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to upload Worker as a module.
        #[builder(into, default)]
        pub module: pulumi_wasm_rust::Output<Option<bool>>,
        /// The name for the script. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        #[builder(into, default)]
        pub placements: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkerScriptPlacement>>,
        >,
        #[builder(into, default)]
        pub plain_text_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkerScriptPlainTextBinding>>,
        >,
        #[builder(into, default)]
        pub queue_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkerScriptQueueBinding>>,
        >,
        #[builder(into, default)]
        pub r2_bucket_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkerScriptR2BucketBinding>>,
        >,
        #[builder(into, default)]
        pub secret_text_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkerScriptSecretTextBinding>>,
        >,
        #[builder(into, default)]
        pub service_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkerScriptServiceBinding>>,
        >,
        #[builder(into, default)]
        pub tags: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        #[builder(into, default)]
        pub webassembly_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkerScriptWebassemblyBinding>>,
        >,
    }
    #[allow(dead_code)]
    pub struct WorkerScriptResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        pub analytics_engine_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkerScriptAnalyticsEngineBinding>>,
        >,
        /// The date to use for the compatibility flag.
        pub compatibility_date: pulumi_wasm_rust::Output<Option<String>>,
        /// Compatibility flags used for Worker Scripts.
        pub compatibility_flags: pulumi_wasm_rust::Output<Vec<String>>,
        /// The script content.
        pub content: pulumi_wasm_rust::Output<String>,
        pub d1_database_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkerScriptD1DatabaseBinding>>,
        >,
        /// Name of the Workers for Platforms dispatch namespace.
        pub dispatch_namespace: pulumi_wasm_rust::Output<Option<String>>,
        pub hyperdrive_config_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkerScriptHyperdriveConfigBinding>>,
        >,
        pub kv_namespace_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkerScriptKvNamespaceBinding>>,
        >,
        /// Enabling allows Worker events to be sent to a defined Logpush destination.
        pub logpush: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to upload Worker as a module.
        pub module: pulumi_wasm_rust::Output<Option<bool>>,
        /// The name for the script. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
        pub placements: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkerScriptPlacement>>,
        >,
        pub plain_text_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkerScriptPlainTextBinding>>,
        >,
        pub queue_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkerScriptQueueBinding>>,
        >,
        pub r2_bucket_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkerScriptR2BucketBinding>>,
        >,
        pub secret_text_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkerScriptSecretTextBinding>>,
        >,
        pub service_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkerScriptServiceBinding>>,
        >,
        pub tags: pulumi_wasm_rust::Output<Vec<String>>,
        pub webassembly_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkerScriptWebassemblyBinding>>,
        >,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: WorkerScriptArgs) -> WorkerScriptResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let analytics_engine_bindings_binding = args
            .analytics_engine_bindings
            .get_inner();
        let compatibility_date_binding = args.compatibility_date.get_inner();
        let compatibility_flags_binding = args.compatibility_flags.get_inner();
        let content_binding = args.content.get_inner();
        let d1_database_bindings_binding = args.d1_database_bindings.get_inner();
        let dispatch_namespace_binding = args.dispatch_namespace.get_inner();
        let hyperdrive_config_bindings_binding = args
            .hyperdrive_config_bindings
            .get_inner();
        let kv_namespace_bindings_binding = args.kv_namespace_bindings.get_inner();
        let logpush_binding = args.logpush.get_inner();
        let module_binding = args.module.get_inner();
        let name_binding = args.name.get_inner();
        let placements_binding = args.placements.get_inner();
        let plain_text_bindings_binding = args.plain_text_bindings.get_inner();
        let queue_bindings_binding = args.queue_bindings.get_inner();
        let r2_bucket_bindings_binding = args.r2_bucket_bindings.get_inner();
        let secret_text_bindings_binding = args.secret_text_bindings.get_inner();
        let service_bindings_binding = args.service_bindings.get_inner();
        let tags_binding = args.tags.get_inner();
        let webassembly_bindings_binding = args.webassembly_bindings.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/workerScript:WorkerScript".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "analyticsEngineBindings".into(),
                    value: &analytics_engine_bindings_binding,
                },
                register_interface::ObjectField {
                    name: "compatibilityDate".into(),
                    value: &compatibility_date_binding,
                },
                register_interface::ObjectField {
                    name: "compatibilityFlags".into(),
                    value: &compatibility_flags_binding,
                },
                register_interface::ObjectField {
                    name: "content".into(),
                    value: &content_binding,
                },
                register_interface::ObjectField {
                    name: "d1DatabaseBindings".into(),
                    value: &d1_database_bindings_binding,
                },
                register_interface::ObjectField {
                    name: "dispatchNamespace".into(),
                    value: &dispatch_namespace_binding,
                },
                register_interface::ObjectField {
                    name: "hyperdriveConfigBindings".into(),
                    value: &hyperdrive_config_bindings_binding,
                },
                register_interface::ObjectField {
                    name: "kvNamespaceBindings".into(),
                    value: &kv_namespace_bindings_binding,
                },
                register_interface::ObjectField {
                    name: "logpush".into(),
                    value: &logpush_binding,
                },
                register_interface::ObjectField {
                    name: "module".into(),
                    value: &module_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "placements".into(),
                    value: &placements_binding,
                },
                register_interface::ObjectField {
                    name: "plainTextBindings".into(),
                    value: &plain_text_bindings_binding,
                },
                register_interface::ObjectField {
                    name: "queueBindings".into(),
                    value: &queue_bindings_binding,
                },
                register_interface::ObjectField {
                    name: "r2BucketBindings".into(),
                    value: &r2_bucket_bindings_binding,
                },
                register_interface::ObjectField {
                    name: "secretTextBindings".into(),
                    value: &secret_text_bindings_binding,
                },
                register_interface::ObjectField {
                    name: "serviceBindings".into(),
                    value: &service_bindings_binding,
                },
                register_interface::ObjectField {
                    name: "tags".into(),
                    value: &tags_binding,
                },
                register_interface::ObjectField {
                    name: "webassemblyBindings".into(),
                    value: &webassembly_bindings_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "analyticsEngineBindings".into(),
                },
                register_interface::ResultField {
                    name: "compatibilityDate".into(),
                },
                register_interface::ResultField {
                    name: "compatibilityFlags".into(),
                },
                register_interface::ResultField {
                    name: "content".into(),
                },
                register_interface::ResultField {
                    name: "d1DatabaseBindings".into(),
                },
                register_interface::ResultField {
                    name: "dispatchNamespace".into(),
                },
                register_interface::ResultField {
                    name: "hyperdriveConfigBindings".into(),
                },
                register_interface::ResultField {
                    name: "kvNamespaceBindings".into(),
                },
                register_interface::ResultField {
                    name: "logpush".into(),
                },
                register_interface::ResultField {
                    name: "module".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "placements".into(),
                },
                register_interface::ResultField {
                    name: "plainTextBindings".into(),
                },
                register_interface::ResultField {
                    name: "queueBindings".into(),
                },
                register_interface::ResultField {
                    name: "r2BucketBindings".into(),
                },
                register_interface::ResultField {
                    name: "secretTextBindings".into(),
                },
                register_interface::ResultField {
                    name: "serviceBindings".into(),
                },
                register_interface::ResultField {
                    name: "tags".into(),
                },
                register_interface::ResultField {
                    name: "webassemblyBindings".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        WorkerScriptResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            analytics_engine_bindings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("analyticsEngineBindings").unwrap(),
            ),
            compatibility_date: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("compatibilityDate").unwrap(),
            ),
            compatibility_flags: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("compatibilityFlags").unwrap(),
            ),
            content: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("content").unwrap(),
            ),
            d1_database_bindings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("d1DatabaseBindings").unwrap(),
            ),
            dispatch_namespace: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("dispatchNamespace").unwrap(),
            ),
            hyperdrive_config_bindings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("hyperdriveConfigBindings").unwrap(),
            ),
            kv_namespace_bindings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("kvNamespaceBindings").unwrap(),
            ),
            logpush: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("logpush").unwrap(),
            ),
            module: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("module").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            placements: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("placements").unwrap(),
            ),
            plain_text_bindings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("plainTextBindings").unwrap(),
            ),
            queue_bindings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("queueBindings").unwrap(),
            ),
            r2_bucket_bindings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("r2BucketBindings").unwrap(),
            ),
            secret_text_bindings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("secretTextBindings").unwrap(),
            ),
            service_bindings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("serviceBindings").unwrap(),
            ),
            tags: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tags").unwrap(),
            ),
            webassembly_bindings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("webassemblyBindings").unwrap(),
            ),
        }
    }
}
pub mod worker_secret {
    //! Provides a Cloudflare Worker secret resource.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let mySecret = worker_secret::create(
    //!         "mySecret",
    //!         WorkerSecretArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .name("MY_EXAMPLE_SECRET_TEXT")
    //!             .script_name("script_1")
    //!             .secret_text("my_secret_value")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/workerSecret:WorkerSecret example <account_id>/<script_name>/<secret_name>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct WorkerSecretArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the Worker secret. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The name of the Worker script to associate the secret with. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub script_name: pulumi_wasm_rust::Output<String>,
        /// The text of the Worker secret. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub secret_text: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct WorkerSecretResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the Worker secret. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
        /// The name of the Worker script to associate the secret with. **Modifying this attribute will force creation of a new resource.**
        pub script_name: pulumi_wasm_rust::Output<String>,
        /// The text of the Worker secret. **Modifying this attribute will force creation of a new resource.**
        pub secret_text: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: WorkerSecretArgs) -> WorkerSecretResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let name_binding = args.name.get_inner();
        let script_name_binding = args.script_name.get_inner();
        let secret_text_binding = args.secret_text.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/workerSecret:WorkerSecret".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "scriptName".into(),
                    value: &script_name_binding,
                },
                register_interface::ObjectField {
                    name: "secretText".into(),
                    value: &secret_text_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "scriptName".into(),
                },
                register_interface::ResultField {
                    name: "secretText".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        WorkerSecretResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            script_name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("scriptName").unwrap(),
            ),
            secret_text: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("secretText").unwrap(),
            ),
        }
    }
}
pub mod workers_cron_trigger {
    //! Worker Cron Triggers allow users to map a cron expression to a Worker script
    //! using a `ScheduledEvent` listener that enables Workers to be executed on a
    //! schedule. Worker Cron Triggers are ideal for running periodic jobs for
    //! maintenance or calling third-party APIs to collect up-to-date data.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   exampleScript:
    //!     type: cloudflare:WorkersScript
    //!     name: example_script
    //!     properties:
    //!       accountId: f037e56e89293a057740de681ac9abbe
    //!       name: example-script
    //!       content:
    //!         fn::invoke:
    //!           Function: std:file
    //!           Arguments:
    //!             input: path/to/my.js
    //!           Return: result
    //!   exampleTrigger:
    //!     type: cloudflare:WorkersCronTrigger
    //!     name: example_trigger
    //!     properties:
    //!       accountId: f037e56e89293a057740de681ac9abbe
    //!       scriptName: ${exampleScript.name}
    //!       schedules:
    //!         - '*/5 * * * *'
    //!         - 10 7 * * mon-fri
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/workersCronTrigger:WorkersCronTrigger example <account_id>/<script_name>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct WorkersCronTriggerArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Cron expressions to execute the Worker script.
        #[builder(into)]
        pub schedules: pulumi_wasm_rust::Output<Vec<String>>,
        /// Worker script to target for the schedules.
        #[builder(into)]
        pub script_name: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct WorkersCronTriggerResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Cron expressions to execute the Worker script.
        pub schedules: pulumi_wasm_rust::Output<Vec<String>>,
        /// Worker script to target for the schedules.
        pub script_name: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: WorkersCronTriggerArgs) -> WorkersCronTriggerResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let schedules_binding = args.schedules.get_inner();
        let script_name_binding = args.script_name.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/workersCronTrigger:WorkersCronTrigger".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "schedules".into(),
                    value: &schedules_binding,
                },
                register_interface::ObjectField {
                    name: "scriptName".into(),
                    value: &script_name_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "schedules".into(),
                },
                register_interface::ResultField {
                    name: "scriptName".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        WorkersCronTriggerResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            schedules: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("schedules").unwrap(),
            ),
            script_name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("scriptName").unwrap(),
            ),
        }
    }
}
pub mod workers_domain {
    //! Creates a Worker Custom Domain.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = workers_domain::create(
    //!         "example",
    //!         WorkersDomainArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .hostname("subdomain.example.com")
    //!             .service("my-service")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/workersDomain:WorkersDomain example <account_id>/<worker_domain_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct WorkersDomainArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the Worker environment. Defaults to `production`.
        #[builder(into, default)]
        pub environment: pulumi_wasm_rust::Output<Option<String>>,
        /// Hostname of the Worker Domain.
        #[builder(into)]
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// Name of worker script to attach the domain to.
        #[builder(into)]
        pub service: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct WorkersDomainResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the Worker environment. Defaults to `production`.
        pub environment: pulumi_wasm_rust::Output<Option<String>>,
        /// Hostname of the Worker Domain.
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// Name of worker script to attach the domain to.
        pub service: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: WorkersDomainArgs) -> WorkersDomainResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let environment_binding = args.environment.get_inner();
        let hostname_binding = args.hostname.get_inner();
        let service_binding = args.service.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/workersDomain:WorkersDomain".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "environment".into(),
                    value: &environment_binding,
                },
                register_interface::ObjectField {
                    name: "hostname".into(),
                    value: &hostname_binding,
                },
                register_interface::ObjectField {
                    name: "service".into(),
                    value: &service_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "environment".into(),
                },
                register_interface::ResultField {
                    name: "hostname".into(),
                },
                register_interface::ResultField {
                    name: "service".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        WorkersDomainResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            environment: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("environment").unwrap(),
            ),
            hostname: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("hostname").unwrap(),
            ),
            service: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("service").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod workers_for_platforms_dispatch_namespace {
    //! The [Workers for Platforms](https://developers.cloudflare.com/cloudflare-for-platforms/workers-for-platforms/) resource allows you
    //! to manage Cloudflare Workers for Platforms dispatch namespaces.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   example:
    //!     type: cloudflare:WorkersForPlatformsDispatchNamespace
    //!     properties:
    //!       accountId: f037e56e89293a057740de681ac9abbe
    //!       name: example-namespace
    //!   customerWorker1:
    //!     type: cloudflare:WorkersScript
    //!     name: customer_worker_1
    //!     properties:
    //!       accountId: f037e56e89293a057740de681ac9abbe
    //!       name: customer-worker-1
    //!       content:
    //!         fn::invoke:
    //!           Function: std:file
    //!           Arguments:
    //!             input: script.js
    //!           Return: result
    //!       dispatchNamespace: ${example.name}
    //!       tags:
    //!         - free
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/workersForPlatformsDispatchNamespace:WorkersForPlatformsDispatchNamespace example <account_id>/<namespace_name>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct WorkersForPlatformsDispatchNamespaceArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the Workers for Platforms namespace.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct WorkersForPlatformsDispatchNamespaceResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the Workers for Platforms namespace.
        pub name: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: WorkersForPlatformsDispatchNamespaceArgs,
    ) -> WorkersForPlatformsDispatchNamespaceResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let name_binding = args.name.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/workersForPlatformsDispatchNamespace:WorkersForPlatformsDispatchNamespace"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        WorkersForPlatformsDispatchNamespaceResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
        }
    }
}
pub mod workers_for_platforms_namespace {
    //! The [Workers for Platforms](https://developers.cloudflare.com/cloudflare-for-platforms/workers-for-platforms/) resource allows you
    //! to manage Cloudflare Workers for Platforms namespaces.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   example:
    //!     type: cloudflare:WorkersForPlatformsNamespace
    //!     properties:
    //!       accountId: f037e56e89293a057740de681ac9abbe
    //!       name: example-namespace
    //!   customerWorker1:
    //!     type: cloudflare:WorkersScript
    //!     name: customer_worker_1
    //!     properties:
    //!       accountId: f037e56e89293a057740de681ac9abbe
    //!       name: customer-worker-1
    //!       content:
    //!         fn::invoke:
    //!           Function: std:file
    //!           Arguments:
    //!             input: script.js
    //!           Return: result
    //!       dispatchNamespace: ${example.name}
    //!       tags:
    //!         - free
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/workersForPlatformsNamespace:WorkersForPlatformsNamespace example <account_id>/<namespace_name>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct WorkersForPlatformsNamespaceArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the Workers for Platforms namespace.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct WorkersForPlatformsNamespaceResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the Workers for Platforms namespace.
        pub name: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: WorkersForPlatformsNamespaceArgs,
    ) -> WorkersForPlatformsNamespaceResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let name_binding = args.name.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/workersForPlatformsNamespace:WorkersForPlatformsNamespace"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        WorkersForPlatformsNamespaceResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
        }
    }
}
pub mod workers_kv {
    //! Provides a resource to manage a Cloudflare Workers KV Pair.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = workers_kv::create(
    //!         "example",
    //!         WorkersKvArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .key("test-key")
    //!             .namespace_id("${exampleNs.id}")
    //!             .value("test value")
    //!             .build_struct(),
    //!     );
    //!     let exampleNs = workers_kv_namespace::create(
    //!         "exampleNs",
    //!         WorkersKvNamespaceArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .title("test-namespace")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/workersKv:WorkersKv example <account_id>/<namespace_id>/<key_name>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct WorkersKvArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Name of the KV pair. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub key: pulumi_wasm_rust::Output<String>,
        /// The ID of the Workers KV namespace in which you want to create the KV pair. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub namespace_id: pulumi_wasm_rust::Output<String>,
        /// Value of the KV pair.
        #[builder(into)]
        pub value: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct WorkersKvResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Name of the KV pair. **Modifying this attribute will force creation of a new resource.**
        pub key: pulumi_wasm_rust::Output<String>,
        /// The ID of the Workers KV namespace in which you want to create the KV pair. **Modifying this attribute will force creation of a new resource.**
        pub namespace_id: pulumi_wasm_rust::Output<String>,
        /// Value of the KV pair.
        pub value: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: WorkersKvArgs) -> WorkersKvResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let key_binding = args.key.get_inner();
        let namespace_id_binding = args.namespace_id.get_inner();
        let value_binding = args.value.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/workersKv:WorkersKv".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "key".into(),
                    value: &key_binding,
                },
                register_interface::ObjectField {
                    name: "namespaceId".into(),
                    value: &namespace_id_binding,
                },
                register_interface::ObjectField {
                    name: "value".into(),
                    value: &value_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "key".into(),
                },
                register_interface::ResultField {
                    name: "namespaceId".into(),
                },
                register_interface::ResultField {
                    name: "value".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        WorkersKvResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            key: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("key").unwrap(),
            ),
            namespace_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("namespaceId").unwrap(),
            ),
            value: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("value").unwrap(),
            ),
        }
    }
}
pub mod workers_kv_namespace {
    //! Provides the ability to manage Cloudflare Workers KV Namespace features.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = workers_kv_namespace::create(
    //!         "example",
    //!         WorkersKvNamespaceArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .title("test-namespace")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/workersKvNamespace:WorkersKvNamespace example <account_id>/<namespace_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct WorkersKvNamespaceArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Title value of the Worker KV Namespace.
        #[builder(into)]
        pub title: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct WorkersKvNamespaceResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Title value of the Worker KV Namespace.
        pub title: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: WorkersKvNamespaceArgs) -> WorkersKvNamespaceResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let title_binding = args.title.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/workersKvNamespace:WorkersKvNamespace".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "title".into(),
                    value: &title_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "title".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        WorkersKvNamespaceResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            title: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("title").unwrap(),
            ),
        }
    }
}
pub mod workers_route {
    //! Provides a Cloudflare worker route resource. A route will also require a `cloudflare.WorkerScript`.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let myRoute = workers_route::create(
    //!         "myRoute",
    //!         WorkersRouteArgs::builder()
    //!             .pattern("example.com/*")
    //!             .script_name("${myScript.name}")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //!     let myScript = workers_script::create(
    //!         "myScript",
    //!         WorkersScriptArgs::builder().build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/workersRoute:WorkersRoute example <zone_id>/<route_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct WorkersRouteArgs {
        /// The [route pattern](https://developers.cloudflare.com/workers/about/routes/) to associate the Worker with.
        #[builder(into)]
        pub pattern: pulumi_wasm_rust::Output<String>,
        /// Worker script name to invoke for requests that match the route pattern.
        #[builder(into, default)]
        pub script_name: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct WorkersRouteResult {
        /// The [route pattern](https://developers.cloudflare.com/workers/about/routes/) to associate the Worker with.
        pub pattern: pulumi_wasm_rust::Output<String>,
        /// Worker script name to invoke for requests that match the route pattern.
        pub script_name: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: WorkersRouteArgs) -> WorkersRouteResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let pattern_binding = args.pattern.get_inner();
        let script_name_binding = args.script_name.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/workersRoute:WorkersRoute".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "pattern".into(),
                    value: &pattern_binding,
                },
                register_interface::ObjectField {
                    name: "scriptName".into(),
                    value: &script_name_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "pattern".into(),
                },
                register_interface::ResultField {
                    name: "scriptName".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        WorkersRouteResult {
            pattern: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("pattern").unwrap(),
            ),
            script_name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("scriptName").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod workers_script {
    //! Provides a Cloudflare worker script resource. In order for a script to be active, you'll also need to setup a `cloudflare.WorkerRoute`.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   myNamespace:
    //!     type: cloudflare:WorkersKvNamespace
    //!     name: my_namespace
    //!     properties:
    //!       accountId: f037e56e89293a057740de681ac9abbe
    //!       title: example
    //!   # Sets the script with the name "script_1"
    //!   myScript:
    //!     type: cloudflare:WorkersScript
    //!     name: my_script
    //!     properties:
    //!       accountId: f037e56e89293a057740de681ac9abbe
    //!       name: script_1
    //!       content:
    //!         fn::invoke:
    //!           Function: std:file
    //!           Arguments:
    //!             input: script.js
    //!           Return: result
    //!       kvNamespaceBindings:
    //!         - name: MY_EXAMPLE_KV_NAMESPACE
    //!           namespaceId: ${myNamespace.id}
    //!       plainTextBindings:
    //!         - name: MY_EXAMPLE_PLAIN_TEXT
    //!           text: foobar
    //!       secretTextBindings:
    //!         - name: MY_EXAMPLE_SECRET_TEXT
    //!           text: ${secretFooValue}
    //!       webassemblyBindings:
    //!         - name: MY_EXAMPLE_WASM
    //!           module:
    //!             fn::invoke:
    //!               Function: std:filebase64
    //!               Arguments:
    //!                 input: example.wasm
    //!               Return: result
    //!       serviceBindings:
    //!         - name: MY_SERVICE_BINDING
    //!           service: MY_SERVICE
    //!           environment: production
    //!       r2BucketBindings:
    //!         - name: MY_BUCKET
    //!           bucketName: MY_BUCKET_NAME
    //!       analyticsEngineBindings:
    //!         - name: MY_DATASET
    //!           dataset: dataset1
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/workersScript:WorkersScript example <account_id>/<script_name>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct WorkersScriptArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        #[builder(into, default)]
        pub analytics_engine_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkersScriptAnalyticsEngineBinding>>,
        >,
        /// The date to use for the compatibility flag.
        #[builder(into, default)]
        pub compatibility_date: pulumi_wasm_rust::Output<Option<String>>,
        /// Compatibility flags used for Worker Scripts.
        #[builder(into, default)]
        pub compatibility_flags: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The script content.
        #[builder(into)]
        pub content: pulumi_wasm_rust::Output<String>,
        #[builder(into, default)]
        pub d1_database_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkersScriptD1DatabaseBinding>>,
        >,
        /// Name of the Workers for Platforms dispatch namespace.
        #[builder(into, default)]
        pub dispatch_namespace: pulumi_wasm_rust::Output<Option<String>>,
        #[builder(into, default)]
        pub hyperdrive_config_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkersScriptHyperdriveConfigBinding>>,
        >,
        #[builder(into, default)]
        pub kv_namespace_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkersScriptKvNamespaceBinding>>,
        >,
        /// Enabling allows Worker events to be sent to a defined Logpush destination.
        #[builder(into, default)]
        pub logpush: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to upload Worker as a module.
        #[builder(into, default)]
        pub module: pulumi_wasm_rust::Output<Option<bool>>,
        /// The name for the script. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        #[builder(into, default)]
        pub placements: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkersScriptPlacement>>,
        >,
        #[builder(into, default)]
        pub plain_text_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkersScriptPlainTextBinding>>,
        >,
        #[builder(into, default)]
        pub queue_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkersScriptQueueBinding>>,
        >,
        #[builder(into, default)]
        pub r2_bucket_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkersScriptR2BucketBinding>>,
        >,
        #[builder(into, default)]
        pub secret_text_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkersScriptSecretTextBinding>>,
        >,
        #[builder(into, default)]
        pub service_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkersScriptServiceBinding>>,
        >,
        #[builder(into, default)]
        pub tags: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        #[builder(into, default)]
        pub webassembly_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkersScriptWebassemblyBinding>>,
        >,
    }
    #[allow(dead_code)]
    pub struct WorkersScriptResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        pub analytics_engine_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkersScriptAnalyticsEngineBinding>>,
        >,
        /// The date to use for the compatibility flag.
        pub compatibility_date: pulumi_wasm_rust::Output<Option<String>>,
        /// Compatibility flags used for Worker Scripts.
        pub compatibility_flags: pulumi_wasm_rust::Output<Vec<String>>,
        /// The script content.
        pub content: pulumi_wasm_rust::Output<String>,
        pub d1_database_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkersScriptD1DatabaseBinding>>,
        >,
        /// Name of the Workers for Platforms dispatch namespace.
        pub dispatch_namespace: pulumi_wasm_rust::Output<Option<String>>,
        pub hyperdrive_config_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkersScriptHyperdriveConfigBinding>>,
        >,
        pub kv_namespace_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkersScriptKvNamespaceBinding>>,
        >,
        /// Enabling allows Worker events to be sent to a defined Logpush destination.
        pub logpush: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to upload Worker as a module.
        pub module: pulumi_wasm_rust::Output<Option<bool>>,
        /// The name for the script. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
        pub placements: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkersScriptPlacement>>,
        >,
        pub plain_text_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkersScriptPlainTextBinding>>,
        >,
        pub queue_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkersScriptQueueBinding>>,
        >,
        pub r2_bucket_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkersScriptR2BucketBinding>>,
        >,
        pub secret_text_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkersScriptSecretTextBinding>>,
        >,
        pub service_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkersScriptServiceBinding>>,
        >,
        pub tags: pulumi_wasm_rust::Output<Vec<String>>,
        pub webassembly_bindings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::WorkersScriptWebassemblyBinding>>,
        >,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: WorkersScriptArgs) -> WorkersScriptResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let analytics_engine_bindings_binding = args
            .analytics_engine_bindings
            .get_inner();
        let compatibility_date_binding = args.compatibility_date.get_inner();
        let compatibility_flags_binding = args.compatibility_flags.get_inner();
        let content_binding = args.content.get_inner();
        let d1_database_bindings_binding = args.d1_database_bindings.get_inner();
        let dispatch_namespace_binding = args.dispatch_namespace.get_inner();
        let hyperdrive_config_bindings_binding = args
            .hyperdrive_config_bindings
            .get_inner();
        let kv_namespace_bindings_binding = args.kv_namespace_bindings.get_inner();
        let logpush_binding = args.logpush.get_inner();
        let module_binding = args.module.get_inner();
        let name_binding = args.name.get_inner();
        let placements_binding = args.placements.get_inner();
        let plain_text_bindings_binding = args.plain_text_bindings.get_inner();
        let queue_bindings_binding = args.queue_bindings.get_inner();
        let r2_bucket_bindings_binding = args.r2_bucket_bindings.get_inner();
        let secret_text_bindings_binding = args.secret_text_bindings.get_inner();
        let service_bindings_binding = args.service_bindings.get_inner();
        let tags_binding = args.tags.get_inner();
        let webassembly_bindings_binding = args.webassembly_bindings.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/workersScript:WorkersScript".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "analyticsEngineBindings".into(),
                    value: &analytics_engine_bindings_binding,
                },
                register_interface::ObjectField {
                    name: "compatibilityDate".into(),
                    value: &compatibility_date_binding,
                },
                register_interface::ObjectField {
                    name: "compatibilityFlags".into(),
                    value: &compatibility_flags_binding,
                },
                register_interface::ObjectField {
                    name: "content".into(),
                    value: &content_binding,
                },
                register_interface::ObjectField {
                    name: "d1DatabaseBindings".into(),
                    value: &d1_database_bindings_binding,
                },
                register_interface::ObjectField {
                    name: "dispatchNamespace".into(),
                    value: &dispatch_namespace_binding,
                },
                register_interface::ObjectField {
                    name: "hyperdriveConfigBindings".into(),
                    value: &hyperdrive_config_bindings_binding,
                },
                register_interface::ObjectField {
                    name: "kvNamespaceBindings".into(),
                    value: &kv_namespace_bindings_binding,
                },
                register_interface::ObjectField {
                    name: "logpush".into(),
                    value: &logpush_binding,
                },
                register_interface::ObjectField {
                    name: "module".into(),
                    value: &module_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "placements".into(),
                    value: &placements_binding,
                },
                register_interface::ObjectField {
                    name: "plainTextBindings".into(),
                    value: &plain_text_bindings_binding,
                },
                register_interface::ObjectField {
                    name: "queueBindings".into(),
                    value: &queue_bindings_binding,
                },
                register_interface::ObjectField {
                    name: "r2BucketBindings".into(),
                    value: &r2_bucket_bindings_binding,
                },
                register_interface::ObjectField {
                    name: "secretTextBindings".into(),
                    value: &secret_text_bindings_binding,
                },
                register_interface::ObjectField {
                    name: "serviceBindings".into(),
                    value: &service_bindings_binding,
                },
                register_interface::ObjectField {
                    name: "tags".into(),
                    value: &tags_binding,
                },
                register_interface::ObjectField {
                    name: "webassemblyBindings".into(),
                    value: &webassembly_bindings_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "analyticsEngineBindings".into(),
                },
                register_interface::ResultField {
                    name: "compatibilityDate".into(),
                },
                register_interface::ResultField {
                    name: "compatibilityFlags".into(),
                },
                register_interface::ResultField {
                    name: "content".into(),
                },
                register_interface::ResultField {
                    name: "d1DatabaseBindings".into(),
                },
                register_interface::ResultField {
                    name: "dispatchNamespace".into(),
                },
                register_interface::ResultField {
                    name: "hyperdriveConfigBindings".into(),
                },
                register_interface::ResultField {
                    name: "kvNamespaceBindings".into(),
                },
                register_interface::ResultField {
                    name: "logpush".into(),
                },
                register_interface::ResultField {
                    name: "module".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "placements".into(),
                },
                register_interface::ResultField {
                    name: "plainTextBindings".into(),
                },
                register_interface::ResultField {
                    name: "queueBindings".into(),
                },
                register_interface::ResultField {
                    name: "r2BucketBindings".into(),
                },
                register_interface::ResultField {
                    name: "secretTextBindings".into(),
                },
                register_interface::ResultField {
                    name: "serviceBindings".into(),
                },
                register_interface::ResultField {
                    name: "tags".into(),
                },
                register_interface::ResultField {
                    name: "webassemblyBindings".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        WorkersScriptResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            analytics_engine_bindings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("analyticsEngineBindings").unwrap(),
            ),
            compatibility_date: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("compatibilityDate").unwrap(),
            ),
            compatibility_flags: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("compatibilityFlags").unwrap(),
            ),
            content: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("content").unwrap(),
            ),
            d1_database_bindings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("d1DatabaseBindings").unwrap(),
            ),
            dispatch_namespace: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("dispatchNamespace").unwrap(),
            ),
            hyperdrive_config_bindings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("hyperdriveConfigBindings").unwrap(),
            ),
            kv_namespace_bindings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("kvNamespaceBindings").unwrap(),
            ),
            logpush: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("logpush").unwrap(),
            ),
            module: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("module").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            placements: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("placements").unwrap(),
            ),
            plain_text_bindings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("plainTextBindings").unwrap(),
            ),
            queue_bindings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("queueBindings").unwrap(),
            ),
            r2_bucket_bindings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("r2BucketBindings").unwrap(),
            ),
            secret_text_bindings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("secretTextBindings").unwrap(),
            ),
            service_bindings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("serviceBindings").unwrap(),
            ),
            tags: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tags").unwrap(),
            ),
            webassembly_bindings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("webassemblyBindings").unwrap(),
            ),
        }
    }
}
pub mod workers_secret {
    //! Provides a Cloudflare Worker secret resource.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let mySecret = workers_secret::create(
    //!         "mySecret",
    //!         WorkersSecretArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .name("MY_EXAMPLE_SECRET_TEXT")
    //!             .script_name("script_1")
    //!             .secret_text("my_secret_value")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/workersSecret:WorkersSecret example <account_id>/<script_name>/<secret_name>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct WorkersSecretArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the Worker secret. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The name of the Worker script to associate the secret with. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub script_name: pulumi_wasm_rust::Output<String>,
        /// The text of the Worker secret. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub secret_text: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct WorkersSecretResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The name of the Worker secret. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
        /// The name of the Worker script to associate the secret with. **Modifying this attribute will force creation of a new resource.**
        pub script_name: pulumi_wasm_rust::Output<String>,
        /// The text of the Worker secret. **Modifying this attribute will force creation of a new resource.**
        pub secret_text: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: WorkersSecretArgs) -> WorkersSecretResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let name_binding = args.name.get_inner();
        let script_name_binding = args.script_name.get_inner();
        let secret_text_binding = args.secret_text.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/workersSecret:WorkersSecret".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "scriptName".into(),
                    value: &script_name_binding,
                },
                register_interface::ObjectField {
                    name: "secretText".into(),
                    value: &secret_text_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "scriptName".into(),
                },
                register_interface::ResultField {
                    name: "secretText".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        WorkersSecretResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            script_name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("scriptName").unwrap(),
            ),
            secret_text: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("secretText").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_access_application {
    //! Provides a Cloudflare Access Application resource. Access
    //! Applications are used to restrict access to a whole application using an
    //! authorisation gateway managed by Cloudflare.
    //!
    //! > It's required that an `account_id` or `zone_id` is provided and in
    //!    most cases using either is fine. However, if you're using a scoped
    //!    access token, you must provide the argument that matches the token's
    //!    scope. For example, an access token that is scoped to the "example.com"
    //!    zone needs to use the `zone_id` argument.
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustAccessApplication:ZeroTrustAccessApplication example <account_id>/<application_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustAccessApplicationArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// When set to true, users can authenticate to this application using their WARP session. When set to false this application will always require direct IdP authentication. This setting always overrides the organization setting for WARP authentication.
        #[builder(into, default)]
        pub allow_authenticate_via_warp: pulumi_wasm_rust::Output<Option<bool>>,
        /// The identity providers selected for the application.
        #[builder(into, default)]
        pub allowed_idps: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The logo URL of the app launcher.
        #[builder(into, default)]
        pub app_launcher_logo_url: pulumi_wasm_rust::Output<Option<String>>,
        /// Option to show/hide applications in App Launcher. Defaults to `true`.
        #[builder(into, default)]
        pub app_launcher_visible: pulumi_wasm_rust::Output<Option<bool>>,
        /// Option to skip identity provider selection if only one is configured in `allowed_idps`. Defaults to `false`.
        #[builder(into, default)]
        pub auto_redirect_to_identity: pulumi_wasm_rust::Output<Option<bool>>,
        /// The background color of the app launcher.
        #[builder(into, default)]
        pub bg_color: pulumi_wasm_rust::Output<Option<String>>,
        /// CORS configuration for the Access Application. See below for reference structure.
        #[builder(into, default)]
        pub cors_headers: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessApplicationCorsHeader>>,
        >,
        /// Option that returns a custom error message when a user is denied access to the application.
        #[builder(into, default)]
        pub custom_deny_message: pulumi_wasm_rust::Output<Option<String>>,
        /// Option that redirects to a custom URL when a user is denied access to the application via identity based rules.
        #[builder(into, default)]
        pub custom_deny_url: pulumi_wasm_rust::Output<Option<String>>,
        /// Option that redirects to a custom URL when a user is denied access to the application via non identity rules.
        #[builder(into, default)]
        pub custom_non_identity_deny_url: pulumi_wasm_rust::Output<Option<String>>,
        /// The custom pages selected for the application.
        #[builder(into, default)]
        pub custom_pages: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The primary hostname and path that Access will secure. If the app is visible in the App Launcher dashboard, this is the domain that will be displayed.
        #[builder(into, default)]
        pub domain: pulumi_wasm_rust::Output<Option<String>>,
        /// Option to provide increased security against compromised authorization tokens and CSRF attacks by requiring an additional "binding" cookie on requests. Defaults to `false`.
        #[builder(into, default)]
        pub enable_binding_cookie: pulumi_wasm_rust::Output<Option<bool>>,
        /// The footer links of the app launcher.
        #[builder(into, default)]
        pub footer_links: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessApplicationFooterLink>>,
        >,
        /// The background color of the header bar in the app launcher.
        #[builder(into, default)]
        pub header_bg_color: pulumi_wasm_rust::Output<Option<String>>,
        /// Option to add the `HttpOnly` cookie flag to access tokens.
        #[builder(into, default)]
        pub http_only_cookie_attribute: pulumi_wasm_rust::Output<Option<bool>>,
        /// The landing page design of the app launcher.
        #[builder(into, default)]
        pub landing_page_design: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustAccessApplicationLandingPageDesign>,
        >,
        /// Image URL for the logo shown in the app launcher dashboard.
        #[builder(into, default)]
        pub logo_url: pulumi_wasm_rust::Output<Option<String>>,
        /// Friendly name of the Access Application.
        #[builder(into, default)]
        pub name: pulumi_wasm_rust::Output<Option<String>>,
        /// Allows options preflight requests to bypass Access authentication and go directly to the origin. Cannot turn on if cors_headers is set. Defaults to `false`.
        #[builder(into, default)]
        pub options_preflight_bypass: pulumi_wasm_rust::Output<Option<bool>>,
        /// The policies associated with the application, in ascending order of precedence. Warning: Do not use this field while you still have this application ID referenced as `application_id` in any `cloudflare.AccessPolicy` resource, as it can result in an inconsistent state.
        #[builder(into, default)]
        pub policies: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// SaaS configuration for the Access Application.
        #[builder(into, default)]
        pub saas_app: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustAccessApplicationSaasApp>,
        >,
        /// Defines the same-site cookie setting for access tokens. Available values: `none`, `lax`, `strict`.
        #[builder(into, default)]
        pub same_site_cookie_attribute: pulumi_wasm_rust::Output<Option<String>>,
        /// Configuration for provisioning to this application via SCIM. This is currently in closed beta.
        #[builder(into, default)]
        pub scim_config: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustAccessApplicationScimConfig>,
        >,
        /// List of domains that access will secure. Only present for self_hosted, vnc, and ssh applications. Always includes the value set as `domain`.
        #[builder(into, default)]
        pub self_hosted_domains: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Option to return a 401 status code in service authentication rules on failed requests. Defaults to `false`.
        #[builder(into, default)]
        pub service_auth401_redirect: pulumi_wasm_rust::Output<Option<bool>>,
        /// How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`. Defaults to `24h`.
        #[builder(into, default)]
        pub session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// Option to skip the App Launcher landing page. Defaults to `false`.
        #[builder(into, default)]
        pub skip_app_launcher_login_page: pulumi_wasm_rust::Output<Option<bool>>,
        /// Option to skip the authorization interstitial when using the CLI. Defaults to `false`.
        #[builder(into, default)]
        pub skip_interstitial: pulumi_wasm_rust::Output<Option<bool>>,
        /// The itags associated with the application.
        #[builder(into, default)]
        pub tags: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The payload for an infrastructure application which defines the port, protocol, and target attributes. Only applicable to Infrastructure Applications, in which case this field is required.
        #[builder(into, default)]
        pub target_criterias: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessApplicationTargetCriteria>>,
        >,
        /// The application type. Available values: `app_launcher`, `bookmark`, `biso`, `dash_sso`, `saas`, `self_hosted`, `ssh`, `vnc`, `warp`, `infrastructure`. Defaults to `self_hosted`.
        #[builder(into, default)]
        pub type_: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustAccessApplicationResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// When set to true, users can authenticate to this application using their WARP session. When set to false this application will always require direct IdP authentication. This setting always overrides the organization setting for WARP authentication.
        pub allow_authenticate_via_warp: pulumi_wasm_rust::Output<Option<bool>>,
        /// The identity providers selected for the application.
        pub allowed_idps: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The logo URL of the app launcher.
        pub app_launcher_logo_url: pulumi_wasm_rust::Output<Option<String>>,
        /// Option to show/hide applications in App Launcher. Defaults to `true`.
        pub app_launcher_visible: pulumi_wasm_rust::Output<Option<bool>>,
        /// Application Audience (AUD) Tag of the application.
        pub aud: pulumi_wasm_rust::Output<String>,
        /// Option to skip identity provider selection if only one is configured in `allowed_idps`. Defaults to `false`.
        pub auto_redirect_to_identity: pulumi_wasm_rust::Output<Option<bool>>,
        /// The background color of the app launcher.
        pub bg_color: pulumi_wasm_rust::Output<Option<String>>,
        /// CORS configuration for the Access Application. See below for reference structure.
        pub cors_headers: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessApplicationCorsHeader>>,
        >,
        /// Option that returns a custom error message when a user is denied access to the application.
        pub custom_deny_message: pulumi_wasm_rust::Output<Option<String>>,
        /// Option that redirects to a custom URL when a user is denied access to the application via identity based rules.
        pub custom_deny_url: pulumi_wasm_rust::Output<Option<String>>,
        /// Option that redirects to a custom URL when a user is denied access to the application via non identity rules.
        pub custom_non_identity_deny_url: pulumi_wasm_rust::Output<Option<String>>,
        /// The custom pages selected for the application.
        pub custom_pages: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The primary hostname and path that Access will secure. If the app is visible in the App Launcher dashboard, this is the domain that will be displayed.
        pub domain: pulumi_wasm_rust::Output<String>,
        /// Option to provide increased security against compromised authorization tokens and CSRF attacks by requiring an additional "binding" cookie on requests. Defaults to `false`.
        pub enable_binding_cookie: pulumi_wasm_rust::Output<Option<bool>>,
        /// The footer links of the app launcher.
        pub footer_links: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessApplicationFooterLink>>,
        >,
        /// The background color of the header bar in the app launcher.
        pub header_bg_color: pulumi_wasm_rust::Output<Option<String>>,
        /// Option to add the `HttpOnly` cookie flag to access tokens.
        pub http_only_cookie_attribute: pulumi_wasm_rust::Output<Option<bool>>,
        /// The landing page design of the app launcher.
        pub landing_page_design: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustAccessApplicationLandingPageDesign>,
        >,
        /// Image URL for the logo shown in the app launcher dashboard.
        pub logo_url: pulumi_wasm_rust::Output<Option<String>>,
        /// Friendly name of the Access Application.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Allows options preflight requests to bypass Access authentication and go directly to the origin. Cannot turn on if cors_headers is set. Defaults to `false`.
        pub options_preflight_bypass: pulumi_wasm_rust::Output<Option<bool>>,
        /// The policies associated with the application, in ascending order of precedence. Warning: Do not use this field while you still have this application ID referenced as `application_id` in any `cloudflare.AccessPolicy` resource, as it can result in an inconsistent state.
        pub policies: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// SaaS configuration for the Access Application.
        pub saas_app: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustAccessApplicationSaasApp>,
        >,
        /// Defines the same-site cookie setting for access tokens. Available values: `none`, `lax`, `strict`.
        pub same_site_cookie_attribute: pulumi_wasm_rust::Output<Option<String>>,
        /// Configuration for provisioning to this application via SCIM. This is currently in closed beta.
        pub scim_config: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustAccessApplicationScimConfig>,
        >,
        /// List of domains that access will secure. Only present for self_hosted, vnc, and ssh applications. Always includes the value set as `domain`.
        pub self_hosted_domains: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// Option to return a 401 status code in service authentication rules on failed requests. Defaults to `false`.
        pub service_auth401_redirect: pulumi_wasm_rust::Output<Option<bool>>,
        /// How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`. Defaults to `24h`.
        pub session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// Option to skip the App Launcher landing page. Defaults to `false`.
        pub skip_app_launcher_login_page: pulumi_wasm_rust::Output<Option<bool>>,
        /// Option to skip the authorization interstitial when using the CLI. Defaults to `false`.
        pub skip_interstitial: pulumi_wasm_rust::Output<Option<bool>>,
        /// The itags associated with the application.
        pub tags: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The payload for an infrastructure application which defines the port, protocol, and target attributes. Only applicable to Infrastructure Applications, in which case this field is required.
        pub target_criterias: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessApplicationTargetCriteria>>,
        >,
        /// The application type. Available values: `app_launcher`, `bookmark`, `biso`, `dash_sso`, `saas`, `self_hosted`, `ssh`, `vnc`, `warp`, `infrastructure`. Defaults to `self_hosted`.
        pub type_: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustAccessApplicationArgs,
    ) -> ZeroTrustAccessApplicationResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let allow_authenticate_via_warp_binding = args
            .allow_authenticate_via_warp
            .get_inner();
        let allowed_idps_binding = args.allowed_idps.get_inner();
        let app_launcher_logo_url_binding = args.app_launcher_logo_url.get_inner();
        let app_launcher_visible_binding = args.app_launcher_visible.get_inner();
        let auto_redirect_to_identity_binding = args
            .auto_redirect_to_identity
            .get_inner();
        let bg_color_binding = args.bg_color.get_inner();
        let cors_headers_binding = args.cors_headers.get_inner();
        let custom_deny_message_binding = args.custom_deny_message.get_inner();
        let custom_deny_url_binding = args.custom_deny_url.get_inner();
        let custom_non_identity_deny_url_binding = args
            .custom_non_identity_deny_url
            .get_inner();
        let custom_pages_binding = args.custom_pages.get_inner();
        let domain_binding = args.domain.get_inner();
        let enable_binding_cookie_binding = args.enable_binding_cookie.get_inner();
        let footer_links_binding = args.footer_links.get_inner();
        let header_bg_color_binding = args.header_bg_color.get_inner();
        let http_only_cookie_attribute_binding = args
            .http_only_cookie_attribute
            .get_inner();
        let landing_page_design_binding = args.landing_page_design.get_inner();
        let logo_url_binding = args.logo_url.get_inner();
        let name_binding = args.name.get_inner();
        let options_preflight_bypass_binding = args.options_preflight_bypass.get_inner();
        let policies_binding = args.policies.get_inner();
        let saas_app_binding = args.saas_app.get_inner();
        let same_site_cookie_attribute_binding = args
            .same_site_cookie_attribute
            .get_inner();
        let scim_config_binding = args.scim_config.get_inner();
        let self_hosted_domains_binding = args.self_hosted_domains.get_inner();
        let service_auth401_redirect_binding = args.service_auth401_redirect.get_inner();
        let session_duration_binding = args.session_duration.get_inner();
        let skip_app_launcher_login_page_binding = args
            .skip_app_launcher_login_page
            .get_inner();
        let skip_interstitial_binding = args.skip_interstitial.get_inner();
        let tags_binding = args.tags.get_inner();
        let target_criterias_binding = args.target_criterias.get_inner();
        let type__binding = args.type_.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustAccessApplication:ZeroTrustAccessApplication"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "allowAuthenticateViaWarp".into(),
                    value: &allow_authenticate_via_warp_binding,
                },
                register_interface::ObjectField {
                    name: "allowedIdps".into(),
                    value: &allowed_idps_binding,
                },
                register_interface::ObjectField {
                    name: "appLauncherLogoUrl".into(),
                    value: &app_launcher_logo_url_binding,
                },
                register_interface::ObjectField {
                    name: "appLauncherVisible".into(),
                    value: &app_launcher_visible_binding,
                },
                register_interface::ObjectField {
                    name: "autoRedirectToIdentity".into(),
                    value: &auto_redirect_to_identity_binding,
                },
                register_interface::ObjectField {
                    name: "bgColor".into(),
                    value: &bg_color_binding,
                },
                register_interface::ObjectField {
                    name: "corsHeaders".into(),
                    value: &cors_headers_binding,
                },
                register_interface::ObjectField {
                    name: "customDenyMessage".into(),
                    value: &custom_deny_message_binding,
                },
                register_interface::ObjectField {
                    name: "customDenyUrl".into(),
                    value: &custom_deny_url_binding,
                },
                register_interface::ObjectField {
                    name: "customNonIdentityDenyUrl".into(),
                    value: &custom_non_identity_deny_url_binding,
                },
                register_interface::ObjectField {
                    name: "customPages".into(),
                    value: &custom_pages_binding,
                },
                register_interface::ObjectField {
                    name: "domain".into(),
                    value: &domain_binding,
                },
                register_interface::ObjectField {
                    name: "enableBindingCookie".into(),
                    value: &enable_binding_cookie_binding,
                },
                register_interface::ObjectField {
                    name: "footerLinks".into(),
                    value: &footer_links_binding,
                },
                register_interface::ObjectField {
                    name: "headerBgColor".into(),
                    value: &header_bg_color_binding,
                },
                register_interface::ObjectField {
                    name: "httpOnlyCookieAttribute".into(),
                    value: &http_only_cookie_attribute_binding,
                },
                register_interface::ObjectField {
                    name: "landingPageDesign".into(),
                    value: &landing_page_design_binding,
                },
                register_interface::ObjectField {
                    name: "logoUrl".into(),
                    value: &logo_url_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "optionsPreflightBypass".into(),
                    value: &options_preflight_bypass_binding,
                },
                register_interface::ObjectField {
                    name: "policies".into(),
                    value: &policies_binding,
                },
                register_interface::ObjectField {
                    name: "saasApp".into(),
                    value: &saas_app_binding,
                },
                register_interface::ObjectField {
                    name: "sameSiteCookieAttribute".into(),
                    value: &same_site_cookie_attribute_binding,
                },
                register_interface::ObjectField {
                    name: "scimConfig".into(),
                    value: &scim_config_binding,
                },
                register_interface::ObjectField {
                    name: "selfHostedDomains".into(),
                    value: &self_hosted_domains_binding,
                },
                register_interface::ObjectField {
                    name: "serviceAuth401Redirect".into(),
                    value: &service_auth401_redirect_binding,
                },
                register_interface::ObjectField {
                    name: "sessionDuration".into(),
                    value: &session_duration_binding,
                },
                register_interface::ObjectField {
                    name: "skipAppLauncherLoginPage".into(),
                    value: &skip_app_launcher_login_page_binding,
                },
                register_interface::ObjectField {
                    name: "skipInterstitial".into(),
                    value: &skip_interstitial_binding,
                },
                register_interface::ObjectField {
                    name: "tags".into(),
                    value: &tags_binding,
                },
                register_interface::ObjectField {
                    name: "targetCriterias".into(),
                    value: &target_criterias_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "allowAuthenticateViaWarp".into(),
                },
                register_interface::ResultField {
                    name: "allowedIdps".into(),
                },
                register_interface::ResultField {
                    name: "appLauncherLogoUrl".into(),
                },
                register_interface::ResultField {
                    name: "appLauncherVisible".into(),
                },
                register_interface::ResultField {
                    name: "aud".into(),
                },
                register_interface::ResultField {
                    name: "autoRedirectToIdentity".into(),
                },
                register_interface::ResultField {
                    name: "bgColor".into(),
                },
                register_interface::ResultField {
                    name: "corsHeaders".into(),
                },
                register_interface::ResultField {
                    name: "customDenyMessage".into(),
                },
                register_interface::ResultField {
                    name: "customDenyUrl".into(),
                },
                register_interface::ResultField {
                    name: "customNonIdentityDenyUrl".into(),
                },
                register_interface::ResultField {
                    name: "customPages".into(),
                },
                register_interface::ResultField {
                    name: "domain".into(),
                },
                register_interface::ResultField {
                    name: "enableBindingCookie".into(),
                },
                register_interface::ResultField {
                    name: "footerLinks".into(),
                },
                register_interface::ResultField {
                    name: "headerBgColor".into(),
                },
                register_interface::ResultField {
                    name: "httpOnlyCookieAttribute".into(),
                },
                register_interface::ResultField {
                    name: "landingPageDesign".into(),
                },
                register_interface::ResultField {
                    name: "logoUrl".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "optionsPreflightBypass".into(),
                },
                register_interface::ResultField {
                    name: "policies".into(),
                },
                register_interface::ResultField {
                    name: "saasApp".into(),
                },
                register_interface::ResultField {
                    name: "sameSiteCookieAttribute".into(),
                },
                register_interface::ResultField {
                    name: "scimConfig".into(),
                },
                register_interface::ResultField {
                    name: "selfHostedDomains".into(),
                },
                register_interface::ResultField {
                    name: "serviceAuth401Redirect".into(),
                },
                register_interface::ResultField {
                    name: "sessionDuration".into(),
                },
                register_interface::ResultField {
                    name: "skipAppLauncherLoginPage".into(),
                },
                register_interface::ResultField {
                    name: "skipInterstitial".into(),
                },
                register_interface::ResultField {
                    name: "tags".into(),
                },
                register_interface::ResultField {
                    name: "targetCriterias".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustAccessApplicationResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            allow_authenticate_via_warp: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("allowAuthenticateViaWarp").unwrap(),
            ),
            allowed_idps: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("allowedIdps").unwrap(),
            ),
            app_launcher_logo_url: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("appLauncherLogoUrl").unwrap(),
            ),
            app_launcher_visible: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("appLauncherVisible").unwrap(),
            ),
            aud: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("aud").unwrap(),
            ),
            auto_redirect_to_identity: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("autoRedirectToIdentity").unwrap(),
            ),
            bg_color: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("bgColor").unwrap(),
            ),
            cors_headers: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("corsHeaders").unwrap(),
            ),
            custom_deny_message: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customDenyMessage").unwrap(),
            ),
            custom_deny_url: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customDenyUrl").unwrap(),
            ),
            custom_non_identity_deny_url: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customNonIdentityDenyUrl").unwrap(),
            ),
            custom_pages: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customPages").unwrap(),
            ),
            domain: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("domain").unwrap(),
            ),
            enable_binding_cookie: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enableBindingCookie").unwrap(),
            ),
            footer_links: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("footerLinks").unwrap(),
            ),
            header_bg_color: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("headerBgColor").unwrap(),
            ),
            http_only_cookie_attribute: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("httpOnlyCookieAttribute").unwrap(),
            ),
            landing_page_design: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("landingPageDesign").unwrap(),
            ),
            logo_url: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("logoUrl").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            options_preflight_bypass: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("optionsPreflightBypass").unwrap(),
            ),
            policies: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("policies").unwrap(),
            ),
            saas_app: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("saasApp").unwrap(),
            ),
            same_site_cookie_attribute: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("sameSiteCookieAttribute").unwrap(),
            ),
            scim_config: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("scimConfig").unwrap(),
            ),
            self_hosted_domains: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("selfHostedDomains").unwrap(),
            ),
            service_auth401_redirect: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("serviceAuth401Redirect").unwrap(),
            ),
            session_duration: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("sessionDuration").unwrap(),
            ),
            skip_app_launcher_login_page: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("skipAppLauncherLoginPage").unwrap(),
            ),
            skip_interstitial: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("skipInterstitial").unwrap(),
            ),
            tags: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tags").unwrap(),
            ),
            target_criterias: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("targetCriterias").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_access_custom_page {
    //! Provides a resource to customize the pages your end users will see
    //! when trying to reach applications behind Cloudflare Access.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = zero_trust_access_custom_page::create(
    //!         "example",
    //!         ZeroTrustAccessCustomPageArgs::builder()
    //!             .custom_html("<html><body><h1>Forbidden</h1></body></html>")
    //!             .name("example")
    //!             .type_("forbidden")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustAccessCustomPageArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Number of apps to display on the custom page.
        #[builder(into, default)]
        pub app_count: pulumi_wasm_rust::Output<Option<i32>>,
        /// Custom HTML to display on the custom page.
        #[builder(into, default)]
        pub custom_html: pulumi_wasm_rust::Output<Option<String>>,
        /// Friendly name of the Access Custom Page configuration.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// Type of Access custom page to create. Available values: `identity_denied`, `forbidden`.
        #[builder(into)]
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustAccessCustomPageResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Number of apps to display on the custom page.
        pub app_count: pulumi_wasm_rust::Output<Option<i32>>,
        /// Custom HTML to display on the custom page.
        pub custom_html: pulumi_wasm_rust::Output<Option<String>>,
        /// Friendly name of the Access Custom Page configuration.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Type of Access custom page to create. Available values: `identity_denied`, `forbidden`.
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustAccessCustomPageArgs,
    ) -> ZeroTrustAccessCustomPageResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let app_count_binding = args.app_count.get_inner();
        let custom_html_binding = args.custom_html.get_inner();
        let name_binding = args.name.get_inner();
        let type__binding = args.type_.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustAccessCustomPage:ZeroTrustAccessCustomPage"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "appCount".into(),
                    value: &app_count_binding,
                },
                register_interface::ObjectField {
                    name: "customHtml".into(),
                    value: &custom_html_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "appCount".into(),
                },
                register_interface::ResultField {
                    name: "customHtml".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustAccessCustomPageResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            app_count: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("appCount").unwrap(),
            ),
            custom_html: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customHtml").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_access_group {
    //! Provides a Cloudflare Access Group resource. Access Groups are used
    //! in conjunction with Access Policies to restrict access to a
    //! particular resource based on group membership.
    //!
    //! > It's required that an `account_id` or `zone_id` is provided and in
    //!    most cases using either is fine. However, if you're using a scoped
    //!    access token, you must provide the argument that matches the token's
    //!    scope. For example, an access token that is scoped to the "example.com"
    //!    zone needs to use the `zone_id` argument.
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustAccessGroup:ZeroTrustAccessGroup example <account_id>/<group_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustAccessGroupArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        #[builder(into, default)]
        pub excludes: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessGroupExclude>>,
        >,
        #[builder(into)]
        pub includes: pulumi_wasm_rust::Output<
            Vec<super::types::ZeroTrustAccessGroupInclude>,
        >,
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        #[builder(into, default)]
        pub requires: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessGroupRequire>>,
        >,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustAccessGroupResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        pub excludes: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessGroupExclude>>,
        >,
        pub includes: pulumi_wasm_rust::Output<
            Vec<super::types::ZeroTrustAccessGroupInclude>,
        >,
        pub name: pulumi_wasm_rust::Output<String>,
        pub requires: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessGroupRequire>>,
        >,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustAccessGroupArgs,
    ) -> ZeroTrustAccessGroupResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let excludes_binding = args.excludes.get_inner();
        let includes_binding = args.includes.get_inner();
        let name_binding = args.name.get_inner();
        let requires_binding = args.requires.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustAccessGroup:ZeroTrustAccessGroup".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "excludes".into(),
                    value: &excludes_binding,
                },
                register_interface::ObjectField {
                    name: "includes".into(),
                    value: &includes_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "requires".into(),
                    value: &requires_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "excludes".into(),
                },
                register_interface::ResultField {
                    name: "includes".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "requires".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustAccessGroupResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            excludes: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("excludes").unwrap(),
            ),
            includes: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("includes").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            requires: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("requires").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_access_identity_provider {
    //! Provides a Cloudflare Access Identity Provider resource. Identity
    //! Providers are used as an authentication or authorisation source
    //! within Access.
    //!
    //! > It's required that an `account_id` or `zone_id` is provided and in
    //!    most cases using either is fine. However, if you're using a scoped
    //!    access token, you must provide the argument that matches the token's
    //!    scope. For example, an access token that is scoped to the "example.com"
    //!    zone needs to use the `zone_id` argument.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let githubOauth = zero_trust_access_identity_provider::create(
    //!         "githubOauth",
    //!         ZeroTrustAccessIdentityProviderArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .configs(
    //!                 vec![
    //!                     ZeroTrustAccessIdentityProviderConfig::builder().clientId("example")
    //!                     .clientSecret("secret_key").build_struct(),
    //!                 ],
    //!             )
    //!             .name("GitHub OAuth")
    //!             .type_("github")
    //!             .build_struct(),
    //!     );
    //!     let jumpcloudSaml = zero_trust_access_identity_provider::create(
    //!         "jumpcloudSaml",
    //!         ZeroTrustAccessIdentityProviderArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .configs(
    //!                 vec![
    //!                     ZeroTrustAccessIdentityProviderConfig::builder()
    //!                     .attributes(vec!["email", "username",])
    //!                     .idpPublicCert("MIIDpDCCAoygAwIBAgIGAV2ka+55MA0GCSqGSIb3DQEBCwUAMIGSMQswCQ...GF/Q2/MHadws97cZg\nuTnQyuOqPuHbnN83d/2l1NSYKCbHt24o")
    //!                     .issuerUrl("jumpcloud").signRequest(false)
    //!                     .ssoTargetUrl("https://sso.myexample.jumpcloud.com/saml2/cloudflareaccess")
    //!                     .build_struct(),
    //!                 ],
    //!             )
    //!             .name("JumpCloud SAML")
    //!             .type_("saml")
    //!             .build_struct(),
    //!     );
    //!     let okta = zero_trust_access_identity_provider::create(
    //!         "okta",
    //!         ZeroTrustAccessIdentityProviderArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .configs(
    //!                 vec![
    //!                     ZeroTrustAccessIdentityProviderConfig::builder()
    //!                     .apiToken("okta_api_token").clientId("example")
    //!                     .clientSecret("secret_key").oktaAccount("https://example.com")
    //!                     .build_struct(),
    //!                 ],
    //!             )
    //!             .name("Okta")
    //!             .type_("okta")
    //!             .build_struct(),
    //!     );
    //!     let pinLogin = zero_trust_access_identity_provider::create(
    //!         "pinLogin",
    //!         ZeroTrustAccessIdentityProviderArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .name("PIN login")
    //!             .type_("onetimepin")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustAccessIdentityProvider:ZeroTrustAccessIdentityProvider example <account_id>/<identity_provider_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustAccessIdentityProviderArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Provider configuration from the [developer documentation](https://developers.cloudflare.com/access/configuring-identity-providers/).
        #[builder(into, default)]
        pub configs: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessIdentityProviderConfig>>,
        >,
        /// Friendly name of the Access Identity Provider configuration.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// Configuration for SCIM settings for a given IDP.
        #[builder(into, default)]
        pub scim_configs: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessIdentityProviderScimConfig>>,
        >,
        /// The provider type to use. Available values: `azureAD`, `centrify`, `facebook`, `github`, `google`, `google-apps`, `linkedin`, `oidc`, `okta`, `onelogin`, `onetimepin`, `pingone`, `saml`, `yandex`.
        #[builder(into)]
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustAccessIdentityProviderResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Provider configuration from the [developer documentation](https://developers.cloudflare.com/access/configuring-identity-providers/).
        pub configs: pulumi_wasm_rust::Output<
            Vec<super::types::ZeroTrustAccessIdentityProviderConfig>,
        >,
        /// Friendly name of the Access Identity Provider configuration.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Configuration for SCIM settings for a given IDP.
        pub scim_configs: pulumi_wasm_rust::Output<
            Vec<super::types::ZeroTrustAccessIdentityProviderScimConfig>,
        >,
        /// The provider type to use. Available values: `azureAD`, `centrify`, `facebook`, `github`, `google`, `google-apps`, `linkedin`, `oidc`, `okta`, `onelogin`, `onetimepin`, `pingone`, `saml`, `yandex`.
        pub type_: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustAccessIdentityProviderArgs,
    ) -> ZeroTrustAccessIdentityProviderResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let configs_binding = args.configs.get_inner();
        let name_binding = args.name.get_inner();
        let scim_configs_binding = args.scim_configs.get_inner();
        let type__binding = args.type_.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustAccessIdentityProvider:ZeroTrustAccessIdentityProvider"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "configs".into(),
                    value: &configs_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "scimConfigs".into(),
                    value: &scim_configs_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "configs".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "scimConfigs".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustAccessIdentityProviderResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            configs: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("configs").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            scim_configs: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("scimConfigs").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_access_mtls_certificate {
    //! Provides a Cloudflare Access Mutual TLS Certificate resource.
    //! Mutual TLS authentication ensures that the traffic is secure and
    //! trusted in both directions between a client and server and can be
    //!  used with Access to only allows requests from devices with a
    //!  corresponding client certificate.
    //!
    //! > It's required that an `account_id` or `zone_id` is provided and in
    //!    most cases using either is fine. However, if you're using a scoped
    //!    access token, you must provide the argument that matches the token's
    //!    scope. For example, an access token that is scoped to the "example.com"
    //!    zone needs to use the `zone_id` argument.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let myCert = zero_trust_access_mtls_certificate::create(
    //!         "myCert",
    //!         ZeroTrustAccessMtlsCertificateArgs::builder()
    //!             .associated_hostnames(vec!["staging.example.com",])
    //!             .certificate("${caPem}")
    //!             .name("My Root Cert")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! Account level import.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustAccessMtlsCertificate:ZeroTrustAccessMtlsCertificate cloudflare_zero_sd -t_access_mtls_certificate.example account/<account_id>/<mutual_tls_certificate_id>
    //! ```
    //!
    //! Zone level import.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustAccessMtlsCertificate:ZeroTrustAccessMtlsCertificate cloudflare_zero_sd -t_access_mtls_certificate.example zone/<zone_id>/<mutual_tls_certificate_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustAccessMtlsCertificateArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The hostnames that will be prompted for this certificate.
        #[builder(into, default)]
        pub associated_hostnames: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The Root CA for your certificates.
        #[builder(into, default)]
        pub certificate: pulumi_wasm_rust::Output<Option<String>>,
        /// The name of the certificate.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustAccessMtlsCertificateResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The hostnames that will be prompted for this certificate.
        pub associated_hostnames: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The Root CA for your certificates.
        pub certificate: pulumi_wasm_rust::Output<Option<String>>,
        pub fingerprint: pulumi_wasm_rust::Output<String>,
        /// The name of the certificate.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustAccessMtlsCertificateArgs,
    ) -> ZeroTrustAccessMtlsCertificateResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let associated_hostnames_binding = args.associated_hostnames.get_inner();
        let certificate_binding = args.certificate.get_inner();
        let name_binding = args.name.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustAccessMtlsCertificate:ZeroTrustAccessMtlsCertificate"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "associatedHostnames".into(),
                    value: &associated_hostnames_binding,
                },
                register_interface::ObjectField {
                    name: "certificate".into(),
                    value: &certificate_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "associatedHostnames".into(),
                },
                register_interface::ResultField {
                    name: "certificate".into(),
                },
                register_interface::ResultField {
                    name: "fingerprint".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustAccessMtlsCertificateResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            associated_hostnames: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("associatedHostnames").unwrap(),
            ),
            certificate: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("certificate").unwrap(),
            ),
            fingerprint: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("fingerprint").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_access_mtls_hostname_settings {
    //! Provides a Cloudflare Access Mutual TLS Certificate Settings resource.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = zero_trust_access_mtls_hostname_settings::create(
    //!         "example",
    //!         ZeroTrustAccessMtlsHostnameSettingsArgs::builder()
    //!             .settings(
    //!                 vec![
    //!                     ZeroTrustAccessMtlsHostnameSettingsSetting::builder()
    //!                     .chinaNetwork(false).clientCertificateForwarding(true)
    //!                     .hostname("example.com").build_struct(),
    //!                 ],
    //!             )
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! Account level mTLS hostname settings import.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustAccessMtlsHostnameSettings:ZeroTrustAccessMtlsHostnameSettings example account/<account_id>
    //! ```
    //!
    //! Zone level mTLS hostname settings import.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustAccessMtlsHostnameSettings:ZeroTrustAccessMtlsHostnameSettings example zone/<zone_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustAccessMtlsHostnameSettingsArgs {
        /// The account identifier to target for the resource.
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        #[builder(into, default)]
        pub settings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessMtlsHostnameSettingsSetting>>,
        >,
        /// The zone identifier to target for the resource.
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustAccessMtlsHostnameSettingsResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        pub settings: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessMtlsHostnameSettingsSetting>>,
        >,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustAccessMtlsHostnameSettingsArgs,
    ) -> ZeroTrustAccessMtlsHostnameSettingsResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let settings_binding = args.settings.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustAccessMtlsHostnameSettings:ZeroTrustAccessMtlsHostnameSettings"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "settings".into(),
                    value: &settings_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "settings".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustAccessMtlsHostnameSettingsResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            settings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("settings").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_access_organization {
    //! A Zero Trust organization defines the user login experience.
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustAccessOrganizationArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// When set to true, users can authenticate via WARP for any application in your organization. Application settings will take precedence over this value.
        #[builder(into, default)]
        pub allow_authenticate_via_warp: pulumi_wasm_rust::Output<Option<bool>>,
        /// The unique subdomain assigned to your Zero Trust organization.
        #[builder(into)]
        pub auth_domain: pulumi_wasm_rust::Output<String>,
        /// When set to true, users skip the identity provider selection step during login.
        #[builder(into, default)]
        pub auto_redirect_to_identity: pulumi_wasm_rust::Output<Option<bool>>,
        /// Custom pages for your Zero Trust organization.
        #[builder(into, default)]
        pub custom_pages: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessOrganizationCustomPage>>,
        >,
        /// When set to true, this will disable all editing of Access resources via the Zero Trust Dashboard.
        #[builder(into, default)]
        pub is_ui_read_only: pulumi_wasm_rust::Output<Option<bool>>,
        #[builder(into, default)]
        pub login_designs: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessOrganizationLoginDesign>>,
        >,
        /// The name of your Zero Trust organization.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.
        #[builder(into, default)]
        pub session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// A description of the reason why the UI read only field is being toggled.
        #[builder(into, default)]
        pub ui_read_only_toggle_reason: pulumi_wasm_rust::Output<Option<String>>,
        /// The amount of time a user seat is inactive before it expires. When the user seat exceeds the set time of inactivity, the user is removed as an active seat and no longer counts against your Teams seat count. Must be in the format `300ms` or `2h45m`.
        #[builder(into, default)]
        pub user_seat_expiration_inactive_time: pulumi_wasm_rust::Output<Option<String>>,
        /// The amount of time that tokens issued for applications will be valid. Must be in the format 30m or 2h45m. Valid time units are: m, h.
        #[builder(into, default)]
        pub warp_auth_session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustAccessOrganizationResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// When set to true, users can authenticate via WARP for any application in your organization. Application settings will take precedence over this value.
        pub allow_authenticate_via_warp: pulumi_wasm_rust::Output<Option<bool>>,
        /// The unique subdomain assigned to your Zero Trust organization.
        pub auth_domain: pulumi_wasm_rust::Output<String>,
        /// When set to true, users skip the identity provider selection step during login.
        pub auto_redirect_to_identity: pulumi_wasm_rust::Output<Option<bool>>,
        /// Custom pages for your Zero Trust organization.
        pub custom_pages: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessOrganizationCustomPage>>,
        >,
        /// When set to true, this will disable all editing of Access resources via the Zero Trust Dashboard.
        pub is_ui_read_only: pulumi_wasm_rust::Output<Option<bool>>,
        pub login_designs: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessOrganizationLoginDesign>>,
        >,
        /// The name of your Zero Trust organization.
        pub name: pulumi_wasm_rust::Output<String>,
        /// How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.
        pub session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// A description of the reason why the UI read only field is being toggled.
        pub ui_read_only_toggle_reason: pulumi_wasm_rust::Output<Option<String>>,
        /// The amount of time a user seat is inactive before it expires. When the user seat exceeds the set time of inactivity, the user is removed as an active seat and no longer counts against your Teams seat count. Must be in the format `300ms` or `2h45m`.
        pub user_seat_expiration_inactive_time: pulumi_wasm_rust::Output<Option<String>>,
        /// The amount of time that tokens issued for applications will be valid. Must be in the format 30m or 2h45m. Valid time units are: m, h.
        pub warp_auth_session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustAccessOrganizationArgs,
    ) -> ZeroTrustAccessOrganizationResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let allow_authenticate_via_warp_binding = args
            .allow_authenticate_via_warp
            .get_inner();
        let auth_domain_binding = args.auth_domain.get_inner();
        let auto_redirect_to_identity_binding = args
            .auto_redirect_to_identity
            .get_inner();
        let custom_pages_binding = args.custom_pages.get_inner();
        let is_ui_read_only_binding = args.is_ui_read_only.get_inner();
        let login_designs_binding = args.login_designs.get_inner();
        let name_binding = args.name.get_inner();
        let session_duration_binding = args.session_duration.get_inner();
        let ui_read_only_toggle_reason_binding = args
            .ui_read_only_toggle_reason
            .get_inner();
        let user_seat_expiration_inactive_time_binding = args
            .user_seat_expiration_inactive_time
            .get_inner();
        let warp_auth_session_duration_binding = args
            .warp_auth_session_duration
            .get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustAccessOrganization:ZeroTrustAccessOrganization"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "allowAuthenticateViaWarp".into(),
                    value: &allow_authenticate_via_warp_binding,
                },
                register_interface::ObjectField {
                    name: "authDomain".into(),
                    value: &auth_domain_binding,
                },
                register_interface::ObjectField {
                    name: "autoRedirectToIdentity".into(),
                    value: &auto_redirect_to_identity_binding,
                },
                register_interface::ObjectField {
                    name: "customPages".into(),
                    value: &custom_pages_binding,
                },
                register_interface::ObjectField {
                    name: "isUiReadOnly".into(),
                    value: &is_ui_read_only_binding,
                },
                register_interface::ObjectField {
                    name: "loginDesigns".into(),
                    value: &login_designs_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "sessionDuration".into(),
                    value: &session_duration_binding,
                },
                register_interface::ObjectField {
                    name: "uiReadOnlyToggleReason".into(),
                    value: &ui_read_only_toggle_reason_binding,
                },
                register_interface::ObjectField {
                    name: "userSeatExpirationInactiveTime".into(),
                    value: &user_seat_expiration_inactive_time_binding,
                },
                register_interface::ObjectField {
                    name: "warpAuthSessionDuration".into(),
                    value: &warp_auth_session_duration_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "allowAuthenticateViaWarp".into(),
                },
                register_interface::ResultField {
                    name: "authDomain".into(),
                },
                register_interface::ResultField {
                    name: "autoRedirectToIdentity".into(),
                },
                register_interface::ResultField {
                    name: "customPages".into(),
                },
                register_interface::ResultField {
                    name: "isUiReadOnly".into(),
                },
                register_interface::ResultField {
                    name: "loginDesigns".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "sessionDuration".into(),
                },
                register_interface::ResultField {
                    name: "uiReadOnlyToggleReason".into(),
                },
                register_interface::ResultField {
                    name: "userSeatExpirationInactiveTime".into(),
                },
                register_interface::ResultField {
                    name: "warpAuthSessionDuration".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustAccessOrganizationResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            allow_authenticate_via_warp: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("allowAuthenticateViaWarp").unwrap(),
            ),
            auth_domain: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("authDomain").unwrap(),
            ),
            auto_redirect_to_identity: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("autoRedirectToIdentity").unwrap(),
            ),
            custom_pages: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customPages").unwrap(),
            ),
            is_ui_read_only: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("isUiReadOnly").unwrap(),
            ),
            login_designs: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("loginDesigns").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            session_duration: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("sessionDuration").unwrap(),
            ),
            ui_read_only_toggle_reason: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("uiReadOnlyToggleReason").unwrap(),
            ),
            user_seat_expiration_inactive_time: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("userSeatExpirationInactiveTime").unwrap(),
            ),
            warp_auth_session_duration: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("warpAuthSessionDuration").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_access_policy {
    //! Provides a Cloudflare Access Policy resource. Access Policies are
    //! used in conjunction with Access Applications to restrict access to
    //! a particular resource.
    //!
    //! > It's required that an `account_id` or `zone_id` is provided and in most cases using either is fine.
    //!    However, if you're using a scoped access token, you must provide the argument that matches the token's
    //!    scope. For example, an access token that is scoped to the "example.com" zone needs to use the `zone_id` argument.
    //!    If 'application_id' is omitted, the policy created can be reused by multiple access applications.
    //!    Any cloudflare.AccessApplication resource can reference reusable policies through its `policies` argument.
    //!    To destroy a reusable policy and remove it from all applications' policies lists on the same apply, preemptively set the
    //!    lifecycle option `create_before_destroy` to true on the 'cloudflare_access_policy' resource.
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustAccessPolicy:ZeroTrustAccessPolicy example account/<account_id>/<application_id>/<policy_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustAccessPolicyArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The ID of the application the policy is associated with. Required when using `precedence`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub application_id: pulumi_wasm_rust::Output<Option<String>>,
        #[builder(into, default)]
        pub approval_groups: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessPolicyApprovalGroup>>,
        >,
        #[builder(into, default)]
        pub approval_required: pulumi_wasm_rust::Output<Option<bool>>,
        /// The rules that define how users may connect to the targets secured by your application. Only applicable to Infrastructure Applications, in which case this field is required.
        #[builder(into, default)]
        pub connection_rules: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustAccessPolicyConnectionRules>,
        >,
        /// Defines the action Access will take if the policy matches the user. Available values: `allow`, `deny`, `non_identity`, `bypass`.
        #[builder(into)]
        pub decision: pulumi_wasm_rust::Output<String>,
        /// A series of access conditions, see Access Groups.
        #[builder(into, default)]
        pub excludes: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessPolicyExclude>>,
        >,
        /// A series of access conditions, see Access Groups.
        #[builder(into)]
        pub includes: pulumi_wasm_rust::Output<
            Vec<super::types::ZeroTrustAccessPolicyInclude>,
        >,
        /// Require this application to be served in an isolated browser for users matching this policy.
        #[builder(into, default)]
        pub isolation_required: pulumi_wasm_rust::Output<Option<bool>>,
        /// Friendly name of the Access Policy.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The unique precedence for policies on a single application. Required when using `application_id`.
        #[builder(into, default)]
        pub precedence: pulumi_wasm_rust::Output<Option<i32>>,
        /// The prompt to display to the user for a justification for accessing the resource. Required when using `purpose_justification_required`.
        #[builder(into, default)]
        pub purpose_justification_prompt: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether to prompt the user for a justification for accessing the resource.
        #[builder(into, default)]
        pub purpose_justification_required: pulumi_wasm_rust::Output<Option<bool>>,
        /// A series of access conditions, see Access Groups.
        #[builder(into, default)]
        pub requires: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessPolicyRequire>>,
        >,
        /// How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.
        #[builder(into, default)]
        pub session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustAccessPolicyResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The ID of the application the policy is associated with. Required when using `precedence`. **Modifying this attribute will force creation of a new resource.**
        pub application_id: pulumi_wasm_rust::Output<Option<String>>,
        pub approval_groups: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessPolicyApprovalGroup>>,
        >,
        pub approval_required: pulumi_wasm_rust::Output<Option<bool>>,
        /// The rules that define how users may connect to the targets secured by your application. Only applicable to Infrastructure Applications, in which case this field is required.
        pub connection_rules: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustAccessPolicyConnectionRules>,
        >,
        /// Defines the action Access will take if the policy matches the user. Available values: `allow`, `deny`, `non_identity`, `bypass`.
        pub decision: pulumi_wasm_rust::Output<String>,
        /// A series of access conditions, see Access Groups.
        pub excludes: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessPolicyExclude>>,
        >,
        /// A series of access conditions, see Access Groups.
        pub includes: pulumi_wasm_rust::Output<
            Vec<super::types::ZeroTrustAccessPolicyInclude>,
        >,
        /// Require this application to be served in an isolated browser for users matching this policy.
        pub isolation_required: pulumi_wasm_rust::Output<Option<bool>>,
        /// Friendly name of the Access Policy.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The unique precedence for policies on a single application. Required when using `application_id`.
        pub precedence: pulumi_wasm_rust::Output<Option<i32>>,
        /// The prompt to display to the user for a justification for accessing the resource. Required when using `purpose_justification_required`.
        pub purpose_justification_prompt: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether to prompt the user for a justification for accessing the resource.
        pub purpose_justification_required: pulumi_wasm_rust::Output<Option<bool>>,
        /// A series of access conditions, see Access Groups.
        pub requires: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustAccessPolicyRequire>>,
        >,
        /// How often a user will be forced to re-authorise. Must be in the format `48h` or `2h45m`.
        pub session_duration: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustAccessPolicyArgs,
    ) -> ZeroTrustAccessPolicyResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let application_id_binding = args.application_id.get_inner();
        let approval_groups_binding = args.approval_groups.get_inner();
        let approval_required_binding = args.approval_required.get_inner();
        let connection_rules_binding = args.connection_rules.get_inner();
        let decision_binding = args.decision.get_inner();
        let excludes_binding = args.excludes.get_inner();
        let includes_binding = args.includes.get_inner();
        let isolation_required_binding = args.isolation_required.get_inner();
        let name_binding = args.name.get_inner();
        let precedence_binding = args.precedence.get_inner();
        let purpose_justification_prompt_binding = args
            .purpose_justification_prompt
            .get_inner();
        let purpose_justification_required_binding = args
            .purpose_justification_required
            .get_inner();
        let requires_binding = args.requires.get_inner();
        let session_duration_binding = args.session_duration.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustAccessPolicy:ZeroTrustAccessPolicy".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "applicationId".into(),
                    value: &application_id_binding,
                },
                register_interface::ObjectField {
                    name: "approvalGroups".into(),
                    value: &approval_groups_binding,
                },
                register_interface::ObjectField {
                    name: "approvalRequired".into(),
                    value: &approval_required_binding,
                },
                register_interface::ObjectField {
                    name: "connectionRules".into(),
                    value: &connection_rules_binding,
                },
                register_interface::ObjectField {
                    name: "decision".into(),
                    value: &decision_binding,
                },
                register_interface::ObjectField {
                    name: "excludes".into(),
                    value: &excludes_binding,
                },
                register_interface::ObjectField {
                    name: "includes".into(),
                    value: &includes_binding,
                },
                register_interface::ObjectField {
                    name: "isolationRequired".into(),
                    value: &isolation_required_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "precedence".into(),
                    value: &precedence_binding,
                },
                register_interface::ObjectField {
                    name: "purposeJustificationPrompt".into(),
                    value: &purpose_justification_prompt_binding,
                },
                register_interface::ObjectField {
                    name: "purposeJustificationRequired".into(),
                    value: &purpose_justification_required_binding,
                },
                register_interface::ObjectField {
                    name: "requires".into(),
                    value: &requires_binding,
                },
                register_interface::ObjectField {
                    name: "sessionDuration".into(),
                    value: &session_duration_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "applicationId".into(),
                },
                register_interface::ResultField {
                    name: "approvalGroups".into(),
                },
                register_interface::ResultField {
                    name: "approvalRequired".into(),
                },
                register_interface::ResultField {
                    name: "connectionRules".into(),
                },
                register_interface::ResultField {
                    name: "decision".into(),
                },
                register_interface::ResultField {
                    name: "excludes".into(),
                },
                register_interface::ResultField {
                    name: "includes".into(),
                },
                register_interface::ResultField {
                    name: "isolationRequired".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "precedence".into(),
                },
                register_interface::ResultField {
                    name: "purposeJustificationPrompt".into(),
                },
                register_interface::ResultField {
                    name: "purposeJustificationRequired".into(),
                },
                register_interface::ResultField {
                    name: "requires".into(),
                },
                register_interface::ResultField {
                    name: "sessionDuration".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustAccessPolicyResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            application_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("applicationId").unwrap(),
            ),
            approval_groups: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("approvalGroups").unwrap(),
            ),
            approval_required: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("approvalRequired").unwrap(),
            ),
            connection_rules: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("connectionRules").unwrap(),
            ),
            decision: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("decision").unwrap(),
            ),
            excludes: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("excludes").unwrap(),
            ),
            includes: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("includes").unwrap(),
            ),
            isolation_required: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("isolationRequired").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            precedence: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("precedence").unwrap(),
            ),
            purpose_justification_prompt: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("purposeJustificationPrompt").unwrap(),
            ),
            purpose_justification_required: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("purposeJustificationRequired").unwrap(),
            ),
            requires: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("requires").unwrap(),
            ),
            session_duration: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("sessionDuration").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_access_service_token {
    //! Access Service Tokens are used for service-to-service communication
    //! when an application is behind Cloudflare Access.
    //!
    //! ## Import
    //!
    //! If you are importing an Access Service Token you will not have the
    //!
    //! client_secret available in the state for use. The client_secret is only
    //!
    //! available once, at creation. In most cases, it is better to just create a new
    //!
    //! resource should you need to reference it in other resources.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustAccessServiceToken:ZeroTrustAccessServiceToken example <account_id>/<service_token_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustAccessServiceTokenArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Length of time the service token is valid for. Available values: `8760h`, `17520h`, `43800h`, `87600h`, `forever`.
        #[builder(into, default)]
        pub duration: pulumi_wasm_rust::Output<Option<String>>,
        #[builder(into, default)]
        pub min_days_for_renewal: pulumi_wasm_rust::Output<Option<i32>>,
        /// Friendly name of the token's intent.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustAccessServiceTokenResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Client ID associated with the Service Token. **Modifying this attribute will force creation of a new resource.**
        pub client_id: pulumi_wasm_rust::Output<String>,
        /// A secret for interacting with Access protocols. **Modifying this attribute will force creation of a new resource.**
        pub client_secret: pulumi_wasm_rust::Output<String>,
        /// Length of time the service token is valid for. Available values: `8760h`, `17520h`, `43800h`, `87600h`, `forever`.
        pub duration: pulumi_wasm_rust::Output<String>,
        /// Date when the token expires.
        pub expires_at: pulumi_wasm_rust::Output<String>,
        pub min_days_for_renewal: pulumi_wasm_rust::Output<Option<i32>>,
        /// Friendly name of the token's intent.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustAccessServiceTokenArgs,
    ) -> ZeroTrustAccessServiceTokenResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let duration_binding = args.duration.get_inner();
        let min_days_for_renewal_binding = args.min_days_for_renewal.get_inner();
        let name_binding = args.name.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustAccessServiceToken:ZeroTrustAccessServiceToken"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "duration".into(),
                    value: &duration_binding,
                },
                register_interface::ObjectField {
                    name: "minDaysForRenewal".into(),
                    value: &min_days_for_renewal_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "clientId".into(),
                },
                register_interface::ResultField {
                    name: "clientSecret".into(),
                },
                register_interface::ResultField {
                    name: "duration".into(),
                },
                register_interface::ResultField {
                    name: "expiresAt".into(),
                },
                register_interface::ResultField {
                    name: "minDaysForRenewal".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustAccessServiceTokenResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            client_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("clientId").unwrap(),
            ),
            client_secret: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("clientSecret").unwrap(),
            ),
            duration: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("duration").unwrap(),
            ),
            expires_at: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("expiresAt").unwrap(),
            ),
            min_days_for_renewal: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("minDaysForRenewal").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_access_short_lived_certificate {
    //! Cloudflare Access can replace traditional SSH key models with
    //! short-lived certificates issued to your users based on the token
    //! generated by their Access login.
    //!
    //! > It's required that an `account_id` or `zone_id` is provided and in
    //!    most cases using either is fine. However, if you're using a scoped
    //!    access token, you must provide the argument that matches the token's
    //!    scope. For example, an access token that is scoped to the "example.com"
    //!    zone needs to use the `zone_id` argument.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let anotherExample = zero_trust_access_short_lived_certificate::create(
    //!         "anotherExample",
    //!         ZeroTrustAccessShortLivedCertificateArgs::builder()
    //!             .application_id("fe2be0ff-7f13-4350-8c8e-a9b9795fe3c2")
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //!     let example = zero_trust_access_short_lived_certificate::create(
    //!         "example",
    //!         ZeroTrustAccessShortLivedCertificateArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .application_id("6cd6cea3-3ef2-4542-9aea-85a0bbcd5414")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! Account level CA certificate import.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustAccessShortLivedCertificate:ZeroTrustAccessShortLivedCertificate example account/<account_id>/<application_id>
    //! ```
    //!
    //! Zone level CA certificate import.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustAccessShortLivedCertificate:ZeroTrustAccessShortLivedCertificate example account/<zone_id>/<application_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustAccessShortLivedCertificateArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The Access Application ID to associate with the CA certificate.
        #[builder(into)]
        pub application_id: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustAccessShortLivedCertificateResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The Access Application ID to associate with the CA certificate.
        pub application_id: pulumi_wasm_rust::Output<String>,
        /// Application Audience (AUD) Tag of the CA certificate.
        pub aud: pulumi_wasm_rust::Output<String>,
        /// Cryptographic public key of the generated CA certificate.
        pub public_key: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustAccessShortLivedCertificateArgs,
    ) -> ZeroTrustAccessShortLivedCertificateResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let application_id_binding = args.application_id.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustAccessShortLivedCertificate:ZeroTrustAccessShortLivedCertificate"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "applicationId".into(),
                    value: &application_id_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "applicationId".into(),
                },
                register_interface::ResultField {
                    name: "aud".into(),
                },
                register_interface::ResultField {
                    name: "publicKey".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustAccessShortLivedCertificateResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            application_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("applicationId").unwrap(),
            ),
            aud: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("aud").unwrap(),
            ),
            public_key: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("publicKey").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_access_tag {
    //! Provides a resource to customize the pages your end users will see
    //! when trying to reach applications behind Cloudflare Access.
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustAccessTagArgs {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Number of apps associated with the tag.
        #[builder(into, default)]
        pub app_count: pulumi_wasm_rust::Output<Option<i32>>,
        /// Friendly name of the Access Tag.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustAccessTagResult {
        /// The account identifier to target for the resource. Conflicts with `zone_id`. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<Option<String>>,
        /// Number of apps associated with the tag.
        pub app_count: pulumi_wasm_rust::Output<i32>,
        /// Friendly name of the Access Tag.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. Conflicts with `account_id`. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: ZeroTrustAccessTagArgs) -> ZeroTrustAccessTagResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let app_count_binding = args.app_count.get_inner();
        let name_binding = args.name.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustAccessTag:ZeroTrustAccessTag".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "appCount".into(),
                    value: &app_count_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "appCount".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustAccessTagResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            app_count: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("appCount").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_device_certificates {
    //! Provides a Cloudflare device policy certificates resource. Device
    //! policy certificate resources enable client device certificate
    //! generation.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = zero_trust_device_certificates::create(
    //!         "example",
    //!         ZeroTrustDeviceCertificatesArgs::builder()
    //!             .enabled(true)
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustDeviceCertificates:ZeroTrustDeviceCertificates example <zone_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustDeviceCertificatesArgs {
        /// `true` if certificate generation is enabled.
        #[builder(into)]
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource.
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustDeviceCertificatesResult {
        /// `true` if certificate generation is enabled.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustDeviceCertificatesArgs,
    ) -> ZeroTrustDeviceCertificatesResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let enabled_binding = args.enabled.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustDeviceCertificates:ZeroTrustDeviceCertificates"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "enabled".into(),
                    value: &enabled_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "enabled".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustDeviceCertificatesResult {
            enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enabled").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_device_managed_networks {
    //! Provides a Cloudflare Device Managed Network resource. Device managed networks allow for building location-aware device settings policies.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let managedNetworks = zero_trust_device_managed_networks::create(
    //!         "managedNetworks",
    //!         ZeroTrustDeviceManagedNetworksArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .config(
    //!                 ZeroTrustDeviceManagedNetworksConfig::builder()
    //!                     .sha256(
    //!                         "b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c",
    //!                     )
    //!                     .tlsSockaddr("foobar:1234")
    //!                     .build_struct(),
    //!             )
    //!             .name("managed-network-1")
    //!             .type_("tls")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustDeviceManagedNetworks:ZeroTrustDeviceManagedNetworks example <account_id>/<device_managed_networks_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustDeviceManagedNetworksArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The configuration containing information for the WARP client to detect the managed network.
        #[builder(into)]
        pub config: pulumi_wasm_rust::Output<
            super::types::ZeroTrustDeviceManagedNetworksConfig,
        >,
        /// The name of the Device Managed Network. Must be unique.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The type of Device Managed Network. Available values: `tls`.
        #[builder(into)]
        pub type_: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustDeviceManagedNetworksResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The configuration containing information for the WARP client to detect the managed network.
        pub config: pulumi_wasm_rust::Output<
            super::types::ZeroTrustDeviceManagedNetworksConfig,
        >,
        /// The name of the Device Managed Network. Must be unique.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The type of Device Managed Network. Available values: `tls`.
        pub type_: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustDeviceManagedNetworksArgs,
    ) -> ZeroTrustDeviceManagedNetworksResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let config_binding = args.config.get_inner();
        let name_binding = args.name.get_inner();
        let type__binding = args.type_.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustDeviceManagedNetworks:ZeroTrustDeviceManagedNetworks"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "config".into(),
                    value: &config_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "config".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustDeviceManagedNetworksResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            config: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("config").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_device_posture_integration {
    //! Provides a Cloudflare Device Posture Integration resource. Device
    //! posture integrations configure third-party data providers for device
    //! posture rules.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = zero_trust_device_posture_integration::create(
    //!         "example",
    //!         ZeroTrustDevicePostureIntegrationArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .configs(
    //!                 vec![
    //!                     ZeroTrustDevicePostureIntegrationConfig::builder()
    //!                     .apiUrl("https://example.com/api")
    //!                     .authUrl("https://example.com/connect/token").clientId("client-id")
    //!                     .clientSecret("client-secret").build_struct(),
    //!                 ],
    //!             )
    //!             .interval("24h")
    //!             .name("Device posture integration")
    //!             .type_("workspace_one")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustDevicePostureIntegration:ZeroTrustDevicePostureIntegration example <account_id>/<device_posture_integration_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustDevicePostureIntegrationArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The device posture integration's connection authorization parameters.
        #[builder(into, default)]
        pub configs: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustDevicePostureIntegrationConfig>>,
        >,
        #[builder(into, default)]
        pub identifier: pulumi_wasm_rust::Output<Option<String>>,
        /// Indicates the frequency with which to poll the third-party API. Must be in the format `1h` or `30m`.
        #[builder(into, default)]
        pub interval: pulumi_wasm_rust::Output<Option<String>>,
        /// Name of the device posture integration.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The device posture integration type. Available values: `workspace_one`, `uptycs`, `crowdstrike_s2s`, `intune`, `kolide`, `sentinelone_s2s`, `tanium_s2s`, `custom_s2s`.
        #[builder(into)]
        pub type_: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustDevicePostureIntegrationResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The device posture integration's connection authorization parameters.
        pub configs: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustDevicePostureIntegrationConfig>>,
        >,
        pub identifier: pulumi_wasm_rust::Output<Option<String>>,
        /// Indicates the frequency with which to poll the third-party API. Must be in the format `1h` or `30m`.
        pub interval: pulumi_wasm_rust::Output<Option<String>>,
        /// Name of the device posture integration.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The device posture integration type. Available values: `workspace_one`, `uptycs`, `crowdstrike_s2s`, `intune`, `kolide`, `sentinelone_s2s`, `tanium_s2s`, `custom_s2s`.
        pub type_: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustDevicePostureIntegrationArgs,
    ) -> ZeroTrustDevicePostureIntegrationResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let configs_binding = args.configs.get_inner();
        let identifier_binding = args.identifier.get_inner();
        let interval_binding = args.interval.get_inner();
        let name_binding = args.name.get_inner();
        let type__binding = args.type_.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustDevicePostureIntegration:ZeroTrustDevicePostureIntegration"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "configs".into(),
                    value: &configs_binding,
                },
                register_interface::ObjectField {
                    name: "identifier".into(),
                    value: &identifier_binding,
                },
                register_interface::ObjectField {
                    name: "interval".into(),
                    value: &interval_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "configs".into(),
                },
                register_interface::ResultField {
                    name: "identifier".into(),
                },
                register_interface::ResultField {
                    name: "interval".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustDevicePostureIntegrationResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            configs: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("configs").unwrap(),
            ),
            identifier: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("identifier").unwrap(),
            ),
            interval: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("interval").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_device_posture_rule {
    //! Provides a Cloudflare Device Posture Rule resource. Device posture rules configure security policies for device posture checks.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let eaxmple = zero_trust_device_posture_rule::create(
    //!         "eaxmple",
    //!         ZeroTrustDevicePostureRuleArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .description("Device posture rule for corporate devices.")
    //!             .expiration("24h")
    //!             .inputs(
    //!                 vec![
    //!                     ZeroTrustDevicePostureRuleInput::builder()
    //!                     .id("${corporateDevices.id}").operator("<").osDistroName("ubuntu")
    //!                     .osDistroRevision("1.0.0").osVersionExtra("(a)").version("1.0.0")
    //!                     .build_struct(),
    //!                 ],
    //!             )
    //!             .matches(
    //!                 vec![
    //!                     ZeroTrustDevicePostureRuleMatch::builder().platform("linux")
    //!                     .build_struct(),
    //!                 ],
    //!             )
    //!             .name("Corporate devices posture rule")
    //!             .schedule("24h")
    //!             .type_("os_version")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustDevicePostureRule:ZeroTrustDevicePostureRule example <account_id>/<device_posture_rule_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustDevicePostureRuleArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Expire posture results after the specified amount of time. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.
        #[builder(into, default)]
        pub expiration: pulumi_wasm_rust::Output<Option<String>>,
        /// Required for all rule types except `warp`, `gateway`, and `tanium`.
        #[builder(into, default)]
        pub inputs: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustDevicePostureRuleInput>>,
        >,
        /// The conditions that the client must match to run the rule.
        #[builder(into, default)]
        pub matches: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustDevicePostureRuleMatch>>,
        >,
        /// Name of the device posture rule.
        #[builder(into, default)]
        pub name: pulumi_wasm_rust::Output<Option<String>>,
        /// Tells the client when to run the device posture check. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.
        #[builder(into, default)]
        pub schedule: pulumi_wasm_rust::Output<Option<String>>,
        /// The device posture rule type. Available values: `serial_number`, `file`, `application`, `gateway`, `warp`, `domain_joined`, `os_version`, `disk_encryption`, `firewall`, `client_certificate`, `client_certificate_v2`, `workspace_one`, `unique_client_id`, `crowdstrike_s2s`, `sentinelone`, `kolide`, `tanium_s2s`, `intune`, `sentinelone_s2s`, `custom_s2s`.
        #[builder(into)]
        pub type_: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustDevicePostureRuleResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Expire posture results after the specified amount of time. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.
        pub expiration: pulumi_wasm_rust::Output<Option<String>>,
        /// Required for all rule types except `warp`, `gateway`, and `tanium`.
        pub inputs: pulumi_wasm_rust::Output<
            Vec<super::types::ZeroTrustDevicePostureRuleInput>,
        >,
        /// The conditions that the client must match to run the rule.
        pub matches: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustDevicePostureRuleMatch>>,
        >,
        /// Name of the device posture rule.
        pub name: pulumi_wasm_rust::Output<Option<String>>,
        /// Tells the client when to run the device posture check. Must be in the format `1h` or `30m`. Valid units are `h` and `m`.
        pub schedule: pulumi_wasm_rust::Output<Option<String>>,
        /// The device posture rule type. Available values: `serial_number`, `file`, `application`, `gateway`, `warp`, `domain_joined`, `os_version`, `disk_encryption`, `firewall`, `client_certificate`, `client_certificate_v2`, `workspace_one`, `unique_client_id`, `crowdstrike_s2s`, `sentinelone`, `kolide`, `tanium_s2s`, `intune`, `sentinelone_s2s`, `custom_s2s`.
        pub type_: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustDevicePostureRuleArgs,
    ) -> ZeroTrustDevicePostureRuleResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let description_binding = args.description.get_inner();
        let expiration_binding = args.expiration.get_inner();
        let inputs_binding = args.inputs.get_inner();
        let matches_binding = args.matches.get_inner();
        let name_binding = args.name.get_inner();
        let schedule_binding = args.schedule.get_inner();
        let type__binding = args.type_.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustDevicePostureRule:ZeroTrustDevicePostureRule"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "expiration".into(),
                    value: &expiration_binding,
                },
                register_interface::ObjectField {
                    name: "inputs".into(),
                    value: &inputs_binding,
                },
                register_interface::ObjectField {
                    name: "matches".into(),
                    value: &matches_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "schedule".into(),
                    value: &schedule_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "expiration".into(),
                },
                register_interface::ResultField {
                    name: "inputs".into(),
                },
                register_interface::ResultField {
                    name: "matches".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "schedule".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustDevicePostureRuleResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            expiration: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("expiration").unwrap(),
            ),
            inputs: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("inputs").unwrap(),
            ),
            matches: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("matches").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            schedule: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("schedule").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_device_profiles {
    //! Provides a Cloudflare Device Settings Policy resource. Device policies configure settings applied to WARP devices.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let developerWarpPolicy = zero_trust_device_profiles::create(
    //!         "developerWarpPolicy",
    //!         ZeroTrustDeviceProfilesArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .allow_mode_switch(true)
    //!             .allow_updates(true)
    //!             .allowed_to_leave(true)
    //!             .auto_connect(0)
    //!             .captive_portal(5)
    //!             .default(false)
    //!             .description("Developers WARP settings policy description")
    //!             .disable_auto_fallback(true)
    //!             .enabled(true)
    //!             .exclude_office_ips(false)
    //!             .match_("any(identity.groups.name[*] in {\"Developers\"})")
    //!             .name("Developers WARP settings policy")
    //!             .precedence(10)
    //!             .service_mode_v_2_mode("warp")
    //!             .service_mode_v_2_port(3000)
    //!             .support_url("https://cloudflare.com")
    //!             .switch_locked(true)
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! For default device settings policies you must use "default" as the policy ID.
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustDeviceProfiles:ZeroTrustDeviceProfiles example <account_id>/<device_policy_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustDeviceProfilesArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether to allow mode switch for this policy.
        #[builder(into, default)]
        pub allow_mode_switch: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to allow updates under this policy.
        #[builder(into, default)]
        pub allow_updates: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to allow devices to leave the organization. Defaults to `true`.
        #[builder(into, default)]
        pub allowed_to_leave: pulumi_wasm_rust::Output<Option<bool>>,
        /// The amount of time in seconds to reconnect after having been disabled.
        #[builder(into, default)]
        pub auto_connect: pulumi_wasm_rust::Output<Option<i32>>,
        /// The captive portal value for this policy. Defaults to `180`.
        #[builder(into, default)]
        pub captive_portal: pulumi_wasm_rust::Output<Option<i32>>,
        /// Whether the policy refers to the default account policy.
        #[builder(into, default)]
        pub default: pulumi_wasm_rust::Output<Option<bool>>,
        /// Description of Policy.
        #[builder(into)]
        pub description: pulumi_wasm_rust::Output<String>,
        /// Whether to disable auto fallback for this policy.
        #[builder(into, default)]
        pub disable_auto_fallback: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether the policy is enabled (cannot be set for default policies). Defaults to `true`.
        #[builder(into, default)]
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to add Microsoft IPs to split tunnel exclusions.
        #[builder(into, default)]
        pub exclude_office_ips: pulumi_wasm_rust::Output<Option<bool>>,
        /// Wirefilter expression to match a device against when evaluating whether this policy should take effect for that device.
        #[builder(into, default)]
        pub match_: pulumi_wasm_rust::Output<Option<String>>,
        /// Name of the policy.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The precedence of the policy. Lower values indicate higher precedence.
        #[builder(into, default)]
        pub precedence: pulumi_wasm_rust::Output<Option<i32>>,
        /// The service mode. Available values: `1dot1`, `warp`, `proxy`, `posture_only`, `warp_tunnel_only`. Defaults to `warp`.
        #[builder(into, default)]
        pub service_mode_v2_mode: pulumi_wasm_rust::Output<Option<String>>,
        /// The port to use for the proxy service mode. Required when using `service_mode_v2_mode`.
        #[builder(into, default)]
        pub service_mode_v2_port: pulumi_wasm_rust::Output<Option<i32>>,
        /// The support URL that will be opened when sending feedback.
        #[builder(into, default)]
        pub support_url: pulumi_wasm_rust::Output<Option<String>>,
        /// Enablement of the ZT client switch lock.
        #[builder(into, default)]
        pub switch_locked: pulumi_wasm_rust::Output<Option<bool>>,
        /// Determines which tunnel protocol to use. Available values: `""`, `wireguard`, `masque`. Defaults to `wireguard`.
        #[builder(into, default)]
        pub tunnel_protocol: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustDeviceProfilesResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether to allow mode switch for this policy.
        pub allow_mode_switch: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to allow updates under this policy.
        pub allow_updates: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to allow devices to leave the organization. Defaults to `true`.
        pub allowed_to_leave: pulumi_wasm_rust::Output<Option<bool>>,
        /// The amount of time in seconds to reconnect after having been disabled.
        pub auto_connect: pulumi_wasm_rust::Output<Option<i32>>,
        /// The captive portal value for this policy. Defaults to `180`.
        pub captive_portal: pulumi_wasm_rust::Output<Option<i32>>,
        /// Whether the policy refers to the default account policy.
        pub default: pulumi_wasm_rust::Output<Option<bool>>,
        /// Description of Policy.
        pub description: pulumi_wasm_rust::Output<String>,
        /// Whether to disable auto fallback for this policy.
        pub disable_auto_fallback: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether the policy is enabled (cannot be set for default policies). Defaults to `true`.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether to add Microsoft IPs to split tunnel exclusions.
        pub exclude_office_ips: pulumi_wasm_rust::Output<Option<bool>>,
        /// Wirefilter expression to match a device against when evaluating whether this policy should take effect for that device.
        pub match_: pulumi_wasm_rust::Output<Option<String>>,
        /// Name of the policy.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The precedence of the policy. Lower values indicate higher precedence.
        pub precedence: pulumi_wasm_rust::Output<Option<i32>>,
        /// The service mode. Available values: `1dot1`, `warp`, `proxy`, `posture_only`, `warp_tunnel_only`. Defaults to `warp`.
        pub service_mode_v2_mode: pulumi_wasm_rust::Output<Option<String>>,
        /// The port to use for the proxy service mode. Required when using `service_mode_v2_mode`.
        pub service_mode_v2_port: pulumi_wasm_rust::Output<Option<i32>>,
        /// The support URL that will be opened when sending feedback.
        pub support_url: pulumi_wasm_rust::Output<Option<String>>,
        /// Enablement of the ZT client switch lock.
        pub switch_locked: pulumi_wasm_rust::Output<Option<bool>>,
        /// Determines which tunnel protocol to use. Available values: `""`, `wireguard`, `masque`. Defaults to `wireguard`.
        pub tunnel_protocol: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustDeviceProfilesArgs,
    ) -> ZeroTrustDeviceProfilesResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let allow_mode_switch_binding = args.allow_mode_switch.get_inner();
        let allow_updates_binding = args.allow_updates.get_inner();
        let allowed_to_leave_binding = args.allowed_to_leave.get_inner();
        let auto_connect_binding = args.auto_connect.get_inner();
        let captive_portal_binding = args.captive_portal.get_inner();
        let default_binding = args.default.get_inner();
        let description_binding = args.description.get_inner();
        let disable_auto_fallback_binding = args.disable_auto_fallback.get_inner();
        let enabled_binding = args.enabled.get_inner();
        let exclude_office_ips_binding = args.exclude_office_ips.get_inner();
        let match__binding = args.match_.get_inner();
        let name_binding = args.name.get_inner();
        let precedence_binding = args.precedence.get_inner();
        let service_mode_v2_mode_binding = args.service_mode_v2_mode.get_inner();
        let service_mode_v2_port_binding = args.service_mode_v2_port.get_inner();
        let support_url_binding = args.support_url.get_inner();
        let switch_locked_binding = args.switch_locked.get_inner();
        let tunnel_protocol_binding = args.tunnel_protocol.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustDeviceProfiles:ZeroTrustDeviceProfiles"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "allowModeSwitch".into(),
                    value: &allow_mode_switch_binding,
                },
                register_interface::ObjectField {
                    name: "allowUpdates".into(),
                    value: &allow_updates_binding,
                },
                register_interface::ObjectField {
                    name: "allowedToLeave".into(),
                    value: &allowed_to_leave_binding,
                },
                register_interface::ObjectField {
                    name: "autoConnect".into(),
                    value: &auto_connect_binding,
                },
                register_interface::ObjectField {
                    name: "captivePortal".into(),
                    value: &captive_portal_binding,
                },
                register_interface::ObjectField {
                    name: "default".into(),
                    value: &default_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "disableAutoFallback".into(),
                    value: &disable_auto_fallback_binding,
                },
                register_interface::ObjectField {
                    name: "enabled".into(),
                    value: &enabled_binding,
                },
                register_interface::ObjectField {
                    name: "excludeOfficeIps".into(),
                    value: &exclude_office_ips_binding,
                },
                register_interface::ObjectField {
                    name: "match".into(),
                    value: &match__binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "precedence".into(),
                    value: &precedence_binding,
                },
                register_interface::ObjectField {
                    name: "serviceModeV2Mode".into(),
                    value: &service_mode_v2_mode_binding,
                },
                register_interface::ObjectField {
                    name: "serviceModeV2Port".into(),
                    value: &service_mode_v2_port_binding,
                },
                register_interface::ObjectField {
                    name: "supportUrl".into(),
                    value: &support_url_binding,
                },
                register_interface::ObjectField {
                    name: "switchLocked".into(),
                    value: &switch_locked_binding,
                },
                register_interface::ObjectField {
                    name: "tunnelProtocol".into(),
                    value: &tunnel_protocol_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "allowModeSwitch".into(),
                },
                register_interface::ResultField {
                    name: "allowUpdates".into(),
                },
                register_interface::ResultField {
                    name: "allowedToLeave".into(),
                },
                register_interface::ResultField {
                    name: "autoConnect".into(),
                },
                register_interface::ResultField {
                    name: "captivePortal".into(),
                },
                register_interface::ResultField {
                    name: "default".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "disableAutoFallback".into(),
                },
                register_interface::ResultField {
                    name: "enabled".into(),
                },
                register_interface::ResultField {
                    name: "excludeOfficeIps".into(),
                },
                register_interface::ResultField {
                    name: "match".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "precedence".into(),
                },
                register_interface::ResultField {
                    name: "serviceModeV2Mode".into(),
                },
                register_interface::ResultField {
                    name: "serviceModeV2Port".into(),
                },
                register_interface::ResultField {
                    name: "supportUrl".into(),
                },
                register_interface::ResultField {
                    name: "switchLocked".into(),
                },
                register_interface::ResultField {
                    name: "tunnelProtocol".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustDeviceProfilesResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            allow_mode_switch: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("allowModeSwitch").unwrap(),
            ),
            allow_updates: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("allowUpdates").unwrap(),
            ),
            allowed_to_leave: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("allowedToLeave").unwrap(),
            ),
            auto_connect: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("autoConnect").unwrap(),
            ),
            captive_portal: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("captivePortal").unwrap(),
            ),
            default: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("default").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            disable_auto_fallback: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("disableAutoFallback").unwrap(),
            ),
            enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enabled").unwrap(),
            ),
            exclude_office_ips: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("excludeOfficeIps").unwrap(),
            ),
            match_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("match").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            precedence: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("precedence").unwrap(),
            ),
            service_mode_v2_mode: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("serviceModeV2Mode").unwrap(),
            ),
            service_mode_v2_port: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("serviceModeV2Port").unwrap(),
            ),
            support_url: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("supportUrl").unwrap(),
            ),
            switch_locked: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("switchLocked").unwrap(),
            ),
            tunnel_protocol: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tunnelProtocol").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_dex_test {
    //! Provides a Cloudflare Device Dex Test resource. Device Dex Tests allow for building location-aware device settings policies.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = zero_trust_dex_test::create(
    //!         "example",
    //!         ZeroTrustDexTestArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .data(
    //!                 ZeroTrustDexTestData::builder()
    //!                     .host("https://example.com/home")
    //!                     .kind("http")
    //!                     .method("GET")
    //!                     .build_struct(),
    //!             )
    //!             .description("Send a HTTP GET request to the home endpoint every half hour.")
    //!             .enabled(true)
    //!             .interval("0h30m0s")
    //!             .name("GET homepage")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustDexTest:ZeroTrustDexTest example <account_id>/<device_dex_test_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustDexTestArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The configuration object which contains the details for the WARP client to conduct the test.
        #[builder(into)]
        pub data: pulumi_wasm_rust::Output<super::types::ZeroTrustDexTestData>,
        /// Additional details about the test.
        #[builder(into)]
        pub description: pulumi_wasm_rust::Output<String>,
        /// Determines whether or not the test is active.
        #[builder(into)]
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// How often the test will run.
        #[builder(into)]
        pub interval: pulumi_wasm_rust::Output<String>,
        /// The name of the Device Dex Test. Must be unique.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustDexTestResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Timestamp of when the Dex Test was created.
        pub created: pulumi_wasm_rust::Output<String>,
        /// The configuration object which contains the details for the WARP client to conduct the test.
        pub data: pulumi_wasm_rust::Output<super::types::ZeroTrustDexTestData>,
        /// Additional details about the test.
        pub description: pulumi_wasm_rust::Output<String>,
        /// Determines whether or not the test is active.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// How often the test will run.
        pub interval: pulumi_wasm_rust::Output<String>,
        /// The name of the Device Dex Test. Must be unique.
        pub name: pulumi_wasm_rust::Output<String>,
        /// Timestamp of when the Dex Test was last updated.
        pub updated: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: ZeroTrustDexTestArgs) -> ZeroTrustDexTestResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let data_binding = args.data.get_inner();
        let description_binding = args.description.get_inner();
        let enabled_binding = args.enabled.get_inner();
        let interval_binding = args.interval.get_inner();
        let name_binding = args.name.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustDexTest:ZeroTrustDexTest".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "data".into(),
                    value: &data_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "enabled".into(),
                    value: &enabled_binding,
                },
                register_interface::ObjectField {
                    name: "interval".into(),
                    value: &interval_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "created".into(),
                },
                register_interface::ResultField {
                    name: "data".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "enabled".into(),
                },
                register_interface::ResultField {
                    name: "interval".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "updated".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustDexTestResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            created: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("created").unwrap(),
            ),
            data: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("data").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enabled").unwrap(),
            ),
            interval: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("interval").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            updated: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("updated").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_dlp_profile {
    //! Provides a Cloudflare DLP Profile resource. Data Loss Prevention profiles
    //! are a set of entries that can be matched in HTTP bodies or files.
    //! They are referenced in Zero Trust Gateway rules.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let creds = zero_trust_dlp_profile::create(
    //!         "creds",
    //!         ZeroTrustDlpProfileArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .allowed_match_count(3)
    //!             .entries(
    //!                 vec![
    //!                     ZeroTrustDlpProfileEntry::builder().enabled(true)
    //!                     .id("d8fcfc9c-773c-405e-8426-21ecbb67ba93")
    //!                     .name("Amazon AWS Access Key ID").build_struct(),
    //!                     ZeroTrustDlpProfileEntry::builder().enabled(false)
    //!                     .id("2c0e33e1-71da-40c8-aad3-32e674ad3d96")
    //!                     .name("Amazon AWS Secret Access Key").build_struct(),
    //!                     ZeroTrustDlpProfileEntry::builder().enabled(true)
    //!                     .id("4e92c006-3802-4dff-bbe1-8e1513b1c92a")
    //!                     .name("Microsoft Azure Client Secret").build_struct(),
    //!                     ZeroTrustDlpProfileEntry::builder().enabled(false)
    //!                     .id("5c713294-2375-4904-abcf-e4a15be4d592").name("SSH Private Key")
    //!                     .build_struct(), ZeroTrustDlpProfileEntry::builder().enabled(true)
    //!                     .id("6c6579e4-d832-42d5-905c-8e53340930f2")
    //!                     .name("Google GCP API Key").build_struct(),
    //!                 ],
    //!             )
    //!             .name("Credentials and Secrets")
    //!             .type_("predefined")
    //!             .build_struct(),
    //!     );
    //!     let exampleCustom = zero_trust_dlp_profile::create(
    //!         "exampleCustom",
    //!         ZeroTrustDlpProfileArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .allowed_match_count(0)
    //!             .description("A profile with example entries")
    //!             .entries(
    //!                 vec![
    //!                     ZeroTrustDlpProfileEntry::builder().enabled(true)
    //!                     .name("Matches visa credit cards")
    //!                     .pattern(ZeroTrustDlpProfileEntryPattern::builder()
    //!                     .regex("4\\d{3}([-\\. ])?\\d{4}([-\\. ])?\\d{4}([-\\. ])?\\d{4}")
    //!                     .validation("luhn").build_struct()).build_struct(),
    //!                     ZeroTrustDlpProfileEntry::builder().enabled(true)
    //!                     .name("Matches diners club card")
    //!                     .pattern(ZeroTrustDlpProfileEntryPattern::builder()
    //!                     .regex("(?:0[0-5]|[68][0-9])[0-9]{11}").validation("luhn")
    //!                     .build_struct()).build_struct(),
    //!                 ],
    //!             )
    //!             .name("Example Custom Profile")
    //!             .type_("custom")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustDlpProfile:ZeroTrustDlpProfile example <account_id>/<dlp_profile_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustDlpProfileArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Related DLP policies will trigger when the match count exceeds the number set.
        #[builder(into)]
        pub allowed_match_count: pulumi_wasm_rust::Output<i32>,
        /// Scan the context of predefined entries to only return matches surrounded by keywords.
        #[builder(into, default)]
        pub context_awareness: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustDlpProfileContextAwareness>,
        >,
        /// Brief summary of the profile and its intended use.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// List of entries to apply to the profile.
        #[builder(into)]
        pub entries: pulumi_wasm_rust::Output<
            Vec<super::types::ZeroTrustDlpProfileEntry>,
        >,
        /// Name of the profile. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// If true, scan images via OCR to determine if any text present matches filters.
        #[builder(into, default)]
        pub ocr_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The type of the profile. Available values: `custom`, `predefined`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub type_: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustDlpProfileResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Related DLP policies will trigger when the match count exceeds the number set.
        pub allowed_match_count: pulumi_wasm_rust::Output<i32>,
        /// Scan the context of predefined entries to only return matches surrounded by keywords.
        pub context_awareness: pulumi_wasm_rust::Output<
            super::types::ZeroTrustDlpProfileContextAwareness,
        >,
        /// Brief summary of the profile and its intended use.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// List of entries to apply to the profile.
        pub entries: pulumi_wasm_rust::Output<
            Vec<super::types::ZeroTrustDlpProfileEntry>,
        >,
        /// Name of the profile. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
        /// If true, scan images via OCR to determine if any text present matches filters.
        pub ocr_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The type of the profile. Available values: `custom`, `predefined`. **Modifying this attribute will force creation of a new resource.**
        pub type_: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustDlpProfileArgs,
    ) -> ZeroTrustDlpProfileResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let allowed_match_count_binding = args.allowed_match_count.get_inner();
        let context_awareness_binding = args.context_awareness.get_inner();
        let description_binding = args.description.get_inner();
        let entries_binding = args.entries.get_inner();
        let name_binding = args.name.get_inner();
        let ocr_enabled_binding = args.ocr_enabled.get_inner();
        let type__binding = args.type_.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustDlpProfile:ZeroTrustDlpProfile".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "allowedMatchCount".into(),
                    value: &allowed_match_count_binding,
                },
                register_interface::ObjectField {
                    name: "contextAwareness".into(),
                    value: &context_awareness_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "entries".into(),
                    value: &entries_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "ocrEnabled".into(),
                    value: &ocr_enabled_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "allowedMatchCount".into(),
                },
                register_interface::ResultField {
                    name: "contextAwareness".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "entries".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "ocrEnabled".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustDlpProfileResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            allowed_match_count: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("allowedMatchCount").unwrap(),
            ),
            context_awareness: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("contextAwareness").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            entries: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("entries").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            ocr_enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("ocrEnabled").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_dns_location {
    //! Provides a Cloudflare Teams Location resource. Teams Locations are
    //! referenced when creating secure web gateway policies.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = zero_trust_dns_location::create(
    //!         "example",
    //!         ZeroTrustDnsLocationArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .client_default(true)
    //!             .ecs_support(false)
    //!             .name("office")
    //!             .networks(
    //!                 vec![
    //!                     ZeroTrustDnsLocationNetwork::builder().network("203.0.113.1/32")
    //!                     .build_struct(), ZeroTrustDnsLocationNetwork::builder()
    //!                     .network("203.0.113.2/32").build_struct(),
    //!                 ],
    //!             )
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustDnsLocation:ZeroTrustDnsLocation example <account_id>/<teams_location_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustDnsLocationArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Indicator that this is the default location.
        #[builder(into, default)]
        pub client_default: pulumi_wasm_rust::Output<Option<bool>>,
        /// Indicator that this location needs to resolve EDNS queries.
        #[builder(into, default)]
        pub ecs_support: pulumi_wasm_rust::Output<Option<bool>>,
        /// Name of the teams location.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The networks CIDRs that comprise the location.
        #[builder(into, default)]
        pub networks: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustDnsLocationNetwork>>,
        >,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustDnsLocationResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Indicator that anonymized logs are enabled.
        pub anonymized_logs_enabled: pulumi_wasm_rust::Output<bool>,
        /// Indicator that this is the default location.
        pub client_default: pulumi_wasm_rust::Output<Option<bool>>,
        /// The FQDN that DoH clients should be pointed at.
        pub doh_subdomain: pulumi_wasm_rust::Output<String>,
        /// Indicator that this location needs to resolve EDNS queries.
        pub ecs_support: pulumi_wasm_rust::Output<Option<bool>>,
        /// Client IP address.
        pub ip: pulumi_wasm_rust::Output<String>,
        /// IP to direct all IPv4 DNS queries to.
        pub ipv4_destination: pulumi_wasm_rust::Output<String>,
        /// Name of the teams location.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The networks CIDRs that comprise the location.
        pub networks: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustDnsLocationNetwork>>,
        >,
        pub policy_ids: pulumi_wasm_rust::Output<Vec<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustDnsLocationArgs,
    ) -> ZeroTrustDnsLocationResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let client_default_binding = args.client_default.get_inner();
        let ecs_support_binding = args.ecs_support.get_inner();
        let name_binding = args.name.get_inner();
        let networks_binding = args.networks.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustDnsLocation:ZeroTrustDnsLocation".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "clientDefault".into(),
                    value: &client_default_binding,
                },
                register_interface::ObjectField {
                    name: "ecsSupport".into(),
                    value: &ecs_support_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "networks".into(),
                    value: &networks_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "anonymizedLogsEnabled".into(),
                },
                register_interface::ResultField {
                    name: "clientDefault".into(),
                },
                register_interface::ResultField {
                    name: "dohSubdomain".into(),
                },
                register_interface::ResultField {
                    name: "ecsSupport".into(),
                },
                register_interface::ResultField {
                    name: "ip".into(),
                },
                register_interface::ResultField {
                    name: "ipv4Destination".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "networks".into(),
                },
                register_interface::ResultField {
                    name: "policyIds".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustDnsLocationResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            anonymized_logs_enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("anonymizedLogsEnabled").unwrap(),
            ),
            client_default: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("clientDefault").unwrap(),
            ),
            doh_subdomain: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("dohSubdomain").unwrap(),
            ),
            ecs_support: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("ecsSupport").unwrap(),
            ),
            ip: pulumi_wasm_rust::__private::into_domain(hashmap.remove("ip").unwrap()),
            ipv4_destination: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("ipv4Destination").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            networks: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("networks").unwrap(),
            ),
            policy_ids: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("policyIds").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_gateway_certificate {
    //! Provides a Cloudflare Teams Gateway Certificate resource. A Teams Certificate can
    //! be specified for Gateway TLS interception and block pages.
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustGatewayCertificateArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether or not to activate a certificate. A certificate must be activated to use in Gateway certificate settings. Defaults to `false`.
        #[builder(into, default)]
        pub activate: pulumi_wasm_rust::Output<Option<bool>>,
        /// The type of certificate (custom or Gateway-managed). Must provide only one of `custom`, `gateway_managed`.
        #[builder(into, default)]
        pub custom: pulumi_wasm_rust::Output<Option<bool>>,
        /// The type of certificate (custom or Gateway-managed). Must provide only one of `custom`, `gateway_managed`.
        #[builder(into, default)]
        pub gateway_managed: pulumi_wasm_rust::Output<Option<bool>>,
        /// Number of days the generated certificate will be valid, minimum 1 day and maximum 30 years. Defaults to 5 years. Defaults to `1826`. Required when using `gateway_managed`. Conflicts with `custom`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub validity_period_days: pulumi_wasm_rust::Output<Option<i32>>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustGatewayCertificateResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether or not to activate a certificate. A certificate must be activated to use in Gateway certificate settings. Defaults to `false`.
        pub activate: pulumi_wasm_rust::Output<Option<bool>>,
        /// The deployment status of the certificate on the edge Available values: `IP`, `SERIAL`, `URL`, `DOMAIN`, `EMAIL`.
        pub binding_status: pulumi_wasm_rust::Output<String>,
        pub created_at: pulumi_wasm_rust::Output<String>,
        /// The type of certificate (custom or Gateway-managed). Must provide only one of `custom`, `gateway_managed`.
        pub custom: pulumi_wasm_rust::Output<Option<bool>>,
        pub expires_on: pulumi_wasm_rust::Output<String>,
        /// The type of certificate (custom or Gateway-managed). Must provide only one of `custom`, `gateway_managed`.
        pub gateway_managed: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether the certificate is in use by Gateway for TLS interception and the block page.
        pub in_use: pulumi_wasm_rust::Output<bool>,
        pub qs_pack_id: pulumi_wasm_rust::Output<String>,
        pub uploaded_on: pulumi_wasm_rust::Output<String>,
        /// Number of days the generated certificate will be valid, minimum 1 day and maximum 30 years. Defaults to 5 years. Defaults to `1826`. Required when using `gateway_managed`. Conflicts with `custom`. **Modifying this attribute will force creation of a new resource.**
        pub validity_period_days: pulumi_wasm_rust::Output<Option<i32>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustGatewayCertificateArgs,
    ) -> ZeroTrustGatewayCertificateResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let activate_binding = args.activate.get_inner();
        let custom_binding = args.custom.get_inner();
        let gateway_managed_binding = args.gateway_managed.get_inner();
        let validity_period_days_binding = args.validity_period_days.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustGatewayCertificate:ZeroTrustGatewayCertificate"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "activate".into(),
                    value: &activate_binding,
                },
                register_interface::ObjectField {
                    name: "custom".into(),
                    value: &custom_binding,
                },
                register_interface::ObjectField {
                    name: "gatewayManaged".into(),
                    value: &gateway_managed_binding,
                },
                register_interface::ObjectField {
                    name: "validityPeriodDays".into(),
                    value: &validity_period_days_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "activate".into(),
                },
                register_interface::ResultField {
                    name: "bindingStatus".into(),
                },
                register_interface::ResultField {
                    name: "createdAt".into(),
                },
                register_interface::ResultField {
                    name: "custom".into(),
                },
                register_interface::ResultField {
                    name: "expiresOn".into(),
                },
                register_interface::ResultField {
                    name: "gatewayManaged".into(),
                },
                register_interface::ResultField {
                    name: "inUse".into(),
                },
                register_interface::ResultField {
                    name: "qsPackId".into(),
                },
                register_interface::ResultField {
                    name: "uploadedOn".into(),
                },
                register_interface::ResultField {
                    name: "validityPeriodDays".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustGatewayCertificateResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            activate: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("activate").unwrap(),
            ),
            binding_status: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("bindingStatus").unwrap(),
            ),
            created_at: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("createdAt").unwrap(),
            ),
            custom: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("custom").unwrap(),
            ),
            expires_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("expiresOn").unwrap(),
            ),
            gateway_managed: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("gatewayManaged").unwrap(),
            ),
            in_use: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("inUse").unwrap(),
            ),
            qs_pack_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("qsPackId").unwrap(),
            ),
            uploaded_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("uploadedOn").unwrap(),
            ),
            validity_period_days: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("validityPeriodDays").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_gateway_policy {
    //! Provides a Cloudflare Teams rule resource. Teams rules comprise secure web gateway policies.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = zero_trust_gateway_policy::create(
    //!         "example",
    //!         ZeroTrustGatewayPolicyArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .action("block")
    //!             .description("desc")
    //!             .filters(vec!["http",])
    //!             .name("office")
    //!             .precedence(1)
    //!             .rule_settings(
    //!                 ZeroTrustGatewayPolicyRuleSettings::builder()
    //!                     .blockPageEnabled(true)
    //!                     .blockPageReason("access not permitted")
    //!                     .build_struct(),
    //!             )
    //!             .traffic("http.request.uri == \"https://www.example.com/malicious\"")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustGatewayPolicy:ZeroTrustGatewayPolicy example <account_id>/<teams_rule_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustGatewayPolicyArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The action executed by matched teams rule. Available values: `allow`, `block`, `safesearch`, `ytrestricted`, `on`, `off`, `scan`, `noscan`, `isolate`, `noisolate`, `override`, `l4_override`, `egress`, `audit_ssh`, `resolve`.
        #[builder(into)]
        pub action: pulumi_wasm_rust::Output<String>,
        /// The description of the teams rule.
        #[builder(into)]
        pub description: pulumi_wasm_rust::Output<String>,
        /// The wirefilter expression to be used for device_posture check matching.
        #[builder(into, default)]
        pub device_posture: pulumi_wasm_rust::Output<Option<String>>,
        /// Indicator of rule enablement.
        #[builder(into, default)]
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The protocol or layer to evaluate the traffic and identity expressions.
        #[builder(into, default)]
        pub filters: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The wirefilter expression to be used for identity matching.
        #[builder(into, default)]
        pub identity: pulumi_wasm_rust::Output<Option<String>>,
        /// The name of the teams rule.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The evaluation precedence of the teams rule.
        #[builder(into)]
        pub precedence: pulumi_wasm_rust::Output<i32>,
        /// Additional rule settings.
        #[builder(into, default)]
        pub rule_settings: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustGatewayPolicyRuleSettings>,
        >,
        /// The wirefilter expression to be used for traffic matching.
        #[builder(into, default)]
        pub traffic: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustGatewayPolicyResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The action executed by matched teams rule. Available values: `allow`, `block`, `safesearch`, `ytrestricted`, `on`, `off`, `scan`, `noscan`, `isolate`, `noisolate`, `override`, `l4_override`, `egress`, `audit_ssh`, `resolve`.
        pub action: pulumi_wasm_rust::Output<String>,
        /// The description of the teams rule.
        pub description: pulumi_wasm_rust::Output<String>,
        /// The wirefilter expression to be used for device_posture check matching.
        pub device_posture: pulumi_wasm_rust::Output<String>,
        /// Indicator of rule enablement.
        pub enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// The protocol or layer to evaluate the traffic and identity expressions.
        pub filters: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The wirefilter expression to be used for identity matching.
        pub identity: pulumi_wasm_rust::Output<String>,
        /// The name of the teams rule.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The evaluation precedence of the teams rule.
        pub precedence: pulumi_wasm_rust::Output<i32>,
        /// Additional rule settings.
        pub rule_settings: pulumi_wasm_rust::Output<
            super::types::ZeroTrustGatewayPolicyRuleSettings,
        >,
        /// The wirefilter expression to be used for traffic matching.
        pub traffic: pulumi_wasm_rust::Output<String>,
        pub version: pulumi_wasm_rust::Output<i32>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustGatewayPolicyArgs,
    ) -> ZeroTrustGatewayPolicyResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let action_binding = args.action.get_inner();
        let description_binding = args.description.get_inner();
        let device_posture_binding = args.device_posture.get_inner();
        let enabled_binding = args.enabled.get_inner();
        let filters_binding = args.filters.get_inner();
        let identity_binding = args.identity.get_inner();
        let name_binding = args.name.get_inner();
        let precedence_binding = args.precedence.get_inner();
        let rule_settings_binding = args.rule_settings.get_inner();
        let traffic_binding = args.traffic.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustGatewayPolicy:ZeroTrustGatewayPolicy"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "action".into(),
                    value: &action_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "devicePosture".into(),
                    value: &device_posture_binding,
                },
                register_interface::ObjectField {
                    name: "enabled".into(),
                    value: &enabled_binding,
                },
                register_interface::ObjectField {
                    name: "filters".into(),
                    value: &filters_binding,
                },
                register_interface::ObjectField {
                    name: "identity".into(),
                    value: &identity_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "precedence".into(),
                    value: &precedence_binding,
                },
                register_interface::ObjectField {
                    name: "ruleSettings".into(),
                    value: &rule_settings_binding,
                },
                register_interface::ObjectField {
                    name: "traffic".into(),
                    value: &traffic_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "action".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "devicePosture".into(),
                },
                register_interface::ResultField {
                    name: "enabled".into(),
                },
                register_interface::ResultField {
                    name: "filters".into(),
                },
                register_interface::ResultField {
                    name: "identity".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "precedence".into(),
                },
                register_interface::ResultField {
                    name: "ruleSettings".into(),
                },
                register_interface::ResultField {
                    name: "traffic".into(),
                },
                register_interface::ResultField {
                    name: "version".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustGatewayPolicyResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            action: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("action").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            device_posture: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("devicePosture").unwrap(),
            ),
            enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enabled").unwrap(),
            ),
            filters: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("filters").unwrap(),
            ),
            identity: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("identity").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            precedence: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("precedence").unwrap(),
            ),
            rule_settings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("ruleSettings").unwrap(),
            ),
            traffic: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("traffic").unwrap(),
            ),
            version: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("version").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_gateway_proxy_endpoint {
    //! Provides a Cloudflare Teams Proxy Endpoint resource. Teams Proxy
    //! Endpoints are used for pointing proxy clients at Cloudflare Secure
    //! Gateway.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = zero_trust_gateway_proxy_endpoint::create(
    //!         "example",
    //!         ZeroTrustGatewayProxyEndpointArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .ips(vec!["192.0.2.0/24",])
    //!             .name("office")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustGatewayProxyEndpoint:ZeroTrustGatewayProxyEndpoint example <account_id>/<proxy_endpoint_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustGatewayProxyEndpointArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The networks CIDRs that will be allowed to initiate proxy connections.
        #[builder(into)]
        pub ips: pulumi_wasm_rust::Output<Vec<String>>,
        /// Name of the teams proxy endpoint.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustGatewayProxyEndpointResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The networks CIDRs that will be allowed to initiate proxy connections.
        pub ips: pulumi_wasm_rust::Output<Vec<String>>,
        /// Name of the teams proxy endpoint.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The FQDN that proxy clients should be pointed at.
        pub subdomain: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustGatewayProxyEndpointArgs,
    ) -> ZeroTrustGatewayProxyEndpointResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let ips_binding = args.ips.get_inner();
        let name_binding = args.name.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustGatewayProxyEndpoint:ZeroTrustGatewayProxyEndpoint"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "ips".into(),
                    value: &ips_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "ips".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "subdomain".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustGatewayProxyEndpointResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            ips: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("ips").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            subdomain: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("subdomain").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_gateway_settings {
    //! Provides a Cloudflare Teams Account resource. The Teams Account
    //! resource defines configuration for secure web gateway.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = zero_trust_gateway_settings::create(
    //!         "example",
    //!         ZeroTrustGatewaySettingsArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .antivirus(
    //!                 ZeroTrustGatewaySettingsAntivirus::builder()
    //!                     .enabledDownloadPhase(true)
    //!                     .enabledUploadPhase(false)
    //!                     .failClosed(true)
    //!                     .notificationSettings(
    //!                         ZeroTrustGatewaySettingsAntivirusNotificationSettings::builder()
    //!                             .enabled(true)
    //!                             .message("you are blocked")
    //!                             .supportUrl("https://example.com/blocked")
    //!                             .build_struct(),
    //!                     )
    //!                     .build_struct(),
    //!             )
    //!             .block_page(
    //!                 ZeroTrustGatewaySettingsBlockPage::builder()
    //!                     .backgroundColor("#000000")
    //!                     .footerText("hello")
    //!                     .headerText("hello")
    //!                     .logoPath("https://example.com/logo.jpg")
    //!                     .build_struct(),
    //!             )
    //!             .body_scanning(
    //!                 ZeroTrustGatewaySettingsBodyScanning::builder()
    //!                     .inspectionMode("deep")
    //!                     .build_struct(),
    //!             )
    //!             .extended_email_matching(
    //!                 ZeroTrustGatewaySettingsExtendedEmailMatching::builder()
    //!                     .enabled(true)
    //!                     .build_struct(),
    //!             )
    //!             .fips(ZeroTrustGatewaySettingsFips::builder().tls(true).build_struct())
    //!             .logging(
    //!                 ZeroTrustGatewaySettingsLogging::builder()
    //!                     .redactPii(true)
    //!                     .settingsByRuleType(
    //!                         ZeroTrustGatewaySettingsLoggingSettingsByRuleType::builder()
    //!                             .dns(
    //!                                 ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDns::builder()
    //!                                     .logAll(false)
    //!                                     .logBlocks(true)
    //!                                     .build_struct(),
    //!                             )
    //!                             .http(
    //!                                 ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttp::builder()
    //!                                     .logAll(true)
    //!                                     .logBlocks(true)
    //!                                     .build_struct(),
    //!                             )
    //!                             .l4(
    //!                                 ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4::builder()
    //!                                     .logAll(false)
    //!                                     .logBlocks(true)
    //!                                     .build_struct(),
    //!                             )
    //!                             .build_struct(),
    //!                     )
    //!                     .build_struct(),
    //!             )
    //!             .protocol_detection_enabled(true)
    //!             .proxy(
    //!                 ZeroTrustGatewaySettingsProxy::builder()
    //!                     .disableForTime(3600)
    //!                     .rootCa(true)
    //!                     .tcp(true)
    //!                     .udp(true)
    //!                     .virtualIp(false)
    //!                     .build_struct(),
    //!             )
    //!             .tls_decrypt_enabled(true)
    //!             .url_browser_isolation_enabled(true)
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustGatewaySettings:ZeroTrustGatewaySettings example <account_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustGatewaySettingsArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether to enable the activity log.
        #[builder(into, default)]
        pub activity_log_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Configuration block for antivirus traffic scanning.
        #[builder(into, default)]
        pub antivirus: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustGatewaySettingsAntivirus>,
        >,
        /// Configuration for a custom block page.
        #[builder(into, default)]
        pub block_page: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustGatewaySettingsBlockPage>,
        >,
        /// Configuration for body scanning.
        #[builder(into, default)]
        pub body_scanning: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustGatewaySettingsBodyScanning>,
        >,
        /// Configuration for TLS interception certificate. This will be required starting Feb 2025.
        #[builder(into, default)]
        pub certificate: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustGatewaySettingsCertificate>,
        >,
        /// Configuration for custom certificates / BYO-PKI. Conflicts with `certificate`.
        #[builder(into, default)]
        pub custom_certificate: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustGatewaySettingsCustomCertificate>,
        >,
        /// Configuration for extended e-mail matching.
        #[builder(into, default)]
        pub extended_email_matching: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustGatewaySettingsExtendedEmailMatching>,
        >,
        /// Configure compliance with Federal Information Processing Standards.
        #[builder(into, default)]
        pub fips: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustGatewaySettingsFips>,
        >,
        #[builder(into, default)]
        pub logging: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustGatewaySettingsLogging>,
        >,
        /// Enable non-identity onramp for Browser Isolation. Defaults to `false`.
        #[builder(into, default)]
        pub non_identity_browser_isolation_enabled: pulumi_wasm_rust::Output<
            Option<bool>,
        >,
        /// Configuration for DLP Payload Logging.
        #[builder(into, default)]
        pub payload_log: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustGatewaySettingsPayloadLog>,
        >,
        /// Indicator that protocol detection is enabled.
        #[builder(into, default)]
        pub protocol_detection_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Configuration block for specifying which protocols are proxied.
        #[builder(into, default)]
        pub proxy: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustGatewaySettingsProxy>,
        >,
        /// Configuration for SSH Session Logging.
        #[builder(into, default)]
        pub ssh_session_log: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustGatewaySettingsSshSessionLog>,
        >,
        /// Indicator that decryption of TLS traffic is enabled.
        #[builder(into, default)]
        pub tls_decrypt_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Safely browse websites in Browser Isolation through a URL. Defaults to `false`.
        #[builder(into, default)]
        pub url_browser_isolation_enabled: pulumi_wasm_rust::Output<Option<bool>>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustGatewaySettingsResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether to enable the activity log.
        pub activity_log_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Configuration block for antivirus traffic scanning.
        pub antivirus: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustGatewaySettingsAntivirus>,
        >,
        /// Configuration for a custom block page.
        pub block_page: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustGatewaySettingsBlockPage>,
        >,
        /// Configuration for body scanning.
        pub body_scanning: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustGatewaySettingsBodyScanning>,
        >,
        /// Configuration for TLS interception certificate. This will be required starting Feb 2025.
        pub certificate: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustGatewaySettingsCertificate>,
        >,
        /// Configuration for custom certificates / BYO-PKI. Conflicts with `certificate`.
        pub custom_certificate: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustGatewaySettingsCustomCertificate>,
        >,
        /// Configuration for extended e-mail matching.
        pub extended_email_matching: pulumi_wasm_rust::Output<
            super::types::ZeroTrustGatewaySettingsExtendedEmailMatching,
        >,
        /// Configure compliance with Federal Information Processing Standards.
        pub fips: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustGatewaySettingsFips>,
        >,
        pub logging: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustGatewaySettingsLogging>,
        >,
        /// Enable non-identity onramp for Browser Isolation. Defaults to `false`.
        pub non_identity_browser_isolation_enabled: pulumi_wasm_rust::Output<
            Option<bool>,
        >,
        /// Configuration for DLP Payload Logging.
        pub payload_log: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustGatewaySettingsPayloadLog>,
        >,
        /// Indicator that protocol detection is enabled.
        pub protocol_detection_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Configuration block for specifying which protocols are proxied.
        pub proxy: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustGatewaySettingsProxy>,
        >,
        /// Configuration for SSH Session Logging.
        pub ssh_session_log: pulumi_wasm_rust::Output<
            Option<super::types::ZeroTrustGatewaySettingsSshSessionLog>,
        >,
        /// Indicator that decryption of TLS traffic is enabled.
        pub tls_decrypt_enabled: pulumi_wasm_rust::Output<Option<bool>>,
        /// Safely browse websites in Browser Isolation through a URL. Defaults to `false`.
        pub url_browser_isolation_enabled: pulumi_wasm_rust::Output<Option<bool>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustGatewaySettingsArgs,
    ) -> ZeroTrustGatewaySettingsResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let activity_log_enabled_binding = args.activity_log_enabled.get_inner();
        let antivirus_binding = args.antivirus.get_inner();
        let block_page_binding = args.block_page.get_inner();
        let body_scanning_binding = args.body_scanning.get_inner();
        let certificate_binding = args.certificate.get_inner();
        let custom_certificate_binding = args.custom_certificate.get_inner();
        let extended_email_matching_binding = args.extended_email_matching.get_inner();
        let fips_binding = args.fips.get_inner();
        let logging_binding = args.logging.get_inner();
        let non_identity_browser_isolation_enabled_binding = args
            .non_identity_browser_isolation_enabled
            .get_inner();
        let payload_log_binding = args.payload_log.get_inner();
        let protocol_detection_enabled_binding = args
            .protocol_detection_enabled
            .get_inner();
        let proxy_binding = args.proxy.get_inner();
        let ssh_session_log_binding = args.ssh_session_log.get_inner();
        let tls_decrypt_enabled_binding = args.tls_decrypt_enabled.get_inner();
        let url_browser_isolation_enabled_binding = args
            .url_browser_isolation_enabled
            .get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustGatewaySettings:ZeroTrustGatewaySettings"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "activityLogEnabled".into(),
                    value: &activity_log_enabled_binding,
                },
                register_interface::ObjectField {
                    name: "antivirus".into(),
                    value: &antivirus_binding,
                },
                register_interface::ObjectField {
                    name: "blockPage".into(),
                    value: &block_page_binding,
                },
                register_interface::ObjectField {
                    name: "bodyScanning".into(),
                    value: &body_scanning_binding,
                },
                register_interface::ObjectField {
                    name: "certificate".into(),
                    value: &certificate_binding,
                },
                register_interface::ObjectField {
                    name: "customCertificate".into(),
                    value: &custom_certificate_binding,
                },
                register_interface::ObjectField {
                    name: "extendedEmailMatching".into(),
                    value: &extended_email_matching_binding,
                },
                register_interface::ObjectField {
                    name: "fips".into(),
                    value: &fips_binding,
                },
                register_interface::ObjectField {
                    name: "logging".into(),
                    value: &logging_binding,
                },
                register_interface::ObjectField {
                    name: "nonIdentityBrowserIsolationEnabled".into(),
                    value: &non_identity_browser_isolation_enabled_binding,
                },
                register_interface::ObjectField {
                    name: "payloadLog".into(),
                    value: &payload_log_binding,
                },
                register_interface::ObjectField {
                    name: "protocolDetectionEnabled".into(),
                    value: &protocol_detection_enabled_binding,
                },
                register_interface::ObjectField {
                    name: "proxy".into(),
                    value: &proxy_binding,
                },
                register_interface::ObjectField {
                    name: "sshSessionLog".into(),
                    value: &ssh_session_log_binding,
                },
                register_interface::ObjectField {
                    name: "tlsDecryptEnabled".into(),
                    value: &tls_decrypt_enabled_binding,
                },
                register_interface::ObjectField {
                    name: "urlBrowserIsolationEnabled".into(),
                    value: &url_browser_isolation_enabled_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "activityLogEnabled".into(),
                },
                register_interface::ResultField {
                    name: "antivirus".into(),
                },
                register_interface::ResultField {
                    name: "blockPage".into(),
                },
                register_interface::ResultField {
                    name: "bodyScanning".into(),
                },
                register_interface::ResultField {
                    name: "certificate".into(),
                },
                register_interface::ResultField {
                    name: "customCertificate".into(),
                },
                register_interface::ResultField {
                    name: "extendedEmailMatching".into(),
                },
                register_interface::ResultField {
                    name: "fips".into(),
                },
                register_interface::ResultField {
                    name: "logging".into(),
                },
                register_interface::ResultField {
                    name: "nonIdentityBrowserIsolationEnabled".into(),
                },
                register_interface::ResultField {
                    name: "payloadLog".into(),
                },
                register_interface::ResultField {
                    name: "protocolDetectionEnabled".into(),
                },
                register_interface::ResultField {
                    name: "proxy".into(),
                },
                register_interface::ResultField {
                    name: "sshSessionLog".into(),
                },
                register_interface::ResultField {
                    name: "tlsDecryptEnabled".into(),
                },
                register_interface::ResultField {
                    name: "urlBrowserIsolationEnabled".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustGatewaySettingsResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            activity_log_enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("activityLogEnabled").unwrap(),
            ),
            antivirus: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("antivirus").unwrap(),
            ),
            block_page: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("blockPage").unwrap(),
            ),
            body_scanning: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("bodyScanning").unwrap(),
            ),
            certificate: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("certificate").unwrap(),
            ),
            custom_certificate: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("customCertificate").unwrap(),
            ),
            extended_email_matching: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("extendedEmailMatching").unwrap(),
            ),
            fips: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("fips").unwrap(),
            ),
            logging: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("logging").unwrap(),
            ),
            non_identity_browser_isolation_enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("nonIdentityBrowserIsolationEnabled").unwrap(),
            ),
            payload_log: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("payloadLog").unwrap(),
            ),
            protocol_detection_enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("protocolDetectionEnabled").unwrap(),
            ),
            proxy: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("proxy").unwrap(),
            ),
            ssh_session_log: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("sshSessionLog").unwrap(),
            ),
            tls_decrypt_enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tlsDecryptEnabled").unwrap(),
            ),
            url_browser_isolation_enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("urlBrowserIsolationEnabled").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_infrastructure_access_target {
    //! The [Infrastructure Access Target](https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/use-cases/ssh/ssh-infrastructure-access/#4-add-a-target) resource allows you to configure Infrastructure Access Targets for an account.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = zero_trust_infrastructure_access_target::create(
    //!         "example",
    //!         ZeroTrustInfrastructureAccessTargetArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .hostname("example-target")
    //!             .ip(
    //!                 ZeroTrustInfrastructureAccessTargetIp::builder()
    //!                     .ipv4(
    //!                         ZeroTrustInfrastructureAccessTargetIpIpv4::builder()
    //!                             .ipAddr("198.51.100.1")
    //!                             .virtualNetworkId("238dccd1-149b-463d-8228-560ab83a54fd")
    //!                             .build_struct(),
    //!                     )
    //!                     .ipv6(
    //!                         ZeroTrustInfrastructureAccessTargetIpIpv6::builder()
    //!                             .ipAddr("2001:db8::")
    //!                             .virtualNetworkId("238dccd1-149b-463d-8228-560ab83a54fd")
    //!                             .build_struct(),
    //!                     )
    //!                     .build_struct(),
    //!             )
    //!             .build_struct(),
    //!     );
    //!     let ipv4OnlyExample = zero_trust_infrastructure_access_target::create(
    //!         "ipv4OnlyExample",
    //!         ZeroTrustInfrastructureAccessTargetArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .hostname("example-ipv4-only")
    //!             .ip(
    //!                 ZeroTrustInfrastructureAccessTargetIp::builder()
    //!                     .ipv4(
    //!                         ZeroTrustInfrastructureAccessTargetIpIpv4::builder()
    //!                             .ipAddr("198.51.100.1")
    //!                             .virtualNetworkId("238dccd1-149b-463d-8228-560ab83a54fd")
    //!                             .build_struct(),
    //!                     )
    //!                     .build_struct(),
    //!             )
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustInfrastructureAccessTarget:ZeroTrustInfrastructureAccessTarget example <account_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustInfrastructureAccessTargetArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// A non-unique field that refers to a target.
        #[builder(into)]
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// The IPv4/IPv6 address that identifies where to reach a target.
        #[builder(into)]
        pub ip: pulumi_wasm_rust::Output<
            super::types::ZeroTrustInfrastructureAccessTargetIp,
        >,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustInfrastructureAccessTargetResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The date and time at which the target was created.
        pub created_at: pulumi_wasm_rust::Output<String>,
        /// A non-unique field that refers to a target.
        pub hostname: pulumi_wasm_rust::Output<String>,
        /// The IPv4/IPv6 address that identifies where to reach a target.
        pub ip: pulumi_wasm_rust::Output<
            super::types::ZeroTrustInfrastructureAccessTargetIp,
        >,
        /// The date and time at which the target was last modified.
        pub modified_at: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustInfrastructureAccessTargetArgs,
    ) -> ZeroTrustInfrastructureAccessTargetResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let hostname_binding = args.hostname.get_inner();
        let ip_binding = args.ip.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustInfrastructureAccessTarget:ZeroTrustInfrastructureAccessTarget"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "hostname".into(),
                    value: &hostname_binding,
                },
                register_interface::ObjectField {
                    name: "ip".into(),
                    value: &ip_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "createdAt".into(),
                },
                register_interface::ResultField {
                    name: "hostname".into(),
                },
                register_interface::ResultField {
                    name: "ip".into(),
                },
                register_interface::ResultField {
                    name: "modifiedAt".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustInfrastructureAccessTargetResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            created_at: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("createdAt").unwrap(),
            ),
            hostname: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("hostname").unwrap(),
            ),
            ip: pulumi_wasm_rust::__private::into_domain(hashmap.remove("ip").unwrap()),
            modified_at: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("modifiedAt").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_key_access_key_configuration {
    //! Access Keys Configuration defines the rotation policy for the keys
    //! that access will use to sign data.
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustKeyAccessKeyConfigurationArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Number of days to trigger a rotation of the keys.
        #[builder(into, default)]
        pub key_rotation_interval_days: pulumi_wasm_rust::Output<Option<i32>>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustKeyAccessKeyConfigurationResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Number of days to trigger a rotation of the keys.
        pub key_rotation_interval_days: pulumi_wasm_rust::Output<i32>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustKeyAccessKeyConfigurationArgs,
    ) -> ZeroTrustKeyAccessKeyConfigurationResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let key_rotation_interval_days_binding = args
            .key_rotation_interval_days
            .get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustKeyAccessKeyConfiguration:ZeroTrustKeyAccessKeyConfiguration"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "keyRotationIntervalDays".into(),
                    value: &key_rotation_interval_days_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "keyRotationIntervalDays".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustKeyAccessKeyConfigurationResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            key_rotation_interval_days: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("keyRotationIntervalDays").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_list {
    //! Provides a Cloudflare Teams List resource. Teams lists are
    //! referenced when creating secure web gateway policies or device
    //! posture rules.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = zero_trust_list::create(
    //!         "example",
    //!         ZeroTrustListArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .description("Serial numbers for all corporate devices.")
    //!             .items(vec!["8GE8721REF", "5RE8543EGG", "1YE2880LNP",])
    //!             .name("Corporate devices")
    //!             .type_("SERIAL")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustList:ZeroTrustList example <account_id>/<teams_list_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustListArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The description of the teams list.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The items of the teams list.
        #[builder(into, default)]
        pub items: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The items of the teams list that has explicit description.
        #[builder(into, default)]
        pub items_with_descriptions: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustListItemsWithDescription>>,
        >,
        /// Name of the teams list.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// The teams list type. Available values: `IP`, `SERIAL`, `URL`, `DOMAIN`, `EMAIL`.
        #[builder(into)]
        pub type_: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustListResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The description of the teams list.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// The items of the teams list.
        pub items: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The items of the teams list that has explicit description.
        pub items_with_descriptions: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustListItemsWithDescription>>,
        >,
        /// Name of the teams list.
        pub name: pulumi_wasm_rust::Output<String>,
        /// The teams list type. Available values: `IP`, `SERIAL`, `URL`, `DOMAIN`, `EMAIL`.
        pub type_: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: ZeroTrustListArgs) -> ZeroTrustListResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let description_binding = args.description.get_inner();
        let items_binding = args.items.get_inner();
        let items_with_descriptions_binding = args.items_with_descriptions.get_inner();
        let name_binding = args.name.get_inner();
        let type__binding = args.type_.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustList:ZeroTrustList".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "items".into(),
                    value: &items_binding,
                },
                register_interface::ObjectField {
                    name: "itemsWithDescriptions".into(),
                    value: &items_with_descriptions_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "items".into(),
                },
                register_interface::ResultField {
                    name: "itemsWithDescriptions".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustListResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            items: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("items").unwrap(),
            ),
            items_with_descriptions: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("itemsWithDescriptions").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_local_fallback_domain {
    //! Provides a Cloudflare Fallback Domain resource. Fallback domains are
    //! used to ignore DNS requests to a given list of domains. These DNS
    //! requests will be passed back to other DNS servers configured on
    //! existing network interfaces on the device.
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustLocalFallbackDomainArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        #[builder(into)]
        pub domains: pulumi_wasm_rust::Output<
            Vec<super::types::ZeroTrustLocalFallbackDomainDomain>,
        >,
        /// The settings policy for which to configure this fallback domain policy.
        #[builder(into, default)]
        pub policy_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustLocalFallbackDomainResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        pub domains: pulumi_wasm_rust::Output<
            Vec<super::types::ZeroTrustLocalFallbackDomainDomain>,
        >,
        /// The settings policy for which to configure this fallback domain policy.
        pub policy_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustLocalFallbackDomainArgs,
    ) -> ZeroTrustLocalFallbackDomainResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let domains_binding = args.domains.get_inner();
        let policy_id_binding = args.policy_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustLocalFallbackDomain:ZeroTrustLocalFallbackDomain"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "domains".into(),
                    value: &domains_binding,
                },
                register_interface::ObjectField {
                    name: "policyId".into(),
                    value: &policy_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "domains".into(),
                },
                register_interface::ResultField {
                    name: "policyId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustLocalFallbackDomainResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            domains: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("domains").unwrap(),
            ),
            policy_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("policyId").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_risk_behavior {
    //! The [Risk Behavior](https://developers.cloudflare.com/cloudflare-one/insights/risk-score/) resource allows you to configure Cloudflare Risk Behaviors for an account.
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustRiskBehaviorArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Zero Trust risk behaviors configured on this account
        #[builder(into, default)]
        pub behaviors: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustRiskBehaviorBehavior>>,
        >,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustRiskBehaviorResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Zero Trust risk behaviors configured on this account
        pub behaviors: pulumi_wasm_rust::Output<
            Option<Vec<super::types::ZeroTrustRiskBehaviorBehavior>>,
        >,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustRiskBehaviorArgs,
    ) -> ZeroTrustRiskBehaviorResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let behaviors_binding = args.behaviors.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustRiskBehavior:ZeroTrustRiskBehavior".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "behaviors".into(),
                    value: &behaviors_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "behaviors".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustRiskBehaviorResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            behaviors: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("behaviors").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_risk_score_integration {
    //! The [Risk Score Integration](https://developers.cloudflare.com/cloudflare-one/insights/risk-score/#send-risk-score-to-okta) resource allows you to transmit changes in User Risk Score to a specified vendor such as Okta.
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustRiskScoreIntegrationArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether this integration is enabled. If disabled, no risk changes will be exported to the third-party.
        #[builder(into, default)]
        pub active: pulumi_wasm_rust::Output<Option<bool>>,
        /// The type of integration, e.g. 'Okta'. Full list of allowed values can be found here: https://developers.cloudflare.com/api/operations/dlp-zt-risk-score-integration-create#request-body
        #[builder(into)]
        pub integration_type: pulumi_wasm_rust::Output<String>,
        /// A reference id that can be supplied by the client. Currently this should be set to the Access-Okta IDP ID (a UUIDv4). If omitted, a random UUIDv4 is used. https://developers.cloudflare.com/api/operations/access-identity-providers-get-an-access-identity-provider
        #[builder(into, default)]
        pub reference_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The base url of the tenant, e.g. 'https://tenant.okta.com'. Must be your Okta Tenant URL and not your custom domain.
        #[builder(into)]
        pub tenant_url: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustRiskScoreIntegrationResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether this integration is enabled. If disabled, no risk changes will be exported to the third-party.
        pub active: pulumi_wasm_rust::Output<bool>,
        /// The type of integration, e.g. 'Okta'. Full list of allowed values can be found here: https://developers.cloudflare.com/api/operations/dlp-zt-risk-score-integration-create#request-body
        pub integration_type: pulumi_wasm_rust::Output<String>,
        /// A reference id that can be supplied by the client. Currently this should be set to the Access-Okta IDP ID (a UUIDv4). If omitted, a random UUIDv4 is used. https://developers.cloudflare.com/api/operations/access-identity-providers-get-an-access-identity-provider
        pub reference_id: pulumi_wasm_rust::Output<String>,
        /// The base url of the tenant, e.g. 'https://tenant.okta.com'. Must be your Okta Tenant URL and not your custom domain.
        pub tenant_url: pulumi_wasm_rust::Output<String>,
        /// The URL for the Shared Signals Framework configuration, e.g. '/.well-known/sse-configuration/{integration*uuid}/'. https://openid.net/specs/openid-sse-framework-1*0.html#rfc.section.6.2.1
        pub well_known_url: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustRiskScoreIntegrationArgs,
    ) -> ZeroTrustRiskScoreIntegrationResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let active_binding = args.active.get_inner();
        let integration_type_binding = args.integration_type.get_inner();
        let reference_id_binding = args.reference_id.get_inner();
        let tenant_url_binding = args.tenant_url.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustRiskScoreIntegration:ZeroTrustRiskScoreIntegration"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "active".into(),
                    value: &active_binding,
                },
                register_interface::ObjectField {
                    name: "integrationType".into(),
                    value: &integration_type_binding,
                },
                register_interface::ObjectField {
                    name: "referenceId".into(),
                    value: &reference_id_binding,
                },
                register_interface::ObjectField {
                    name: "tenantUrl".into(),
                    value: &tenant_url_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "active".into(),
                },
                register_interface::ResultField {
                    name: "integrationType".into(),
                },
                register_interface::ResultField {
                    name: "referenceId".into(),
                },
                register_interface::ResultField {
                    name: "tenantUrl".into(),
                },
                register_interface::ResultField {
                    name: "wellKnownUrl".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustRiskScoreIntegrationResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            active: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("active").unwrap(),
            ),
            integration_type: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("integrationType").unwrap(),
            ),
            reference_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("referenceId").unwrap(),
            ),
            tenant_url: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tenantUrl").unwrap(),
            ),
            well_known_url: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("wellKnownUrl").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_split_tunnel {
    //! Provides a Cloudflare Split Tunnel resource. Split tunnels are used to either
    //! include or exclude lists of routes from the WARP client's tunnel.
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustSplitTunnelArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The mode of the split tunnel policy. Available values: `include`, `exclude`.
        #[builder(into)]
        pub mode: pulumi_wasm_rust::Output<String>,
        /// The settings policy for which to configure this split tunnel policy.
        #[builder(into, default)]
        pub policy_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The value of the tunnel attributes.
        #[builder(into)]
        pub tunnels: pulumi_wasm_rust::Output<
            Vec<super::types::ZeroTrustSplitTunnelTunnel>,
        >,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustSplitTunnelResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// The mode of the split tunnel policy. Available values: `include`, `exclude`.
        pub mode: pulumi_wasm_rust::Output<String>,
        /// The settings policy for which to configure this split tunnel policy.
        pub policy_id: pulumi_wasm_rust::Output<Option<String>>,
        /// The value of the tunnel attributes.
        pub tunnels: pulumi_wasm_rust::Output<
            Vec<super::types::ZeroTrustSplitTunnelTunnel>,
        >,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustSplitTunnelArgs,
    ) -> ZeroTrustSplitTunnelResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let mode_binding = args.mode.get_inner();
        let policy_id_binding = args.policy_id.get_inner();
        let tunnels_binding = args.tunnels.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustSplitTunnel:ZeroTrustSplitTunnel".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "mode".into(),
                    value: &mode_binding,
                },
                register_interface::ObjectField {
                    name: "policyId".into(),
                    value: &policy_id_binding,
                },
                register_interface::ObjectField {
                    name: "tunnels".into(),
                    value: &tunnels_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "mode".into(),
                },
                register_interface::ResultField {
                    name: "policyId".into(),
                },
                register_interface::ResultField {
                    name: "tunnels".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustSplitTunnelResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            mode: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("mode").unwrap(),
            ),
            policy_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("policyId").unwrap(),
            ),
            tunnels: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tunnels").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_tunnel_cloudflared {
    //! Tunnel exposes applications running on your local web server on any
    //! network with an internet connection without manually adding DNS
    //! records or configuring a firewall or router.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = zero_trust_tunnel_cloudflared::create(
    //!         "example",
    //!         ZeroTrustTunnelCloudflaredArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .name("my-tunnel")
    //!             .secret("AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustTunnelCloudflared:ZeroTrustTunnelCloudflared example <account_id>/<tunnel_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustTunnelCloudflaredArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel on the Zero Trust dashboard or using tunnel*config, tunnel*route or tunnel*virtual*network resources. Available values: `local`, `cloudflare`. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub config_src: pulumi_wasm_rust::Output<Option<String>>,
        /// A user-friendly name chosen when the tunnel is created. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
        /// 32 or more bytes, encoded as a base64 string. The Create Argo Tunnel endpoint sets this as the tunnel's password. Anyone wishing to run the tunnel needs this password. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub secret: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustTunnelCloudflaredResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Usable CNAME for accessing the Tunnel.
        pub cname: pulumi_wasm_rust::Output<String>,
        /// Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel on the Zero Trust dashboard or using tunnel*config, tunnel*route or tunnel*virtual*network resources. Available values: `local`, `cloudflare`. **Modifying this attribute will force creation of a new resource.**
        pub config_src: pulumi_wasm_rust::Output<Option<String>>,
        /// A user-friendly name chosen when the tunnel is created. **Modifying this attribute will force creation of a new resource.**
        pub name: pulumi_wasm_rust::Output<String>,
        /// 32 or more bytes, encoded as a base64 string. The Create Argo Tunnel endpoint sets this as the tunnel's password. Anyone wishing to run the tunnel needs this password. **Modifying this attribute will force creation of a new resource.**
        pub secret: pulumi_wasm_rust::Output<String>,
        /// Token used by a connector to authenticate and run the tunnel.
        pub tunnel_token: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustTunnelCloudflaredArgs,
    ) -> ZeroTrustTunnelCloudflaredResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let config_src_binding = args.config_src.get_inner();
        let name_binding = args.name.get_inner();
        let secret_binding = args.secret.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustTunnelCloudflared:ZeroTrustTunnelCloudflared"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "configSrc".into(),
                    value: &config_src_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "secret".into(),
                    value: &secret_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "cname".into(),
                },
                register_interface::ResultField {
                    name: "configSrc".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
                register_interface::ResultField {
                    name: "secret".into(),
                },
                register_interface::ResultField {
                    name: "tunnelToken".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustTunnelCloudflaredResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            cname: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("cname").unwrap(),
            ),
            config_src: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("configSrc").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
            secret: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("secret").unwrap(),
            ),
            tunnel_token: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tunnelToken").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_tunnel_cloudflared_config {
    //! Provides a Cloudflare Tunnel configuration resource.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   exampleTunnel:
    //!     type: cloudflare:ZeroTrustTunnelCloudflared
    //!     name: example_tunnel
    //!     properties:
    //!       accountId: f037e56e89293a057740de681ac9abbe
    //!       name: example_tunnel
    //!       secret: <32 character secret>
    //!   exampleConfig:
    //!     type: cloudflare:ZeroTrustTunnelCloudflaredConfig
    //!     name: example_config
    //!     properties:
    //!       accountId: f037e56e89293a057740de681ac9abbe
    //!       tunnelId: ${exampleTunnel.id}
    //!       config:
    //!         warpRouting:
    //!           enabled: true
    //!         originRequest:
    //!           connectTimeout: 1m0s
    //!           tlsTimeout: 1m0s
    //!           tcpKeepAlive: 1m0s
    //!           noHappyEyeballs: false
    //!           keepAliveConnections: 1024
    //!           keepAliveTimeout: 1m0s
    //!           httpHostHeader: baz
    //!           originServerName: foobar
    //!           caPool: /path/to/unsigned/ca/pool
    //!           noTlsVerify: false
    //!           disableChunkedEncoding: false
    //!           bastionMode: false
    //!           proxyAddress: 10.0.0.1
    //!           proxyPort: '8123'
    //!           proxyType: socks
    //!           ipRules:
    //!             - prefix: /web
    //!               ports:
    //!                 - 80
    //!                 - 443
    //!               allow: false
    //!         ingressRules:
    //!           - hostname: foo
    //!             path: /bar
    //!             service: http://10.0.0.2:8080
    //!             originRequest:
    //!               connectTimeout: 2m0s
    //!               access:
    //!                 required: true
    //!                 teamName: terraform
    //!                 audTags:
    //!                   - AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
    //!           - service: https://10.0.0.3:8081
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustTunnelCloudflaredConfig:ZeroTrustTunnelCloudflaredConfig example <account_id>/<tunnel_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustTunnelCloudflaredConfigArgs {
        /// The account identifier to target for the resource.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Configuration block for Tunnel Configuration.
        #[builder(into)]
        pub config: pulumi_wasm_rust::Output<
            super::types::ZeroTrustTunnelCloudflaredConfigConfig,
        >,
        /// Identifier of the Tunnel to target for this configuration.
        #[builder(into)]
        pub tunnel_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustTunnelCloudflaredConfigResult {
        /// The account identifier to target for the resource.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Configuration block for Tunnel Configuration.
        pub config: pulumi_wasm_rust::Output<
            super::types::ZeroTrustTunnelCloudflaredConfigConfig,
        >,
        /// Identifier of the Tunnel to target for this configuration.
        pub tunnel_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustTunnelCloudflaredConfigArgs,
    ) -> ZeroTrustTunnelCloudflaredConfigResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let config_binding = args.config.get_inner();
        let tunnel_id_binding = args.tunnel_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustTunnelCloudflaredConfig:ZeroTrustTunnelCloudflaredConfig"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "config".into(),
                    value: &config_binding,
                },
                register_interface::ObjectField {
                    name: "tunnelId".into(),
                    value: &tunnel_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "config".into(),
                },
                register_interface::ResultField {
                    name: "tunnelId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustTunnelCloudflaredConfigResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            config: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("config").unwrap(),
            ),
            tunnel_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tunnelId").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_tunnel_route {
    //! Provides a resource, that manages Cloudflare tunnel routes for Zero
    //! Trust. Tunnel routes are used to direct IP traffic through
    //! Cloudflare Tunnels.
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustTunnelRoute:ZeroTrustTunnelRoute example <account_id>/<network_cidr>/<virtual_network_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustTunnelRouteArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Description of the tunnel route.
        #[builder(into, default)]
        pub comment: pulumi_wasm_rust::Output<Option<String>>,
        /// The IPv4 or IPv6 network that should use this tunnel route, in CIDR notation.
        #[builder(into)]
        pub network: pulumi_wasm_rust::Output<String>,
        /// The ID of the tunnel that will service the tunnel route.
        #[builder(into)]
        pub tunnel_id: pulumi_wasm_rust::Output<String>,
        /// The ID of the virtual network for which this route is being added; uses the default virtual network of the account if none is provided. **Modifying this attribute will force creation of a new resource.**
        #[builder(into, default)]
        pub virtual_network_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustTunnelRouteResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Description of the tunnel route.
        pub comment: pulumi_wasm_rust::Output<Option<String>>,
        /// The IPv4 or IPv6 network that should use this tunnel route, in CIDR notation.
        pub network: pulumi_wasm_rust::Output<String>,
        /// The ID of the tunnel that will service the tunnel route.
        pub tunnel_id: pulumi_wasm_rust::Output<String>,
        /// The ID of the virtual network for which this route is being added; uses the default virtual network of the account if none is provided. **Modifying this attribute will force creation of a new resource.**
        pub virtual_network_id: pulumi_wasm_rust::Output<Option<String>>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustTunnelRouteArgs,
    ) -> ZeroTrustTunnelRouteResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let comment_binding = args.comment.get_inner();
        let network_binding = args.network.get_inner();
        let tunnel_id_binding = args.tunnel_id.get_inner();
        let virtual_network_id_binding = args.virtual_network_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustTunnelRoute:ZeroTrustTunnelRoute".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "comment".into(),
                    value: &comment_binding,
                },
                register_interface::ObjectField {
                    name: "network".into(),
                    value: &network_binding,
                },
                register_interface::ObjectField {
                    name: "tunnelId".into(),
                    value: &tunnel_id_binding,
                },
                register_interface::ObjectField {
                    name: "virtualNetworkId".into(),
                    value: &virtual_network_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "comment".into(),
                },
                register_interface::ResultField {
                    name: "network".into(),
                },
                register_interface::ResultField {
                    name: "tunnelId".into(),
                },
                register_interface::ResultField {
                    name: "virtualNetworkId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustTunnelRouteResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            comment: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("comment").unwrap(),
            ),
            network: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("network").unwrap(),
            ),
            tunnel_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tunnelId").unwrap(),
            ),
            virtual_network_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("virtualNetworkId").unwrap(),
            ),
        }
    }
}
pub mod zero_trust_tunnel_virtual_network {
    //! Provides a resource, that manages Cloudflare tunnel virtual networks
    //! for Zero Trust. Tunnel virtual networks are used for segregation of
    //! Tunnel IP Routes via Virtualized Networks to handle overlapping
    //! private IPs in your origins.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = zero_trust_tunnel_virtual_network::create(
    //!         "example",
    //!         ZeroTrustTunnelVirtualNetworkArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .comment("New tunnel virtual network for documentation")
    //!             .name("vnet-for-documentation")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zeroTrustTunnelVirtualNetwork:ZeroTrustTunnelVirtualNetwork example <account_id>/<vnet_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZeroTrustTunnelVirtualNetworkArgs {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Description of the tunnel virtual network.
        #[builder(into, default)]
        pub comment: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether this virtual network is the default one for the account. This means IP Routes belong to this virtual network and Teams Clients in the account route through this virtual network, unless specified otherwise for each case.
        #[builder(into, default)]
        pub is_default_network: pulumi_wasm_rust::Output<Option<bool>>,
        /// A user-friendly name chosen when the virtual network is created.
        #[builder(into)]
        pub name: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ZeroTrustTunnelVirtualNetworkResult {
        /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Description of the tunnel virtual network.
        pub comment: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether this virtual network is the default one for the account. This means IP Routes belong to this virtual network and Teams Clients in the account route through this virtual network, unless specified otherwise for each case.
        pub is_default_network: pulumi_wasm_rust::Output<Option<bool>>,
        /// A user-friendly name chosen when the virtual network is created.
        pub name: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZeroTrustTunnelVirtualNetworkArgs,
    ) -> ZeroTrustTunnelVirtualNetworkResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let comment_binding = args.comment.get_inner();
        let is_default_network_binding = args.is_default_network.get_inner();
        let name_binding = args.name.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zeroTrustTunnelVirtualNetwork:ZeroTrustTunnelVirtualNetwork"
                .into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "comment".into(),
                    value: &comment_binding,
                },
                register_interface::ObjectField {
                    name: "isDefaultNetwork".into(),
                    value: &is_default_network_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "comment".into(),
                },
                register_interface::ResultField {
                    name: "isDefaultNetwork".into(),
                },
                register_interface::ResultField {
                    name: "name".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZeroTrustTunnelVirtualNetworkResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            comment: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("comment").unwrap(),
            ),
            is_default_network: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("isDefaultNetwork").unwrap(),
            ),
            name: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("name").unwrap(),
            ),
        }
    }
}
pub mod zone {
    //! Provides a Cloudflare Zone resource. Zone is the basic resource for
    //! working with Cloudflare and is roughly equivalent to a domain name
    //! that the user purchases.
    //!
    //! > If you are attempting to sign up a subdomain of a zone you must first have Subdomain Support entitlement for your account.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = zone::create(
    //!         "example",
    //!         ZoneArgs::builder()
    //!             .account_id("f037e56e89293a057740de681ac9abbe")
    //!             .zone("example.com")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zone:Zone example <zone_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZoneArgs {
        /// Account ID to manage the zone resource in.
        #[builder(into)]
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether to scan for DNS records on creation. Ignored after zone is created.
        #[builder(into, default)]
        pub jump_start: pulumi_wasm_rust::Output<Option<bool>>,
        /// Whether this zone is paused (traffic bypasses Cloudflare). Defaults to `false`.
        #[builder(into, default)]
        pub paused: pulumi_wasm_rust::Output<Option<bool>>,
        /// The name of the commercial plan to apply to the zone. Available values: `free`, `lite`, `pro`, `pro_plus`, `business`, `enterprise`, `partners_free`, `partners_pro`, `partners_business`, `partners_enterprise`.
        #[builder(into, default)]
        pub plan: pulumi_wasm_rust::Output<Option<String>>,
        /// A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup. Available values: `full`, `partial`, `secondary`. Defaults to `full`.
        #[builder(into, default)]
        pub type_: pulumi_wasm_rust::Output<Option<String>>,
        /// List of Vanity Nameservers (if set).
        #[builder(into, default)]
        pub vanity_name_servers: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The DNS zone name which will be added. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ZoneResult {
        /// Account ID to manage the zone resource in.
        pub account_id: pulumi_wasm_rust::Output<String>,
        /// Whether to scan for DNS records on creation. Ignored after zone is created.
        pub jump_start: pulumi_wasm_rust::Output<Option<bool>>,
        pub meta: pulumi_wasm_rust::Output<std::collections::HashMap<String, bool>>,
        /// Cloudflare-assigned name servers. This is only populated for zones that use Cloudflare DNS.
        pub name_servers: pulumi_wasm_rust::Output<Vec<String>>,
        /// Whether this zone is paused (traffic bypasses Cloudflare). Defaults to `false`.
        pub paused: pulumi_wasm_rust::Output<Option<bool>>,
        /// The name of the commercial plan to apply to the zone. Available values: `free`, `lite`, `pro`, `pro_plus`, `business`, `enterprise`, `partners_free`, `partners_pro`, `partners_business`, `partners_enterprise`.
        pub plan: pulumi_wasm_rust::Output<String>,
        /// Status of the zone. Available values: `active`, `pending`, `initializing`, `moved`, `deleted`, `deactivated`.
        pub status: pulumi_wasm_rust::Output<String>,
        /// A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup. Available values: `full`, `partial`, `secondary`. Defaults to `full`.
        pub type_: pulumi_wasm_rust::Output<Option<String>>,
        /// List of Vanity Nameservers (if set).
        pub vanity_name_servers: pulumi_wasm_rust::Output<Vec<String>>,
        /// Contains the TXT record value to validate domain ownership. This is only populated for zones of type `partial`.
        pub verification_key: pulumi_wasm_rust::Output<String>,
        /// The DNS zone name which will be added. **Modifying this attribute will force creation of a new resource.**
        pub zone: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: ZoneArgs) -> ZoneResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let account_id_binding = args.account_id.get_inner();
        let jump_start_binding = args.jump_start.get_inner();
        let paused_binding = args.paused.get_inner();
        let plan_binding = args.plan.get_inner();
        let type__binding = args.type_.get_inner();
        let vanity_name_servers_binding = args.vanity_name_servers.get_inner();
        let zone_binding = args.zone.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zone:Zone".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accountId".into(),
                    value: &account_id_binding,
                },
                register_interface::ObjectField {
                    name: "jumpStart".into(),
                    value: &jump_start_binding,
                },
                register_interface::ObjectField {
                    name: "paused".into(),
                    value: &paused_binding,
                },
                register_interface::ObjectField {
                    name: "plan".into(),
                    value: &plan_binding,
                },
                register_interface::ObjectField {
                    name: "type".into(),
                    value: &type__binding,
                },
                register_interface::ObjectField {
                    name: "vanityNameServers".into(),
                    value: &vanity_name_servers_binding,
                },
                register_interface::ObjectField {
                    name: "zone".into(),
                    value: &zone_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "accountId".into(),
                },
                register_interface::ResultField {
                    name: "jumpStart".into(),
                },
                register_interface::ResultField {
                    name: "meta".into(),
                },
                register_interface::ResultField {
                    name: "nameServers".into(),
                },
                register_interface::ResultField {
                    name: "paused".into(),
                },
                register_interface::ResultField {
                    name: "plan".into(),
                },
                register_interface::ResultField {
                    name: "status".into(),
                },
                register_interface::ResultField {
                    name: "type".into(),
                },
                register_interface::ResultField {
                    name: "vanityNameServers".into(),
                },
                register_interface::ResultField {
                    name: "verificationKey".into(),
                },
                register_interface::ResultField {
                    name: "zone".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZoneResult {
            account_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("accountId").unwrap(),
            ),
            jump_start: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("jumpStart").unwrap(),
            ),
            meta: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("meta").unwrap(),
            ),
            name_servers: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("nameServers").unwrap(),
            ),
            paused: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("paused").unwrap(),
            ),
            plan: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("plan").unwrap(),
            ),
            status: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("status").unwrap(),
            ),
            type_: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("type").unwrap(),
            ),
            vanity_name_servers: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("vanityNameServers").unwrap(),
            ),
            verification_key: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("verificationKey").unwrap(),
            ),
            zone: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zone").unwrap(),
            ),
        }
    }
}
pub mod zone_cache_reserve {
    //! Provides a Cloudflare Cache Reserve resource. Cache Reserve can
    //! increase cache lifetimes by automatically storing all cacheable
    //! files in Cloudflare's persistent object storage buckets.
    //!
    //! Note: Using Cache Reserve without Tiered Cache is not recommended.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = zone_cache_reserve::create(
    //!         "example",
    //!         ZoneCacheReserveArgs::builder()
    //!             .enabled(true)
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zoneCacheReserve:ZoneCacheReserve example <zone_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZoneCacheReserveArgs {
        /// Whether to enable or disable Cache Reserve support for a given zone.
        #[builder(into)]
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ZoneCacheReserveResult {
        /// Whether to enable or disable Cache Reserve support for a given zone.
        pub enabled: pulumi_wasm_rust::Output<bool>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: ZoneCacheReserveArgs) -> ZoneCacheReserveResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let enabled_binding = args.enabled.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zoneCacheReserve:ZoneCacheReserve".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "enabled".into(),
                    value: &enabled_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "enabled".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZoneCacheReserveResult {
            enabled: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("enabled").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod zone_cache_variants {
    //! Provides a resource which customizes Cloudflare zone cache variants.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = zone_cache_variants::create(
    //!         "example",
    //!         ZoneCacheVariantsArgs::builder()
    //!             .avifs(vec!["image/avif", "image/webp",])
    //!             .bmps(vec!["image/bmp", "image/webp",])
    //!             .gifs(vec!["image/gif", "image/webp",])
    //!             .jp_2_s(vec!["image/jp2", "image/webp",])
    //!             .jpegs(vec!["image/jpeg", "image/webp",])
    //!             .jpg_2_s(vec!["image/jpg2", "image/webp",])
    //!             .jpgs(vec!["image/jpg", "image/webp",])
    //!             .pngs(vec!["image/png", "image/webp",])
    //!             .tiffs(vec!["image/tiff", "image/webp",])
    //!             .tifs(vec!["image/tif", "image/webp",])
    //!             .webps(vec!["image/jpeg", "image/webp",])
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZoneCacheVariantsArgs {
        /// List of strings with the MIME types of all the variants that should be served for avif.
        #[builder(into, default)]
        pub avifs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for bmp.
        #[builder(into, default)]
        pub bmps: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for gif.
        #[builder(into, default)]
        pub gifs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for jp2.
        #[builder(into, default)]
        pub jp2s: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for jpeg.
        #[builder(into, default)]
        pub jpegs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for jpg2.
        #[builder(into, default)]
        pub jpg2s: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for jpg.
        #[builder(into, default)]
        pub jpgs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for png.
        #[builder(into, default)]
        pub pngs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for tiff.
        #[builder(into, default)]
        pub tiffs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for tif.
        #[builder(into, default)]
        pub tifs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for webp.
        #[builder(into, default)]
        pub webps: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ZoneCacheVariantsResult {
        /// List of strings with the MIME types of all the variants that should be served for avif.
        pub avifs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for bmp.
        pub bmps: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for gif.
        pub gifs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for jp2.
        pub jp2s: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for jpeg.
        pub jpegs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for jpg2.
        pub jpg2s: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for jpg.
        pub jpgs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for png.
        pub pngs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for tiff.
        pub tiffs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for tif.
        pub tifs: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// List of strings with the MIME types of all the variants that should be served for webp.
        pub webps: pulumi_wasm_rust::Output<Option<Vec<String>>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: ZoneCacheVariantsArgs) -> ZoneCacheVariantsResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let avifs_binding = args.avifs.get_inner();
        let bmps_binding = args.bmps.get_inner();
        let gifs_binding = args.gifs.get_inner();
        let jp2s_binding = args.jp2s.get_inner();
        let jpegs_binding = args.jpegs.get_inner();
        let jpg2s_binding = args.jpg2s.get_inner();
        let jpgs_binding = args.jpgs.get_inner();
        let pngs_binding = args.pngs.get_inner();
        let tiffs_binding = args.tiffs.get_inner();
        let tifs_binding = args.tifs.get_inner();
        let webps_binding = args.webps.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zoneCacheVariants:ZoneCacheVariants".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "avifs".into(),
                    value: &avifs_binding,
                },
                register_interface::ObjectField {
                    name: "bmps".into(),
                    value: &bmps_binding,
                },
                register_interface::ObjectField {
                    name: "gifs".into(),
                    value: &gifs_binding,
                },
                register_interface::ObjectField {
                    name: "jp2s".into(),
                    value: &jp2s_binding,
                },
                register_interface::ObjectField {
                    name: "jpegs".into(),
                    value: &jpegs_binding,
                },
                register_interface::ObjectField {
                    name: "jpg2s".into(),
                    value: &jpg2s_binding,
                },
                register_interface::ObjectField {
                    name: "jpgs".into(),
                    value: &jpgs_binding,
                },
                register_interface::ObjectField {
                    name: "pngs".into(),
                    value: &pngs_binding,
                },
                register_interface::ObjectField {
                    name: "tiffs".into(),
                    value: &tiffs_binding,
                },
                register_interface::ObjectField {
                    name: "tifs".into(),
                    value: &tifs_binding,
                },
                register_interface::ObjectField {
                    name: "webps".into(),
                    value: &webps_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "avifs".into(),
                },
                register_interface::ResultField {
                    name: "bmps".into(),
                },
                register_interface::ResultField {
                    name: "gifs".into(),
                },
                register_interface::ResultField {
                    name: "jp2s".into(),
                },
                register_interface::ResultField {
                    name: "jpegs".into(),
                },
                register_interface::ResultField {
                    name: "jpg2s".into(),
                },
                register_interface::ResultField {
                    name: "jpgs".into(),
                },
                register_interface::ResultField {
                    name: "pngs".into(),
                },
                register_interface::ResultField {
                    name: "tiffs".into(),
                },
                register_interface::ResultField {
                    name: "tifs".into(),
                },
                register_interface::ResultField {
                    name: "webps".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZoneCacheVariantsResult {
            avifs: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("avifs").unwrap(),
            ),
            bmps: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("bmps").unwrap(),
            ),
            gifs: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("gifs").unwrap(),
            ),
            jp2s: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("jp2s").unwrap(),
            ),
            jpegs: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("jpegs").unwrap(),
            ),
            jpg2s: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("jpg2s").unwrap(),
            ),
            jpgs: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("jpgs").unwrap(),
            ),
            pngs: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("pngs").unwrap(),
            ),
            tiffs: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tiffs").unwrap(),
            ),
            tifs: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("tifs").unwrap(),
            ),
            webps: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("webps").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod zone_dnssec {
    //! Provides a Cloudflare resource to create and modify zone DNSSEC settings.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = zone::create(
    //!         "example",
    //!         ZoneArgs::builder().zone("example.com").build_struct(),
    //!     );
    //!     let exampleZoneDnssec = zone_dnssec::create(
    //!         "exampleZoneDnssec",
    //!         ZoneDnssecArgs::builder().zone_id("${example.id}").build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zoneDnssec:ZoneDnssec example <zone_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZoneDnssecArgs {
        /// Zone DNSSEC updated time.
        #[builder(into, default)]
        pub modified_on: pulumi_wasm_rust::Output<Option<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ZoneDnssecResult {
        /// Zone DNSSEC algorithm.
        pub algorithm: pulumi_wasm_rust::Output<String>,
        /// Zone DNSSEC digest.
        pub digest: pulumi_wasm_rust::Output<String>,
        /// Digest algorithm use for Zone DNSSEC.
        pub digest_algorithm: pulumi_wasm_rust::Output<String>,
        /// Digest Type for Zone DNSSEC.
        pub digest_type: pulumi_wasm_rust::Output<String>,
        /// DS for the Zone DNSSEC.
        pub ds: pulumi_wasm_rust::Output<String>,
        /// Zone DNSSEC flags.
        pub flags: pulumi_wasm_rust::Output<i32>,
        /// Key Tag for the Zone DNSSEC.
        pub key_tag: pulumi_wasm_rust::Output<i32>,
        /// Key type used for Zone DNSSEC.
        pub key_type: pulumi_wasm_rust::Output<String>,
        /// Zone DNSSEC updated time.
        pub modified_on: pulumi_wasm_rust::Output<String>,
        /// Public Key for the Zone DNSSEC.
        pub public_key: pulumi_wasm_rust::Output<String>,
        /// The status of the Zone DNSSEC.
        pub status: pulumi_wasm_rust::Output<String>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: ZoneDnssecArgs) -> ZoneDnssecResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let modified_on_binding = args.modified_on.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zoneDnssec:ZoneDnssec".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "modifiedOn".into(),
                    value: &modified_on_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "algorithm".into(),
                },
                register_interface::ResultField {
                    name: "digest".into(),
                },
                register_interface::ResultField {
                    name: "digestAlgorithm".into(),
                },
                register_interface::ResultField {
                    name: "digestType".into(),
                },
                register_interface::ResultField {
                    name: "ds".into(),
                },
                register_interface::ResultField {
                    name: "flags".into(),
                },
                register_interface::ResultField {
                    name: "keyTag".into(),
                },
                register_interface::ResultField {
                    name: "keyType".into(),
                },
                register_interface::ResultField {
                    name: "modifiedOn".into(),
                },
                register_interface::ResultField {
                    name: "publicKey".into(),
                },
                register_interface::ResultField {
                    name: "status".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZoneDnssecResult {
            algorithm: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("algorithm").unwrap(),
            ),
            digest: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("digest").unwrap(),
            ),
            digest_algorithm: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("digestAlgorithm").unwrap(),
            ),
            digest_type: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("digestType").unwrap(),
            ),
            ds: pulumi_wasm_rust::__private::into_domain(hashmap.remove("ds").unwrap()),
            flags: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("flags").unwrap(),
            ),
            key_tag: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("keyTag").unwrap(),
            ),
            key_type: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("keyType").unwrap(),
            ),
            modified_on: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("modifiedOn").unwrap(),
            ),
            public_key: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("publicKey").unwrap(),
            ),
            status: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("status").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod zone_hold {
    //! Provides a Cloudflare Zone Hold resource that prevents adding
    //! the hostname to another account for use.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let example = zone_hold::create(
    //!         "example",
    //!         ZoneHoldArgs::builder()
    //!             .hold(true)
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zoneHold:ZoneHold example <zone_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZoneHoldArgs {
        /// Enablement status of the zone hold.
        #[builder(into)]
        pub hold: pulumi_wasm_rust::Output<bool>,
        /// The RFC3339 compatible timestamp when to automatically re-enable the zone hold.
        #[builder(into, default)]
        pub hold_after: pulumi_wasm_rust::Output<Option<String>>,
        /// Whether to extend to block any subdomain of the given zone.
        #[builder(into, default)]
        pub include_subdomains: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource.
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ZoneHoldResult {
        /// Enablement status of the zone hold.
        pub hold: pulumi_wasm_rust::Output<bool>,
        /// The RFC3339 compatible timestamp when to automatically re-enable the zone hold.
        pub hold_after: pulumi_wasm_rust::Output<String>,
        /// Whether to extend to block any subdomain of the given zone.
        pub include_subdomains: pulumi_wasm_rust::Output<Option<bool>>,
        /// The zone identifier to target for the resource.
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: ZoneHoldArgs) -> ZoneHoldResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let hold_binding = args.hold.get_inner();
        let hold_after_binding = args.hold_after.get_inner();
        let include_subdomains_binding = args.include_subdomains.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zoneHold:ZoneHold".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "hold".into(),
                    value: &hold_binding,
                },
                register_interface::ObjectField {
                    name: "holdAfter".into(),
                    value: &hold_after_binding,
                },
                register_interface::ObjectField {
                    name: "includeSubdomains".into(),
                    value: &include_subdomains_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "hold".into(),
                },
                register_interface::ResultField {
                    name: "holdAfter".into(),
                },
                register_interface::ResultField {
                    name: "includeSubdomains".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZoneHoldResult {
            hold: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("hold").unwrap(),
            ),
            hold_after: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("holdAfter").unwrap(),
            ),
            include_subdomains: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("includeSubdomains").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod zone_lockdown {
    //! Provides a Cloudflare Zone Lockdown resource. Zone Lockdown allows
    //! you to define one or more URLs (with wildcard matching on the domain
    //! or path) that will only permit access if the request originates
    //! from an IP address that matches a safelist of one or more IP
    //! addresses and/or IP ranges.
    //!
    //! ## Example Usage
    //!
    //! ```yaml
    //! resources:
    //!   # Restrict access to these endpoints to requests from a known IP address range.
    //!   example:
    //!     type: cloudflare:ZoneLockdown
    //!     properties:
    //!       zoneId: 0da42c8d2132a9ddaf714f9e7c920711
    //!       paused: 'false'
    //!       description: Restrict access to these endpoints to requests from a known IP address range
    //!       urls:
    //!         - api.mysite.com/some/endpoint*
    //!       configurations:
    //!         - target: ip_range
    //!           value: 192.0.2.0/24
    //! ```
    //!
    //! ## Import
    //!
    //! ```sh
    //! $ pulumi import cloudflare:index/zoneLockdown:ZoneLockdown example <zone_id>/<lockdown_id>
    //! ```
    //!
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZoneLockdownArgs {
        /// A list of IP addresses or IP ranges to match the request against specified in target, value pairs.
        #[builder(into)]
        pub configurations: pulumi_wasm_rust::Output<
            Vec<super::types::ZoneLockdownConfiguration>,
        >,
        /// A description about the lockdown entry. Typically used as a reminder or explanation for the lockdown.
        #[builder(into, default)]
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Boolean of whether this zone lockdown is currently paused. Defaults to `false`.
        #[builder(into, default)]
        pub paused: pulumi_wasm_rust::Output<Option<bool>>,
        #[builder(into, default)]
        pub priority: pulumi_wasm_rust::Output<Option<i32>>,
        /// A list of simple wildcard patterns to match requests against. The order of the urls is unimportant.
        #[builder(into)]
        pub urls: pulumi_wasm_rust::Output<Vec<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ZoneLockdownResult {
        /// A list of IP addresses or IP ranges to match the request against specified in target, value pairs.
        pub configurations: pulumi_wasm_rust::Output<
            Vec<super::types::ZoneLockdownConfiguration>,
        >,
        /// A description about the lockdown entry. Typically used as a reminder or explanation for the lockdown.
        pub description: pulumi_wasm_rust::Output<Option<String>>,
        /// Boolean of whether this zone lockdown is currently paused. Defaults to `false`.
        pub paused: pulumi_wasm_rust::Output<Option<bool>>,
        pub priority: pulumi_wasm_rust::Output<Option<i32>>,
        /// A list of simple wildcard patterns to match requests against. The order of the urls is unimportant.
        pub urls: pulumi_wasm_rust::Output<Vec<String>>,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(name: &str, args: ZoneLockdownArgs) -> ZoneLockdownResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let configurations_binding = args.configurations.get_inner();
        let description_binding = args.description.get_inner();
        let paused_binding = args.paused.get_inner();
        let priority_binding = args.priority.get_inner();
        let urls_binding = args.urls.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zoneLockdown:ZoneLockdown".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "configurations".into(),
                    value: &configurations_binding,
                },
                register_interface::ObjectField {
                    name: "description".into(),
                    value: &description_binding,
                },
                register_interface::ObjectField {
                    name: "paused".into(),
                    value: &paused_binding,
                },
                register_interface::ObjectField {
                    name: "priority".into(),
                    value: &priority_binding,
                },
                register_interface::ObjectField {
                    name: "urls".into(),
                    value: &urls_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "configurations".into(),
                },
                register_interface::ResultField {
                    name: "description".into(),
                },
                register_interface::ResultField {
                    name: "paused".into(),
                },
                register_interface::ResultField {
                    name: "priority".into(),
                },
                register_interface::ResultField {
                    name: "urls".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZoneLockdownResult {
            configurations: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("configurations").unwrap(),
            ),
            description: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("description").unwrap(),
            ),
            paused: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("paused").unwrap(),
            ),
            priority: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("priority").unwrap(),
            ),
            urls: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("urls").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
        }
    }
}
pub mod zone_settings_override {
    //! Provides a resource which customizes Cloudflare zone settings.
    //!
    //! > You **should not** use this resource to manage every zone setting. This
    //!   resource is only intended to override those which you do not want the default.
    //!   Attempting to manage all settings will result in problems with the resource
    //!   applying in a consistent manner.
    //!
    //! ## Plan-Dependent Settings
    //!
    //! Note that some settings are only available on certain plans. Setting an argument
    //! for a feature that is not available on the plan configured for the zone will
    //! result in an error:
    //!
    //! ```sh
    //! Error: invalid zone setting "\<argument\>" (value: \<value\>) found - cannot be set as it is read only
    //! ```
    //!
    //! This is true even when setting the argument to its default value. These values
    //! should either be omitted or set to `null` for zones with plans that don't
    //! support the feature. See the [plan feature matrices](https://www.cloudflare.com/plans/) for details on
    //! feature support by plan.
    //!
    //! ## Example Usage
    //!
    //! ```ignore
    //! use pulumi_wasm_rust::Output;
    //! use pulumi_wasm_rust::{add_export, pulumi_main};
    //! #[pulumi_main]
    //! fn test_main() -> Result<(), Error> {
    //!     let test = zone_settings_override::create(
    //!         "test",
    //!         ZoneSettingsOverrideArgs::builder()
    //!             .settings(
    //!                 ZoneSettingsOverrideSettings::builder()
    //!                     .automaticHttpsRewrites("on")
    //!                     .brotli("on")
    //!                     .challengeTtl(2700)
    //!                     .minify(
    //!                         ZoneSettingsOverrideSettingsMinify::builder()
    //!                             .css("on")
    //!                             .html("off")
    //!                             .js("off")
    //!                             .build_struct(),
    //!                     )
    //!                     .mirage("on")
    //!                     .opportunisticEncryption("on")
    //!                     .securityHeader(
    //!                         ZoneSettingsOverrideSettingsSecurityHeader::builder()
    //!                             .enabled(true)
    //!                             .build_struct(),
    //!                     )
    //!                     .securityLevel("high")
    //!                     .waf("on")
    //!                     .build_struct(),
    //!             )
    //!             .zone_id("0da42c8d2132a9ddaf714f9e7c920711")
    //!             .build_struct(),
    //!     );
    //! }
    //! ```
    #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct ZoneSettingsOverrideArgs {
        #[builder(into, default)]
        pub settings: pulumi_wasm_rust::Output<
            Option<super::types::ZoneSettingsOverrideSettings>,
        >,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        #[builder(into)]
        pub zone_id: pulumi_wasm_rust::Output<String>,
    }
    #[allow(dead_code)]
    pub struct ZoneSettingsOverrideResult {
        pub initial_settings: pulumi_wasm_rust::Output<
            Vec<super::types::ZoneSettingsOverrideInitialSetting>,
        >,
        pub initial_settings_read_at: pulumi_wasm_rust::Output<String>,
        pub readonly_settings: pulumi_wasm_rust::Output<Vec<String>>,
        pub settings: pulumi_wasm_rust::Output<
            super::types::ZoneSettingsOverrideSettings,
        >,
        /// The zone identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
        pub zone_id: pulumi_wasm_rust::Output<String>,
        pub zone_status: pulumi_wasm_rust::Output<String>,
        pub zone_type: pulumi_wasm_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        name: &str,
        args: ZoneSettingsOverrideArgs,
    ) -> ZoneSettingsOverrideResult {
        use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
        use std::collections::HashMap;
        let settings_binding = args.settings.get_inner();
        let zone_id_binding = args.zone_id.get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "cloudflare:index/zoneSettingsOverride:ZoneSettingsOverride".into(),
            name: name.to_string(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "settings".into(),
                    value: &settings_binding,
                },
                register_interface::ObjectField {
                    name: "zoneId".into(),
                    value: &zone_id_binding,
                },
            ]),
            results: Vec::from([
                register_interface::ResultField {
                    name: "initialSettings".into(),
                },
                register_interface::ResultField {
                    name: "initialSettingsReadAt".into(),
                },
                register_interface::ResultField {
                    name: "readonlySettings".into(),
                },
                register_interface::ResultField {
                    name: "settings".into(),
                },
                register_interface::ResultField {
                    name: "zoneId".into(),
                },
                register_interface::ResultField {
                    name: "zoneStatus".into(),
                },
                register_interface::ResultField {
                    name: "zoneType".into(),
                },
            ]),
        };
        let o = register_interface::register(&request);
        let mut hashmap: HashMap<String, _> = o
            .fields
            .into_iter()
            .map(|f| (f.name, f.output))
            .collect();
        ZoneSettingsOverrideResult {
            initial_settings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("initialSettings").unwrap(),
            ),
            initial_settings_read_at: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("initialSettingsReadAt").unwrap(),
            ),
            readonly_settings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("readonlySettings").unwrap(),
            ),
            settings: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("settings").unwrap(),
            ),
            zone_id: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneId").unwrap(),
            ),
            zone_status: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneStatus").unwrap(),
            ),
            zone_type: pulumi_wasm_rust::__private::into_domain(
                hashmap.remove("zoneType").unwrap(),
            ),
        }
    }
}
pub mod functions {
    pub mod get_access_application {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetAccessApplicationArgs {
            /// The account identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.
            #[builder(into, default)]
            pub account_id: pulumi_wasm_rust::Output<Option<String>>,
            /// The primary hostname and path that Access will secure. Must provide only one of `name`, `domain`.
            #[builder(into, default)]
            pub domain: pulumi_wasm_rust::Output<Option<String>>,
            /// Friendly name of the Access Application. Must provide only one of `name`, `domain`.
            #[builder(into, default)]
            pub name: pulumi_wasm_rust::Output<Option<String>>,
            /// The zone identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.
            #[builder(into, default)]
            pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
        }
        #[allow(dead_code)]
        pub struct GetAccessApplicationResult {
            /// The account identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.
            pub account_id: pulumi_wasm_rust::Output<Option<String>>,
            /// Application Audience (AUD) Tag of the application.
            pub aud: pulumi_wasm_rust::Output<String>,
            /// The primary hostname and path that Access will secure. Must provide only one of `name`, `domain`.
            pub domain: pulumi_wasm_rust::Output<String>,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
            /// Friendly name of the Access Application. Must provide only one of `name`, `domain`.
            pub name: pulumi_wasm_rust::Output<String>,
            /// The zone identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.
            pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(args: GetAccessApplicationArgs) -> GetAccessApplicationResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let account_id_binding = args.account_id.get_inner();
            let domain_binding = args.domain.get_inner();
            let name_binding = args.name.get_inner();
            let zone_id_binding = args.zone_id.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getAccessApplication:getAccessApplication"
                    .into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "accountId".into(),
                        value: &account_id_binding,
                    },
                    register_interface::ObjectField {
                        name: "domain".into(),
                        value: &domain_binding,
                    },
                    register_interface::ObjectField {
                        name: "name".into(),
                        value: &name_binding,
                    },
                    register_interface::ObjectField {
                        name: "zoneId".into(),
                        value: &zone_id_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "accountId".into(),
                    },
                    register_interface::ResultField {
                        name: "aud".into(),
                    },
                    register_interface::ResultField {
                        name: "domain".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "name".into(),
                    },
                    register_interface::ResultField {
                        name: "zoneId".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetAccessApplicationResult {
                account_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("accountId").unwrap(),
                ),
                aud: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("aud").unwrap(),
                ),
                domain: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("domain").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                name: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("name").unwrap(),
                ),
                zone_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("zoneId").unwrap(),
                ),
            }
        }
    }
    pub mod get_access_identity_provider {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetAccessIdentityProviderArgs {
            /// The account identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.
            #[builder(into, default)]
            pub account_id: pulumi_wasm_rust::Output<Option<String>>,
            /// Access Identity Provider name to search for.
            #[builder(into)]
            pub name: pulumi_wasm_rust::Output<String>,
            /// The zone identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.
            #[builder(into, default)]
            pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
        }
        #[allow(dead_code)]
        pub struct GetAccessIdentityProviderResult {
            /// The account identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.
            pub account_id: pulumi_wasm_rust::Output<Option<String>>,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
            /// Access Identity Provider name to search for.
            pub name: pulumi_wasm_rust::Output<String>,
            /// Access Identity Provider Type.
            pub type_: pulumi_wasm_rust::Output<String>,
            /// The zone identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.
            pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(
            args: GetAccessIdentityProviderArgs,
        ) -> GetAccessIdentityProviderResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let account_id_binding = args.account_id.get_inner();
            let name_binding = args.name.get_inner();
            let zone_id_binding = args.zone_id.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getAccessIdentityProvider:getAccessIdentityProvider"
                    .into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "accountId".into(),
                        value: &account_id_binding,
                    },
                    register_interface::ObjectField {
                        name: "name".into(),
                        value: &name_binding,
                    },
                    register_interface::ObjectField {
                        name: "zoneId".into(),
                        value: &zone_id_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "accountId".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "name".into(),
                    },
                    register_interface::ResultField {
                        name: "type".into(),
                    },
                    register_interface::ResultField {
                        name: "zoneId".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetAccessIdentityProviderResult {
                account_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("accountId").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                name: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("name").unwrap(),
                ),
                type_: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("type").unwrap(),
                ),
                zone_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("zoneId").unwrap(),
                ),
            }
        }
    }
    pub mod get_account_roles {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetAccountRolesArgs {
            /// The account identifier to target for the resource.
            #[builder(into)]
            pub account_id: pulumi_wasm_rust::Output<String>,
        }
        #[allow(dead_code)]
        pub struct GetAccountRolesResult {
            /// The account identifier to target for the resource.
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
            /// A list of roles object.
            pub roles: pulumi_wasm_rust::Output<
                Vec<super::super::types::GetAccountRolesRole>,
            >,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(args: GetAccountRolesArgs) -> GetAccountRolesResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let account_id_binding = args.account_id.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getAccountRoles:getAccountRoles".into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "accountId".into(),
                        value: &account_id_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "accountId".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "roles".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetAccountRolesResult {
                account_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("accountId").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                roles: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("roles").unwrap(),
                ),
            }
        }
    }
    pub mod get_accounts {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetAccountsArgs {
            /// The account name to target for the resource.
            #[builder(into, default)]
            pub name: pulumi_wasm_rust::Output<Option<String>>,
        }
        #[allow(dead_code)]
        pub struct GetAccountsResult {
            pub accounts: pulumi_wasm_rust::Output<
                Vec<super::super::types::GetAccountsAccount>,
            >,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
            /// The account name to target for the resource.
            pub name: pulumi_wasm_rust::Output<Option<String>>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(args: GetAccountsArgs) -> GetAccountsResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let name_binding = args.name.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getAccounts:getAccounts".into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "name".into(),
                        value: &name_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "accounts".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "name".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetAccountsResult {
                accounts: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("accounts").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                name: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("name").unwrap(),
                ),
            }
        }
    }
    pub mod get_api_token_permission_groups {
        #[allow(dead_code)]
        pub struct GetApiTokenPermissionGroupsResult {
            /// Map of permissions for account level resources.
            pub account: pulumi_wasm_rust::Output<
                std::collections::HashMap<String, String>,
            >,
            /// Checksum of permissions.
            pub id: pulumi_wasm_rust::Output<String>,
            /// Map of all permissions available. Should not be used as some permissions will overlap resource scope. Instead, use resource level specific attributes.
            pub permissions: pulumi_wasm_rust::Output<
                std::collections::HashMap<String, String>,
            >,
            /// Map of permissions for r2 level resources.
            pub r2: pulumi_wasm_rust::Output<std::collections::HashMap<String, String>>,
            /// Map of permissions for user level resources.
            pub user: pulumi_wasm_rust::Output<
                std::collections::HashMap<String, String>,
            >,
            /// Map of permissions for zone level resources.
            pub zone: pulumi_wasm_rust::Output<
                std::collections::HashMap<String, String>,
            >,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke() -> GetApiTokenPermissionGroupsResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getApiTokenPermissionGroups:getApiTokenPermissionGroups"
                    .into(),
                object: Vec::from([]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "account".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "permissions".into(),
                    },
                    register_interface::ResultField {
                        name: "r2".into(),
                    },
                    register_interface::ResultField {
                        name: "user".into(),
                    },
                    register_interface::ResultField {
                        name: "zone".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetApiTokenPermissionGroupsResult {
                account: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("account").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                permissions: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("permissions").unwrap(),
                ),
                r2: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("r2").unwrap(),
                ),
                user: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("user").unwrap(),
                ),
                zone: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("zone").unwrap(),
                ),
            }
        }
    }
    pub mod get_dcv_delegation {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetDcvDelegationArgs {
            /// The zone identifier to target for the resource.
            #[builder(into)]
            pub zone_id: pulumi_wasm_rust::Output<String>,
        }
        #[allow(dead_code)]
        pub struct GetDcvDelegationResult {
            /// The DCV Delegation hostname
            pub hostname: pulumi_wasm_rust::Output<String>,
            /// The DCV Delegation unique identifier
            pub id: pulumi_wasm_rust::Output<String>,
            /// The zone identifier to target for the resource.
            pub zone_id: pulumi_wasm_rust::Output<String>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(args: GetDcvDelegationArgs) -> GetDcvDelegationResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let zone_id_binding = args.zone_id.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getDcvDelegation:getDcvDelegation".into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "zoneId".into(),
                        value: &zone_id_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "hostname".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "zoneId".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetDcvDelegationResult {
                hostname: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("hostname").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                zone_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("zoneId").unwrap(),
                ),
            }
        }
    }
    pub mod get_device_posture_rules {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetDevicePostureRulesArgs {
            /// The account identifier to target for the resource.
            #[builder(into)]
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// Name of the Device Posture Rule.
            #[builder(into, default)]
            pub name: pulumi_wasm_rust::Output<Option<String>>,
            /// The device posture rule type. Available values: `serial_number`, `file`, `application`, `gateway`, `warp`, `domain_joined`, `os_version`, `disk_encryption`, `firewall`, `client_certificate`, `client_certificate_v2`, `workspace_one`, `unique_client_id`, `crowdstrike_s2s`, `sentinelone`, `kolide`, `tanium_s2s`, `intune`, `sentinelone_s2s`, `custom_s2s`.
            #[builder(into, default)]
            pub type_: pulumi_wasm_rust::Output<Option<String>>,
        }
        #[allow(dead_code)]
        pub struct GetDevicePostureRulesResult {
            /// The account identifier to target for the resource.
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
            /// Name of the Device Posture Rule.
            pub name: pulumi_wasm_rust::Output<Option<String>>,
            /// A list of matching Device Posture Rules.
            pub rules: pulumi_wasm_rust::Output<
                Vec<super::super::types::GetDevicePostureRulesRule>,
            >,
            /// The device posture rule type. Available values: `serial_number`, `file`, `application`, `gateway`, `warp`, `domain_joined`, `os_version`, `disk_encryption`, `firewall`, `client_certificate`, `client_certificate_v2`, `workspace_one`, `unique_client_id`, `crowdstrike_s2s`, `sentinelone`, `kolide`, `tanium_s2s`, `intune`, `sentinelone_s2s`, `custom_s2s`.
            pub type_: pulumi_wasm_rust::Output<Option<String>>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(args: GetDevicePostureRulesArgs) -> GetDevicePostureRulesResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let account_id_binding = args.account_id.get_inner();
            let name_binding = args.name.get_inner();
            let type__binding = args.type_.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getDevicePostureRules:getDevicePostureRules"
                    .into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "accountId".into(),
                        value: &account_id_binding,
                    },
                    register_interface::ObjectField {
                        name: "name".into(),
                        value: &name_binding,
                    },
                    register_interface::ObjectField {
                        name: "type".into(),
                        value: &type__binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "accountId".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "name".into(),
                    },
                    register_interface::ResultField {
                        name: "rules".into(),
                    },
                    register_interface::ResultField {
                        name: "type".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetDevicePostureRulesResult {
                account_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("accountId").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                name: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("name").unwrap(),
                ),
                rules: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("rules").unwrap(),
                ),
                type_: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("type").unwrap(),
                ),
            }
        }
    }
    pub mod get_devices {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetDevicesArgs {
            /// The account identifier to target for the resource.
            #[builder(into)]
            pub account_id: pulumi_wasm_rust::Output<String>,
        }
        #[allow(dead_code)]
        pub struct GetDevicesResult {
            /// The account identifier to target for the resource.
            pub account_id: pulumi_wasm_rust::Output<String>,
            pub devices: pulumi_wasm_rust::Output<
                Vec<super::super::types::GetDevicesDevice>,
            >,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(args: GetDevicesArgs) -> GetDevicesResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let account_id_binding = args.account_id.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getDevices:getDevices".into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "accountId".into(),
                        value: &account_id_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "accountId".into(),
                    },
                    register_interface::ResultField {
                        name: "devices".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetDevicesResult {
                account_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("accountId").unwrap(),
                ),
                devices: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("devices").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
            }
        }
    }
    pub mod get_dlp_datasets {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetDlpDatasetsArgs {
            /// The account ID to fetch DLP Datasets from.
            #[builder(into)]
            pub account_id: pulumi_wasm_rust::Output<String>,
        }
        #[allow(dead_code)]
        pub struct GetDlpDatasetsResult {
            /// The account ID to fetch DLP Datasets from.
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// A list of DLP Datasets.
            pub datasets: pulumi_wasm_rust::Output<
                Vec<super::super::types::GetDlpDatasetsDataset>,
            >,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(args: GetDlpDatasetsArgs) -> GetDlpDatasetsResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let account_id_binding = args.account_id.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getDlpDatasets:getDlpDatasets".into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "accountId".into(),
                        value: &account_id_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "accountId".into(),
                    },
                    register_interface::ResultField {
                        name: "datasets".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetDlpDatasetsResult {
                account_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("accountId").unwrap(),
                ),
                datasets: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("datasets").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
            }
        }
    }
    pub mod get_gateway_app_types {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetGatewayAppTypesArgs {
            /// The account ID to fetch Gateway App Types from.
            #[builder(into)]
            pub account_id: pulumi_wasm_rust::Output<String>,
        }
        #[allow(dead_code)]
        pub struct GetGatewayAppTypesResult {
            /// The account ID to fetch Gateway App Types from.
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// A list of Gateway App Types.
            pub app_types: pulumi_wasm_rust::Output<
                Vec<super::super::types::GetGatewayAppTypesAppType>,
            >,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(args: GetGatewayAppTypesArgs) -> GetGatewayAppTypesResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let account_id_binding = args.account_id.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getGatewayAppTypes:getGatewayAppTypes".into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "accountId".into(),
                        value: &account_id_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "accountId".into(),
                    },
                    register_interface::ResultField {
                        name: "appTypes".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetGatewayAppTypesResult {
                account_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("accountId").unwrap(),
                ),
                app_types: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("appTypes").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
            }
        }
    }
    pub mod get_gateway_categories {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetGatewayCategoriesArgs {
            /// The account ID to fetch Gateway Categories from.
            #[builder(into)]
            pub account_id: pulumi_wasm_rust::Output<String>,
        }
        #[allow(dead_code)]
        pub struct GetGatewayCategoriesResult {
            /// The account ID to fetch Gateway Categories from.
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// A list of Gateway Categories.
            pub categories: pulumi_wasm_rust::Output<
                Vec<super::super::types::GetGatewayCategoriesCategory>,
            >,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(args: GetGatewayCategoriesArgs) -> GetGatewayCategoriesResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let account_id_binding = args.account_id.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getGatewayCategories:getGatewayCategories"
                    .into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "accountId".into(),
                        value: &account_id_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "accountId".into(),
                    },
                    register_interface::ResultField {
                        name: "categories".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetGatewayCategoriesResult {
                account_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("accountId").unwrap(),
                ),
                categories: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("categories").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
            }
        }
    }
    pub mod get_infrastructure_access_targets {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetInfrastructureAccessTargetsArgs {
            /// The account identifier to target for the resource.
            #[builder(into)]
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// A date and time after a target was created to filter on.
            #[builder(into, default)]
            pub created_after: pulumi_wasm_rust::Output<Option<String>>,
            /// The hostname of the target.
            #[builder(into, default)]
            pub hostname: pulumi_wasm_rust::Output<Option<String>>,
            /// Partial match to the hostname of a target
            #[builder(into, default)]
            pub hostname_contains: pulumi_wasm_rust::Output<Option<String>>,
            /// The target's IPv4 address.
            #[builder(into, default)]
            pub ipv4: pulumi_wasm_rust::Output<Option<String>>,
            /// The target's IPv6 address.
            #[builder(into, default)]
            pub ipv6: pulumi_wasm_rust::Output<Option<String>>,
            /// A date and time after a target was modified to filter on.
            #[builder(into, default)]
            pub modified_after: pulumi_wasm_rust::Output<Option<String>>,
            /// The private virtual network identifier for the target.
            #[builder(into, default)]
            pub virtual_network_id: pulumi_wasm_rust::Output<Option<String>>,
        }
        #[allow(dead_code)]
        pub struct GetInfrastructureAccessTargetsResult {
            /// The account identifier to target for the resource.
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// A date and time after a target was created to filter on.
            pub created_after: pulumi_wasm_rust::Output<Option<String>>,
            /// The hostname of the target.
            pub hostname: pulumi_wasm_rust::Output<Option<String>>,
            /// Partial match to the hostname of a target
            pub hostname_contains: pulumi_wasm_rust::Output<Option<String>>,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
            /// The target's IPv4 address.
            pub ipv4: pulumi_wasm_rust::Output<Option<String>>,
            /// The target's IPv6 address.
            pub ipv6: pulumi_wasm_rust::Output<Option<String>>,
            /// A date and time after a target was modified to filter on.
            pub modified_after: pulumi_wasm_rust::Output<Option<String>>,
            pub targets: pulumi_wasm_rust::Output<
                Vec<super::super::types::GetInfrastructureAccessTargetsTarget>,
            >,
            /// The private virtual network identifier for the target.
            pub virtual_network_id: pulumi_wasm_rust::Output<Option<String>>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(
            args: GetInfrastructureAccessTargetsArgs,
        ) -> GetInfrastructureAccessTargetsResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let account_id_binding = args.account_id.get_inner();
            let created_after_binding = args.created_after.get_inner();
            let hostname_binding = args.hostname.get_inner();
            let hostname_contains_binding = args.hostname_contains.get_inner();
            let ipv4_binding = args.ipv4.get_inner();
            let ipv6_binding = args.ipv6.get_inner();
            let modified_after_binding = args.modified_after.get_inner();
            let virtual_network_id_binding = args.virtual_network_id.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getInfrastructureAccessTargets:getInfrastructureAccessTargets"
                    .into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "accountId".into(),
                        value: &account_id_binding,
                    },
                    register_interface::ObjectField {
                        name: "createdAfter".into(),
                        value: &created_after_binding,
                    },
                    register_interface::ObjectField {
                        name: "hostname".into(),
                        value: &hostname_binding,
                    },
                    register_interface::ObjectField {
                        name: "hostnameContains".into(),
                        value: &hostname_contains_binding,
                    },
                    register_interface::ObjectField {
                        name: "ipv4".into(),
                        value: &ipv4_binding,
                    },
                    register_interface::ObjectField {
                        name: "ipv6".into(),
                        value: &ipv6_binding,
                    },
                    register_interface::ObjectField {
                        name: "modifiedAfter".into(),
                        value: &modified_after_binding,
                    },
                    register_interface::ObjectField {
                        name: "virtualNetworkId".into(),
                        value: &virtual_network_id_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "accountId".into(),
                    },
                    register_interface::ResultField {
                        name: "createdAfter".into(),
                    },
                    register_interface::ResultField {
                        name: "hostname".into(),
                    },
                    register_interface::ResultField {
                        name: "hostnameContains".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "ipv4".into(),
                    },
                    register_interface::ResultField {
                        name: "ipv6".into(),
                    },
                    register_interface::ResultField {
                        name: "modifiedAfter".into(),
                    },
                    register_interface::ResultField {
                        name: "targets".into(),
                    },
                    register_interface::ResultField {
                        name: "virtualNetworkId".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetInfrastructureAccessTargetsResult {
                account_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("accountId").unwrap(),
                ),
                created_after: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("createdAfter").unwrap(),
                ),
                hostname: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("hostname").unwrap(),
                ),
                hostname_contains: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("hostnameContains").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                ipv4: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("ipv4").unwrap(),
                ),
                ipv6: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("ipv6").unwrap(),
                ),
                modified_after: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("modifiedAfter").unwrap(),
                ),
                targets: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("targets").unwrap(),
                ),
                virtual_network_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("virtualNetworkId").unwrap(),
                ),
            }
        }
    }
    pub mod get_ip_ranges {
        #[allow(dead_code)]
        pub struct GetIpRangesResult {
            /// The lexically ordered list of only the IPv4 China CIDR blocks.
            pub china_ipv4_cidr_blocks: pulumi_wasm_rust::Output<Vec<String>>,
            /// The lexically ordered list of only the IPv6 China CIDR blocks.
            pub china_ipv6_cidr_blocks: pulumi_wasm_rust::Output<Vec<String>>,
            /// The lexically ordered list of all non-China CIDR blocks.
            pub cidr_blocks: pulumi_wasm_rust::Output<Vec<String>>,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
            /// The lexically ordered list of only the IPv4 CIDR blocks.
            pub ipv4_cidr_blocks: pulumi_wasm_rust::Output<Vec<String>>,
            /// The lexically ordered list of only the IPv6 CIDR blocks.
            pub ipv6_cidr_blocks: pulumi_wasm_rust::Output<Vec<String>>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke() -> GetIpRangesResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getIpRanges:getIpRanges".into(),
                object: Vec::from([]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "chinaIpv4CidrBlocks".into(),
                    },
                    register_interface::ResultField {
                        name: "chinaIpv6CidrBlocks".into(),
                    },
                    register_interface::ResultField {
                        name: "cidrBlocks".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "ipv4CidrBlocks".into(),
                    },
                    register_interface::ResultField {
                        name: "ipv6CidrBlocks".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetIpRangesResult {
                china_ipv4_cidr_blocks: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("chinaIpv4CidrBlocks").unwrap(),
                ),
                china_ipv6_cidr_blocks: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("chinaIpv6CidrBlocks").unwrap(),
                ),
                cidr_blocks: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("cidrBlocks").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                ipv4_cidr_blocks: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("ipv4CidrBlocks").unwrap(),
                ),
                ipv6_cidr_blocks: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("ipv6CidrBlocks").unwrap(),
                ),
            }
        }
    }
    pub mod get_list {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetListArgs {
            /// The account identifier to target for the resource.
            #[builder(into)]
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// The list name to target for the resource.
            #[builder(into)]
            pub name: pulumi_wasm_rust::Output<String>,
        }
        #[allow(dead_code)]
        pub struct GetListResult {
            /// The account identifier to target for the resource.
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// List description.
            pub description: pulumi_wasm_rust::Output<String>,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
            /// List kind.
            pub kind: pulumi_wasm_rust::Output<String>,
            /// The list name to target for the resource.
            pub name: pulumi_wasm_rust::Output<String>,
            /// Number of items in list.
            pub numitems: pulumi_wasm_rust::Output<i32>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(args: GetListArgs) -> GetListResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let account_id_binding = args.account_id.get_inner();
            let name_binding = args.name.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getList:getList".into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "accountId".into(),
                        value: &account_id_binding,
                    },
                    register_interface::ObjectField {
                        name: "name".into(),
                        value: &name_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "accountId".into(),
                    },
                    register_interface::ResultField {
                        name: "description".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "kind".into(),
                    },
                    register_interface::ResultField {
                        name: "name".into(),
                    },
                    register_interface::ResultField {
                        name: "numitems".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetListResult {
                account_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("accountId").unwrap(),
                ),
                description: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("description").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                kind: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("kind").unwrap(),
                ),
                name: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("name").unwrap(),
                ),
                numitems: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("numitems").unwrap(),
                ),
            }
        }
    }
    pub mod get_lists {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetListsArgs {
            /// The account identifier to target for the resource.
            #[builder(into)]
            pub account_id: pulumi_wasm_rust::Output<String>,
        }
        #[allow(dead_code)]
        pub struct GetListsResult {
            /// The account identifier to target for the resource.
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
            pub lists: pulumi_wasm_rust::Output<Vec<super::super::types::GetListsList>>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(args: GetListsArgs) -> GetListsResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let account_id_binding = args.account_id.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getLists:getLists".into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "accountId".into(),
                        value: &account_id_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "accountId".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "lists".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetListsResult {
                account_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("accountId").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                lists: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("lists").unwrap(),
                ),
            }
        }
    }
    pub mod get_load_balancer_pools {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetLoadBalancerPoolsArgs {
            /// The account identifier to target for the datasource lookups.
            #[builder(into)]
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// One or more values used to look up Load Balancer pools. If more than one value is given all values must match in order to be included.
            #[builder(into, default)]
            pub filter: pulumi_wasm_rust::Output<
                Option<super::super::types::GetLoadBalancerPoolsFilter>,
            >,
            /// A list of Load Balancer Pools details.
            #[builder(into, default)]
            pub pools: pulumi_wasm_rust::Output<
                Option<Vec<super::super::types::GetLoadBalancerPoolsPool>>,
            >,
        }
        #[allow(dead_code)]
        pub struct GetLoadBalancerPoolsResult {
            /// The account identifier to target for the datasource lookups.
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// One or more values used to look up Load Balancer pools. If more than one value is given all values must match in order to be included.
            pub filter: pulumi_wasm_rust::Output<
                Option<super::super::types::GetLoadBalancerPoolsFilter>,
            >,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
            /// A list of Load Balancer Pools details.
            pub pools: pulumi_wasm_rust::Output<
                Vec<super::super::types::GetLoadBalancerPoolsPool>,
            >,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(args: GetLoadBalancerPoolsArgs) -> GetLoadBalancerPoolsResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let account_id_binding = args.account_id.get_inner();
            let filter_binding = args.filter.get_inner();
            let pools_binding = args.pools.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getLoadBalancerPools:getLoadBalancerPools"
                    .into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "accountId".into(),
                        value: &account_id_binding,
                    },
                    register_interface::ObjectField {
                        name: "filter".into(),
                        value: &filter_binding,
                    },
                    register_interface::ObjectField {
                        name: "pools".into(),
                        value: &pools_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "accountId".into(),
                    },
                    register_interface::ResultField {
                        name: "filter".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "pools".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetLoadBalancerPoolsResult {
                account_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("accountId").unwrap(),
                ),
                filter: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("filter").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                pools: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("pools").unwrap(),
                ),
            }
        }
    }
    pub mod get_origin_ca_certificate {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetOriginCaCertificateArgs {
            /// The Origin CA Certificate unique identifier.
            #[builder(into)]
            pub id: pulumi_wasm_rust::Output<String>,
        }
        #[allow(dead_code)]
        pub struct GetOriginCaCertificateResult {
            /// The Origin CA certificate.
            pub certificate: pulumi_wasm_rust::Output<String>,
            /// The timestamp when the certificate will expire.
            pub expires_on: pulumi_wasm_rust::Output<String>,
            /// A list of hostnames or wildcard names bound to the certificate.
            pub hostnames: pulumi_wasm_rust::Output<Vec<String>>,
            /// The Origin CA Certificate unique identifier.
            pub id: pulumi_wasm_rust::Output<String>,
            /// The signature type desired on the certificate. Available values: `origin-rsa`, `origin-ecc`, `keyless-certificate`
            pub request_type: pulumi_wasm_rust::Output<String>,
            /// The timestamp when the certificate was revoked.
            pub revoked_at: pulumi_wasm_rust::Output<String>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(args: GetOriginCaCertificateArgs) -> GetOriginCaCertificateResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let id_binding = args.id.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getOriginCaCertificate:getOriginCaCertificate"
                    .into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "id".into(),
                        value: &id_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "certificate".into(),
                    },
                    register_interface::ResultField {
                        name: "expiresOn".into(),
                    },
                    register_interface::ResultField {
                        name: "hostnames".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "requestType".into(),
                    },
                    register_interface::ResultField {
                        name: "revokedAt".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetOriginCaCertificateResult {
                certificate: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("certificate").unwrap(),
                ),
                expires_on: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("expiresOn").unwrap(),
                ),
                hostnames: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("hostnames").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                request_type: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("requestType").unwrap(),
                ),
                revoked_at: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("revokedAt").unwrap(),
                ),
            }
        }
    }
    pub mod get_origin_ca_root_certificate {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetOriginCaRootCertificateArgs {
            /// The name of the algorithm used when creating an Origin CA certificate. Available values: `rsa`, `ecc`.
            #[builder(into)]
            pub algorithm: pulumi_wasm_rust::Output<String>,
        }
        #[allow(dead_code)]
        pub struct GetOriginCaRootCertificateResult {
            /// The name of the algorithm used when creating an Origin CA certificate. Available values: `rsa`, `ecc`.
            pub algorithm: pulumi_wasm_rust::Output<String>,
            /// The Origin CA root certificate in PEM format.
            pub cert_pem: pulumi_wasm_rust::Output<String>,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(
            args: GetOriginCaRootCertificateArgs,
        ) -> GetOriginCaRootCertificateResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let algorithm_binding = args.algorithm.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getOriginCaRootCertificate:getOriginCaRootCertificate"
                    .into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "algorithm".into(),
                        value: &algorithm_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "algorithm".into(),
                    },
                    register_interface::ResultField {
                        name: "certPem".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetOriginCaRootCertificateResult {
                algorithm: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("algorithm").unwrap(),
                ),
                cert_pem: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("certPem").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
            }
        }
    }
    pub mod get_record {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetRecordArgs {
            /// Content to filter record results on.
            #[builder(into, default)]
            pub content: pulumi_wasm_rust::Output<Option<String>>,
            /// Hostname to filter DNS record results on.
            #[builder(into)]
            pub hostname: pulumi_wasm_rust::Output<String>,
            /// DNS priority to filter record results on.
            #[builder(into, default)]
            pub priority: pulumi_wasm_rust::Output<Option<i32>>,
            /// DNS record type to filter record results on. Defaults to `A`.
            #[builder(into, default)]
            pub type_: pulumi_wasm_rust::Output<Option<String>>,
            /// The zone identifier to target for the resource.
            #[builder(into)]
            pub zone_id: pulumi_wasm_rust::Output<String>,
        }
        #[allow(dead_code)]
        pub struct GetRecordResult {
            /// Content to filter record results on.
            pub content: pulumi_wasm_rust::Output<Option<String>>,
            /// Hostname to filter DNS record results on.
            pub hostname: pulumi_wasm_rust::Output<String>,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
            /// DNS priority to filter record results on.
            pub priority: pulumi_wasm_rust::Output<Option<i32>>,
            /// Proxiable status of the found DNS record.
            pub proxiable: pulumi_wasm_rust::Output<bool>,
            /// Proxied status of the found DNS record.
            pub proxied: pulumi_wasm_rust::Output<bool>,
            /// TTL of the found DNS record.
            pub ttl: pulumi_wasm_rust::Output<i32>,
            /// DNS record type to filter record results on. Defaults to `A`.
            pub type_: pulumi_wasm_rust::Output<Option<String>>,
            /// Value of the found DNS record.
            pub value: pulumi_wasm_rust::Output<String>,
            /// The zone identifier to target for the resource.
            pub zone_id: pulumi_wasm_rust::Output<String>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(args: GetRecordArgs) -> GetRecordResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let content_binding = args.content.get_inner();
            let hostname_binding = args.hostname.get_inner();
            let priority_binding = args.priority.get_inner();
            let type__binding = args.type_.get_inner();
            let zone_id_binding = args.zone_id.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getRecord:getRecord".into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "content".into(),
                        value: &content_binding,
                    },
                    register_interface::ObjectField {
                        name: "hostname".into(),
                        value: &hostname_binding,
                    },
                    register_interface::ObjectField {
                        name: "priority".into(),
                        value: &priority_binding,
                    },
                    register_interface::ObjectField {
                        name: "type".into(),
                        value: &type__binding,
                    },
                    register_interface::ObjectField {
                        name: "zoneId".into(),
                        value: &zone_id_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "content".into(),
                    },
                    register_interface::ResultField {
                        name: "hostname".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "priority".into(),
                    },
                    register_interface::ResultField {
                        name: "proxiable".into(),
                    },
                    register_interface::ResultField {
                        name: "proxied".into(),
                    },
                    register_interface::ResultField {
                        name: "ttl".into(),
                    },
                    register_interface::ResultField {
                        name: "type".into(),
                    },
                    register_interface::ResultField {
                        name: "value".into(),
                    },
                    register_interface::ResultField {
                        name: "zoneId".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetRecordResult {
                content: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("content").unwrap(),
                ),
                hostname: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("hostname").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                priority: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("priority").unwrap(),
                ),
                proxiable: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("proxiable").unwrap(),
                ),
                proxied: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("proxied").unwrap(),
                ),
                ttl: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("ttl").unwrap(),
                ),
                type_: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("type").unwrap(),
                ),
                value: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("value").unwrap(),
                ),
                zone_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("zoneId").unwrap(),
                ),
            }
        }
    }
    pub mod get_rulesets {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetRulesetsArgs {
            /// The account identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.
            #[builder(into, default)]
            pub account_id: pulumi_wasm_rust::Output<Option<String>>,
            #[builder(into, default)]
            pub filter: pulumi_wasm_rust::Output<
                Option<super::super::types::GetRulesetsFilter>,
            >,
            /// Include rule data in response.
            #[builder(into, default)]
            pub include_rules: pulumi_wasm_rust::Output<Option<bool>>,
            /// The zone identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.
            #[builder(into, default)]
            pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
        }
        #[allow(dead_code)]
        pub struct GetRulesetsResult {
            /// The account identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.
            pub account_id: pulumi_wasm_rust::Output<Option<String>>,
            pub filter: pulumi_wasm_rust::Output<
                Option<super::super::types::GetRulesetsFilter>,
            >,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
            /// Include rule data in response.
            pub include_rules: pulumi_wasm_rust::Output<Option<bool>>,
            pub rulesets: pulumi_wasm_rust::Output<
                Vec<super::super::types::GetRulesetsRuleset>,
            >,
            /// The zone identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.
            pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(args: GetRulesetsArgs) -> GetRulesetsResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let account_id_binding = args.account_id.get_inner();
            let filter_binding = args.filter.get_inner();
            let include_rules_binding = args.include_rules.get_inner();
            let zone_id_binding = args.zone_id.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getRulesets:getRulesets".into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "accountId".into(),
                        value: &account_id_binding,
                    },
                    register_interface::ObjectField {
                        name: "filter".into(),
                        value: &filter_binding,
                    },
                    register_interface::ObjectField {
                        name: "includeRules".into(),
                        value: &include_rules_binding,
                    },
                    register_interface::ObjectField {
                        name: "zoneId".into(),
                        value: &zone_id_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "accountId".into(),
                    },
                    register_interface::ResultField {
                        name: "filter".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "includeRules".into(),
                    },
                    register_interface::ResultField {
                        name: "rulesets".into(),
                    },
                    register_interface::ResultField {
                        name: "zoneId".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetRulesetsResult {
                account_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("accountId").unwrap(),
                ),
                filter: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("filter").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                include_rules: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("includeRules").unwrap(),
                ),
                rulesets: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("rulesets").unwrap(),
                ),
                zone_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("zoneId").unwrap(),
                ),
            }
        }
    }
    pub mod get_tunnel {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetTunnelArgs {
            /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
            #[builder(into)]
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// If true, only include deleted tunnels. If false, exclude deleted tunnels. If empty, all tunnels will be included. **Modifying this attribute will force creation of a new resource.**
            #[builder(into, default)]
            pub is_deleted: pulumi_wasm_rust::Output<Option<bool>>,
            /// Name of the tunnel. **Modifying this attribute will force creation of a new resource.**
            #[builder(into)]
            pub name: pulumi_wasm_rust::Output<String>,
        }
        #[allow(dead_code)]
        pub struct GetTunnelResult {
            /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// ID of the tunnel.
            pub id: pulumi_wasm_rust::Output<String>,
            /// If true, only include deleted tunnels. If false, exclude deleted tunnels. If empty, all tunnels will be included. **Modifying this attribute will force creation of a new resource.**
            pub is_deleted: pulumi_wasm_rust::Output<Option<bool>>,
            /// Name of the tunnel. **Modifying this attribute will force creation of a new resource.**
            pub name: pulumi_wasm_rust::Output<String>,
            /// Whether the tunnel can be configured remotely from the Zero Trust dashboard.
            pub remote_config: pulumi_wasm_rust::Output<bool>,
            /// The status of the tunnel. Available values: `inactive`, `degraded`, `healthy`, `down`.
            pub status: pulumi_wasm_rust::Output<String>,
            /// The type of the tunnel. Available values: `cfd_tunnel`, `warp_connector`.
            pub tunnel_type: pulumi_wasm_rust::Output<String>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(args: GetTunnelArgs) -> GetTunnelResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let account_id_binding = args.account_id.get_inner();
            let is_deleted_binding = args.is_deleted.get_inner();
            let name_binding = args.name.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getTunnel:getTunnel".into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "accountId".into(),
                        value: &account_id_binding,
                    },
                    register_interface::ObjectField {
                        name: "isDeleted".into(),
                        value: &is_deleted_binding,
                    },
                    register_interface::ObjectField {
                        name: "name".into(),
                        value: &name_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "accountId".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "isDeleted".into(),
                    },
                    register_interface::ResultField {
                        name: "name".into(),
                    },
                    register_interface::ResultField {
                        name: "remoteConfig".into(),
                    },
                    register_interface::ResultField {
                        name: "status".into(),
                    },
                    register_interface::ResultField {
                        name: "tunnelType".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetTunnelResult {
                account_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("accountId").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                is_deleted: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("isDeleted").unwrap(),
                ),
                name: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("name").unwrap(),
                ),
                remote_config: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("remoteConfig").unwrap(),
                ),
                status: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("status").unwrap(),
                ),
                tunnel_type: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("tunnelType").unwrap(),
                ),
            }
        }
    }
    pub mod get_tunnel_virtual_network {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetTunnelVirtualNetworkArgs {
            /// The account identifier to target for the resource.
            #[builder(into)]
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// The Virtual Network Name.
            #[builder(into)]
            pub name: pulumi_wasm_rust::Output<String>,
        }
        #[allow(dead_code)]
        pub struct GetTunnelVirtualNetworkResult {
            /// The account identifier to target for the resource.
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// The Virtual Network Comment.
            pub comment: pulumi_wasm_rust::Output<String>,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
            /// If true, only include deleted virtual networks. If false, exclude deleted virtual networks. If empty, all virtual networks will be included.
            pub is_default: pulumi_wasm_rust::Output<bool>,
            /// The Virtual Network Name.
            pub name: pulumi_wasm_rust::Output<String>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(
            args: GetTunnelVirtualNetworkArgs,
        ) -> GetTunnelVirtualNetworkResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let account_id_binding = args.account_id.get_inner();
            let name_binding = args.name.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getTunnelVirtualNetwork:getTunnelVirtualNetwork"
                    .into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "accountId".into(),
                        value: &account_id_binding,
                    },
                    register_interface::ObjectField {
                        name: "name".into(),
                        value: &name_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "accountId".into(),
                    },
                    register_interface::ResultField {
                        name: "comment".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "isDefault".into(),
                    },
                    register_interface::ResultField {
                        name: "name".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetTunnelVirtualNetworkResult {
                account_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("accountId").unwrap(),
                ),
                comment: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("comment").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                is_default: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("isDefault").unwrap(),
                ),
                name: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("name").unwrap(),
                ),
            }
        }
    }
    pub mod get_user {
        #[allow(dead_code)]
        pub struct GetUserResult {
            /// The user's email address.
            pub email: pulumi_wasm_rust::Output<String>,
            /// The user's unique identifier.
            pub id: pulumi_wasm_rust::Output<String>,
            /// The user's username.
            pub username: pulumi_wasm_rust::Output<String>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke() -> GetUserResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getUser:getUser".into(),
                object: Vec::from([]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "email".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "username".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetUserResult {
                email: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("email").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                username: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("username").unwrap(),
                ),
            }
        }
    }
    pub mod get_zero_trust_access_application {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetZeroTrustAccessApplicationArgs {
            /// The account identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.
            #[builder(into, default)]
            pub account_id: pulumi_wasm_rust::Output<Option<String>>,
            /// The primary hostname and path that Access will secure. Must provide only one of `name`, `domain`.
            #[builder(into, default)]
            pub domain: pulumi_wasm_rust::Output<Option<String>>,
            /// Friendly name of the Access Application. Must provide only one of `name`, `domain`.
            #[builder(into, default)]
            pub name: pulumi_wasm_rust::Output<Option<String>>,
            /// The zone identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.
            #[builder(into, default)]
            pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
        }
        #[allow(dead_code)]
        pub struct GetZeroTrustAccessApplicationResult {
            /// The account identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.
            pub account_id: pulumi_wasm_rust::Output<Option<String>>,
            /// Application Audience (AUD) Tag of the application.
            pub aud: pulumi_wasm_rust::Output<String>,
            /// The primary hostname and path that Access will secure. Must provide only one of `name`, `domain`.
            pub domain: pulumi_wasm_rust::Output<String>,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
            /// Friendly name of the Access Application. Must provide only one of `name`, `domain`.
            pub name: pulumi_wasm_rust::Output<String>,
            /// The zone identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.
            pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(
            args: GetZeroTrustAccessApplicationArgs,
        ) -> GetZeroTrustAccessApplicationResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let account_id_binding = args.account_id.get_inner();
            let domain_binding = args.domain.get_inner();
            let name_binding = args.name.get_inner();
            let zone_id_binding = args.zone_id.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getZeroTrustAccessApplication:getZeroTrustAccessApplication"
                    .into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "accountId".into(),
                        value: &account_id_binding,
                    },
                    register_interface::ObjectField {
                        name: "domain".into(),
                        value: &domain_binding,
                    },
                    register_interface::ObjectField {
                        name: "name".into(),
                        value: &name_binding,
                    },
                    register_interface::ObjectField {
                        name: "zoneId".into(),
                        value: &zone_id_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "accountId".into(),
                    },
                    register_interface::ResultField {
                        name: "aud".into(),
                    },
                    register_interface::ResultField {
                        name: "domain".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "name".into(),
                    },
                    register_interface::ResultField {
                        name: "zoneId".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetZeroTrustAccessApplicationResult {
                account_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("accountId").unwrap(),
                ),
                aud: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("aud").unwrap(),
                ),
                domain: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("domain").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                name: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("name").unwrap(),
                ),
                zone_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("zoneId").unwrap(),
                ),
            }
        }
    }
    pub mod get_zero_trust_access_identity_provider {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetZeroTrustAccessIdentityProviderArgs {
            /// The account identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.
            #[builder(into, default)]
            pub account_id: pulumi_wasm_rust::Output<Option<String>>,
            /// Access Identity Provider name to search for.
            #[builder(into)]
            pub name: pulumi_wasm_rust::Output<String>,
            /// The zone identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.
            #[builder(into, default)]
            pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
        }
        #[allow(dead_code)]
        pub struct GetZeroTrustAccessIdentityProviderResult {
            /// The account identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.
            pub account_id: pulumi_wasm_rust::Output<Option<String>>,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
            /// Access Identity Provider name to search for.
            pub name: pulumi_wasm_rust::Output<String>,
            /// Access Identity Provider Type.
            pub type_: pulumi_wasm_rust::Output<String>,
            /// The zone identifier to target for the resource. Must provide only one of `zone_id`, `account_id`.
            pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(
            args: GetZeroTrustAccessIdentityProviderArgs,
        ) -> GetZeroTrustAccessIdentityProviderResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let account_id_binding = args.account_id.get_inner();
            let name_binding = args.name.get_inner();
            let zone_id_binding = args.zone_id.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getZeroTrustAccessIdentityProvider:getZeroTrustAccessIdentityProvider"
                    .into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "accountId".into(),
                        value: &account_id_binding,
                    },
                    register_interface::ObjectField {
                        name: "name".into(),
                        value: &name_binding,
                    },
                    register_interface::ObjectField {
                        name: "zoneId".into(),
                        value: &zone_id_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "accountId".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "name".into(),
                    },
                    register_interface::ResultField {
                        name: "type".into(),
                    },
                    register_interface::ResultField {
                        name: "zoneId".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetZeroTrustAccessIdentityProviderResult {
                account_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("accountId").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                name: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("name").unwrap(),
                ),
                type_: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("type").unwrap(),
                ),
                zone_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("zoneId").unwrap(),
                ),
            }
        }
    }
    pub mod get_zero_trust_infrastructure_access_targets {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetZeroTrustInfrastructureAccessTargetsArgs {
            /// The account identifier to target for the resource.
            #[builder(into)]
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// A date and time after a target was created to filter on.
            #[builder(into, default)]
            pub created_after: pulumi_wasm_rust::Output<Option<String>>,
            /// The hostname of the target.
            #[builder(into, default)]
            pub hostname: pulumi_wasm_rust::Output<Option<String>>,
            /// Partial match to the hostname of a target
            #[builder(into, default)]
            pub hostname_contains: pulumi_wasm_rust::Output<Option<String>>,
            /// The target's IPv4 address.
            #[builder(into, default)]
            pub ipv4: pulumi_wasm_rust::Output<Option<String>>,
            /// The target's IPv6 address.
            #[builder(into, default)]
            pub ipv6: pulumi_wasm_rust::Output<Option<String>>,
            /// A date and time after a target was modified to filter on.
            #[builder(into, default)]
            pub modified_after: pulumi_wasm_rust::Output<Option<String>>,
            /// The private virtual network identifier for the target.
            #[builder(into, default)]
            pub virtual_network_id: pulumi_wasm_rust::Output<Option<String>>,
        }
        #[allow(dead_code)]
        pub struct GetZeroTrustInfrastructureAccessTargetsResult {
            /// The account identifier to target for the resource.
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// A date and time after a target was created to filter on.
            pub created_after: pulumi_wasm_rust::Output<Option<String>>,
            /// The hostname of the target.
            pub hostname: pulumi_wasm_rust::Output<Option<String>>,
            /// Partial match to the hostname of a target
            pub hostname_contains: pulumi_wasm_rust::Output<Option<String>>,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
            /// The target's IPv4 address.
            pub ipv4: pulumi_wasm_rust::Output<Option<String>>,
            /// The target's IPv6 address.
            pub ipv6: pulumi_wasm_rust::Output<Option<String>>,
            /// A date and time after a target was modified to filter on.
            pub modified_after: pulumi_wasm_rust::Output<Option<String>>,
            pub targets: pulumi_wasm_rust::Output<
                Vec<super::super::types::GetZeroTrustInfrastructureAccessTargetsTarget>,
            >,
            /// The private virtual network identifier for the target.
            pub virtual_network_id: pulumi_wasm_rust::Output<Option<String>>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(
            args: GetZeroTrustInfrastructureAccessTargetsArgs,
        ) -> GetZeroTrustInfrastructureAccessTargetsResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let account_id_binding = args.account_id.get_inner();
            let created_after_binding = args.created_after.get_inner();
            let hostname_binding = args.hostname.get_inner();
            let hostname_contains_binding = args.hostname_contains.get_inner();
            let ipv4_binding = args.ipv4.get_inner();
            let ipv6_binding = args.ipv6.get_inner();
            let modified_after_binding = args.modified_after.get_inner();
            let virtual_network_id_binding = args.virtual_network_id.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getZeroTrustInfrastructureAccessTargets:getZeroTrustInfrastructureAccessTargets"
                    .into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "accountId".into(),
                        value: &account_id_binding,
                    },
                    register_interface::ObjectField {
                        name: "createdAfter".into(),
                        value: &created_after_binding,
                    },
                    register_interface::ObjectField {
                        name: "hostname".into(),
                        value: &hostname_binding,
                    },
                    register_interface::ObjectField {
                        name: "hostnameContains".into(),
                        value: &hostname_contains_binding,
                    },
                    register_interface::ObjectField {
                        name: "ipv4".into(),
                        value: &ipv4_binding,
                    },
                    register_interface::ObjectField {
                        name: "ipv6".into(),
                        value: &ipv6_binding,
                    },
                    register_interface::ObjectField {
                        name: "modifiedAfter".into(),
                        value: &modified_after_binding,
                    },
                    register_interface::ObjectField {
                        name: "virtualNetworkId".into(),
                        value: &virtual_network_id_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "accountId".into(),
                    },
                    register_interface::ResultField {
                        name: "createdAfter".into(),
                    },
                    register_interface::ResultField {
                        name: "hostname".into(),
                    },
                    register_interface::ResultField {
                        name: "hostnameContains".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "ipv4".into(),
                    },
                    register_interface::ResultField {
                        name: "ipv6".into(),
                    },
                    register_interface::ResultField {
                        name: "modifiedAfter".into(),
                    },
                    register_interface::ResultField {
                        name: "targets".into(),
                    },
                    register_interface::ResultField {
                        name: "virtualNetworkId".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetZeroTrustInfrastructureAccessTargetsResult {
                account_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("accountId").unwrap(),
                ),
                created_after: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("createdAfter").unwrap(),
                ),
                hostname: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("hostname").unwrap(),
                ),
                hostname_contains: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("hostnameContains").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                ipv4: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("ipv4").unwrap(),
                ),
                ipv6: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("ipv6").unwrap(),
                ),
                modified_after: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("modifiedAfter").unwrap(),
                ),
                targets: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("targets").unwrap(),
                ),
                virtual_network_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("virtualNetworkId").unwrap(),
                ),
            }
        }
    }
    pub mod get_zero_trust_tunnel_cloudflared {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetZeroTrustTunnelCloudflaredArgs {
            /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
            #[builder(into)]
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// If true, only include deleted tunnels. If false, exclude deleted tunnels. If empty, all tunnels will be included. **Modifying this attribute will force creation of a new resource.**
            #[builder(into, default)]
            pub is_deleted: pulumi_wasm_rust::Output<Option<bool>>,
            /// Name of the tunnel. **Modifying this attribute will force creation of a new resource.**
            #[builder(into)]
            pub name: pulumi_wasm_rust::Output<String>,
        }
        #[allow(dead_code)]
        pub struct GetZeroTrustTunnelCloudflaredResult {
            /// The account identifier to target for the resource. **Modifying this attribute will force creation of a new resource.**
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// ID of the tunnel.
            pub id: pulumi_wasm_rust::Output<String>,
            /// If true, only include deleted tunnels. If false, exclude deleted tunnels. If empty, all tunnels will be included. **Modifying this attribute will force creation of a new resource.**
            pub is_deleted: pulumi_wasm_rust::Output<Option<bool>>,
            /// Name of the tunnel. **Modifying this attribute will force creation of a new resource.**
            pub name: pulumi_wasm_rust::Output<String>,
            /// Whether the tunnel can be configured remotely from the Zero Trust dashboard.
            pub remote_config: pulumi_wasm_rust::Output<bool>,
            /// The status of the tunnel. Available values: `inactive`, `degraded`, `healthy`, `down`.
            pub status: pulumi_wasm_rust::Output<String>,
            /// The type of the tunnel. Available values: `cfd_tunnel`, `warp_connector`.
            pub tunnel_type: pulumi_wasm_rust::Output<String>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(
            args: GetZeroTrustTunnelCloudflaredArgs,
        ) -> GetZeroTrustTunnelCloudflaredResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let account_id_binding = args.account_id.get_inner();
            let is_deleted_binding = args.is_deleted.get_inner();
            let name_binding = args.name.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getZeroTrustTunnelCloudflared:getZeroTrustTunnelCloudflared"
                    .into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "accountId".into(),
                        value: &account_id_binding,
                    },
                    register_interface::ObjectField {
                        name: "isDeleted".into(),
                        value: &is_deleted_binding,
                    },
                    register_interface::ObjectField {
                        name: "name".into(),
                        value: &name_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "accountId".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "isDeleted".into(),
                    },
                    register_interface::ResultField {
                        name: "name".into(),
                    },
                    register_interface::ResultField {
                        name: "remoteConfig".into(),
                    },
                    register_interface::ResultField {
                        name: "status".into(),
                    },
                    register_interface::ResultField {
                        name: "tunnelType".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetZeroTrustTunnelCloudflaredResult {
                account_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("accountId").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                is_deleted: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("isDeleted").unwrap(),
                ),
                name: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("name").unwrap(),
                ),
                remote_config: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("remoteConfig").unwrap(),
                ),
                status: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("status").unwrap(),
                ),
                tunnel_type: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("tunnelType").unwrap(),
                ),
            }
        }
    }
    pub mod get_zero_trust_tunnel_virtual_network {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetZeroTrustTunnelVirtualNetworkArgs {
            /// The account identifier to target for the resource.
            #[builder(into)]
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// The Virtual Network Name.
            #[builder(into)]
            pub name: pulumi_wasm_rust::Output<String>,
        }
        #[allow(dead_code)]
        pub struct GetZeroTrustTunnelVirtualNetworkResult {
            /// The account identifier to target for the resource.
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// The Virtual Network Comment.
            pub comment: pulumi_wasm_rust::Output<String>,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
            /// If true, only include deleted virtual networks. If false, exclude deleted virtual networks. If empty, all virtual networks will be included.
            pub is_default: pulumi_wasm_rust::Output<bool>,
            /// The Virtual Network Name.
            pub name: pulumi_wasm_rust::Output<String>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(
            args: GetZeroTrustTunnelVirtualNetworkArgs,
        ) -> GetZeroTrustTunnelVirtualNetworkResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let account_id_binding = args.account_id.get_inner();
            let name_binding = args.name.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getZeroTrustTunnelVirtualNetwork:getZeroTrustTunnelVirtualNetwork"
                    .into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "accountId".into(),
                        value: &account_id_binding,
                    },
                    register_interface::ObjectField {
                        name: "name".into(),
                        value: &name_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "accountId".into(),
                    },
                    register_interface::ResultField {
                        name: "comment".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "isDefault".into(),
                    },
                    register_interface::ResultField {
                        name: "name".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetZeroTrustTunnelVirtualNetworkResult {
                account_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("accountId").unwrap(),
                ),
                comment: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("comment").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                is_default: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("isDefault").unwrap(),
                ),
                name: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("name").unwrap(),
                ),
            }
        }
    }
    pub mod get_zone {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetZoneArgs {
            /// The account identifier to target for the resource.
            #[builder(into, default)]
            pub account_id: pulumi_wasm_rust::Output<Option<String>>,
            /// The name of the zone. Must provide only one of `zone_id`, `name`.
            #[builder(into, default)]
            pub name: pulumi_wasm_rust::Output<Option<String>>,
            /// The zone identifier to target for the resource. Must provide only one of `zone_id`, `name`.
            #[builder(into, default)]
            pub zone_id: pulumi_wasm_rust::Output<Option<String>>,
        }
        #[allow(dead_code)]
        pub struct GetZoneResult {
            /// The account identifier to target for the resource.
            pub account_id: pulumi_wasm_rust::Output<String>,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
            /// The name of the zone. Must provide only one of `zone_id`, `name`.
            pub name: pulumi_wasm_rust::Output<String>,
            /// Cloudflare assigned name servers. This is only populated for zones that use Cloudflare DNS.
            pub name_servers: pulumi_wasm_rust::Output<Vec<String>>,
            /// Whether the zone is paused on Cloudflare.
            pub paused: pulumi_wasm_rust::Output<bool>,
            /// The name of the plan associated with the zone.
            pub plan: pulumi_wasm_rust::Output<String>,
            /// Status of the zone.
            pub status: pulumi_wasm_rust::Output<String>,
            /// List of Vanity Nameservers (if set).
            pub vanity_name_servers: pulumi_wasm_rust::Output<Vec<String>>,
            /// The zone identifier to target for the resource. Must provide only one of `zone_id`, `name`.
            pub zone_id: pulumi_wasm_rust::Output<String>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(args: GetZoneArgs) -> GetZoneResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let account_id_binding = args.account_id.get_inner();
            let name_binding = args.name.get_inner();
            let zone_id_binding = args.zone_id.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getZone:getZone".into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "accountId".into(),
                        value: &account_id_binding,
                    },
                    register_interface::ObjectField {
                        name: "name".into(),
                        value: &name_binding,
                    },
                    register_interface::ObjectField {
                        name: "zoneId".into(),
                        value: &zone_id_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "accountId".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "name".into(),
                    },
                    register_interface::ResultField {
                        name: "nameServers".into(),
                    },
                    register_interface::ResultField {
                        name: "paused".into(),
                    },
                    register_interface::ResultField {
                        name: "plan".into(),
                    },
                    register_interface::ResultField {
                        name: "status".into(),
                    },
                    register_interface::ResultField {
                        name: "vanityNameServers".into(),
                    },
                    register_interface::ResultField {
                        name: "zoneId".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetZoneResult {
                account_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("accountId").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                name: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("name").unwrap(),
                ),
                name_servers: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("nameServers").unwrap(),
                ),
                paused: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("paused").unwrap(),
                ),
                plan: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("plan").unwrap(),
                ),
                status: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("status").unwrap(),
                ),
                vanity_name_servers: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("vanityNameServers").unwrap(),
                ),
                zone_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("zoneId").unwrap(),
                ),
            }
        }
    }
    pub mod get_zone_cache_reserve {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetZoneCacheReserveArgs {
            /// The zone identifier to target for the resource.
            #[builder(into)]
            pub zone_id: pulumi_wasm_rust::Output<String>,
        }
        #[allow(dead_code)]
        pub struct GetZoneCacheReserveResult {
            /// The status of Cache Reserve support.
            pub enabled: pulumi_wasm_rust::Output<bool>,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
            /// The zone identifier to target for the resource.
            pub zone_id: pulumi_wasm_rust::Output<String>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(args: GetZoneCacheReserveArgs) -> GetZoneCacheReserveResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let zone_id_binding = args.zone_id.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getZoneCacheReserve:getZoneCacheReserve".into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "zoneId".into(),
                        value: &zone_id_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "enabled".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "zoneId".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetZoneCacheReserveResult {
                enabled: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("enabled").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                zone_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("zoneId").unwrap(),
                ),
            }
        }
    }
    pub mod get_zone_dnssec {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetZoneDnssecArgs {
            /// The zone identifier to target for the resource.
            #[builder(into)]
            pub zone_id: pulumi_wasm_rust::Output<String>,
        }
        #[allow(dead_code)]
        pub struct GetZoneDnssecResult {
            /// Zone DNSSEC algorithm.
            pub algorithm: pulumi_wasm_rust::Output<String>,
            /// Zone DNSSEC digest.
            pub digest: pulumi_wasm_rust::Output<String>,
            /// Digest algorithm use for Zone DNSSEC.
            pub digest_algorithm: pulumi_wasm_rust::Output<String>,
            /// Digest Type for Zone DNSSEC.
            pub digest_type: pulumi_wasm_rust::Output<String>,
            /// DS for the Zone DNSSEC.
            pub ds: pulumi_wasm_rust::Output<String>,
            /// Zone DNSSEC flags.
            pub flags: pulumi_wasm_rust::Output<i32>,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
            /// Key Tag for the Zone DNSSEC.
            pub key_tag: pulumi_wasm_rust::Output<i32>,
            /// Key type used for Zone DNSSEC.
            pub key_type: pulumi_wasm_rust::Output<String>,
            /// Public Key for the Zone DNSSEC.
            pub public_key: pulumi_wasm_rust::Output<String>,
            /// The status of the Zone DNSSEC.
            pub status: pulumi_wasm_rust::Output<String>,
            /// The zone identifier to target for the resource.
            pub zone_id: pulumi_wasm_rust::Output<String>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(args: GetZoneDnssecArgs) -> GetZoneDnssecResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let zone_id_binding = args.zone_id.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getZoneDnssec:getZoneDnssec".into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "zoneId".into(),
                        value: &zone_id_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "algorithm".into(),
                    },
                    register_interface::ResultField {
                        name: "digest".into(),
                    },
                    register_interface::ResultField {
                        name: "digestAlgorithm".into(),
                    },
                    register_interface::ResultField {
                        name: "digestType".into(),
                    },
                    register_interface::ResultField {
                        name: "ds".into(),
                    },
                    register_interface::ResultField {
                        name: "flags".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "keyTag".into(),
                    },
                    register_interface::ResultField {
                        name: "keyType".into(),
                    },
                    register_interface::ResultField {
                        name: "publicKey".into(),
                    },
                    register_interface::ResultField {
                        name: "status".into(),
                    },
                    register_interface::ResultField {
                        name: "zoneId".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetZoneDnssecResult {
                algorithm: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("algorithm").unwrap(),
                ),
                digest: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("digest").unwrap(),
                ),
                digest_algorithm: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("digestAlgorithm").unwrap(),
                ),
                digest_type: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("digestType").unwrap(),
                ),
                ds: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("ds").unwrap(),
                ),
                flags: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("flags").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                key_tag: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("keyTag").unwrap(),
                ),
                key_type: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("keyType").unwrap(),
                ),
                public_key: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("publicKey").unwrap(),
                ),
                status: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("status").unwrap(),
                ),
                zone_id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("zoneId").unwrap(),
                ),
            }
        }
    }
    pub mod get_zones {
        #[derive(pulumi_wasm_rust::__private::bon::Builder, Clone)]
        #[builder(finish_fn = build_struct)]
        #[allow(dead_code)]
        pub struct GetZonesArgs {
            /// One or more values used to look up zone records. If more than one value is given all values must match in order to be included.
            #[builder(into)]
            pub filter: pulumi_wasm_rust::Output<super::super::types::GetZonesFilter>,
        }
        #[allow(dead_code)]
        pub struct GetZonesResult {
            /// One or more values used to look up zone records. If more than one value is given all values must match in order to be included.
            pub filter: pulumi_wasm_rust::Output<super::super::types::GetZonesFilter>,
            /// The provider-assigned unique ID for this managed resource.
            pub id: pulumi_wasm_rust::Output<String>,
            /// A list of zone objects.
            pub zones: pulumi_wasm_rust::Output<Vec<super::super::types::GetZonesZone>>,
        }
        ///
        /// Registers a new resource with the given unique name and arguments
        ///
        #[allow(non_snake_case, unused_imports, dead_code)]
        pub fn invoke(args: GetZonesArgs) -> GetZonesResult {
            use pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::register_interface;
            use std::collections::HashMap;
            let filter_binding = args.filter.get_inner();
            let request = register_interface::ResourceInvokeRequest {
                token: "cloudflare:index/getZones:getZones".into(),
                object: Vec::from([
                    register_interface::ObjectField {
                        name: "filter".into(),
                        value: &filter_binding,
                    },
                ]),
                results: Vec::from([
                    register_interface::ResultField {
                        name: "filter".into(),
                    },
                    register_interface::ResultField {
                        name: "id".into(),
                    },
                    register_interface::ResultField {
                        name: "zones".into(),
                    },
                ]),
            };
            let o = register_interface::invoke(&request);
            let mut hashmap: HashMap<String, _> = o
                .fields
                .into_iter()
                .map(|f| (f.name, f.output))
                .collect();
            GetZonesResult {
                filter: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("filter").unwrap(),
                ),
                id: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("id").unwrap(),
                ),
                zones: pulumi_wasm_rust::__private::into_domain(
                    hashmap.remove("zones").unwrap(),
                ),
            }
        }
    }
}
pub mod types {
    include!("types/access_application_cors_header.rs");
    include!("types/access_application_footer_link.rs");
    include!("types/access_application_landing_page_design.rs");
    include!("types/access_application_saas_app.rs");
    include!("types/access_application_saas_app_custom_attribute.rs");
    include!("types/access_application_saas_app_custom_attribute_source.rs");
    include!("types/access_application_saas_app_custom_claim.rs");
    include!("types/access_application_saas_app_custom_claim_source.rs");
    include!("types/access_application_saas_app_hybrid_and_implicit_options.rs");
    include!("types/access_application_saas_app_refresh_token_option.rs");
    include!("types/access_application_scim_config.rs");
    include!("types/access_application_scim_config_authentication.rs");
    include!("types/access_application_scim_config_mapping.rs");
    include!("types/access_application_scim_config_mapping_operations.rs");
    include!("types/access_application_target_criteria.rs");
    include!("types/access_application_target_criteria_target_attribute.rs");
    include!("types/access_group_exclude.rs");
    include!("types/access_group_exclude_auth_context.rs");
    include!("types/access_group_exclude_azure.rs");
    include!("types/access_group_exclude_external_evaluation.rs");
    include!("types/access_group_exclude_github.rs");
    include!("types/access_group_exclude_gsuite.rs");
    include!("types/access_group_exclude_okta.rs");
    include!("types/access_group_exclude_saml.rs");
    include!("types/access_group_include.rs");
    include!("types/access_group_include_auth_context.rs");
    include!("types/access_group_include_azure.rs");
    include!("types/access_group_include_external_evaluation.rs");
    include!("types/access_group_include_github.rs");
    include!("types/access_group_include_gsuite.rs");
    include!("types/access_group_include_okta.rs");
    include!("types/access_group_include_saml.rs");
    include!("types/access_group_require.rs");
    include!("types/access_group_require_auth_context.rs");
    include!("types/access_group_require_azure.rs");
    include!("types/access_group_require_external_evaluation.rs");
    include!("types/access_group_require_github.rs");
    include!("types/access_group_require_gsuite.rs");
    include!("types/access_group_require_okta.rs");
    include!("types/access_group_require_saml.rs");
    include!("types/access_identity_provider_config.rs");
    include!("types/access_identity_provider_scim_config.rs");
    include!("types/access_mutual_tls_hostname_settings_setting.rs");
    include!("types/access_organization_custom_page.rs");
    include!("types/access_organization_login_design.rs");
    include!("types/access_policy_approval_group.rs");
    include!("types/access_policy_connection_rules.rs");
    include!("types/access_policy_connection_rules_ssh.rs");
    include!("types/access_policy_exclude.rs");
    include!("types/access_policy_exclude_auth_context.rs");
    include!("types/access_policy_exclude_azure.rs");
    include!("types/access_policy_exclude_external_evaluation.rs");
    include!("types/access_policy_exclude_github.rs");
    include!("types/access_policy_exclude_gsuite.rs");
    include!("types/access_policy_exclude_okta.rs");
    include!("types/access_policy_exclude_saml.rs");
    include!("types/access_policy_include.rs");
    include!("types/access_policy_include_auth_context.rs");
    include!("types/access_policy_include_azure.rs");
    include!("types/access_policy_include_external_evaluation.rs");
    include!("types/access_policy_include_github.rs");
    include!("types/access_policy_include_gsuite.rs");
    include!("types/access_policy_include_okta.rs");
    include!("types/access_policy_include_saml.rs");
    include!("types/access_policy_require.rs");
    include!("types/access_policy_require_auth_context.rs");
    include!("types/access_policy_require_azure.rs");
    include!("types/access_policy_require_external_evaluation.rs");
    include!("types/access_policy_require_github.rs");
    include!("types/access_policy_require_gsuite.rs");
    include!("types/access_policy_require_okta.rs");
    include!("types/access_policy_require_saml.rs");
    include!("types/access_rule_configuration.rs");
    include!("types/address_map_ip.rs");
    include!("types/address_map_membership.rs");
    include!("types/api_shield_auth_id_characteristic.rs");
    include!("types/api_token_condition.rs");
    include!("types/api_token_condition_request_ip.rs");
    include!("types/api_token_policy.rs");
    include!("types/certificate_pack_validation_error.rs");
    include!("types/certificate_pack_validation_record.rs");
    include!("types/cloud_connector_rules_rule.rs");
    include!("types/cloud_connector_rules_rule_parameters.rs");
    include!("types/custom_hostname_ssl.rs");
    include!("types/custom_hostname_ssl_setting.rs");
    include!("types/custom_hostname_ssl_validation_error.rs");
    include!("types/custom_hostname_ssl_validation_record.rs");
    include!("types/custom_ssl_custom_ssl_options.rs");
    include!("types/custom_ssl_custom_ssl_priority.rs");
    include!("types/device_dex_test_data.rs");
    include!("types/device_managed_networks_config.rs");
    include!("types/device_posture_integration_config.rs");
    include!("types/device_posture_rule_input.rs");
    include!("types/device_posture_rule_input_location.rs");
    include!("types/device_posture_rule_match.rs");
    include!("types/dlp_profile_context_awareness.rs");
    include!("types/dlp_profile_context_awareness_skip.rs");
    include!("types/dlp_profile_entry.rs");
    include!("types/dlp_profile_entry_pattern.rs");
    include!("types/email_routing_catch_all_action.rs");
    include!("types/email_routing_catch_all_matcher.rs");
    include!("types/email_routing_rule_action.rs");
    include!("types/email_routing_rule_matcher.rs");
    include!("types/fallback_domain_domain.rs");
    include!("types/healthcheck_header.rs");
    include!("types/hyperdrive_config_caching.rs");
    include!("types/hyperdrive_config_origin.rs");
    include!("types/infrastructure_access_target_ip.rs");
    include!("types/infrastructure_access_target_ip_ipv_4.rs");
    include!("types/infrastructure_access_target_ip_ipv_6.rs");
    include!("types/list_item.rs");
    include!("types/list_item_hostname.rs");
    include!("types/list_item_redirect.rs");
    include!("types/list_item_value.rs");
    include!("types/list_item_value_hostname.rs");
    include!("types/list_item_value_redirect.rs");
    include!("types/load_balancer_adaptive_routing.rs");
    include!("types/load_balancer_country_pool.rs");
    include!("types/load_balancer_location_strategy.rs");
    include!("types/load_balancer_monitor_header.rs");
    include!("types/load_balancer_pool_load_shedding.rs");
    include!("types/load_balancer_pool_origin.rs");
    include!("types/load_balancer_pool_origin_header.rs");
    include!("types/load_balancer_pool_origin_steering.rs");
    include!("types/load_balancer_pop_pool.rs");
    include!("types/load_balancer_random_steering.rs");
    include!("types/load_balancer_region_pool.rs");
    include!("types/load_balancer_rule.rs");
    include!("types/load_balancer_rule_fixed_response.rs");
    include!("types/load_balancer_rule_override.rs");
    include!("types/load_balancer_rule_override_adaptive_routing.rs");
    include!("types/load_balancer_rule_override_country_pool.rs");
    include!("types/load_balancer_rule_override_location_strategy.rs");
    include!("types/load_balancer_rule_override_pop_pool.rs");
    include!("types/load_balancer_rule_override_random_steering.rs");
    include!("types/load_balancer_rule_override_region_pool.rs");
    include!("types/load_balancer_rule_override_session_affinity_attribute.rs");
    include!("types/load_balancer_session_affinity_attribute.rs");
    include!("types/logpush_job_output_options.rs");
    include!("types/managed_headers_managed_request_header.rs");
    include!("types/managed_headers_managed_response_header.rs");
    include!("types/notification_policy_email_integration.rs");
    include!("types/notification_policy_filters.rs");
    include!("types/notification_policy_pagerduty_integration.rs");
    include!("types/notification_policy_webhooks_integration.rs");
    include!("types/page_rule_actions.rs");
    include!("types/page_rule_actions_cache_key_fields.rs");
    include!("types/page_rule_actions_cache_key_fields_cookie.rs");
    include!("types/page_rule_actions_cache_key_fields_header.rs");
    include!("types/page_rule_actions_cache_key_fields_host.rs");
    include!("types/page_rule_actions_cache_key_fields_query_string.rs");
    include!("types/page_rule_actions_cache_key_fields_user.rs");
    include!("types/page_rule_actions_cache_ttl_by_status.rs");
    include!("types/page_rule_actions_forwarding_url.rs");
    include!("types/page_rule_actions_minify.rs");
    include!("types/pages_project_build_config.rs");
    include!("types/pages_project_deployment_configs.rs");
    include!("types/pages_project_deployment_configs_preview.rs");
    include!("types/pages_project_deployment_configs_preview_placement.rs");
    include!("types/pages_project_deployment_configs_preview_service_binding.rs");
    include!("types/pages_project_deployment_configs_production.rs");
    include!("types/pages_project_deployment_configs_production_placement.rs");
    include!("types/pages_project_deployment_configs_production_service_binding.rs");
    include!("types/pages_project_source.rs");
    include!("types/pages_project_source_config.rs");
    include!("types/rate_limit_action.rs");
    include!("types/rate_limit_action_response.rs");
    include!("types/rate_limit_correlate.rs");
    include!("types/rate_limit_match.rs");
    include!("types/rate_limit_match_request.rs");
    include!("types/rate_limit_match_response.rs");
    include!("types/record_data.rs");
    include!("types/risk_behavior_behavior.rs");
    include!("types/ruleset_rule.rs");
    include!("types/ruleset_rule_action_parameters.rs");
    include!("types/ruleset_rule_action_parameters_algorithm.rs");
    include!("types/ruleset_rule_action_parameters_autominify.rs");
    include!("types/ruleset_rule_action_parameters_browser_ttl.rs");
    include!("types/ruleset_rule_action_parameters_cache_key.rs");
    include!("types/ruleset_rule_action_parameters_cache_key_custom_key.rs");
    include!("types/ruleset_rule_action_parameters_cache_key_custom_key_cookie.rs");
    include!("types/ruleset_rule_action_parameters_cache_key_custom_key_header.rs");
    include!("types/ruleset_rule_action_parameters_cache_key_custom_key_host.rs");
    include!(
        "types/ruleset_rule_action_parameters_cache_key_custom_key_query_string.rs"
    );
    include!("types/ruleset_rule_action_parameters_cache_key_custom_key_user.rs");
    include!("types/ruleset_rule_action_parameters_cache_reserve.rs");
    include!("types/ruleset_rule_action_parameters_edge_ttl.rs");
    include!("types/ruleset_rule_action_parameters_edge_ttl_status_code_ttl.rs");
    include!(
        "types/ruleset_rule_action_parameters_edge_ttl_status_code_ttl_status_code_range.rs"
    );
    include!("types/ruleset_rule_action_parameters_from_list.rs");
    include!("types/ruleset_rule_action_parameters_from_value.rs");
    include!("types/ruleset_rule_action_parameters_from_value_target_url.rs");
    include!("types/ruleset_rule_action_parameters_header.rs");
    include!("types/ruleset_rule_action_parameters_matched_data.rs");
    include!("types/ruleset_rule_action_parameters_origin.rs");
    include!("types/ruleset_rule_action_parameters_overrides.rs");
    include!("types/ruleset_rule_action_parameters_overrides_category.rs");
    include!("types/ruleset_rule_action_parameters_overrides_rule.rs");
    include!("types/ruleset_rule_action_parameters_response.rs");
    include!("types/ruleset_rule_action_parameters_serve_stale.rs");
    include!("types/ruleset_rule_action_parameters_sni.rs");
    include!("types/ruleset_rule_action_parameters_uri.rs");
    include!("types/ruleset_rule_action_parameters_uri_path.rs");
    include!("types/ruleset_rule_action_parameters_uri_query.rs");
    include!("types/ruleset_rule_exposed_credential_check.rs");
    include!("types/ruleset_rule_logging.rs");
    include!("types/ruleset_rule_ratelimit.rs");
    include!("types/spectrum_application_dns.rs");
    include!("types/spectrum_application_edge_ips.rs");
    include!("types/spectrum_application_origin_dns.rs");
    include!("types/spectrum_application_origin_port_range.rs");
    include!("types/split_tunnel_tunnel.rs");
    include!("types/teams_account_antivirus.rs");
    include!("types/teams_account_antivirus_notification_settings.rs");
    include!("types/teams_account_block_page.rs");
    include!("types/teams_account_body_scanning.rs");
    include!("types/teams_account_certificate.rs");
    include!("types/teams_account_custom_certificate.rs");
    include!("types/teams_account_extended_email_matching.rs");
    include!("types/teams_account_fips.rs");
    include!("types/teams_account_logging.rs");
    include!("types/teams_account_logging_settings_by_rule_type.rs");
    include!("types/teams_account_logging_settings_by_rule_type_dns.rs");
    include!("types/teams_account_logging_settings_by_rule_type_http.rs");
    include!("types/teams_account_logging_settings_by_rule_type_l_4.rs");
    include!("types/teams_account_payload_log.rs");
    include!("types/teams_account_proxy.rs");
    include!("types/teams_account_ssh_session_log.rs");
    include!("types/teams_list_items_with_description.rs");
    include!("types/teams_location_network.rs");
    include!("types/teams_rule_rule_settings.rs");
    include!("types/teams_rule_rule_settings_audit_ssh.rs");
    include!("types/teams_rule_rule_settings_biso_admin_controls.rs");
    include!("types/teams_rule_rule_settings_check_session.rs");
    include!("types/teams_rule_rule_settings_dns_resolvers.rs");
    include!("types/teams_rule_rule_settings_dns_resolvers_ipv_4.rs");
    include!("types/teams_rule_rule_settings_dns_resolvers_ipv_6.rs");
    include!("types/teams_rule_rule_settings_egress.rs");
    include!("types/teams_rule_rule_settings_l_4_override.rs");
    include!("types/teams_rule_rule_settings_notification_settings.rs");
    include!("types/teams_rule_rule_settings_payload_log.rs");
    include!("types/teams_rule_rule_settings_untrusted_cert.rs");
    include!("types/tunnel_config_config.rs");
    include!("types/tunnel_config_config_ingress_rule.rs");
    include!("types/tunnel_config_config_ingress_rule_origin_request.rs");
    include!("types/tunnel_config_config_ingress_rule_origin_request_access.rs");
    include!("types/tunnel_config_config_ingress_rule_origin_request_ip_rule.rs");
    include!("types/tunnel_config_config_origin_request.rs");
    include!("types/tunnel_config_config_origin_request_access.rs");
    include!("types/tunnel_config_config_origin_request_ip_rule.rs");
    include!("types/tunnel_config_config_warp_routing.rs");
    include!("types/user_agent_blocking_rule_configuration.rs");
    include!("types/waiting_room_additional_route.rs");
    include!("types/waiting_room_rules_rule.rs");
    include!("types/worker_script_analytics_engine_binding.rs");
    include!("types/worker_script_d_1_database_binding.rs");
    include!("types/worker_script_hyperdrive_config_binding.rs");
    include!("types/worker_script_kv_namespace_binding.rs");
    include!("types/worker_script_placement.rs");
    include!("types/worker_script_plain_text_binding.rs");
    include!("types/worker_script_queue_binding.rs");
    include!("types/worker_script_r_2_bucket_binding.rs");
    include!("types/worker_script_secret_text_binding.rs");
    include!("types/worker_script_service_binding.rs");
    include!("types/worker_script_webassembly_binding.rs");
    include!("types/workers_script_analytics_engine_binding.rs");
    include!("types/workers_script_d_1_database_binding.rs");
    include!("types/workers_script_hyperdrive_config_binding.rs");
    include!("types/workers_script_kv_namespace_binding.rs");
    include!("types/workers_script_placement.rs");
    include!("types/workers_script_plain_text_binding.rs");
    include!("types/workers_script_queue_binding.rs");
    include!("types/workers_script_r_2_bucket_binding.rs");
    include!("types/workers_script_secret_text_binding.rs");
    include!("types/workers_script_service_binding.rs");
    include!("types/workers_script_webassembly_binding.rs");
    include!("types/zero_trust_access_application_cors_header.rs");
    include!("types/zero_trust_access_application_footer_link.rs");
    include!("types/zero_trust_access_application_landing_page_design.rs");
    include!("types/zero_trust_access_application_saas_app.rs");
    include!("types/zero_trust_access_application_saas_app_custom_attribute.rs");
    include!("types/zero_trust_access_application_saas_app_custom_attribute_source.rs");
    include!("types/zero_trust_access_application_saas_app_custom_claim.rs");
    include!("types/zero_trust_access_application_saas_app_custom_claim_source.rs");
    include!(
        "types/zero_trust_access_application_saas_app_hybrid_and_implicit_options.rs"
    );
    include!("types/zero_trust_access_application_saas_app_refresh_token_option.rs");
    include!("types/zero_trust_access_application_scim_config.rs");
    include!("types/zero_trust_access_application_scim_config_authentication.rs");
    include!("types/zero_trust_access_application_scim_config_mapping.rs");
    include!("types/zero_trust_access_application_scim_config_mapping_operations.rs");
    include!("types/zero_trust_access_application_target_criteria.rs");
    include!("types/zero_trust_access_application_target_criteria_target_attribute.rs");
    include!("types/zero_trust_access_group_exclude.rs");
    include!("types/zero_trust_access_group_exclude_auth_context.rs");
    include!("types/zero_trust_access_group_exclude_azure.rs");
    include!("types/zero_trust_access_group_exclude_external_evaluation.rs");
    include!("types/zero_trust_access_group_exclude_github.rs");
    include!("types/zero_trust_access_group_exclude_gsuite.rs");
    include!("types/zero_trust_access_group_exclude_okta.rs");
    include!("types/zero_trust_access_group_exclude_saml.rs");
    include!("types/zero_trust_access_group_include.rs");
    include!("types/zero_trust_access_group_include_auth_context.rs");
    include!("types/zero_trust_access_group_include_azure.rs");
    include!("types/zero_trust_access_group_include_external_evaluation.rs");
    include!("types/zero_trust_access_group_include_github.rs");
    include!("types/zero_trust_access_group_include_gsuite.rs");
    include!("types/zero_trust_access_group_include_okta.rs");
    include!("types/zero_trust_access_group_include_saml.rs");
    include!("types/zero_trust_access_group_require.rs");
    include!("types/zero_trust_access_group_require_auth_context.rs");
    include!("types/zero_trust_access_group_require_azure.rs");
    include!("types/zero_trust_access_group_require_external_evaluation.rs");
    include!("types/zero_trust_access_group_require_github.rs");
    include!("types/zero_trust_access_group_require_gsuite.rs");
    include!("types/zero_trust_access_group_require_okta.rs");
    include!("types/zero_trust_access_group_require_saml.rs");
    include!("types/zero_trust_access_identity_provider_config.rs");
    include!("types/zero_trust_access_identity_provider_scim_config.rs");
    include!("types/zero_trust_access_mtls_hostname_settings_setting.rs");
    include!("types/zero_trust_access_organization_custom_page.rs");
    include!("types/zero_trust_access_organization_login_design.rs");
    include!("types/zero_trust_access_policy_approval_group.rs");
    include!("types/zero_trust_access_policy_connection_rules.rs");
    include!("types/zero_trust_access_policy_connection_rules_ssh.rs");
    include!("types/zero_trust_access_policy_exclude.rs");
    include!("types/zero_trust_access_policy_exclude_auth_context.rs");
    include!("types/zero_trust_access_policy_exclude_azure.rs");
    include!("types/zero_trust_access_policy_exclude_external_evaluation.rs");
    include!("types/zero_trust_access_policy_exclude_github.rs");
    include!("types/zero_trust_access_policy_exclude_gsuite.rs");
    include!("types/zero_trust_access_policy_exclude_okta.rs");
    include!("types/zero_trust_access_policy_exclude_saml.rs");
    include!("types/zero_trust_access_policy_include.rs");
    include!("types/zero_trust_access_policy_include_auth_context.rs");
    include!("types/zero_trust_access_policy_include_azure.rs");
    include!("types/zero_trust_access_policy_include_external_evaluation.rs");
    include!("types/zero_trust_access_policy_include_github.rs");
    include!("types/zero_trust_access_policy_include_gsuite.rs");
    include!("types/zero_trust_access_policy_include_okta.rs");
    include!("types/zero_trust_access_policy_include_saml.rs");
    include!("types/zero_trust_access_policy_require.rs");
    include!("types/zero_trust_access_policy_require_auth_context.rs");
    include!("types/zero_trust_access_policy_require_azure.rs");
    include!("types/zero_trust_access_policy_require_external_evaluation.rs");
    include!("types/zero_trust_access_policy_require_github.rs");
    include!("types/zero_trust_access_policy_require_gsuite.rs");
    include!("types/zero_trust_access_policy_require_okta.rs");
    include!("types/zero_trust_access_policy_require_saml.rs");
    include!("types/zero_trust_device_managed_networks_config.rs");
    include!("types/zero_trust_device_posture_integration_config.rs");
    include!("types/zero_trust_device_posture_rule_input.rs");
    include!("types/zero_trust_device_posture_rule_input_location.rs");
    include!("types/zero_trust_device_posture_rule_match.rs");
    include!("types/zero_trust_dex_test_data.rs");
    include!("types/zero_trust_dlp_profile_context_awareness.rs");
    include!("types/zero_trust_dlp_profile_context_awareness_skip.rs");
    include!("types/zero_trust_dlp_profile_entry.rs");
    include!("types/zero_trust_dlp_profile_entry_pattern.rs");
    include!("types/zero_trust_dns_location_network.rs");
    include!("types/zero_trust_gateway_policy_rule_settings.rs");
    include!("types/zero_trust_gateway_policy_rule_settings_audit_ssh.rs");
    include!("types/zero_trust_gateway_policy_rule_settings_biso_admin_controls.rs");
    include!("types/zero_trust_gateway_policy_rule_settings_check_session.rs");
    include!("types/zero_trust_gateway_policy_rule_settings_dns_resolvers.rs");
    include!("types/zero_trust_gateway_policy_rule_settings_dns_resolvers_ipv_4.rs");
    include!("types/zero_trust_gateway_policy_rule_settings_dns_resolvers_ipv_6.rs");
    include!("types/zero_trust_gateway_policy_rule_settings_egress.rs");
    include!("types/zero_trust_gateway_policy_rule_settings_l_4_override.rs");
    include!("types/zero_trust_gateway_policy_rule_settings_notification_settings.rs");
    include!("types/zero_trust_gateway_policy_rule_settings_payload_log.rs");
    include!("types/zero_trust_gateway_policy_rule_settings_untrusted_cert.rs");
    include!("types/zero_trust_gateway_settings_antivirus.rs");
    include!("types/zero_trust_gateway_settings_antivirus_notification_settings.rs");
    include!("types/zero_trust_gateway_settings_block_page.rs");
    include!("types/zero_trust_gateway_settings_body_scanning.rs");
    include!("types/zero_trust_gateway_settings_certificate.rs");
    include!("types/zero_trust_gateway_settings_custom_certificate.rs");
    include!("types/zero_trust_gateway_settings_extended_email_matching.rs");
    include!("types/zero_trust_gateway_settings_fips.rs");
    include!("types/zero_trust_gateway_settings_logging.rs");
    include!("types/zero_trust_gateway_settings_logging_settings_by_rule_type.rs");
    include!("types/zero_trust_gateway_settings_logging_settings_by_rule_type_dns.rs");
    include!("types/zero_trust_gateway_settings_logging_settings_by_rule_type_http.rs");
    include!("types/zero_trust_gateway_settings_logging_settings_by_rule_type_l_4.rs");
    include!("types/zero_trust_gateway_settings_payload_log.rs");
    include!("types/zero_trust_gateway_settings_proxy.rs");
    include!("types/zero_trust_gateway_settings_ssh_session_log.rs");
    include!("types/zero_trust_infrastructure_access_target_ip.rs");
    include!("types/zero_trust_infrastructure_access_target_ip_ipv_4.rs");
    include!("types/zero_trust_infrastructure_access_target_ip_ipv_6.rs");
    include!("types/zero_trust_list_items_with_description.rs");
    include!("types/zero_trust_local_fallback_domain_domain.rs");
    include!("types/zero_trust_risk_behavior_behavior.rs");
    include!("types/zero_trust_split_tunnel_tunnel.rs");
    include!("types/zero_trust_tunnel_cloudflared_config_config.rs");
    include!("types/zero_trust_tunnel_cloudflared_config_config_ingress_rule.rs");
    include!(
        "types/zero_trust_tunnel_cloudflared_config_config_ingress_rule_origin_request.rs"
    );
    include!(
        "types/zero_trust_tunnel_cloudflared_config_config_ingress_rule_origin_request_access.rs"
    );
    include!(
        "types/zero_trust_tunnel_cloudflared_config_config_ingress_rule_origin_request_ip_rule.rs"
    );
    include!("types/zero_trust_tunnel_cloudflared_config_config_origin_request.rs");
    include!(
        "types/zero_trust_tunnel_cloudflared_config_config_origin_request_access.rs"
    );
    include!(
        "types/zero_trust_tunnel_cloudflared_config_config_origin_request_ip_rule.rs"
    );
    include!("types/zero_trust_tunnel_cloudflared_config_config_warp_routing.rs");
    include!("types/zone_lockdown_configuration.rs");
    include!("types/zone_settings_override_initial_setting.rs");
    include!("types/zone_settings_override_initial_setting_minify.rs");
    include!("types/zone_settings_override_initial_setting_mobile_redirect.rs");
    include!("types/zone_settings_override_initial_setting_nel.rs");
    include!("types/zone_settings_override_initial_setting_security_header.rs");
    include!("types/zone_settings_override_settings.rs");
    include!("types/zone_settings_override_settings_minify.rs");
    include!("types/zone_settings_override_settings_mobile_redirect.rs");
    include!("types/zone_settings_override_settings_nel.rs");
    include!("types/zone_settings_override_settings_security_header.rs");
    include!("types/get_account_roles_role.rs");
    include!("types/get_accounts_account.rs");
    include!("types/get_device_posture_rules_rule.rs");
    include!("types/get_devices_device.rs");
    include!("types/get_dlp_datasets_dataset.rs");
    include!("types/get_gateway_app_types_app_type.rs");
    include!("types/get_gateway_categories_category.rs");
    include!("types/get_gateway_categories_category_subcategory.rs");
    include!("types/get_infrastructure_access_targets_target.rs");
    include!("types/get_infrastructure_access_targets_target_ip.rs");
    include!("types/get_infrastructure_access_targets_target_ip_ipv_4.rs");
    include!("types/get_infrastructure_access_targets_target_ip_ipv_6.rs");
    include!("types/get_lists_list.rs");
    include!("types/get_load_balancer_pools_filter.rs");
    include!("types/get_load_balancer_pools_pool.rs");
    include!("types/get_load_balancer_pools_pool_load_shedding.rs");
    include!("types/get_load_balancer_pools_pool_origin.rs");
    include!("types/get_load_balancer_pools_pool_origin_header.rs");
    include!("types/get_rulesets_filter.rs");
    include!("types/get_rulesets_ruleset.rs");
    include!("types/get_rulesets_ruleset_rule.rs");
    include!("types/get_rulesets_ruleset_rule_action_parameters.rs");
    include!("types/get_rulesets_ruleset_rule_action_parameters_autominify.rs");
    include!("types/get_rulesets_ruleset_rule_action_parameters_browser_ttl.rs");
    include!("types/get_rulesets_ruleset_rule_action_parameters_cache_key.rs");
    include!(
        "types/get_rulesets_ruleset_rule_action_parameters_cache_key_custom_key.rs"
    );
    include!(
        "types/get_rulesets_ruleset_rule_action_parameters_cache_key_custom_key_cookie.rs"
    );
    include!(
        "types/get_rulesets_ruleset_rule_action_parameters_cache_key_custom_key_header.rs"
    );
    include!(
        "types/get_rulesets_ruleset_rule_action_parameters_cache_key_custom_key_host.rs"
    );
    include!(
        "types/get_rulesets_ruleset_rule_action_parameters_cache_key_custom_key_query_string.rs"
    );
    include!(
        "types/get_rulesets_ruleset_rule_action_parameters_cache_key_custom_key_user.rs"
    );
    include!("types/get_rulesets_ruleset_rule_action_parameters_cache_reserve.rs");
    include!("types/get_rulesets_ruleset_rule_action_parameters_edge_ttl.rs");
    include!(
        "types/get_rulesets_ruleset_rule_action_parameters_edge_ttl_status_code_ttl.rs"
    );
    include!(
        "types/get_rulesets_ruleset_rule_action_parameters_edge_ttl_status_code_ttl_status_code_range.rs"
    );
    include!("types/get_rulesets_ruleset_rule_action_parameters_from_list.rs");
    include!("types/get_rulesets_ruleset_rule_action_parameters_from_value.rs");
    include!(
        "types/get_rulesets_ruleset_rule_action_parameters_from_value_target_url.rs"
    );
    include!("types/get_rulesets_ruleset_rule_action_parameters_header.rs");
    include!("types/get_rulesets_ruleset_rule_action_parameters_matched_data.rs");
    include!("types/get_rulesets_ruleset_rule_action_parameters_origin.rs");
    include!("types/get_rulesets_ruleset_rule_action_parameters_overrides.rs");
    include!("types/get_rulesets_ruleset_rule_action_parameters_overrides_category.rs");
    include!("types/get_rulesets_ruleset_rule_action_parameters_overrides_rule.rs");
    include!("types/get_rulesets_ruleset_rule_action_parameters_response.rs");
    include!("types/get_rulesets_ruleset_rule_action_parameters_serve_stale.rs");
    include!("types/get_rulesets_ruleset_rule_action_parameters_sni.rs");
    include!("types/get_rulesets_ruleset_rule_action_parameters_uri.rs");
    include!("types/get_rulesets_ruleset_rule_action_parameters_uri_path.rs");
    include!("types/get_rulesets_ruleset_rule_action_parameters_uri_query.rs");
    include!("types/get_rulesets_ruleset_rule_exposed_credential_check.rs");
    include!("types/get_rulesets_ruleset_rule_logging.rs");
    include!("types/get_rulesets_ruleset_rule_ratelimit.rs");
    include!("types/get_zero_trust_infrastructure_access_targets_target.rs");
    include!("types/get_zero_trust_infrastructure_access_targets_target_ip.rs");
    include!("types/get_zero_trust_infrastructure_access_targets_target_ip_ipv_4.rs");
    include!("types/get_zero_trust_infrastructure_access_targets_target_ip_ipv_6.rs");
    include!("types/get_zones_filter.rs");
    include!("types/get_zones_zone.rs");
}
#[doc(hidden)]
pub mod constants {}
mod bindings {
    pulumi_wasm_rust::__private::wit_bindgen::generate!(
        { inline :
        r"package component:pulumi-wasm@0.0.0-DEV;

world world-cloudflare {
    import output-interface;
}

interface output-interface {

    resource output {
        constructor(value: string);
        map: func(function-name: string) -> output;
    }
    combine: func(outputs: list<borrow<output>>) -> output;
}


interface register-interface {
    use output-interface.{output};

    record object-field {
        name: string,
        value: borrow<output>
    }

    record result-field {
        name: string
    }

    record register-resource-result-field {
        name: string,
        output: output
    }

    record register-resource-request {
        %type: string,
        name: string,
        object: list<object-field>,
        results: list<result-field>
    }

    record register-resource-result {
        fields: list<register-resource-result-field>
    }

    register: func(request: register-resource-request) -> register-resource-result;

    record resource-invoke-result-field {
        name: string,
        output: output
    }

    record resource-invoke-request {
        token: string,
        object: list<object-field>,
        results: list<result-field>
    }

    record resource-invoke-result {
        fields: list<resource-invoke-result-field>
    }

    invoke: func(request: resource-invoke-request) -> resource-invoke-result;
}",
        with : { "component:pulumi-wasm/output-interface@0.0.0-DEV" :
        pulumi_wasm_rust::__private::pulumi_wasm_wit::client_bindings::component::pulumi_wasm::output_interface
        } }
    );
}
