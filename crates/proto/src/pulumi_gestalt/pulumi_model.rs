// This file is @generated by prost-build.
/// Main Package definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Package {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub plugin_download_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub version: ::prost::alloc::string::String,
    #[prost(map = "string, message", tag = "5")]
    pub resources: ::std::collections::HashMap<::prost::alloc::string::String, Resource>,
    #[prost(map = "string, message", tag = "6")]
    pub functions: ::std::collections::HashMap<::prost::alloc::string::String, Function>,
    #[prost(map = "string, message", tag = "7")]
    pub types: ::std::collections::HashMap<::prost::alloc::string::String, GlobalType>,
}
/// Resource definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Resource {
    #[prost(message, optional, tag = "1")]
    pub element_id: ::core::option::Option<ElementId>,
    #[prost(string, optional, tag = "2")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3")]
    pub input_properties: ::prost::alloc::vec::Vec<InputProperty>,
    #[prost(message, repeated, tag = "4")]
    pub output_properties: ::prost::alloc::vec::Vec<OutputProperty>,
}
/// Function definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Function {
    #[prost(message, optional, tag = "1")]
    pub element_id: ::core::option::Option<ElementId>,
    #[prost(string, optional, tag = "2")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3")]
    pub input_properties: ::prost::alloc::vec::Vec<InputProperty>,
    #[prost(message, repeated, tag = "4")]
    pub output_properties: ::prost::alloc::vec::Vec<OutputProperty>,
}
/// ElementId definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ElementId {
    #[prost(string, repeated, tag = "1")]
    pub namespace: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub raw: ::prost::alloc::string::String,
}
/// InputProperty definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputProperty {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub r#type: ::core::option::Option<Type>,
    #[prost(string, optional, tag = "3")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
}
/// OutputProperty definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputProperty {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub r#type: ::core::option::Option<Type>,
    #[prost(string, optional, tag = "3")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
}
/// Type definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Type {
    #[prost(oneof = "r#type::TypeValue", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10")]
    pub type_value: ::core::option::Option<r#type::TypeValue>,
}
/// Nested message and enum types in `Type`.
pub mod r#type {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TypeValue {
        #[prost(message, tag = "1")]
        Boolean(super::Empty),
        #[prost(message, tag = "2")]
        Integer(super::Empty),
        #[prost(message, tag = "3")]
        Number(super::Empty),
        #[prost(message, tag = "4")]
        String(super::Empty),
        #[prost(message, tag = "5")]
        ArrayType(::prost::alloc::boxed::Box<super::Type>),
        #[prost(message, tag = "6")]
        ObjectType(::prost::alloc::boxed::Box<super::Type>),
        #[prost(message, tag = "7")]
        RefType(super::RefType),
        #[prost(message, tag = "8")]
        OptionType(::prost::alloc::boxed::Box<super::Type>),
        #[prost(message, tag = "9")]
        DiscriminatedUnion(super::DiscriminatedUnion),
        #[prost(string, tag = "10")]
        ConstString(::prost::alloc::string::String),
    }
}
/// Empty message for types that don't need additional fields
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Empty {}
/// RefType definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefType {
    #[prost(oneof = "ref_type::RefValue", tags = "1, 2, 3, 4")]
    pub ref_value: ::core::option::Option<ref_type::RefValue>,
}
/// Nested message and enum types in `RefType`.
pub mod ref_type {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RefValue {
        #[prost(message, tag = "1")]
        TypeRef(super::ElementId),
        #[prost(message, tag = "2")]
        Archive(super::Empty),
        #[prost(message, tag = "3")]
        Asset(super::Empty),
        #[prost(message, tag = "4")]
        Any(super::Empty),
    }
}
/// DiscriminatedUnion definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiscriminatedUnion {
    #[prost(message, repeated, tag = "1")]
    pub types: ::prost::alloc::vec::Vec<Type>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlobalType {
    #[prost(message, optional, tag = "1")]
    pub element_id: ::core::option::Option<ElementId>,
    #[prost(message, optional, tag = "2")]
    pub global_type_value: ::core::option::Option<GlobalTypeValue>,
}
/// GlobalType definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlobalTypeValue {
    #[prost(oneof = "global_type_value::Value", tags = "1, 2, 3, 4")]
    pub value: ::core::option::Option<global_type_value::Value>,
}
/// Nested message and enum types in `GlobalTypeValue`.
pub mod global_type_value {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag = "1")]
        Object(super::ObjectType),
        #[prost(message, tag = "2")]
        StringEnum(super::StringEnum),
        #[prost(message, tag = "3")]
        NumberEnum(super::NumberEnum),
        #[prost(message, tag = "4")]
        IntegerEnum(super::IntegerEnum),
    }
}
/// ObjectType definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectType {
    #[prost(string, optional, tag = "1")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2")]
    pub properties: ::prost::alloc::vec::Vec<GlobalTypeProperty>,
}
/// StringEnum definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringEnum {
    #[prost(string, optional, tag = "1")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2")]
    pub elements: ::prost::alloc::vec::Vec<StringEnumElement>,
}
/// NumberEnum definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NumberEnum {
    #[prost(string, optional, tag = "1")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2")]
    pub elements: ::prost::alloc::vec::Vec<NumberEnumElement>,
}
/// IntegerEnum definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntegerEnum {
    #[prost(string, optional, tag = "1")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2")]
    pub elements: ::prost::alloc::vec::Vec<IntegerEnumElement>,
}
/// GlobalTypeProperty definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlobalTypeProperty {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub r#type: ::core::option::Option<Type>,
    #[prost(string, optional, tag = "3")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
}
/// StringEnumElement definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringEnumElement {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
}
/// NumberEnumElement definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NumberEnumElement {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(double, tag = "2")]
    pub value: f64,
    #[prost(string, optional, tag = "3")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
}
/// IntegerEnumElement definition
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntegerEnumElement {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub value: i64,
    #[prost(string, optional, tag = "3")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
}
