/// Provides an Elastic Load Balancer resource, also known as a "Classic
/// Load Balancer" after the release of
/// Application/Network Load Balancers.
///
/// > **NOTE on ELB Instances and ELB Attachments:** This provider currently
/// provides both a standalone ELB Attachment resource
/// (describing an instance attached to an ELB), and an ELB resource with
/// `instances` defined in-line. At this time you cannot use an ELB with in-line
/// instances in conjunction with a ELB Attachment resources. Doing so will cause a
/// conflict and will overwrite attachments.
///
/// ## Example Usage
///
/// ```yaml
/// resources:
///   # Create a new load balancer
///   bar:
///     type: aws:elb:LoadBalancer
///     properties:
///       name: foobar-elb
///       availabilityZones:
///         - us-west-2a
///         - us-west-2b
///         - us-west-2c
///       accessLogs:
///         bucket: foo
///         bucketPrefix: bar
///         interval: 60
///       listeners:
///         - instancePort: 8000
///           instanceProtocol: http
///           lbPort: 80
///           lbProtocol: http
///         - instancePort: 8000
///           instanceProtocol: http
///           lbPort: 443
///           lbProtocol: https
///           sslCertificateId: arn:aws:iam::123456789012:server-certificate/certName
///       healthCheck:
///         healthyThreshold: 2
///         unhealthyThreshold: 2
///         timeout: 3
///         target: HTTP:8000/
///         interval: 30
///       instances:
///         - ${foo.id}
///       crossZoneLoadBalancing: true
///       idleTimeout: 400
///       connectionDraining: true
///       connectionDrainingTimeout: 400
///       tags:
///         Name: foobar-elb
/// ```
///
/// ## Note on ECDSA Key Algorithm
///
/// If the ARN of the `ssl_certificate_id` that is pointed to references a
/// certificate that was signed by an ECDSA key, note that ELB only supports the
/// P256 and P384 curves.  Using a certificate signed by a key using a different
/// curve could produce the error `ERR_SSL_VERSION_OR_CIPHER_MISMATCH` in your
/// browser.
///
/// ## Import
///
/// Using `pulumi import`, import ELBs using the `name`. For example:
///
/// ```sh
/// $ pulumi import aws:elb/loadBalancer:LoadBalancer bar elb-production-12345
/// ```
#[allow(clippy::doc_lazy_continuation, clippy::tabs_in_doc_comments)]
pub mod load_balancer {
    #[derive(pulumi_gestalt_rust::__private::bon::Builder)]
    #[builder(finish_fn = build_struct)]
    #[allow(dead_code)]
    pub struct LoadBalancerArgs {
        /// An Access Logs block. Access Logs documented below.
        #[builder(into, default)]
        pub access_logs: pulumi_gestalt_rust::InputOrOutput<
            Option<super::super::types::elb::LoadBalancerAccessLogs>,
        >,
        /// The AZ's to serve traffic in.
        #[builder(into, default)]
        pub availability_zones: pulumi_gestalt_rust::InputOrOutput<Option<Vec<String>>>,
        /// Boolean to enable connection draining. Default: `false`
        #[builder(into, default)]
        pub connection_draining: pulumi_gestalt_rust::InputOrOutput<Option<bool>>,
        /// The time in seconds to allow for connections to drain. Default: `300`
        #[builder(into, default)]
        pub connection_draining_timeout: pulumi_gestalt_rust::InputOrOutput<Option<i32>>,
        /// Enable cross-zone load balancing. Default: `true`
        #[builder(into, default)]
        pub cross_zone_load_balancing: pulumi_gestalt_rust::InputOrOutput<Option<bool>>,
        /// Determines how the load balancer handles requests that might pose a security risk to an application due to HTTP desync. Valid values are `monitor`, `defensive` (default), `strictest`.
        #[builder(into, default)]
        pub desync_mitigation_mode: pulumi_gestalt_rust::InputOrOutput<Option<String>>,
        /// A health_check block. Health Check documented below.
        #[builder(into, default)]
        pub health_check: pulumi_gestalt_rust::InputOrOutput<
            Option<super::super::types::elb::LoadBalancerHealthCheck>,
        >,
        /// The time in seconds that the connection is allowed to be idle. Default: `60`
        #[builder(into, default)]
        pub idle_timeout: pulumi_gestalt_rust::InputOrOutput<Option<i32>>,
        /// A list of instance ids to place in the ELB pool.
        #[builder(into, default)]
        pub instances: pulumi_gestalt_rust::InputOrOutput<Option<Vec<String>>>,
        /// If true, ELB will be an internal ELB.
        #[builder(into, default)]
        pub internal: pulumi_gestalt_rust::InputOrOutput<Option<bool>>,
        /// A list of listener blocks. Listeners documented below.
        #[builder(into)]
        pub listeners: pulumi_gestalt_rust::InputOrOutput<
            Vec<super::super::types::elb::LoadBalancerListener>,
        >,
        /// The name of the ELB. By default generated by this provider.
        #[builder(into, default)]
        pub name: pulumi_gestalt_rust::InputOrOutput<Option<String>>,
        /// Creates a unique name beginning with the specified
        /// prefix. Conflicts with `name`.
        #[builder(into, default)]
        pub name_prefix: pulumi_gestalt_rust::InputOrOutput<Option<String>>,
        /// A list of security group IDs to assign to the ELB.
        /// Only valid if creating an ELB within a VPC
        #[builder(into, default)]
        pub security_groups: pulumi_gestalt_rust::InputOrOutput<Option<Vec<String>>>,
        /// The name of the security group that you can use as
        /// part of your inbound rules for your load balancer's back-end application
        /// instances. Use this for Classic or Default VPC only.
        #[builder(into, default)]
        pub source_security_group: pulumi_gestalt_rust::InputOrOutput<Option<String>>,
        /// A list of subnet IDs to attach to the ELB. When an update to subnets will remove all current subnets, this will force a new resource.
        #[builder(into, default)]
        pub subnets: pulumi_gestalt_rust::InputOrOutput<Option<Vec<String>>>,
        /// A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        ///
        /// Exactly one of `availability_zones` or `subnets` must be specified: this
        /// determines if the ELB exists in a VPC or in EC2-classic.
        #[builder(into, default)]
        pub tags: pulumi_gestalt_rust::InputOrOutput<
            Option<std::collections::HashMap<String, String>>,
        >,
    }
    #[allow(dead_code)]
    pub struct LoadBalancerResult {
        /// An Access Logs block. Access Logs documented below.
        pub access_logs: pulumi_gestalt_rust::Output<
            Option<super::super::types::elb::LoadBalancerAccessLogs>,
        >,
        /// The ARN of the ELB
        pub arn: pulumi_gestalt_rust::Output<String>,
        /// The AZ's to serve traffic in.
        pub availability_zones: pulumi_gestalt_rust::Output<Vec<String>>,
        /// Boolean to enable connection draining. Default: `false`
        pub connection_draining: pulumi_gestalt_rust::Output<Option<bool>>,
        /// The time in seconds to allow for connections to drain. Default: `300`
        pub connection_draining_timeout: pulumi_gestalt_rust::Output<Option<i32>>,
        /// Enable cross-zone load balancing. Default: `true`
        pub cross_zone_load_balancing: pulumi_gestalt_rust::Output<Option<bool>>,
        /// Determines how the load balancer handles requests that might pose a security risk to an application due to HTTP desync. Valid values are `monitor`, `defensive` (default), `strictest`.
        pub desync_mitigation_mode: pulumi_gestalt_rust::Output<Option<String>>,
        /// The DNS name of the ELB
        pub dns_name: pulumi_gestalt_rust::Output<String>,
        /// A health_check block. Health Check documented below.
        pub health_check: pulumi_gestalt_rust::Output<
            super::super::types::elb::LoadBalancerHealthCheck,
        >,
        /// The time in seconds that the connection is allowed to be idle. Default: `60`
        pub idle_timeout: pulumi_gestalt_rust::Output<Option<i32>>,
        /// A list of instance ids to place in the ELB pool.
        pub instances: pulumi_gestalt_rust::Output<Vec<String>>,
        /// If true, ELB will be an internal ELB.
        pub internal: pulumi_gestalt_rust::Output<bool>,
        /// A list of listener blocks. Listeners documented below.
        pub listeners: pulumi_gestalt_rust::Output<
            Vec<super::super::types::elb::LoadBalancerListener>,
        >,
        /// The name of the ELB. By default generated by this provider.
        pub name: pulumi_gestalt_rust::Output<String>,
        /// Creates a unique name beginning with the specified
        /// prefix. Conflicts with `name`.
        pub name_prefix: pulumi_gestalt_rust::Output<String>,
        /// A list of security group IDs to assign to the ELB.
        /// Only valid if creating an ELB within a VPC
        pub security_groups: pulumi_gestalt_rust::Output<Vec<String>>,
        /// The name of the security group that you can use as
        /// part of your inbound rules for your load balancer's back-end application
        /// instances. Use this for Classic or Default VPC only.
        pub source_security_group: pulumi_gestalt_rust::Output<String>,
        /// The ID of the security group that you can use as
        /// part of your inbound rules for your load balancer's back-end application
        /// instances. Only available on ELBs launched in a VPC.
        pub source_security_group_id: pulumi_gestalt_rust::Output<String>,
        /// A list of subnet IDs to attach to the ELB. When an update to subnets will remove all current subnets, this will force a new resource.
        pub subnets: pulumi_gestalt_rust::Output<Vec<String>>,
        /// A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
        ///
        /// Exactly one of `availability_zones` or `subnets` must be specified: this
        /// determines if the ELB exists in a VPC or in EC2-classic.
        pub tags: pulumi_gestalt_rust::Output<
            Option<std::collections::HashMap<String, String>>,
        >,
        /// A map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
        pub tags_all: pulumi_gestalt_rust::Output<
            std::collections::HashMap<String, String>,
        >,
        /// The canonical hosted zone ID of the ELB (to be used in a Route 53 Alias record)
        pub zone_id: pulumi_gestalt_rust::Output<String>,
    }
    ///
    /// Registers a new resource with the given unique name and arguments
    ///
    #[allow(non_snake_case, unused_imports, dead_code)]
    pub fn create(
        context: &pulumi_gestalt_rust::PulumiContext,
        name: &str,
        args: LoadBalancerArgs,
    ) -> LoadBalancerResult {
        use pulumi_gestalt_rust::__private::pulumi_gestalt_wit::client_bindings::component::pulumi_gestalt::register_interface;
        use std::collections::HashMap;
        let access_logs_binding = args.access_logs.get_output(context).get_inner();
        let availability_zones_binding = args
            .availability_zones
            .get_output(context)
            .get_inner();
        let connection_draining_binding = args
            .connection_draining
            .get_output(context)
            .get_inner();
        let connection_draining_timeout_binding = args
            .connection_draining_timeout
            .get_output(context)
            .get_inner();
        let cross_zone_load_balancing_binding = args
            .cross_zone_load_balancing
            .get_output(context)
            .get_inner();
        let desync_mitigation_mode_binding = args
            .desync_mitigation_mode
            .get_output(context)
            .get_inner();
        let health_check_binding = args.health_check.get_output(context).get_inner();
        let idle_timeout_binding = args.idle_timeout.get_output(context).get_inner();
        let instances_binding = args.instances.get_output(context).get_inner();
        let internal_binding = args.internal.get_output(context).get_inner();
        let listeners_binding = args.listeners.get_output(context).get_inner();
        let name_binding = args.name.get_output(context).get_inner();
        let name_prefix_binding = args.name_prefix.get_output(context).get_inner();
        let security_groups_binding = args
            .security_groups
            .get_output(context)
            .get_inner();
        let source_security_group_binding = args
            .source_security_group
            .get_output(context)
            .get_inner();
        let subnets_binding = args.subnets.get_output(context).get_inner();
        let tags_binding = args.tags.get_output(context).get_inner();
        let request = register_interface::RegisterResourceRequest {
            type_: "aws:elb/loadBalancer:LoadBalancer".into(),
            name: name.to_string(),
            version: super::super::get_version(),
            object: Vec::from([
                register_interface::ObjectField {
                    name: "accessLogs".into(),
                    value: &access_logs_binding,
                },
                register_interface::ObjectField {
                    name: "availabilityZones".into(),
                    value: &availability_zones_binding,
                },
                register_interface::ObjectField {
                    name: "connectionDraining".into(),
                    value: &connection_draining_binding,
                },
                register_interface::ObjectField {
                    name: "connectionDrainingTimeout".into(),
                    value: &connection_draining_timeout_binding,
                },
                register_interface::ObjectField {
                    name: "crossZoneLoadBalancing".into(),
                    value: &cross_zone_load_balancing_binding,
                },
                register_interface::ObjectField {
                    name: "desyncMitigationMode".into(),
                    value: &desync_mitigation_mode_binding,
                },
                register_interface::ObjectField {
                    name: "healthCheck".into(),
                    value: &health_check_binding,
                },
                register_interface::ObjectField {
                    name: "idleTimeout".into(),
                    value: &idle_timeout_binding,
                },
                register_interface::ObjectField {
                    name: "instances".into(),
                    value: &instances_binding,
                },
                register_interface::ObjectField {
                    name: "internal".into(),
                    value: &internal_binding,
                },
                register_interface::ObjectField {
                    name: "listeners".into(),
                    value: &listeners_binding,
                },
                register_interface::ObjectField {
                    name: "name".into(),
                    value: &name_binding,
                },
                register_interface::ObjectField {
                    name: "namePrefix".into(),
                    value: &name_prefix_binding,
                },
                register_interface::ObjectField {
                    name: "securityGroups".into(),
                    value: &security_groups_binding,
                },
                register_interface::ObjectField {
                    name: "sourceSecurityGroup".into(),
                    value: &source_security_group_binding,
                },
                register_interface::ObjectField {
                    name: "subnets".into(),
                    value: &subnets_binding,
                },
                register_interface::ObjectField {
                    name: "tags".into(),
                    value: &tags_binding,
                },
            ]),
        };
        let o = register_interface::register(context.get_inner(), &request);
        LoadBalancerResult {
            access_logs: pulumi_gestalt_rust::__private::into_domain(
                o.extract_field("accessLogs"),
            ),
            arn: pulumi_gestalt_rust::__private::into_domain(o.extract_field("arn")),
            availability_zones: pulumi_gestalt_rust::__private::into_domain(
                o.extract_field("availabilityZones"),
            ),
            connection_draining: pulumi_gestalt_rust::__private::into_domain(
                o.extract_field("connectionDraining"),
            ),
            connection_draining_timeout: pulumi_gestalt_rust::__private::into_domain(
                o.extract_field("connectionDrainingTimeout"),
            ),
            cross_zone_load_balancing: pulumi_gestalt_rust::__private::into_domain(
                o.extract_field("crossZoneLoadBalancing"),
            ),
            desync_mitigation_mode: pulumi_gestalt_rust::__private::into_domain(
                o.extract_field("desyncMitigationMode"),
            ),
            dns_name: pulumi_gestalt_rust::__private::into_domain(
                o.extract_field("dnsName"),
            ),
            health_check: pulumi_gestalt_rust::__private::into_domain(
                o.extract_field("healthCheck"),
            ),
            idle_timeout: pulumi_gestalt_rust::__private::into_domain(
                o.extract_field("idleTimeout"),
            ),
            instances: pulumi_gestalt_rust::__private::into_domain(
                o.extract_field("instances"),
            ),
            internal: pulumi_gestalt_rust::__private::into_domain(
                o.extract_field("internal"),
            ),
            listeners: pulumi_gestalt_rust::__private::into_domain(
                o.extract_field("listeners"),
            ),
            name: pulumi_gestalt_rust::__private::into_domain(o.extract_field("name")),
            name_prefix: pulumi_gestalt_rust::__private::into_domain(
                o.extract_field("namePrefix"),
            ),
            security_groups: pulumi_gestalt_rust::__private::into_domain(
                o.extract_field("securityGroups"),
            ),
            source_security_group: pulumi_gestalt_rust::__private::into_domain(
                o.extract_field("sourceSecurityGroup"),
            ),
            source_security_group_id: pulumi_gestalt_rust::__private::into_domain(
                o.extract_field("sourceSecurityGroupId"),
            ),
            subnets: pulumi_gestalt_rust::__private::into_domain(
                o.extract_field("subnets"),
            ),
            tags: pulumi_gestalt_rust::__private::into_domain(o.extract_field("tags")),
            tags_all: pulumi_gestalt_rust::__private::into_domain(
                o.extract_field("tagsAll"),
            ),
            zone_id: pulumi_gestalt_rust::__private::into_domain(
                o.extract_field("zoneId"),
            ),
        }
    }
}
