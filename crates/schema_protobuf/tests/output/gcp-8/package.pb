
gcpGoogle Cloud"8.12.1*ëﬁ
:
memorystoreInstance!gcp:memorystore/instance:Instanceã§A Google Cloud Memorystore instance.



## Example Usage

### Memorystore Instance Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const producerNet = new gcp.compute.Network("producer_net", {
    name: "my-network",
    autoCreateSubnetworks: false,
});
const producerSubnet = new gcp.compute.Subnetwork("producer_subnet", {
    name: "my-subnet",
    ipCidrRange: "10.0.0.248/29",
    region: "us-central1",
    network: producerNet.id,
});
const _default = new gcp.networkconnectivity.ServiceConnectionPolicy("default", {
    name: "my-policy",
    location: "us-central1",
    serviceClass: "gcp-memorystore",
    description: "my basic service connection policy",
    network: producerNet.id,
    pscConfig: {
        subnetworks: [producerSubnet.id],
    },
});
const project = gcp.organizations.getProject({});
const instance_basic = new gcp.memorystore.Instance("instance-basic", {
    instanceId: "basic-instance",
    shardCount: 3,
    desiredPscAutoConnections: [{
        network: producerNet.id,
        projectId: project.then(project => project.projectId),
    }],
    location: "us-central1",
    deletionProtectionEnabled: false,
}, {
    dependsOn: [_default],
});
```
```python
import pulumi
import pulumi_gcp as gcp

producer_net = gcp.compute.Network("producer_net",
    name="my-network",
    auto_create_subnetworks=False)
producer_subnet = gcp.compute.Subnetwork("producer_subnet",
    name="my-subnet",
    ip_cidr_range="10.0.0.248/29",
    region="us-central1",
    network=producer_net.id)
default = gcp.networkconnectivity.ServiceConnectionPolicy("default",
    name="my-policy",
    location="us-central1",
    service_class="gcp-memorystore",
    description="my basic service connection policy",
    network=producer_net.id,
    psc_config={
        "subnetworks": [producer_subnet.id],
    })
project = gcp.organizations.get_project()
instance_basic = gcp.memorystore.Instance("instance-basic",
    instance_id="basic-instance",
    shard_count=3,
    desired_psc_auto_connections=[{
        "network": producer_net.id,
        "project_id": project.project_id,
    }],
    location="us-central1",
    deletion_protection_enabled=False,
    opts = pulumi.ResourceOptions(depends_on=[default]))
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var producerNet = new Gcp.Compute.Network("producer_net", new()
    {
        Name = "my-network",
        AutoCreateSubnetworks = false,
    });

    var producerSubnet = new Gcp.Compute.Subnetwork("producer_subnet", new()
    {
        Name = "my-subnet",
        IpCidrRange = "10.0.0.248/29",
        Region = "us-central1",
        Network = producerNet.Id,
    });

    var @default = new Gcp.NetworkConnectivity.ServiceConnectionPolicy("default", new()
    {
        Name = "my-policy",
        Location = "us-central1",
        ServiceClass = "gcp-memorystore",
        Description = "my basic service connection policy",
        Network = producerNet.Id,
        PscConfig = new Gcp.NetworkConnectivity.Inputs.ServiceConnectionPolicyPscConfigArgs
        {
            Subnetworks = new[]
            {
                producerSubnet.Id,
            },
        },
    });

    var project = Gcp.Organizations.GetProject.Invoke();

    var instance_basic = new Gcp.MemoryStore.Instance("instance-basic", new()
    {
        InstanceId = "basic-instance",
        ShardCount = 3,
        DesiredPscAutoConnections = new[]
        {
            new Gcp.MemoryStore.Inputs.InstanceDesiredPscAutoConnectionArgs
            {
                Network = producerNet.Id,
                ProjectId = project.Apply(getProjectResult => getProjectResult.ProjectId),
            },
        },
        Location = "us-central1",
        DeletionProtectionEnabled = false,
    }, new CustomResourceOptions
    {
        DependsOn =
        {
            @default,
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/memorystore"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkconnectivity"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		producerNet, err := compute.NewNetwork(ctx, "producer_net", &compute.NetworkArgs{
			Name:                  pulumi.String("my-network"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		producerSubnet, err := compute.NewSubnetwork(ctx, "producer_subnet", &compute.SubnetworkArgs{
			Name:        pulumi.String("my-subnet"),
			IpCidrRange: pulumi.String("10.0.0.248/29"),
			Region:      pulumi.String("us-central1"),
			Network:     producerNet.ID(),
		})
		if err != nil {
			return err
		}
		_, err = networkconnectivity.NewServiceConnectionPolicy(ctx, "default", &networkconnectivity.ServiceConnectionPolicyArgs{
			Name:         pulumi.String("my-policy"),
			Location:     pulumi.String("us-central1"),
			ServiceClass: pulumi.String("gcp-memorystore"),
			Description:  pulumi.String("my basic service connection policy"),
			Network:      producerNet.ID(),
			PscConfig: &networkconnectivity.ServiceConnectionPolicyPscConfigArgs{
				Subnetworks: pulumi.StringArray{
					producerSubnet.ID(),
				},
			},
		})
		if err != nil {
			return err
		}
		project, err := organizations.LookupProject(ctx, &organizations.LookupProjectArgs{}, nil)
		if err != nil {
			return err
		}
		_, err = memorystore.NewInstance(ctx, "instance-basic", &memorystore.InstanceArgs{
			InstanceId: pulumi.String("basic-instance"),
			ShardCount: pulumi.Int(3),
			DesiredPscAutoConnections: memorystore.InstanceDesiredPscAutoConnectionArray{
				&memorystore.InstanceDesiredPscAutoConnectionArgs{
					Network:   producerNet.ID(),
					ProjectId: pulumi.String(project.ProjectId),
				},
			},
			Location:                  pulumi.String("us-central1"),
			DeletionProtectionEnabled: pulumi.Bool(false),
		}, pulumi.DependsOn([]pulumi.Resource{
			_default,
		}))
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.Subnetwork;
import com.pulumi.gcp.compute.SubnetworkArgs;
import com.pulumi.gcp.networkconnectivity.ServiceConnectionPolicy;
import com.pulumi.gcp.networkconnectivity.ServiceConnectionPolicyArgs;
import com.pulumi.gcp.networkconnectivity.inputs.ServiceConnectionPolicyPscConfigArgs;
import com.pulumi.gcp.organizations.OrganizationsFunctions;
import com.pulumi.gcp.organizations.inputs.GetProjectArgs;
import com.pulumi.gcp.memorystore.Instance;
import com.pulumi.gcp.memorystore.InstanceArgs;
import com.pulumi.gcp.memorystore.inputs.InstanceDesiredPscAutoConnectionArgs;
import com.pulumi.resources.CustomResourceOptions;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var producerNet = new Network("producerNet", NetworkArgs.builder()
            .name("my-network")
            .autoCreateSubnetworks(false)
            .build());

        var producerSubnet = new Subnetwork("producerSubnet", SubnetworkArgs.builder()
            .name("my-subnet")
            .ipCidrRange("10.0.0.248/29")
            .region("us-central1")
            .network(producerNet.id())
            .build());

        var default_ = new ServiceConnectionPolicy("default", ServiceConnectionPolicyArgs.builder()
            .name("my-policy")
            .location("us-central1")
            .serviceClass("gcp-memorystore")
            .description("my basic service connection policy")
            .network(producerNet.id())
            .pscConfig(ServiceConnectionPolicyPscConfigArgs.builder()
                .subnetworks(producerSubnet.id())
                .build())
            .build());

        final var project = OrganizationsFunctions.getProject();

        var instance_basic = new Instance("instance-basic", InstanceArgs.builder()
            .instanceId("basic-instance")
            .shardCount(3)
            .desiredPscAutoConnections(InstanceDesiredPscAutoConnectionArgs.builder()
                .network(producerNet.id())
                .projectId(project.applyValue(getProjectResult -> getProjectResult.projectId()))
                .build())
            .location("us-central1")
            .deletionProtectionEnabled(false)
            .build(), CustomResourceOptions.builder()
                .dependsOn(default_)
                .build());

    }
}
```
```yaml
resources:
  instance-basic:
    type: gcp:memorystore:Instance
    properties:
      instanceId: basic-instance
      shardCount: 3
      desiredPscAutoConnections:
        - network: ${producerNet.id}
          projectId: ${project.projectId}
      location: us-central1
      deletionProtectionEnabled: false
    options:
      dependsOn:
        - ${default}
  default:
    type: gcp:networkconnectivity:ServiceConnectionPolicy
    properties:
      name: my-policy
      location: us-central1
      serviceClass: gcp-memorystore
      description: my basic service connection policy
      network: ${producerNet.id}
      pscConfig:
        subnetworks:
          - ${producerSubnet.id}
  producerSubnet:
    type: gcp:compute:Subnetwork
    name: producer_subnet
    properties:
      name: my-subnet
      ipCidrRange: 10.0.0.248/29
      region: us-central1
      network: ${producerNet.id}
  producerNet:
    type: gcp:compute:Network
    name: producer_net
    properties:
      name: my-network
      autoCreateSubnetworks: false
variables:
  project:
    fn::invoke:
      function: gcp:organizations:getProject
      arguments: {}
```
<!--End PulumiCodeChooser -->
### Memorystore Instance Full


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const producerNet = new gcp.compute.Network("producer_net", {
    name: "my-network",
    autoCreateSubnetworks: false,
});
const producerSubnet = new gcp.compute.Subnetwork("producer_subnet", {
    name: "my-subnet",
    ipCidrRange: "10.0.0.248/29",
    region: "us-central1",
    network: producerNet.id,
});
const _default = new gcp.networkconnectivity.ServiceConnectionPolicy("default", {
    name: "my-policy",
    location: "us-central1",
    serviceClass: "gcp-memorystore",
    description: "my basic service connection policy",
    network: producerNet.id,
    pscConfig: {
        subnetworks: [producerSubnet.id],
    },
});
const project = gcp.organizations.getProject({});
const instance_full = new gcp.memorystore.Instance("instance-full", {
    instanceId: "full-instance",
    shardCount: 3,
    desiredPscAutoConnections: [{
        network: producerNet.id,
        projectId: project.then(project => project.projectId),
    }],
    location: "us-central1",
    replicaCount: 2,
    nodeType: "SHARED_CORE_NANO",
    transitEncryptionMode: "TRANSIT_ENCRYPTION_DISABLED",
    authorizationMode: "AUTH_DISABLED",
    engineConfigs: {
        "maxmemory-policy": "volatile-ttl",
    },
    zoneDistributionConfig: {
        mode: "SINGLE_ZONE",
        zone: "us-central1-b",
    },
    engineVersion: "VALKEY_7_2",
    deletionProtectionEnabled: false,
    mode: "CLUSTER",
    persistenceConfig: {
        mode: "RDB",
        rdbConfig: {
            rdbSnapshotPeriod: "ONE_HOUR",
            rdbSnapshotStartTime: "2024-10-02T15:01:23Z",
        },
    },
    labels: {
        abc: "xyz",
    },
}, {
    dependsOn: [_default],
});
```
```python
import pulumi
import pulumi_gcp as gcp

producer_net = gcp.compute.Network("producer_net",
    name="my-network",
    auto_create_subnetworks=False)
producer_subnet = gcp.compute.Subnetwork("producer_subnet",
    name="my-subnet",
    ip_cidr_range="10.0.0.248/29",
    region="us-central1",
    network=producer_net.id)
default = gcp.networkconnectivity.ServiceConnectionPolicy("default",
    name="my-policy",
    location="us-central1",
    service_class="gcp-memorystore",
    description="my basic service connection policy",
    network=producer_net.id,
    psc_config={
        "subnetworks": [producer_subnet.id],
    })
project = gcp.organizations.get_project()
instance_full = gcp.memorystore.Instance("instance-full",
    instance_id="full-instance",
    shard_count=3,
    desired_psc_auto_connections=[{
        "network": producer_net.id,
        "project_id": project.project_id,
    }],
    location="us-central1",
    replica_count=2,
    node_type="SHARED_CORE_NANO",
    transit_encryption_mode="TRANSIT_ENCRYPTION_DISABLED",
    authorization_mode="AUTH_DISABLED",
    engine_configs={
        "maxmemory-policy": "volatile-ttl",
    },
    zone_distribution_config={
        "mode": "SINGLE_ZONE",
        "zone": "us-central1-b",
    },
    engine_version="VALKEY_7_2",
    deletion_protection_enabled=False,
    mode="CLUSTER",
    persistence_config={
        "mode": "RDB",
        "rdb_config": {
            "rdb_snapshot_period": "ONE_HOUR",
            "rdb_snapshot_start_time": "2024-10-02T15:01:23Z",
        },
    },
    labels={
        "abc": "xyz",
    },
    opts = pulumi.ResourceOptions(depends_on=[default]))
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var producerNet = new Gcp.Compute.Network("producer_net", new()
    {
        Name = "my-network",
        AutoCreateSubnetworks = false,
    });

    var producerSubnet = new Gcp.Compute.Subnetwork("producer_subnet", new()
    {
        Name = "my-subnet",
        IpCidrRange = "10.0.0.248/29",
        Region = "us-central1",
        Network = producerNet.Id,
    });

    var @default = new Gcp.NetworkConnectivity.ServiceConnectionPolicy("default", new()
    {
        Name = "my-policy",
        Location = "us-central1",
        ServiceClass = "gcp-memorystore",
        Description = "my basic service connection policy",
        Network = producerNet.Id,
        PscConfig = new Gcp.NetworkConnectivity.Inputs.ServiceConnectionPolicyPscConfigArgs
        {
            Subnetworks = new[]
            {
                producerSubnet.Id,
            },
        },
    });

    var project = Gcp.Organizations.GetProject.Invoke();

    var instance_full = new Gcp.MemoryStore.Instance("instance-full", new()
    {
        InstanceId = "full-instance",
        ShardCount = 3,
        DesiredPscAutoConnections = new[]
        {
            new Gcp.MemoryStore.Inputs.InstanceDesiredPscAutoConnectionArgs
            {
                Network = producerNet.Id,
                ProjectId = project.Apply(getProjectResult => getProjectResult.ProjectId),
            },
        },
        Location = "us-central1",
        ReplicaCount = 2,
        NodeType = "SHARED_CORE_NANO",
        TransitEncryptionMode = "TRANSIT_ENCRYPTION_DISABLED",
        AuthorizationMode = "AUTH_DISABLED",
        EngineConfigs = 
        {
            { "maxmemory-policy", "volatile-ttl" },
        },
        ZoneDistributionConfig = new Gcp.MemoryStore.Inputs.InstanceZoneDistributionConfigArgs
        {
            Mode = "SINGLE_ZONE",
            Zone = "us-central1-b",
        },
        EngineVersion = "VALKEY_7_2",
        DeletionProtectionEnabled = false,
        Mode = "CLUSTER",
        PersistenceConfig = new Gcp.MemoryStore.Inputs.InstancePersistenceConfigArgs
        {
            Mode = "RDB",
            RdbConfig = new Gcp.MemoryStore.Inputs.InstancePersistenceConfigRdbConfigArgs
            {
                RdbSnapshotPeriod = "ONE_HOUR",
                RdbSnapshotStartTime = "2024-10-02T15:01:23Z",
            },
        },
        Labels = 
        {
            { "abc", "xyz" },
        },
    }, new CustomResourceOptions
    {
        DependsOn =
        {
            @default,
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/memorystore"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkconnectivity"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		producerNet, err := compute.NewNetwork(ctx, "producer_net", &compute.NetworkArgs{
			Name:                  pulumi.String("my-network"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		producerSubnet, err := compute.NewSubnetwork(ctx, "producer_subnet", &compute.SubnetworkArgs{
			Name:        pulumi.String("my-subnet"),
			IpCidrRange: pulumi.String("10.0.0.248/29"),
			Region:      pulumi.String("us-central1"),
			Network:     producerNet.ID(),
		})
		if err != nil {
			return err
		}
		_, err = networkconnectivity.NewServiceConnectionPolicy(ctx, "default", &networkconnectivity.ServiceConnectionPolicyArgs{
			Name:         pulumi.String("my-policy"),
			Location:     pulumi.String("us-central1"),
			ServiceClass: pulumi.String("gcp-memorystore"),
			Description:  pulumi.String("my basic service connection policy"),
			Network:      producerNet.ID(),
			PscConfig: &networkconnectivity.ServiceConnectionPolicyPscConfigArgs{
				Subnetworks: pulumi.StringArray{
					producerSubnet.ID(),
				},
			},
		})
		if err != nil {
			return err
		}
		project, err := organizations.LookupProject(ctx, &organizations.LookupProjectArgs{}, nil)
		if err != nil {
			return err
		}
		_, err = memorystore.NewInstance(ctx, "instance-full", &memorystore.InstanceArgs{
			InstanceId: pulumi.String("full-instance"),
			ShardCount: pulumi.Int(3),
			DesiredPscAutoConnections: memorystore.InstanceDesiredPscAutoConnectionArray{
				&memorystore.InstanceDesiredPscAutoConnectionArgs{
					Network:   producerNet.ID(),
					ProjectId: pulumi.String(project.ProjectId),
				},
			},
			Location:              pulumi.String("us-central1"),
			ReplicaCount:          pulumi.Int(2),
			NodeType:              pulumi.String("SHARED_CORE_NANO"),
			TransitEncryptionMode: pulumi.String("TRANSIT_ENCRYPTION_DISABLED"),
			AuthorizationMode:     pulumi.String("AUTH_DISABLED"),
			EngineConfigs: pulumi.StringMap{
				"maxmemory-policy": pulumi.String("volatile-ttl"),
			},
			ZoneDistributionConfig: &memorystore.InstanceZoneDistributionConfigArgs{
				Mode: pulumi.String("SINGLE_ZONE"),
				Zone: pulumi.String("us-central1-b"),
			},
			EngineVersion:             pulumi.String("VALKEY_7_2"),
			DeletionProtectionEnabled: pulumi.Bool(false),
			Mode:                      pulumi.String("CLUSTER"),
			PersistenceConfig: &memorystore.InstancePersistenceConfigArgs{
				Mode: pulumi.String("RDB"),
				RdbConfig: &memorystore.InstancePersistenceConfigRdbConfigArgs{
					RdbSnapshotPeriod:    pulumi.String("ONE_HOUR"),
					RdbSnapshotStartTime: pulumi.String("2024-10-02T15:01:23Z"),
				},
			},
			Labels: pulumi.StringMap{
				"abc": pulumi.String("xyz"),
			},
		}, pulumi.DependsOn([]pulumi.Resource{
			_default,
		}))
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.Subnetwork;
import com.pulumi.gcp.compute.SubnetworkArgs;
import com.pulumi.gcp.networkconnectivity.ServiceConnectionPolicy;
import com.pulumi.gcp.networkconnectivity.ServiceConnectionPolicyArgs;
import com.pulumi.gcp.networkconnectivity.inputs.ServiceConnectionPolicyPscConfigArgs;
import com.pulumi.gcp.organizations.OrganizationsFunctions;
import com.pulumi.gcp.organizations.inputs.GetProjectArgs;
import com.pulumi.gcp.memorystore.Instance;
import com.pulumi.gcp.memorystore.InstanceArgs;
import com.pulumi.gcp.memorystore.inputs.InstanceDesiredPscAutoConnectionArgs;
import com.pulumi.gcp.memorystore.inputs.InstanceZoneDistributionConfigArgs;
import com.pulumi.gcp.memorystore.inputs.InstancePersistenceConfigArgs;
import com.pulumi.gcp.memorystore.inputs.InstancePersistenceConfigRdbConfigArgs;
import com.pulumi.resources.CustomResourceOptions;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var producerNet = new Network("producerNet", NetworkArgs.builder()
            .name("my-network")
            .autoCreateSubnetworks(false)
            .build());

        var producerSubnet = new Subnetwork("producerSubnet", SubnetworkArgs.builder()
            .name("my-subnet")
            .ipCidrRange("10.0.0.248/29")
            .region("us-central1")
            .network(producerNet.id())
            .build());

        var default_ = new ServiceConnectionPolicy("default", ServiceConnectionPolicyArgs.builder()
            .name("my-policy")
            .location("us-central1")
            .serviceClass("gcp-memorystore")
            .description("my basic service connection policy")
            .network(producerNet.id())
            .pscConfig(ServiceConnectionPolicyPscConfigArgs.builder()
                .subnetworks(producerSubnet.id())
                .build())
            .build());

        final var project = OrganizationsFunctions.getProject();

        var instance_full = new Instance("instance-full", InstanceArgs.builder()
            .instanceId("full-instance")
            .shardCount(3)
            .desiredPscAutoConnections(InstanceDesiredPscAutoConnectionArgs.builder()
                .network(producerNet.id())
                .projectId(project.applyValue(getProjectResult -> getProjectResult.projectId()))
                .build())
            .location("us-central1")
            .replicaCount(2)
            .nodeType("SHARED_CORE_NANO")
            .transitEncryptionMode("TRANSIT_ENCRYPTION_DISABLED")
            .authorizationMode("AUTH_DISABLED")
            .engineConfigs(Map.of("maxmemory-policy", "volatile-ttl"))
            .zoneDistributionConfig(InstanceZoneDistributionConfigArgs.builder()
                .mode("SINGLE_ZONE")
                .zone("us-central1-b")
                .build())
            .engineVersion("VALKEY_7_2")
            .deletionProtectionEnabled(false)
            .mode("CLUSTER")
            .persistenceConfig(InstancePersistenceConfigArgs.builder()
                .mode("RDB")
                .rdbConfig(InstancePersistenceConfigRdbConfigArgs.builder()
                    .rdbSnapshotPeriod("ONE_HOUR")
                    .rdbSnapshotStartTime("2024-10-02T15:01:23Z")
                    .build())
                .build())
            .labels(Map.of("abc", "xyz"))
            .build(), CustomResourceOptions.builder()
                .dependsOn(default_)
                .build());

    }
}
```
```yaml
resources:
  instance-full:
    type: gcp:memorystore:Instance
    properties:
      instanceId: full-instance
      shardCount: 3
      desiredPscAutoConnections:
        - network: ${producerNet.id}
          projectId: ${project.projectId}
      location: us-central1
      replicaCount: 2
      nodeType: SHARED_CORE_NANO
      transitEncryptionMode: TRANSIT_ENCRYPTION_DISABLED
      authorizationMode: AUTH_DISABLED
      engineConfigs:
        maxmemory-policy: volatile-ttl
      zoneDistributionConfig:
        mode: SINGLE_ZONE
        zone: us-central1-b
      engineVersion: VALKEY_7_2
      deletionProtectionEnabled: false
      mode: CLUSTER
      persistenceConfig:
        mode: RDB
        rdbConfig:
          rdbSnapshotPeriod: ONE_HOUR
          rdbSnapshotStartTime: 2024-10-02T15:01:23Z
      labels:
        abc: xyz
    options:
      dependsOn:
        - ${default}
  default:
    type: gcp:networkconnectivity:ServiceConnectionPolicy
    properties:
      name: my-policy
      location: us-central1
      serviceClass: gcp-memorystore
      description: my basic service connection policy
      network: ${producerNet.id}
      pscConfig:
        subnetworks:
          - ${producerSubnet.id}
  producerSubnet:
    type: gcp:compute:Subnetwork
    name: producer_subnet
    properties:
      name: my-subnet
      ipCidrRange: 10.0.0.248/29
      region: us-central1
      network: ${producerNet.id}
  producerNet:
    type: gcp:compute:Network
    name: producer_net
    properties:
      name: my-network
      autoCreateSubnetworks: false
variables:
  project:
    fn::invoke:
      function: gcp:organizations:getProject
      arguments: {}
```
<!--End PulumiCodeChooser -->
### Memorystore Instance Persistence Aof


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const producerNet = new gcp.compute.Network("producer_net", {
    name: "my-network",
    autoCreateSubnetworks: false,
});
const producerSubnet = new gcp.compute.Subnetwork("producer_subnet", {
    name: "my-subnet",
    ipCidrRange: "10.0.0.248/29",
    region: "us-central1",
    network: producerNet.id,
});
const _default = new gcp.networkconnectivity.ServiceConnectionPolicy("default", {
    name: "my-policy",
    location: "us-central1",
    serviceClass: "gcp-memorystore",
    description: "my basic service connection policy",
    network: producerNet.id,
    pscConfig: {
        subnetworks: [producerSubnet.id],
    },
});
const project = gcp.organizations.getProject({});
const instance_persistence_aof = new gcp.memorystore.Instance("instance-persistence-aof", {
    instanceId: "aof-instance",
    shardCount: 3,
    desiredPscAutoConnections: [{
        network: producerNet.id,
        projectId: project.then(project => project.projectId),
    }],
    location: "us-central1",
    persistenceConfig: {
        mode: "AOF",
        aofConfig: {
            appendFsync: "EVERY_SEC",
        },
    },
    deletionProtectionEnabled: false,
}, {
    dependsOn: [_default],
});
```
```python
import pulumi
import pulumi_gcp as gcp

producer_net = gcp.compute.Network("producer_net",
    name="my-network",
    auto_create_subnetworks=False)
producer_subnet = gcp.compute.Subnetwork("producer_subnet",
    name="my-subnet",
    ip_cidr_range="10.0.0.248/29",
    region="us-central1",
    network=producer_net.id)
default = gcp.networkconnectivity.ServiceConnectionPolicy("default",
    name="my-policy",
    location="us-central1",
    service_class="gcp-memorystore",
    description="my basic service connection policy",
    network=producer_net.id,
    psc_config={
        "subnetworks": [producer_subnet.id],
    })
project = gcp.organizations.get_project()
instance_persistence_aof = gcp.memorystore.Instance("instance-persistence-aof",
    instance_id="aof-instance",
    shard_count=3,
    desired_psc_auto_connections=[{
        "network": producer_net.id,
        "project_id": project.project_id,
    }],
    location="us-central1",
    persistence_config={
        "mode": "AOF",
        "aof_config": {
            "append_fsync": "EVERY_SEC",
        },
    },
    deletion_protection_enabled=False,
    opts = pulumi.ResourceOptions(depends_on=[default]))
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var producerNet = new Gcp.Compute.Network("producer_net", new()
    {
        Name = "my-network",
        AutoCreateSubnetworks = false,
    });

    var producerSubnet = new Gcp.Compute.Subnetwork("producer_subnet", new()
    {
        Name = "my-subnet",
        IpCidrRange = "10.0.0.248/29",
        Region = "us-central1",
        Network = producerNet.Id,
    });

    var @default = new Gcp.NetworkConnectivity.ServiceConnectionPolicy("default", new()
    {
        Name = "my-policy",
        Location = "us-central1",
        ServiceClass = "gcp-memorystore",
        Description = "my basic service connection policy",
        Network = producerNet.Id,
        PscConfig = new Gcp.NetworkConnectivity.Inputs.ServiceConnectionPolicyPscConfigArgs
        {
            Subnetworks = new[]
            {
                producerSubnet.Id,
            },
        },
    });

    var project = Gcp.Organizations.GetProject.Invoke();

    var instance_persistence_aof = new Gcp.MemoryStore.Instance("instance-persistence-aof", new()
    {
        InstanceId = "aof-instance",
        ShardCount = 3,
        DesiredPscAutoConnections = new[]
        {
            new Gcp.MemoryStore.Inputs.InstanceDesiredPscAutoConnectionArgs
            {
                Network = producerNet.Id,
                ProjectId = project.Apply(getProjectResult => getProjectResult.ProjectId),
            },
        },
        Location = "us-central1",
        PersistenceConfig = new Gcp.MemoryStore.Inputs.InstancePersistenceConfigArgs
        {
            Mode = "AOF",
            AofConfig = new Gcp.MemoryStore.Inputs.InstancePersistenceConfigAofConfigArgs
            {
                AppendFsync = "EVERY_SEC",
            },
        },
        DeletionProtectionEnabled = false,
    }, new CustomResourceOptions
    {
        DependsOn =
        {
            @default,
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/memorystore"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkconnectivity"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		producerNet, err := compute.NewNetwork(ctx, "producer_net", &compute.NetworkArgs{
			Name:                  pulumi.String("my-network"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		producerSubnet, err := compute.NewSubnetwork(ctx, "producer_subnet", &compute.SubnetworkArgs{
			Name:        pulumi.String("my-subnet"),
			IpCidrRange: pulumi.String("10.0.0.248/29"),
			Region:      pulumi.String("us-central1"),
			Network:     producerNet.ID(),
		})
		if err != nil {
			return err
		}
		_, err = networkconnectivity.NewServiceConnectionPolicy(ctx, "default", &networkconnectivity.ServiceConnectionPolicyArgs{
			Name:         pulumi.String("my-policy"),
			Location:     pulumi.String("us-central1"),
			ServiceClass: pulumi.String("gcp-memorystore"),
			Description:  pulumi.String("my basic service connection policy"),
			Network:      producerNet.ID(),
			PscConfig: &networkconnectivity.ServiceConnectionPolicyPscConfigArgs{
				Subnetworks: pulumi.StringArray{
					producerSubnet.ID(),
				},
			},
		})
		if err != nil {
			return err
		}
		project, err := organizations.LookupProject(ctx, &organizations.LookupProjectArgs{}, nil)
		if err != nil {
			return err
		}
		_, err = memorystore.NewInstance(ctx, "instance-persistence-aof", &memorystore.InstanceArgs{
			InstanceId: pulumi.String("aof-instance"),
			ShardCount: pulumi.Int(3),
			DesiredPscAutoConnections: memorystore.InstanceDesiredPscAutoConnectionArray{
				&memorystore.InstanceDesiredPscAutoConnectionArgs{
					Network:   producerNet.ID(),
					ProjectId: pulumi.String(project.ProjectId),
				},
			},
			Location: pulumi.String("us-central1"),
			PersistenceConfig: &memorystore.InstancePersistenceConfigArgs{
				Mode: pulumi.String("AOF"),
				AofConfig: &memorystore.InstancePersistenceConfigAofConfigArgs{
					AppendFsync: pulumi.String("EVERY_SEC"),
				},
			},
			DeletionProtectionEnabled: pulumi.Bool(false),
		}, pulumi.DependsOn([]pulumi.Resource{
			_default,
		}))
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.Subnetwork;
import com.pulumi.gcp.compute.SubnetworkArgs;
import com.pulumi.gcp.networkconnectivity.ServiceConnectionPolicy;
import com.pulumi.gcp.networkconnectivity.ServiceConnectionPolicyArgs;
import com.pulumi.gcp.networkconnectivity.inputs.ServiceConnectionPolicyPscConfigArgs;
import com.pulumi.gcp.organizations.OrganizationsFunctions;
import com.pulumi.gcp.organizations.inputs.GetProjectArgs;
import com.pulumi.gcp.memorystore.Instance;
import com.pulumi.gcp.memorystore.InstanceArgs;
import com.pulumi.gcp.memorystore.inputs.InstanceDesiredPscAutoConnectionArgs;
import com.pulumi.gcp.memorystore.inputs.InstancePersistenceConfigArgs;
import com.pulumi.gcp.memorystore.inputs.InstancePersistenceConfigAofConfigArgs;
import com.pulumi.resources.CustomResourceOptions;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var producerNet = new Network("producerNet", NetworkArgs.builder()
            .name("my-network")
            .autoCreateSubnetworks(false)
            .build());

        var producerSubnet = new Subnetwork("producerSubnet", SubnetworkArgs.builder()
            .name("my-subnet")
            .ipCidrRange("10.0.0.248/29")
            .region("us-central1")
            .network(producerNet.id())
            .build());

        var default_ = new ServiceConnectionPolicy("default", ServiceConnectionPolicyArgs.builder()
            .name("my-policy")
            .location("us-central1")
            .serviceClass("gcp-memorystore")
            .description("my basic service connection policy")
            .network(producerNet.id())
            .pscConfig(ServiceConnectionPolicyPscConfigArgs.builder()
                .subnetworks(producerSubnet.id())
                .build())
            .build());

        final var project = OrganizationsFunctions.getProject();

        var instance_persistence_aof = new Instance("instance-persistence-aof", InstanceArgs.builder()
            .instanceId("aof-instance")
            .shardCount(3)
            .desiredPscAutoConnections(InstanceDesiredPscAutoConnectionArgs.builder()
                .network(producerNet.id())
                .projectId(project.applyValue(getProjectResult -> getProjectResult.projectId()))
                .build())
            .location("us-central1")
            .persistenceConfig(InstancePersistenceConfigArgs.builder()
                .mode("AOF")
                .aofConfig(InstancePersistenceConfigAofConfigArgs.builder()
                    .appendFsync("EVERY_SEC")
                    .build())
                .build())
            .deletionProtectionEnabled(false)
            .build(), CustomResourceOptions.builder()
                .dependsOn(default_)
                .build());

    }
}
```
```yaml
resources:
  instance-persistence-aof:
    type: gcp:memorystore:Instance
    properties:
      instanceId: aof-instance
      shardCount: 3
      desiredPscAutoConnections:
        - network: ${producerNet.id}
          projectId: ${project.projectId}
      location: us-central1
      persistenceConfig:
        mode: AOF
        aofConfig:
          appendFsync: EVERY_SEC
      deletionProtectionEnabled: false
    options:
      dependsOn:
        - ${default}
  default:
    type: gcp:networkconnectivity:ServiceConnectionPolicy
    properties:
      name: my-policy
      location: us-central1
      serviceClass: gcp-memorystore
      description: my basic service connection policy
      network: ${producerNet.id}
      pscConfig:
        subnetworks:
          - ${producerSubnet.id}
  producerSubnet:
    type: gcp:compute:Subnetwork
    name: producer_subnet
    properties:
      name: my-subnet
      ipCidrRange: 10.0.0.248/29
      region: us-central1
      network: ${producerNet.id}
  producerNet:
    type: gcp:compute:Network
    name: producer_net
    properties:
      name: my-network
      autoCreateSubnetworks: false
variables:
  project:
    fn::invoke:
      function: gcp:organizations:getProject
      arguments: {}
```
<!--End PulumiCodeChooser -->

## Import

Instance can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/instances/{{instance_id}}`

* `{{project}}/{{location}}/{{instance_id}}`

* `{{location}}/{{instance_id}}`

When using the `pulumi import` command, Instance can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:memorystore/instance:Instance default projects/{{project}}/locations/{{location}}/instances/{{instance_id}}
```

```sh
$ pulumi import gcp:memorystore/instance:Instance default {{project}}/{{location}}/{{instance_id}}
```

```sh
$ pulumi import gcp:memorystore/instance:Instance default {{location}}/{{instance_id}}
```

|
authorizationModeB" aOptional. Immutable. Authorization mode of the instance. Possible values:
AUTH_DISABLED
IAM_AUTH
`
deletionProtectionEnabledB
 =Optional. If set to true deletion of the instance will fail.
Ú
desiredPscAutoConnectionsã*à:Ö
Ç
memorystore InstanceDesiredPscAutoConnectionQgcp:memorystore/InstanceDesiredPscAutoConnection:InstanceDesiredPscAutoConnectionGRequired. Immutable. User inputs for the auto-created PSC connections.
Y
engineConfigsB2" @Optional. User-provided engine configurations for the instance.
L
engineVersionB" 5Optional. Immutable. Engine version of the instance.
Ñ

instanceId" ÒRequired. The ID to use for the instance, which will become the final component of
the instance's resource name.
This value is subject to the following restrictions:
* Must be 4-63 characters in length
* Must begin with a letter or digit
* Must contain only lowercase letters, digits, and hyphens
* Must not end with a hyphen
* Must be unique within a location


- - -
è
labelsB2" ¸Optional. Labels to represent user-provided metadata.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
˚
location" ÍResource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122. See documentation for resource type `memorystore.googleapis.com/CertificateAuthority`.
Å
modeB" sOptional. Standalone or cluster.
Possible values:
CLUSTER
STANDALONE
Possible values are: `CLUSTER`, `STANDALONE`.
™
nodeTypeB" óOptional. Immutable. Machine type for individual nodes of the instance.
Possible values:
SHARED_CORE_NANO
HIGHMEM_MEDIUM
HIGHMEM_XLARGE
STANDARD_SMALL
ﬁ
persistenceConfigsBq:o
m
memorystoreInstancePersistenceConfigCgcp:memorystore/InstancePersistenceConfig:InstancePersistenceConfigTRepresents persistence configuration for a instance.
Structure is documented below.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
i
replicaCountB SOptional. Number of replica nodes per shard. If omitted the default is 0 replicas.
?

shardCount -Required. Number of shards for the instance.
§
transitEncryptionModeB" ÑOptional. Immutable. In-transit encryption mode of the instance.
Possible values:
TRANSIT_ENCRYPTION_DISABLED
SERVER_AUTHENTICATION
Ö
zoneDistributionConfigÉBÄ:~
|
memorystoreInstanceZoneDistributionConfigMgcp:memorystore/InstanceZoneDistributionConfig:InstanceZoneDistributionConfigeZone distribution configuration for allocation of instance resources.
Structure is documented below.
"z
authorizationMode" aOptional. Immutable. Authorization mode of the instance. Possible values:
AUTH_DISABLED
IAM_AUTH
"C

createTime" 1Output only. Creation timestamp of the instance.
"`
deletionProtectionEnabledB
 =Optional. If set to true deletion of the instance will fail.
"Ú
desiredPscAutoConnectionsã*à:Ö
Ç
memorystore InstanceDesiredPscAutoConnectionQgcp:memorystore/InstanceDesiredPscAutoConnection:InstanceDesiredPscAutoConnectionGRequired. Immutable. User inputs for the auto-created PSC connections.
"£
discoveryEndpointss*q:o
m
memorystoreInstanceDiscoveryEndpointCgcp:memorystore/InstanceDiscoveryEndpoint:InstanceDiscoveryEndpointóOutput only. Endpoints clients can connect to the instance through. Currently only one
discovery endpoint is supported.
Structure is documented below.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"3
	endpoints**:" Endpoints for the instance.
"Y
engineConfigsB2" @Optional. User-provided engine configurations for the instance.
"J
engineVersion" 5Optional. Immutable. Engine version of the instance.
"Ñ

instanceId" ÒRequired. The ID to use for the instance, which will become the final component of
the instance's resource name.
This value is subject to the following restrictions:
* Must be 4-63 characters in length
* Must begin with a letter or digit
* Must contain only lowercase letters, digits, and hyphens
* Must not end with a hyphen
* Must be unique within a location


- - -
"è
labelsB2" ¸Optional. Labels to represent user-provided metadata.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"˚
location" ÍResource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122. See documentation for resource type `memorystore.googleapis.com/CertificateAuthority`.
"
mode" sOptional. Standalone or cluster.
Possible values:
CLUSTER
STANDALONE
Possible values are: `CLUSTER`, `STANDALONE`.
"z
name" nIdentifier. Unique name of the instance.
Format: projects/{project}/locations/{location}/instances/{instance}
"¬
nodeConfigs^*\:Z
X
memorystoreInstanceNodeConfig5gcp:memorystore/InstanceNodeConfig:InstanceNodeConfigSRepresents configuration for nodes of the instance.
Structure is documented below.
"®
nodeType" óOptional. Immutable. Machine type for individual nodes of the instance.
Possible values:
SHARED_CORE_NANO
HIGHMEM_MEDIUM
HIGHMEM_XLARGE
STANDARD_SMALL
"‹
persistenceConfigq:o
m
memorystoreInstancePersistenceConfigCgcp:memorystore/InstancePersistenceConfig:InstancePersistenceConfigTRepresents persistence configuration for a instance.
Structure is documented below.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"˝
pscAutoConnectionss*q:o
m
memorystoreInstancePscAutoConnectionCgcp:memorystore/InstancePscAutoConnection:InstancePscAutoConnectionrOutput only. User inputs and resource details of the auto-created PSC connections.
Structure is documented below.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"g
replicaCount SOptional. Number of replica nodes per shard. If omitted the default is 0 replicas.
"?

shardCount -Required. Number of shards for the instance.
"l
state" _Output only. Current state of the instance.
Possible values:
CREATING
ACTIVE
UPDATING
DELETING
"¬

stateInfos[*Y:W
U
memorystoreInstanceStateInfo3gcp:memorystore/InstanceStateInfo:InstanceStateInfoWAdditional information about the state of the instance.
Structure is documented below.
"¢
transitEncryptionMode" ÑOptional. Immutable. In-transit encryption mode of the instance.
Possible values:
TRANSIT_ENCRYPTION_DISABLED
SERVER_AUTHENTICATION
"M
uid" BOutput only. System assigned, unique identifier for the instance.
"H

updateTime" 6Output only. Latest update timestamp of the instance.
"Ç
zoneDistributionConfigÄ:~
|
memorystoreInstanceZoneDistributionConfigMgcp:memorystore/InstanceZoneDistributionConfig:InstanceZoneDistributionConfigeZone distribution configuration for allocation of instance resources.
Structure is documented below.
*À0
9
migrationcenterGroupgcp:migrationcenter/group:Group—A resource that represents an asset group. The purpose of an asset group is to bundle a set of assets that have something in common, while allowing users to add annotations to the group.



## Example Usage

### Migration Group Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.migrationcenter.Group("default", {
    location: "us-central1",
    groupId: "group-test",
    description: "Terraform integration test description",
    displayName: "Terraform integration test display",
    labels: {
        key: "value",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.migrationcenter.Group("default",
    location="us-central1",
    group_id="group-test",
    description="Terraform integration test description",
    display_name="Terraform integration test display",
    labels={
        "key": "value",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.MigrationCenter.Group("default", new()
    {
        Location = "us-central1",
        GroupId = "group-test",
        Description = "Terraform integration test description",
        DisplayName = "Terraform integration test display",
        Labels = 
        {
            { "key", "value" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/migrationcenter"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := migrationcenter.NewGroup(ctx, "default", &migrationcenter.GroupArgs{
			Location:    pulumi.String("us-central1"),
			GroupId:     pulumi.String("group-test"),
			Description: pulumi.String("Terraform integration test description"),
			DisplayName: pulumi.String("Terraform integration test display"),
			Labels: pulumi.StringMap{
				"key": pulumi.String("value"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.migrationcenter.Group;
import com.pulumi.gcp.migrationcenter.GroupArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new Group("default", GroupArgs.builder()
            .location("us-central1")
            .groupId("group-test")
            .description("Terraform integration test description")
            .displayName("Terraform integration test display")
            .labels(Map.of("key", "value"))
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:migrationcenter:Group
    properties:
      location: us-central1
      groupId: group-test
      description: Terraform integration test description
      displayName: Terraform integration test display
      labels:
        key: value
```
<!--End PulumiCodeChooser -->

## Import

Group can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/groups/{{group_id}}`

* `{{project}}/{{location}}/{{group_id}}`

* `{{location}}/{{group_id}}`

When using the `pulumi import` command, Group can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:migrationcenter/group:Group default projects/{{project}}/locations/{{location}}/groups/{{group_id}}
```

```sh
$ pulumi import gcp:migrationcenter/group:Group default {{project}}/{{location}}/{{group_id}}
```

```sh
$ pulumi import gcp:migrationcenter/group:Group default {{location}}/{{group_id}}
```

=
descriptionB" (Optional. The description of the group.
;
displayNameB" &Optional. User-friendly display name.
¡
groupId" ±Required. User specified ID for the group. It will become the last component of the group name. The ID must be unique within the project, must conform with RFC-1034, is restricted to lower-cased letters, and has a maximum length of 63 characters. The ID must match the regular expression: `a-z?`.


- - -
Ù
labelsB2" ·Labels as key value pairs.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
+
location" The location of the group.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"I

createTime" 7Output only. The timestamp when the group was created.
"=
descriptionB" (Optional. The description of the group.
";
displayNameB" &Optional. User-friendly display name.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"¡
groupId" ±Required. User specified ID for the group. It will become the last component of the group name. The ID must be unique within the project, must conform with RFC-1034, is restricted to lower-cased letters, and has a maximum length of 63 characters. The ID must match the regular expression: `a-z?`.


- - -
"Ù
labelsB2" ·Labels as key value pairs.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"+
location" The location of the group.
"0
name" $Output only. The name of the group.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"N

updateTime" <Output only. The timestamp when the group was last updated.
*¿≠
Q
migrationcenterPreferenceSet/gcp:migrationcenter/preferenceSet:PreferenceSetÂòManages the PreferenceSet resource.


To get more information about PreferenceSet, see:

* [API documentation](https://cloud.google.com/migration-center/docs/reference/rest/v1)
* How-to Guides
    * [Managing Migration Preferences](https://cloud.google.com/migration-center/docs/migration-preferences)

## Example Usage

### Preference Set Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.migrationcenter.PreferenceSet("default", {
    location: "us-central1",
    preferenceSetId: "preference-set-test",
    description: "Terraform integration test description",
    displayName: "Terraform integration test display",
    virtualMachinePreferences: {
        vmwareEnginePreferences: {
            cpuOvercommitRatio: 1.5,
        },
        sizingOptimizationStrategy: "SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE",
        targetProduct: "COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.migrationcenter.PreferenceSet("default",
    location="us-central1",
    preference_set_id="preference-set-test",
    description="Terraform integration test description",
    display_name="Terraform integration test display",
    virtual_machine_preferences={
        "vmware_engine_preferences": {
            "cpu_overcommit_ratio": 1.5,
        },
        "sizing_optimization_strategy": "SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE",
        "target_product": "COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.MigrationCenter.PreferenceSet("default", new()
    {
        Location = "us-central1",
        PreferenceSetId = "preference-set-test",
        Description = "Terraform integration test description",
        DisplayName = "Terraform integration test display",
        VirtualMachinePreferences = new Gcp.MigrationCenter.Inputs.PreferenceSetVirtualMachinePreferencesArgs
        {
            VmwareEnginePreferences = new Gcp.MigrationCenter.Inputs.PreferenceSetVirtualMachinePreferencesVmwareEnginePreferencesArgs
            {
                CpuOvercommitRatio = 1.5,
            },
            SizingOptimizationStrategy = "SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE",
            TargetProduct = "COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/migrationcenter"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := migrationcenter.NewPreferenceSet(ctx, "default", &migrationcenter.PreferenceSetArgs{
			Location:        pulumi.String("us-central1"),
			PreferenceSetId: pulumi.String("preference-set-test"),
			Description:     pulumi.String("Terraform integration test description"),
			DisplayName:     pulumi.String("Terraform integration test display"),
			VirtualMachinePreferences: &migrationcenter.PreferenceSetVirtualMachinePreferencesArgs{
				VmwareEnginePreferences: &migrationcenter.PreferenceSetVirtualMachinePreferencesVmwareEnginePreferencesArgs{
					CpuOvercommitRatio: pulumi.Float64(1.5),
				},
				SizingOptimizationStrategy: pulumi.String("SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE"),
				TargetProduct:              pulumi.String("COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.migrationcenter.PreferenceSet;
import com.pulumi.gcp.migrationcenter.PreferenceSetArgs;
import com.pulumi.gcp.migrationcenter.inputs.PreferenceSetVirtualMachinePreferencesArgs;
import com.pulumi.gcp.migrationcenter.inputs.PreferenceSetVirtualMachinePreferencesVmwareEnginePreferencesArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new PreferenceSet("default", PreferenceSetArgs.builder()
            .location("us-central1")
            .preferenceSetId("preference-set-test")
            .description("Terraform integration test description")
            .displayName("Terraform integration test display")
            .virtualMachinePreferences(PreferenceSetVirtualMachinePreferencesArgs.builder()
                .vmwareEnginePreferences(PreferenceSetVirtualMachinePreferencesVmwareEnginePreferencesArgs.builder()
                    .cpuOvercommitRatio(1.5)
                    .build())
                .sizingOptimizationStrategy("SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE")
                .targetProduct("COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE")
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:migrationcenter:PreferenceSet
    properties:
      location: us-central1
      preferenceSetId: preference-set-test
      description: Terraform integration test description
      displayName: Terraform integration test display
      virtualMachinePreferences:
        vmwareEnginePreferences:
          cpuOvercommitRatio: 1.5
        sizingOptimizationStrategy: SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE
        targetProduct: COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE
```
<!--End PulumiCodeChooser -->
### Preference Set Full


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.migrationcenter.PreferenceSet("default", {
    location: "us-central1",
    preferenceSetId: "preference-set-test",
    description: "Terraform integration test description",
    displayName: "Terraform integration test display",
    virtualMachinePreferences: {
        vmwareEnginePreferences: {
            cpuOvercommitRatio: 1.5,
            storageDeduplicationCompressionRatio: 1.3,
            commitmentPlan: "ON_DEMAND",
        },
        sizingOptimizationStrategy: "SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE",
        targetProduct: "COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE",
        commitmentPlan: "COMMITMENT_PLAN_ONE_YEAR",
        regionPreferences: {
            preferredRegions: ["us-central1"],
        },
        soleTenancyPreferences: {
            commitmentPlan: "ON_DEMAND",
            cpuOvercommitRatio: 1.2,
            hostMaintenancePolicy: "HOST_MAINTENANCE_POLICY_DEFAULT",
            nodeTypes: [{
                nodeName: "tf-test",
            }],
        },
        computeEnginePreferences: {
            licenseType: "LICENSE_TYPE_BRING_YOUR_OWN_LICENSE",
            machinePreferences: {
                allowedMachineSeries: [{
                    code: "C3",
                }],
            },
        },
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.migrationcenter.PreferenceSet("default",
    location="us-central1",
    preference_set_id="preference-set-test",
    description="Terraform integration test description",
    display_name="Terraform integration test display",
    virtual_machine_preferences={
        "vmware_engine_preferences": {
            "cpu_overcommit_ratio": 1.5,
            "storage_deduplication_compression_ratio": 1.3,
            "commitment_plan": "ON_DEMAND",
        },
        "sizing_optimization_strategy": "SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE",
        "target_product": "COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE",
        "commitment_plan": "COMMITMENT_PLAN_ONE_YEAR",
        "region_preferences": {
            "preferred_regions": ["us-central1"],
        },
        "sole_tenancy_preferences": {
            "commitment_plan": "ON_DEMAND",
            "cpu_overcommit_ratio": 1.2,
            "host_maintenance_policy": "HOST_MAINTENANCE_POLICY_DEFAULT",
            "node_types": [{
                "node_name": "tf-test",
            }],
        },
        "compute_engine_preferences": {
            "license_type": "LICENSE_TYPE_BRING_YOUR_OWN_LICENSE",
            "machine_preferences": {
                "allowed_machine_series": [{
                    "code": "C3",
                }],
            },
        },
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.MigrationCenter.PreferenceSet("default", new()
    {
        Location = "us-central1",
        PreferenceSetId = "preference-set-test",
        Description = "Terraform integration test description",
        DisplayName = "Terraform integration test display",
        VirtualMachinePreferences = new Gcp.MigrationCenter.Inputs.PreferenceSetVirtualMachinePreferencesArgs
        {
            VmwareEnginePreferences = new Gcp.MigrationCenter.Inputs.PreferenceSetVirtualMachinePreferencesVmwareEnginePreferencesArgs
            {
                CpuOvercommitRatio = 1.5,
                StorageDeduplicationCompressionRatio = 1.3,
                CommitmentPlan = "ON_DEMAND",
            },
            SizingOptimizationStrategy = "SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE",
            TargetProduct = "COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE",
            CommitmentPlan = "COMMITMENT_PLAN_ONE_YEAR",
            RegionPreferences = new Gcp.MigrationCenter.Inputs.PreferenceSetVirtualMachinePreferencesRegionPreferencesArgs
            {
                PreferredRegions = new[]
                {
                    "us-central1",
                },
            },
            SoleTenancyPreferences = new Gcp.MigrationCenter.Inputs.PreferenceSetVirtualMachinePreferencesSoleTenancyPreferencesArgs
            {
                CommitmentPlan = "ON_DEMAND",
                CpuOvercommitRatio = 1.2,
                HostMaintenancePolicy = "HOST_MAINTENANCE_POLICY_DEFAULT",
                NodeTypes = new[]
                {
                    new Gcp.MigrationCenter.Inputs.PreferenceSetVirtualMachinePreferencesSoleTenancyPreferencesNodeTypeArgs
                    {
                        NodeName = "tf-test",
                    },
                },
            },
            ComputeEnginePreferences = new Gcp.MigrationCenter.Inputs.PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesArgs
            {
                LicenseType = "LICENSE_TYPE_BRING_YOUR_OWN_LICENSE",
                MachinePreferences = new Gcp.MigrationCenter.Inputs.PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferencesArgs
                {
                    AllowedMachineSeries = new[]
                    {
                        new Gcp.MigrationCenter.Inputs.PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferencesAllowedMachineSeriesArgs
                        {
                            Code = "C3",
                        },
                    },
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/migrationcenter"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := migrationcenter.NewPreferenceSet(ctx, "default", &migrationcenter.PreferenceSetArgs{
			Location:        pulumi.String("us-central1"),
			PreferenceSetId: pulumi.String("preference-set-test"),
			Description:     pulumi.String("Terraform integration test description"),
			DisplayName:     pulumi.String("Terraform integration test display"),
			VirtualMachinePreferences: &migrationcenter.PreferenceSetVirtualMachinePreferencesArgs{
				VmwareEnginePreferences: &migrationcenter.PreferenceSetVirtualMachinePreferencesVmwareEnginePreferencesArgs{
					CpuOvercommitRatio:                   pulumi.Float64(1.5),
					StorageDeduplicationCompressionRatio: pulumi.Float64(1.3),
					CommitmentPlan:                       pulumi.String("ON_DEMAND"),
				},
				SizingOptimizationStrategy: pulumi.String("SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE"),
				TargetProduct:              pulumi.String("COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE"),
				CommitmentPlan:             pulumi.String("COMMITMENT_PLAN_ONE_YEAR"),
				RegionPreferences: &migrationcenter.PreferenceSetVirtualMachinePreferencesRegionPreferencesArgs{
					PreferredRegions: pulumi.StringArray{
						pulumi.String("us-central1"),
					},
				},
				SoleTenancyPreferences: &migrationcenter.PreferenceSetVirtualMachinePreferencesSoleTenancyPreferencesArgs{
					CommitmentPlan:        pulumi.String("ON_DEMAND"),
					CpuOvercommitRatio:    pulumi.Float64(1.2),
					HostMaintenancePolicy: pulumi.String("HOST_MAINTENANCE_POLICY_DEFAULT"),
					NodeTypes: migrationcenter.PreferenceSetVirtualMachinePreferencesSoleTenancyPreferencesNodeTypeArray{
						&migrationcenter.PreferenceSetVirtualMachinePreferencesSoleTenancyPreferencesNodeTypeArgs{
							NodeName: pulumi.String("tf-test"),
						},
					},
				},
				ComputeEnginePreferences: &migrationcenter.PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesArgs{
					LicenseType: pulumi.String("LICENSE_TYPE_BRING_YOUR_OWN_LICENSE"),
					MachinePreferences: &migrationcenter.PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferencesArgs{
						AllowedMachineSeries: migrationcenter.PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferencesAllowedMachineSeriesArray{
							&migrationcenter.PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferencesAllowedMachineSeriesArgs{
								Code: pulumi.String("C3"),
							},
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.migrationcenter.PreferenceSet;
import com.pulumi.gcp.migrationcenter.PreferenceSetArgs;
import com.pulumi.gcp.migrationcenter.inputs.PreferenceSetVirtualMachinePreferencesArgs;
import com.pulumi.gcp.migrationcenter.inputs.PreferenceSetVirtualMachinePreferencesVmwareEnginePreferencesArgs;
import com.pulumi.gcp.migrationcenter.inputs.PreferenceSetVirtualMachinePreferencesRegionPreferencesArgs;
import com.pulumi.gcp.migrationcenter.inputs.PreferenceSetVirtualMachinePreferencesSoleTenancyPreferencesArgs;
import com.pulumi.gcp.migrationcenter.inputs.PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesArgs;
import com.pulumi.gcp.migrationcenter.inputs.PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferencesArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new PreferenceSet("default", PreferenceSetArgs.builder()
            .location("us-central1")
            .preferenceSetId("preference-set-test")
            .description("Terraform integration test description")
            .displayName("Terraform integration test display")
            .virtualMachinePreferences(PreferenceSetVirtualMachinePreferencesArgs.builder()
                .vmwareEnginePreferences(PreferenceSetVirtualMachinePreferencesVmwareEnginePreferencesArgs.builder()
                    .cpuOvercommitRatio(1.5)
                    .storageDeduplicationCompressionRatio(1.3)
                    .commitmentPlan("ON_DEMAND")
                    .build())
                .sizingOptimizationStrategy("SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE")
                .targetProduct("COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE")
                .commitmentPlan("COMMITMENT_PLAN_ONE_YEAR")
                .regionPreferences(PreferenceSetVirtualMachinePreferencesRegionPreferencesArgs.builder()
                    .preferredRegions("us-central1")
                    .build())
                .soleTenancyPreferences(PreferenceSetVirtualMachinePreferencesSoleTenancyPreferencesArgs.builder()
                    .commitmentPlan("ON_DEMAND")
                    .cpuOvercommitRatio(1.2)
                    .hostMaintenancePolicy("HOST_MAINTENANCE_POLICY_DEFAULT")
                    .nodeTypes(PreferenceSetVirtualMachinePreferencesSoleTenancyPreferencesNodeTypeArgs.builder()
                        .nodeName("tf-test")
                        .build())
                    .build())
                .computeEnginePreferences(PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesArgs.builder()
                    .licenseType("LICENSE_TYPE_BRING_YOUR_OWN_LICENSE")
                    .machinePreferences(PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferencesArgs.builder()
                        .allowedMachineSeries(PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferencesAllowedMachineSeriesArgs.builder()
                            .code("C3")
                            .build())
                        .build())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:migrationcenter:PreferenceSet
    properties:
      location: us-central1
      preferenceSetId: preference-set-test
      description: Terraform integration test description
      displayName: Terraform integration test display
      virtualMachinePreferences:
        vmwareEnginePreferences:
          cpuOvercommitRatio: 1.5
          storageDeduplicationCompressionRatio: 1.3
          commitmentPlan: ON_DEMAND
        sizingOptimizationStrategy: SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE
        targetProduct: COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE
        commitmentPlan: COMMITMENT_PLAN_ONE_YEAR
        regionPreferences:
          preferredRegions:
            - us-central1
        soleTenancyPreferences:
          commitmentPlan: ON_DEMAND
          cpuOvercommitRatio: 1.2
          hostMaintenancePolicy: HOST_MAINTENANCE_POLICY_DEFAULT
          nodeTypes:
            - nodeName: tf-test
        computeEnginePreferences:
          licenseType: LICENSE_TYPE_BRING_YOUR_OWN_LICENSE
          machinePreferences:
            allowedMachineSeries:
              - code: C3
```
<!--End PulumiCodeChooser -->

## Import

PreferenceSet can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/preferenceSets/{{preference_set_id}}`

* `{{project}}/{{location}}/{{preference_set_id}}`

* `{{location}}/{{preference_set_id}}`

When using the `pulumi import` command, PreferenceSet can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:migrationcenter/preferenceSet:PreferenceSet default projects/{{project}}/locations/{{location}}/preferenceSets/{{preference_set_id}}
```

```sh
$ pulumi import gcp:migrationcenter/preferenceSet:PreferenceSet default {{project}}/{{location}}/{{preference_set_id}}
```

```sh
$ pulumi import gcp:migrationcenter/preferenceSet:PreferenceSet default {{location}}/{{preference_set_id}}
```

:
descriptionB" %A description of the preference set.
R
displayNameB" =User-friendly display name. Maximum length is 63 characters.
E
location" 5Part of `parent`. See documentation of `projectsId`.
⁄
preferenceSetId" ¬Required. User specified ID for the preference set. It will become the last component of the preference set name. The ID must be unique within the project, must conform with RFC-1034, is restricted to lower-cased letters, and has a maximum length of 63 characters. The ID must match the regular expression `a-z?`.


- - -
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
›
virtualMachinePreferences•B¢:ü
ú
migrationcenter&PreferenceSetVirtualMachinePreferencesagcp:migrationcenter/PreferenceSetVirtualMachinePreferences:PreferenceSetVirtualMachinePreferencesóVirtualMachinePreferences enables you to create sets of assumptions, for example, a geographical location and pricing track, for your migrated virtual machines. The set of preferences influence recommendations for migrating virtual machine assets.
Structure is documented below.
"R

createTime" @Output only. The timestamp when the preference set was created.
":
descriptionB" %A description of the preference set.
"R
displayNameB" =User-friendly display name. Maximum length is 63 characters.
"E
location" 5Part of `parent`. See documentation of `projectsId`.
"5
name" )Output only. Name of the preference set.
"⁄
preferenceSetId" ¬Required. User specified ID for the preference set. It will become the last component of the preference set name. The ID must be unique within the project, must conform with RFC-1034, is restricted to lower-cased letters, and has a maximum length of 63 characters. The ID must match the regular expression `a-z?`.


- - -
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"W

updateTime" EOutput only. The timestamp when the preference set was last updated.
"›
virtualMachinePreferences•B¢:ü
ú
migrationcenter&PreferenceSetVirtualMachinePreferencesagcp:migrationcenter/PreferenceSetVirtualMachinePreferences:PreferenceSetVirtualMachinePreferencesóVirtualMachinePreferences enables you to create sets of assumptions, for example, a geographical location and pricing track, for your migrated virtual machines. The set of preferences influence recommendations for migrating virtual machine assets.
Structure is documented below.
*ˆD
1
mlEngineModelgcp:ml/engineModel:EngineModelœ/Represents a machine learning solution.

A model can have multiple versions, each of which is a deployed, trained model
ready to receive prediction requests. The model itself is just a container.


To get more information about Model, see:

* [API documentation](https://cloud.google.com/ai-platform/prediction/docs/reference/rest/v1/projects.models)
* How-to Guides
    * [Official Documentation](https://cloud.google.com/ai-platform/prediction/docs/deploying-models)

## Example Usage

### Ml Model Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.ml.EngineModel("default", {
    name: "default",
    description: "My model",
    regions: "us-central1",
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.ml.EngineModel("default",
    name="default",
    description="My model",
    regions="us-central1")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.ML.EngineModel("default", new()
    {
        Name = "default",
        Description = "My model",
        Regions = "us-central1",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/ml"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := ml.NewEngineModel(ctx, "default", &ml.EngineModelArgs{
			Name:        pulumi.String("default"),
			Description: pulumi.String("My model"),
			Regions:     pulumi.String("us-central1"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.ml.EngineModel;
import com.pulumi.gcp.ml.EngineModelArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new EngineModel("default", EngineModelArgs.builder()
            .name("default")
            .description("My model")
            .regions("us-central1")
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:ml:EngineModel
    properties:
      name: default
      description: My model
      regions: us-central1
```
<!--End PulumiCodeChooser -->
### Ml Model Full


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.ml.EngineModel("default", {
    name: "default",
    description: "My model",
    regions: "us-central1",
    labels: {
        my_model: "foo",
    },
    onlinePredictionLogging: true,
    onlinePredictionConsoleLogging: true,
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.ml.EngineModel("default",
    name="default",
    description="My model",
    regions="us-central1",
    labels={
        "my_model": "foo",
    },
    online_prediction_logging=True,
    online_prediction_console_logging=True)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.ML.EngineModel("default", new()
    {
        Name = "default",
        Description = "My model",
        Regions = "us-central1",
        Labels = 
        {
            { "my_model", "foo" },
        },
        OnlinePredictionLogging = true,
        OnlinePredictionConsoleLogging = true,
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/ml"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := ml.NewEngineModel(ctx, "default", &ml.EngineModelArgs{
			Name:        pulumi.String("default"),
			Description: pulumi.String("My model"),
			Regions:     pulumi.String("us-central1"),
			Labels: pulumi.StringMap{
				"my_model": pulumi.String("foo"),
			},
			OnlinePredictionLogging:        pulumi.Bool(true),
			OnlinePredictionConsoleLogging: pulumi.Bool(true),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.ml.EngineModel;
import com.pulumi.gcp.ml.EngineModelArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new EngineModel("default", EngineModelArgs.builder()
            .name("default")
            .description("My model")
            .regions("us-central1")
            .labels(Map.of("my_model", "foo"))
            .onlinePredictionLogging(true)
            .onlinePredictionConsoleLogging(true)
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:ml:EngineModel
    properties:
      name: default
      description: My model
      regions: us-central1
      labels:
        my_model: foo
      onlinePredictionLogging: true
      onlinePredictionConsoleLogging: true
```
<!--End PulumiCodeChooser -->

## Import

Model can be imported using any of these accepted formats:

* `projects/{{project}}/models/{{name}}`

* `{{project}}/{{name}}`

* `{{name}}`

When using the `pulumi import` command, Model can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:ml/engineModel:EngineModel default projects/{{project}}/models/{{name}}
```

```sh
$ pulumi import gcp:ml/engineModel:EngineModel default {{project}}/{{name}}
```

```sh
$ pulumi import gcp:ml/engineModel:EngineModel default {{name}}
```

é
defaultVersionaB_:]
[
mlEngineModelDefaultVersion:gcp:ml/EngineModelDefaultVersion:EngineModelDefaultVersionòThe default version of the model. This version will be used to handle
prediction requests that do not specify a version.
Structure is documented below.
R
descriptionB" =The description specified for the model when it was created.
ó
labelsB2" ÑOne or more labels that you can add, to organize your models.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
8
nameB" *The name specified for the model.


- - -

onlinePredictionConsoleLoggingB
 WIf true, online prediction nodes send stderr and stdout streams to Stackdriver Logging
i
onlinePredictionLoggingB
 HIf true, online prediction access logs are sent to StackDriver Logging.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.

regionsB" nThe list of regions where the model is going to be deployed.
Currently only one region per model is supported
"é
defaultVersionaB_:]
[
mlEngineModelDefaultVersion:gcp:ml/EngineModelDefaultVersion:EngineModelDefaultVersionòThe default version of the model. This version will be used to handle
prediction requests that do not specify a version.
Structure is documented below.
"R
descriptionB" =The description specified for the model when it was created.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"ó
labelsB2" ÑOne or more labels that you can add, to organize your models.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"6
name" *The name specified for the model.


- - -
"
onlinePredictionConsoleLoggingB
 WIf true, online prediction nodes send stderr and stdout streams to Stackdriver Logging
"i
onlinePredictionLoggingB
 HIf true, online prediction access logs are sent to StackDriver Logging.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"
regionsB" nThe list of regions where the model is going to be deployed.
Currently only one region per model is supported
*¸˝
A

monitoringAlertPolicy&gcp:monitoring/alertPolicy:AlertPolicy˚œA description of the conditions under which some aspect of your system is
considered to be "unhealthy" and the ways to notify people or services
about this state.


To get more information about AlertPolicy, see:

* [API documentation](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.alertPolicies)
* How-to Guides
    * [Official Documentation](https://cloud.google.com/monitoring/alerts/)

## Example Usage

### Monitoring Alert Policy Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const alertPolicy = new gcp.monitoring.AlertPolicy("alert_policy", {
    displayName: "My Alert Policy",
    combiner: "OR",
    conditions: [{
        displayName: "test condition",
        conditionThreshold: {
            filter: "metric.type=\"compute.googleapis.com/instance/disk/write_bytes_count\" AND resource.type=\"gce_instance\"",
            duration: "60s",
            comparison: "COMPARISON_GT",
            aggregations: [{
                alignmentPeriod: "60s",
                perSeriesAligner: "ALIGN_RATE",
            }],
        },
    }],
    userLabels: {
        foo: "bar",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

alert_policy = gcp.monitoring.AlertPolicy("alert_policy",
    display_name="My Alert Policy",
    combiner="OR",
    conditions=[{
        "display_name": "test condition",
        "condition_threshold": {
            "filter": "metric.type=\"compute.googleapis.com/instance/disk/write_bytes_count\" AND resource.type=\"gce_instance\"",
            "duration": "60s",
            "comparison": "COMPARISON_GT",
            "aggregations": [{
                "alignment_period": "60s",
                "per_series_aligner": "ALIGN_RATE",
            }],
        },
    }],
    user_labels={
        "foo": "bar",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var alertPolicy = new Gcp.Monitoring.AlertPolicy("alert_policy", new()
    {
        DisplayName = "My Alert Policy",
        Combiner = "OR",
        Conditions = new[]
        {
            new Gcp.Monitoring.Inputs.AlertPolicyConditionArgs
            {
                DisplayName = "test condition",
                ConditionThreshold = new Gcp.Monitoring.Inputs.AlertPolicyConditionConditionThresholdArgs
                {
                    Filter = "metric.type=\"compute.googleapis.com/instance/disk/write_bytes_count\" AND resource.type=\"gce_instance\"",
                    Duration = "60s",
                    Comparison = "COMPARISON_GT",
                    Aggregations = new[]
                    {
                        new Gcp.Monitoring.Inputs.AlertPolicyConditionConditionThresholdAggregationArgs
                        {
                            AlignmentPeriod = "60s",
                            PerSeriesAligner = "ALIGN_RATE",
                        },
                    },
                },
            },
        },
        UserLabels = 
        {
            { "foo", "bar" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := monitoring.NewAlertPolicy(ctx, "alert_policy", &monitoring.AlertPolicyArgs{
			DisplayName: pulumi.String("My Alert Policy"),
			Combiner:    pulumi.String("OR"),
			Conditions: monitoring.AlertPolicyConditionArray{
				&monitoring.AlertPolicyConditionArgs{
					DisplayName: pulumi.String("test condition"),
					ConditionThreshold: &monitoring.AlertPolicyConditionConditionThresholdArgs{
						Filter:     pulumi.String("metric.type=\"compute.googleapis.com/instance/disk/write_bytes_count\" AND resource.type=\"gce_instance\""),
						Duration:   pulumi.String("60s"),
						Comparison: pulumi.String("COMPARISON_GT"),
						Aggregations: monitoring.AlertPolicyConditionConditionThresholdAggregationArray{
							&monitoring.AlertPolicyConditionConditionThresholdAggregationArgs{
								AlignmentPeriod:  pulumi.String("60s"),
								PerSeriesAligner: pulumi.String("ALIGN_RATE"),
							},
						},
					},
				},
			},
			UserLabels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.AlertPolicy;
import com.pulumi.gcp.monitoring.AlertPolicyArgs;
import com.pulumi.gcp.monitoring.inputs.AlertPolicyConditionArgs;
import com.pulumi.gcp.monitoring.inputs.AlertPolicyConditionConditionThresholdArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var alertPolicy = new AlertPolicy("alertPolicy", AlertPolicyArgs.builder()
            .displayName("My Alert Policy")
            .combiner("OR")
            .conditions(AlertPolicyConditionArgs.builder()
                .displayName("test condition")
                .conditionThreshold(AlertPolicyConditionConditionThresholdArgs.builder()
                    .filter("metric.type=\"compute.googleapis.com/instance/disk/write_bytes_count\" AND resource.type=\"gce_instance\"")
                    .duration("60s")
                    .comparison("COMPARISON_GT")
                    .aggregations(AlertPolicyConditionConditionThresholdAggregationArgs.builder()
                        .alignmentPeriod("60s")
                        .perSeriesAligner("ALIGN_RATE")
                        .build())
                    .build())
                .build())
            .userLabels(Map.of("foo", "bar"))
            .build());

    }
}
```
```yaml
resources:
  alertPolicy:
    type: gcp:monitoring:AlertPolicy
    name: alert_policy
    properties:
      displayName: My Alert Policy
      combiner: OR
      conditions:
        - displayName: test condition
          conditionThreshold:
            filter: metric.type="compute.googleapis.com/instance/disk/write_bytes_count" AND resource.type="gce_instance"
            duration: 60s
            comparison: COMPARISON_GT
            aggregations:
              - alignmentPeriod: 60s
                perSeriesAligner: ALIGN_RATE
      userLabels:
        foo: bar
```
<!--End PulumiCodeChooser -->
### Monitoring Alert Policy Evaluation Missing Data


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const alertPolicy = new gcp.monitoring.AlertPolicy("alert_policy", {
    displayName: "My Alert Policy",
    combiner: "OR",
    conditions: [{
        displayName: "test condition",
        conditionThreshold: {
            filter: "metric.type=\"compute.googleapis.com/instance/disk/write_bytes_count\" AND resource.type=\"gce_instance\"",
            duration: "60s",
            comparison: "COMPARISON_GT",
            aggregations: [{
                alignmentPeriod: "60s",
                perSeriesAligner: "ALIGN_RATE",
            }],
            evaluationMissingData: "EVALUATION_MISSING_DATA_INACTIVE",
        },
    }],
    userLabels: {
        foo: "bar",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

alert_policy = gcp.monitoring.AlertPolicy("alert_policy",
    display_name="My Alert Policy",
    combiner="OR",
    conditions=[{
        "display_name": "test condition",
        "condition_threshold": {
            "filter": "metric.type=\"compute.googleapis.com/instance/disk/write_bytes_count\" AND resource.type=\"gce_instance\"",
            "duration": "60s",
            "comparison": "COMPARISON_GT",
            "aggregations": [{
                "alignment_period": "60s",
                "per_series_aligner": "ALIGN_RATE",
            }],
            "evaluation_missing_data": "EVALUATION_MISSING_DATA_INACTIVE",
        },
    }],
    user_labels={
        "foo": "bar",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var alertPolicy = new Gcp.Monitoring.AlertPolicy("alert_policy", new()
    {
        DisplayName = "My Alert Policy",
        Combiner = "OR",
        Conditions = new[]
        {
            new Gcp.Monitoring.Inputs.AlertPolicyConditionArgs
            {
                DisplayName = "test condition",
                ConditionThreshold = new Gcp.Monitoring.Inputs.AlertPolicyConditionConditionThresholdArgs
                {
                    Filter = "metric.type=\"compute.googleapis.com/instance/disk/write_bytes_count\" AND resource.type=\"gce_instance\"",
                    Duration = "60s",
                    Comparison = "COMPARISON_GT",
                    Aggregations = new[]
                    {
                        new Gcp.Monitoring.Inputs.AlertPolicyConditionConditionThresholdAggregationArgs
                        {
                            AlignmentPeriod = "60s",
                            PerSeriesAligner = "ALIGN_RATE",
                        },
                    },
                    EvaluationMissingData = "EVALUATION_MISSING_DATA_INACTIVE",
                },
            },
        },
        UserLabels = 
        {
            { "foo", "bar" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := monitoring.NewAlertPolicy(ctx, "alert_policy", &monitoring.AlertPolicyArgs{
			DisplayName: pulumi.String("My Alert Policy"),
			Combiner:    pulumi.String("OR"),
			Conditions: monitoring.AlertPolicyConditionArray{
				&monitoring.AlertPolicyConditionArgs{
					DisplayName: pulumi.String("test condition"),
					ConditionThreshold: &monitoring.AlertPolicyConditionConditionThresholdArgs{
						Filter:     pulumi.String("metric.type=\"compute.googleapis.com/instance/disk/write_bytes_count\" AND resource.type=\"gce_instance\""),
						Duration:   pulumi.String("60s"),
						Comparison: pulumi.String("COMPARISON_GT"),
						Aggregations: monitoring.AlertPolicyConditionConditionThresholdAggregationArray{
							&monitoring.AlertPolicyConditionConditionThresholdAggregationArgs{
								AlignmentPeriod:  pulumi.String("60s"),
								PerSeriesAligner: pulumi.String("ALIGN_RATE"),
							},
						},
						EvaluationMissingData: pulumi.String("EVALUATION_MISSING_DATA_INACTIVE"),
					},
				},
			},
			UserLabels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.AlertPolicy;
import com.pulumi.gcp.monitoring.AlertPolicyArgs;
import com.pulumi.gcp.monitoring.inputs.AlertPolicyConditionArgs;
import com.pulumi.gcp.monitoring.inputs.AlertPolicyConditionConditionThresholdArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var alertPolicy = new AlertPolicy("alertPolicy", AlertPolicyArgs.builder()
            .displayName("My Alert Policy")
            .combiner("OR")
            .conditions(AlertPolicyConditionArgs.builder()
                .displayName("test condition")
                .conditionThreshold(AlertPolicyConditionConditionThresholdArgs.builder()
                    .filter("metric.type=\"compute.googleapis.com/instance/disk/write_bytes_count\" AND resource.type=\"gce_instance\"")
                    .duration("60s")
                    .comparison("COMPARISON_GT")
                    .aggregations(AlertPolicyConditionConditionThresholdAggregationArgs.builder()
                        .alignmentPeriod("60s")
                        .perSeriesAligner("ALIGN_RATE")
                        .build())
                    .evaluationMissingData("EVALUATION_MISSING_DATA_INACTIVE")
                    .build())
                .build())
            .userLabels(Map.of("foo", "bar"))
            .build());

    }
}
```
```yaml
resources:
  alertPolicy:
    type: gcp:monitoring:AlertPolicy
    name: alert_policy
    properties:
      displayName: My Alert Policy
      combiner: OR
      conditions:
        - displayName: test condition
          conditionThreshold:
            filter: metric.type="compute.googleapis.com/instance/disk/write_bytes_count" AND resource.type="gce_instance"
            duration: 60s
            comparison: COMPARISON_GT
            aggregations:
              - alignmentPeriod: 60s
                perSeriesAligner: ALIGN_RATE
            evaluationMissingData: EVALUATION_MISSING_DATA_INACTIVE
      userLabels:
        foo: bar
```
<!--End PulumiCodeChooser -->
### Monitoring Alert Policy Forecast Options


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const alertPolicy = new gcp.monitoring.AlertPolicy("alert_policy", {
    displayName: "My Alert Policy",
    combiner: "OR",
    conditions: [{
        displayName: "test condition",
        conditionThreshold: {
            filter: "metric.type=\"compute.googleapis.com/instance/disk/write_bytes_count\" AND resource.type=\"gce_instance\"",
            duration: "60s",
            forecastOptions: {
                forecastHorizon: "3600s",
            },
            comparison: "COMPARISON_GT",
            aggregations: [{
                alignmentPeriod: "60s",
                perSeriesAligner: "ALIGN_RATE",
            }],
        },
    }],
    userLabels: {
        foo: "bar",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

alert_policy = gcp.monitoring.AlertPolicy("alert_policy",
    display_name="My Alert Policy",
    combiner="OR",
    conditions=[{
        "display_name": "test condition",
        "condition_threshold": {
            "filter": "metric.type=\"compute.googleapis.com/instance/disk/write_bytes_count\" AND resource.type=\"gce_instance\"",
            "duration": "60s",
            "forecast_options": {
                "forecast_horizon": "3600s",
            },
            "comparison": "COMPARISON_GT",
            "aggregations": [{
                "alignment_period": "60s",
                "per_series_aligner": "ALIGN_RATE",
            }],
        },
    }],
    user_labels={
        "foo": "bar",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var alertPolicy = new Gcp.Monitoring.AlertPolicy("alert_policy", new()
    {
        DisplayName = "My Alert Policy",
        Combiner = "OR",
        Conditions = new[]
        {
            new Gcp.Monitoring.Inputs.AlertPolicyConditionArgs
            {
                DisplayName = "test condition",
                ConditionThreshold = new Gcp.Monitoring.Inputs.AlertPolicyConditionConditionThresholdArgs
                {
                    Filter = "metric.type=\"compute.googleapis.com/instance/disk/write_bytes_count\" AND resource.type=\"gce_instance\"",
                    Duration = "60s",
                    ForecastOptions = new Gcp.Monitoring.Inputs.AlertPolicyConditionConditionThresholdForecastOptionsArgs
                    {
                        ForecastHorizon = "3600s",
                    },
                    Comparison = "COMPARISON_GT",
                    Aggregations = new[]
                    {
                        new Gcp.Monitoring.Inputs.AlertPolicyConditionConditionThresholdAggregationArgs
                        {
                            AlignmentPeriod = "60s",
                            PerSeriesAligner = "ALIGN_RATE",
                        },
                    },
                },
            },
        },
        UserLabels = 
        {
            { "foo", "bar" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := monitoring.NewAlertPolicy(ctx, "alert_policy", &monitoring.AlertPolicyArgs{
			DisplayName: pulumi.String("My Alert Policy"),
			Combiner:    pulumi.String("OR"),
			Conditions: monitoring.AlertPolicyConditionArray{
				&monitoring.AlertPolicyConditionArgs{
					DisplayName: pulumi.String("test condition"),
					ConditionThreshold: &monitoring.AlertPolicyConditionConditionThresholdArgs{
						Filter:   pulumi.String("metric.type=\"compute.googleapis.com/instance/disk/write_bytes_count\" AND resource.type=\"gce_instance\""),
						Duration: pulumi.String("60s"),
						ForecastOptions: &monitoring.AlertPolicyConditionConditionThresholdForecastOptionsArgs{
							ForecastHorizon: pulumi.String("3600s"),
						},
						Comparison: pulumi.String("COMPARISON_GT"),
						Aggregations: monitoring.AlertPolicyConditionConditionThresholdAggregationArray{
							&monitoring.AlertPolicyConditionConditionThresholdAggregationArgs{
								AlignmentPeriod:  pulumi.String("60s"),
								PerSeriesAligner: pulumi.String("ALIGN_RATE"),
							},
						},
					},
				},
			},
			UserLabels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.AlertPolicy;
import com.pulumi.gcp.monitoring.AlertPolicyArgs;
import com.pulumi.gcp.monitoring.inputs.AlertPolicyConditionArgs;
import com.pulumi.gcp.monitoring.inputs.AlertPolicyConditionConditionThresholdArgs;
import com.pulumi.gcp.monitoring.inputs.AlertPolicyConditionConditionThresholdForecastOptionsArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var alertPolicy = new AlertPolicy("alertPolicy", AlertPolicyArgs.builder()
            .displayName("My Alert Policy")
            .combiner("OR")
            .conditions(AlertPolicyConditionArgs.builder()
                .displayName("test condition")
                .conditionThreshold(AlertPolicyConditionConditionThresholdArgs.builder()
                    .filter("metric.type=\"compute.googleapis.com/instance/disk/write_bytes_count\" AND resource.type=\"gce_instance\"")
                    .duration("60s")
                    .forecastOptions(AlertPolicyConditionConditionThresholdForecastOptionsArgs.builder()
                        .forecastHorizon("3600s")
                        .build())
                    .comparison("COMPARISON_GT")
                    .aggregations(AlertPolicyConditionConditionThresholdAggregationArgs.builder()
                        .alignmentPeriod("60s")
                        .perSeriesAligner("ALIGN_RATE")
                        .build())
                    .build())
                .build())
            .userLabels(Map.of("foo", "bar"))
            .build());

    }
}
```
```yaml
resources:
  alertPolicy:
    type: gcp:monitoring:AlertPolicy
    name: alert_policy
    properties:
      displayName: My Alert Policy
      combiner: OR
      conditions:
        - displayName: test condition
          conditionThreshold:
            filter: metric.type="compute.googleapis.com/instance/disk/write_bytes_count" AND resource.type="gce_instance"
            duration: 60s
            forecastOptions:
              forecastHorizon: 3600s
            comparison: COMPARISON_GT
            aggregations:
              - alignmentPeriod: 60s
                perSeriesAligner: ALIGN_RATE
      userLabels:
        foo: bar
```
<!--End PulumiCodeChooser -->
### Monitoring Alert Policy Promql Condition


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const alertPolicy = new gcp.monitoring.AlertPolicy("alert_policy", {
    displayName: "My Alert Policy",
    combiner: "OR",
    conditions: [{
        displayName: "test condition",
        conditionPrometheusQueryLanguage: {
            query: "compute_googleapis_com:instance_cpu_usage_time > 0",
            duration: "60s",
            evaluationInterval: "60s",
            alertRule: "AlwaysOn",
            ruleGroup: "a test",
        },
    }],
    alertStrategy: {
        autoClose: "1800s",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

alert_policy = gcp.monitoring.AlertPolicy("alert_policy",
    display_name="My Alert Policy",
    combiner="OR",
    conditions=[{
        "display_name": "test condition",
        "condition_prometheus_query_language": {
            "query": "compute_googleapis_com:instance_cpu_usage_time > 0",
            "duration": "60s",
            "evaluation_interval": "60s",
            "alert_rule": "AlwaysOn",
            "rule_group": "a test",
        },
    }],
    alert_strategy={
        "auto_close": "1800s",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var alertPolicy = new Gcp.Monitoring.AlertPolicy("alert_policy", new()
    {
        DisplayName = "My Alert Policy",
        Combiner = "OR",
        Conditions = new[]
        {
            new Gcp.Monitoring.Inputs.AlertPolicyConditionArgs
            {
                DisplayName = "test condition",
                ConditionPrometheusQueryLanguage = new Gcp.Monitoring.Inputs.AlertPolicyConditionConditionPrometheusQueryLanguageArgs
                {
                    Query = "compute_googleapis_com:instance_cpu_usage_time > 0",
                    Duration = "60s",
                    EvaluationInterval = "60s",
                    AlertRule = "AlwaysOn",
                    RuleGroup = "a test",
                },
            },
        },
        AlertStrategy = new Gcp.Monitoring.Inputs.AlertPolicyAlertStrategyArgs
        {
            AutoClose = "1800s",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := monitoring.NewAlertPolicy(ctx, "alert_policy", &monitoring.AlertPolicyArgs{
			DisplayName: pulumi.String("My Alert Policy"),
			Combiner:    pulumi.String("OR"),
			Conditions: monitoring.AlertPolicyConditionArray{
				&monitoring.AlertPolicyConditionArgs{
					DisplayName: pulumi.String("test condition"),
					ConditionPrometheusQueryLanguage: &monitoring.AlertPolicyConditionConditionPrometheusQueryLanguageArgs{
						Query:              pulumi.String("compute_googleapis_com:instance_cpu_usage_time > 0"),
						Duration:           pulumi.String("60s"),
						EvaluationInterval: pulumi.String("60s"),
						AlertRule:          pulumi.String("AlwaysOn"),
						RuleGroup:          pulumi.String("a test"),
					},
				},
			},
			AlertStrategy: &monitoring.AlertPolicyAlertStrategyArgs{
				AutoClose: pulumi.String("1800s"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.AlertPolicy;
import com.pulumi.gcp.monitoring.AlertPolicyArgs;
import com.pulumi.gcp.monitoring.inputs.AlertPolicyConditionArgs;
import com.pulumi.gcp.monitoring.inputs.AlertPolicyConditionConditionPrometheusQueryLanguageArgs;
import com.pulumi.gcp.monitoring.inputs.AlertPolicyAlertStrategyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var alertPolicy = new AlertPolicy("alertPolicy", AlertPolicyArgs.builder()
            .displayName("My Alert Policy")
            .combiner("OR")
            .conditions(AlertPolicyConditionArgs.builder()
                .displayName("test condition")
                .conditionPrometheusQueryLanguage(AlertPolicyConditionConditionPrometheusQueryLanguageArgs.builder()
                    .query("compute_googleapis_com:instance_cpu_usage_time > 0")
                    .duration("60s")
                    .evaluationInterval("60s")
                    .alertRule("AlwaysOn")
                    .ruleGroup("a test")
                    .build())
                .build())
            .alertStrategy(AlertPolicyAlertStrategyArgs.builder()
                .autoClose("1800s")
                .build())
            .build());

    }
}
```
```yaml
resources:
  alertPolicy:
    type: gcp:monitoring:AlertPolicy
    name: alert_policy
    properties:
      displayName: My Alert Policy
      combiner: OR
      conditions:
        - displayName: test condition
          conditionPrometheusQueryLanguage:
            query: compute_googleapis_com:instance_cpu_usage_time > 0
            duration: 60s
            evaluationInterval: 60s
            alertRule: AlwaysOn
            ruleGroup: a test
      alertStrategy:
        autoClose: 1800s
```
<!--End PulumiCodeChooser -->

## Import

AlertPolicy can be imported using any of these accepted formats:

* `{{project}}/{{name}}`

* `{{project}} {{name}}`

* `{{name}}`

When using the `pulumi import` command, AlertPolicy can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:monitoring/alertPolicy:AlertPolicy default {{project}}/{{name}}
```

```sh
$ pulumi import gcp:monitoring/alertPolicy:AlertPolicy default "{{project}} {{name}}"
```

```sh
$ pulumi import gcp:monitoring/alertPolicy:AlertPolicy default {{name}}
```

 
alertStrategynBl:j
h

monitoringAlertPolicyAlertStrategy@gcp:monitoring/AlertPolicyAlertStrategy:AlertPolicyAlertStrategyIControl over how this alert policy's notification channels are notified.
±
combiner" †How to combine the results of multiple conditions to
determine if an incident should be opened.
Possible values are: `AND`, `OR`, `AND_WITH_MATCHING_RESOURCE`.
˘

conditionsb*`:^
\

monitoringAlertPolicyCondition8gcp:monitoring/AlertPolicyCondition:AlertPolicyConditionÜA list of conditions for the policy. The conditions are combined by
AND or OR according to the combiner field. If the combined conditions
evaluate to true, then an incident is created. A policy can have from
one to six conditions.
Structure is documented below.
Ç
displayName" ÓA short name or phrase used to identify the policy in
dashboards, notifications, and incidents. To avoid confusion, don't use
the same display name for multiple policies in the same project. The
name is limited to 512 Unicode characters.
‰
documentationnBl:j
h

monitoringAlertPolicyDocumentation@gcp:monitoring/AlertPolicyDocumentation:AlertPolicyDocumentation‚Documentation that is included with notifications and incidents related to this policy. Best practice is for the
documentation to include information to help responders understand, mitigate, escalate, and correct the underlying
problems detected by the alerting policy. Notification channels that have limited capacity might not show this
documentation.
L
enabledB
 ;Whether or not the policy is enabled. The default is true.
“
notificationChannelsB*" ±Identifies the notification channels to which notifications should be sent when incidents are opened or closed or when
new violations occur on an already opened incident. Each element of this array corresponds to the name field in each of
the NotificationChannel objects that are returned from the notificationChannels.list method. The syntax of the entries
in this field is 'projects/[PROJECT_ID]/notificationChannels/[CHANNEL_ID]'

projectB" ¸
severityB" ÈThe severity of an alert policy indicates how important incidents generated by that policy are. The severity level will
be displayed on the Incident detail page and in notifications. Possible values: ["CRITICAL", "ERROR", "WARNING"]
Î

userLabelsB2" ‘This field is intended to be used for organizing and identifying the AlertPolicy objects.The field can contain up to 64
entries. Each key and value is limited to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values
can contain only lowercase letters, numerals, underscores, and dashes. Keys must begin with a letter.
" 
alertStrategynBl:j
h

monitoringAlertPolicyAlertStrategy@gcp:monitoring/AlertPolicyAlertStrategy:AlertPolicyAlertStrategyIControl over how this alert policy's notification channels are notified.
"±
combiner" †How to combine the results of multiple conditions to
determine if an incident should be opened.
Possible values are: `AND`, `OR`, `AND_WITH_MATCHING_RESOURCE`.
"˘

conditionsb*`:^
\

monitoringAlertPolicyCondition8gcp:monitoring/AlertPolicyCondition:AlertPolicyConditionÜA list of conditions for the policy. The conditions are combined by
AND or OR according to the combiner field. If the combined conditions
evaluate to true, then an incident is created. A policy can have from
one to six conditions.
Structure is documented below.
"®
creationRecordsq*o:m
k

monitoringAlertPolicyCreationRecordBgcp:monitoring/AlertPolicyCreationRecord:AlertPolicyCreationRecord°A read-only record of the creation of the alerting policy.
If provided in a call to create or update, this field will
be ignored.
Structure is documented below.
"Ç
displayName" ÓA short name or phrase used to identify the policy in
dashboards, notifications, and incidents. To avoid confusion, don't use
the same display name for multiple policies in the same project. The
name is limited to 512 Unicode characters.
"‰
documentationnBl:j
h

monitoringAlertPolicyDocumentation@gcp:monitoring/AlertPolicyDocumentation:AlertPolicyDocumentation‚Documentation that is included with notifications and incidents related to this policy. Best practice is for the
documentation to include information to help responders understand, mitigate, escalate, and correct the underlying
problems detected by the alerting policy. Notification channels that have limited capacity might not show this
documentation.
"L
enabledB
 ;Whether or not the policy is enabled. The default is true.
"{
name" oThe unique resource name for this policy.
Its syntax is: projects/[PROJECT_ID]/alertPolicies/[ALERT_POLICY_ID]
"“
notificationChannelsB*" ±Identifies the notification channels to which notifications should be sent when incidents are opened or closed or when
new violations occur on an already opened incident. Each element of this array corresponds to the name field in each of
the NotificationChannel objects that are returned from the notificationChannels.list method. The syntax of the entries
in this field is 'projects/[PROJECT_ID]/notificationChannels/[CHANNEL_ID]'
"
project" "¸
severityB" ÈThe severity of an alert policy indicates how important incidents generated by that policy are. The severity level will
be displayed on the Incident detail page and in notifications. Possible values: ["CRITICAL", "ERROR", "WARNING"]
"Î

userLabelsB2" ‘This field is intended to be used for organizing and identifying the AlertPolicy objects.The field can contain up to 64
entries. Each key and value is limited to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values
can contain only lowercase letters, numerals, underscores, and dashes. Keys must begin with a letter.
*Œ6
G

monitoringCustomService*gcp:monitoring/customService:CustomServiceü&A Service is a discrete, autonomous, and network-accessible unit,
designed to solve an individual concern. In Cloud Monitoring,
a Service acts as the root resource under which operational aspects of
the service are accessible


To get more information about Service, see:

* [API documentation](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/services)
* How-to Guides
    * [Monitoring API Documentation](https://cloud.google.com/monitoring/api/v3/)
    * [Service Monitoring](https://cloud.google.com/monitoring/service-monitoring)
    * [Service-orientation on Wikipedia](https://en.wikipedia.org/wiki/Service-orientation)

## Example Usage

### Monitoring Service Custom


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const custom = new gcp.monitoring.CustomService("custom", {
    serviceId: "custom-srv",
    displayName: "My Custom Service custom-srv",
    telemetry: {
        resourceName: "//product.googleapis.com/foo/foo/services/test",
    },
    userLabels: {
        my_key: "my_value",
        my_other_key: "my_other_value",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

custom = gcp.monitoring.CustomService("custom",
    service_id="custom-srv",
    display_name="My Custom Service custom-srv",
    telemetry={
        "resource_name": "//product.googleapis.com/foo/foo/services/test",
    },
    user_labels={
        "my_key": "my_value",
        "my_other_key": "my_other_value",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var custom = new Gcp.Monitoring.CustomService("custom", new()
    {
        ServiceId = "custom-srv",
        DisplayName = "My Custom Service custom-srv",
        Telemetry = new Gcp.Monitoring.Inputs.CustomServiceTelemetryArgs
        {
            ResourceName = "//product.googleapis.com/foo/foo/services/test",
        },
        UserLabels = 
        {
            { "my_key", "my_value" },
            { "my_other_key", "my_other_value" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := monitoring.NewCustomService(ctx, "custom", &monitoring.CustomServiceArgs{
			ServiceId:   pulumi.String("custom-srv"),
			DisplayName: pulumi.String("My Custom Service custom-srv"),
			Telemetry: &monitoring.CustomServiceTelemetryArgs{
				ResourceName: pulumi.String("//product.googleapis.com/foo/foo/services/test"),
			},
			UserLabels: pulumi.StringMap{
				"my_key":       pulumi.String("my_value"),
				"my_other_key": pulumi.String("my_other_value"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.CustomService;
import com.pulumi.gcp.monitoring.CustomServiceArgs;
import com.pulumi.gcp.monitoring.inputs.CustomServiceTelemetryArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var custom = new CustomService("custom", CustomServiceArgs.builder()
            .serviceId("custom-srv")
            .displayName("My Custom Service custom-srv")
            .telemetry(CustomServiceTelemetryArgs.builder()
                .resourceName("//product.googleapis.com/foo/foo/services/test")
                .build())
            .userLabels(Map.ofEntries(
                Map.entry("my_key", "my_value"),
                Map.entry("my_other_key", "my_other_value")
            ))
            .build());

    }
}
```
```yaml
resources:
  custom:
    type: gcp:monitoring:CustomService
    properties:
      serviceId: custom-srv
      displayName: My Custom Service custom-srv
      telemetry:
        resourceName: //product.googleapis.com/foo/foo/services/test
      userLabels:
        my_key: my_value
        my_other_key: my_other_value
```
<!--End PulumiCodeChooser -->

## Import

Service can be imported using any of these accepted formats:

* `{{project}}/{{name}}`

* `{{project}} {{name}}`

* `{{name}}`

When using the `pulumi import` command, Service can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:monitoring/customService:CustomService default {{project}}/{{name}}
```

```sh
$ pulumi import gcp:monitoring/customService:CustomService default "{{project}} {{name}}"
```

```sh
$ pulumi import gcp:monitoring/customService:CustomService default {{name}}
```

E
displayNameB" 0Name used for UI elements listing this Service.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
g
	serviceIdB" TAn optional service ID to use. If not given, the server will generate a
service ID.
Õ
	telemetryhBf:d
b

monitoringCustomServiceTelemetry<gcp:monitoring/CustomServiceTelemetry:CustomServiceTelemetryVConfiguration for how to query telemetry on a Service.
Structure is documented below.
∫

userLabelsB2" £Labels which have been used to annotate the service. Label keys must start
with a letter. Label keys and values may contain lowercase letters,
numbers, underscores, and dashes. Label keys and values have a maximum
length of 63 characters, and must be less than 128 bytes in size. Up to 64
label entries may be stored. For labels which do not have a semantic value,
the empty string may be supplied for the label value.
"E
displayNameB" 0Name used for UI elements listing this Service.
"q
name" eThe full resource name for this service. The syntax is:
projects/[PROJECT_ID]/services/[SERVICE_ID].
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"e
	serviceId" TAn optional service ID to use. If not given, the server will generate a
service ID.
"Õ
	telemetryhBf:d
b

monitoringCustomServiceTelemetry<gcp:monitoring/CustomServiceTelemetry:CustomServiceTelemetryVConfiguration for how to query telemetry on a Service.
Structure is documented below.
"∫

userLabelsB2" £Labels which have been used to annotate the service. Label keys must start
with a letter. Label keys and values may contain lowercase letters,
numbers, underscores, and dashes. Label keys and values have a maximum
length of 63 characters, and must be less than 128 bytes in size. Up to 64
label entries may be stored. For labels which do not have a semantic value,
the empty string may be supplied for the label value.
*ïw
;

monitoring	Dashboard"gcp:monitoring/dashboard:DashboardìrA Google Stackdriver dashboard. Dashboards define the content and layout of pages in the Stackdriver web application.

To get more information about Dashboards, see:

* [API documentation](https://cloud.google.com/monitoring/api/ref_v3/rest/v1/projects.dashboards)
* How-to Guides
    * [Official Documentation](https://cloud.google.com/monitoring/dashboards)

## Example Usage

### Monitoring Dashboard Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const dashboard = new gcp.monitoring.Dashboard("dashboard", {dashboardJson: `{
  "displayName": "Demo Dashboard",
  "gridLayout": {
    "widgets": [
      {
        "blank": {}
      }
    ]
  }
}

`});
```
```python
import pulumi
import pulumi_gcp as gcp

dashboard = gcp.monitoring.Dashboard("dashboard", dashboard_json="""{
  "displayName": "Demo Dashboard",
  "gridLayout": {
    "widgets": [
      {
        "blank": {}
      }
    ]
  }
}

""")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var dashboard = new Gcp.Monitoring.Dashboard("dashboard", new()
    {
        DashboardJson = @"{
  ""displayName"": ""Demo Dashboard"",
  ""gridLayout"": {
    ""widgets"": [
      {
        ""blank"": {}
      }
    ]
  }
}

",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := monitoring.NewDashboard(ctx, "dashboard", &monitoring.DashboardArgs{
			DashboardJson: pulumi.String(`{
  "displayName": "Demo Dashboard",
  "gridLayout": {
    "widgets": [
      {
        "blank": {}
      }
    ]
  }
}

`),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.Dashboard;
import com.pulumi.gcp.monitoring.DashboardArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var dashboard = new Dashboard("dashboard", DashboardArgs.builder()
            .dashboardJson("""
{
  "displayName": "Demo Dashboard",
  "gridLayout": {
    "widgets": [
      {
        "blank": {}
      }
    ]
  }
}

            """)
            .build());

    }
}
```
```yaml
resources:
  dashboard:
    type: gcp:monitoring:Dashboard
    properties:
      dashboardJson: |+
        {
          "displayName": "Demo Dashboard",
          "gridLayout": {
            "widgets": [
              {
                "blank": {}
              }
            ]
          }
        }
```
<!--End PulumiCodeChooser -->

### Monitoring Dashboard GridLayout


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const dashboard = new gcp.monitoring.Dashboard("dashboard", {dashboardJson: `{
  "displayName": "Grid Layout Example",
  "gridLayout": {
    "columns": "2",
    "widgets": [
      {
        "title": "Widget 1",
        "xyChart": {
          "dataSets": [{
            "timeSeriesQuery": {
              "timeSeriesFilter": {
                "filter": "metric.type=\\"agent.googleapis.com/nginx/connections/accepted_count\\"",
                "aggregation": {
                  "perSeriesAligner": "ALIGN_RATE"
                }
              },
              "unitOverride": "1"
            },
            "plotType": "LINE"
          }],
          "timeshiftDuration": "0s",
          "yAxis": {
            "label": "y1Axis",
            "scale": "LINEAR"
          }
        }
      },
      {
        "text": {
          "content": "Widget 2",
          "format": "MARKDOWN"
        }
      },
      {
        "title": "Widget 3",
        "xyChart": {
          "dataSets": [{
            "timeSeriesQuery": {
              "timeSeriesFilter": {
                "filter": "metric.type=\\"agent.googleapis.com/nginx/connections/accepted_count\\"",
                "aggregation": {
                  "perSeriesAligner": "ALIGN_RATE"
                }
              },
              "unitOverride": "1"
            },
            "plotType": "STACKED_BAR"
          }],
          "timeshiftDuration": "0s",
          "yAxis": {
            "label": "y1Axis",
            "scale": "LINEAR"
          }
        }
      }
    ]
  }
}

`});
```
```python
import pulumi
import pulumi_gcp as gcp

dashboard = gcp.monitoring.Dashboard("dashboard", dashboard_json="""{
  "displayName": "Grid Layout Example",
  "gridLayout": {
    "columns": "2",
    "widgets": [
      {
        "title": "Widget 1",
        "xyChart": {
          "dataSets": [{
            "timeSeriesQuery": {
              "timeSeriesFilter": {
                "filter": "metric.type=\"agent.googleapis.com/nginx/connections/accepted_count\"",
                "aggregation": {
                  "perSeriesAligner": "ALIGN_RATE"
                }
              },
              "unitOverride": "1"
            },
            "plotType": "LINE"
          }],
          "timeshiftDuration": "0s",
          "yAxis": {
            "label": "y1Axis",
            "scale": "LINEAR"
          }
        }
      },
      {
        "text": {
          "content": "Widget 2",
          "format": "MARKDOWN"
        }
      },
      {
        "title": "Widget 3",
        "xyChart": {
          "dataSets": [{
            "timeSeriesQuery": {
              "timeSeriesFilter": {
                "filter": "metric.type=\"agent.googleapis.com/nginx/connections/accepted_count\"",
                "aggregation": {
                  "perSeriesAligner": "ALIGN_RATE"
                }
              },
              "unitOverride": "1"
            },
            "plotType": "STACKED_BAR"
          }],
          "timeshiftDuration": "0s",
          "yAxis": {
            "label": "y1Axis",
            "scale": "LINEAR"
          }
        }
      }
    ]
  }
}

""")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var dashboard = new Gcp.Monitoring.Dashboard("dashboard", new()
    {
        DashboardJson = @"{
  ""displayName"": ""Grid Layout Example"",
  ""gridLayout"": {
    ""columns"": ""2"",
    ""widgets"": [
      {
        ""title"": ""Widget 1"",
        ""xyChart"": {
          ""dataSets"": [{
            ""timeSeriesQuery"": {
              ""timeSeriesFilter"": {
                ""filter"": ""metric.type=\""agent.googleapis.com/nginx/connections/accepted_count\"""",
                ""aggregation"": {
                  ""perSeriesAligner"": ""ALIGN_RATE""
                }
              },
              ""unitOverride"": ""1""
            },
            ""plotType"": ""LINE""
          }],
          ""timeshiftDuration"": ""0s"",
          ""yAxis"": {
            ""label"": ""y1Axis"",
            ""scale"": ""LINEAR""
          }
        }
      },
      {
        ""text"": {
          ""content"": ""Widget 2"",
          ""format"": ""MARKDOWN""
        }
      },
      {
        ""title"": ""Widget 3"",
        ""xyChart"": {
          ""dataSets"": [{
            ""timeSeriesQuery"": {
              ""timeSeriesFilter"": {
                ""filter"": ""metric.type=\""agent.googleapis.com/nginx/connections/accepted_count\"""",
                ""aggregation"": {
                  ""perSeriesAligner"": ""ALIGN_RATE""
                }
              },
              ""unitOverride"": ""1""
            },
            ""plotType"": ""STACKED_BAR""
          }],
          ""timeshiftDuration"": ""0s"",
          ""yAxis"": {
            ""label"": ""y1Axis"",
            ""scale"": ""LINEAR""
          }
        }
      }
    ]
  }
}

",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := monitoring.NewDashboard(ctx, "dashboard", &monitoring.DashboardArgs{
			DashboardJson: pulumi.String(`{
  "displayName": "Grid Layout Example",
  "gridLayout": {
    "columns": "2",
    "widgets": [
      {
        "title": "Widget 1",
        "xyChart": {
          "dataSets": [{
            "timeSeriesQuery": {
              "timeSeriesFilter": {
                "filter": "metric.type=\"agent.googleapis.com/nginx/connections/accepted_count\"",
                "aggregation": {
                  "perSeriesAligner": "ALIGN_RATE"
                }
              },
              "unitOverride": "1"
            },
            "plotType": "LINE"
          }],
          "timeshiftDuration": "0s",
          "yAxis": {
            "label": "y1Axis",
            "scale": "LINEAR"
          }
        }
      },
      {
        "text": {
          "content": "Widget 2",
          "format": "MARKDOWN"
        }
      },
      {
        "title": "Widget 3",
        "xyChart": {
          "dataSets": [{
            "timeSeriesQuery": {
              "timeSeriesFilter": {
                "filter": "metric.type=\"agent.googleapis.com/nginx/connections/accepted_count\"",
                "aggregation": {
                  "perSeriesAligner": "ALIGN_RATE"
                }
              },
              "unitOverride": "1"
            },
            "plotType": "STACKED_BAR"
          }],
          "timeshiftDuration": "0s",
          "yAxis": {
            "label": "y1Axis",
            "scale": "LINEAR"
          }
        }
      }
    ]
  }
}

`),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.Dashboard;
import com.pulumi.gcp.monitoring.DashboardArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var dashboard = new Dashboard("dashboard", DashboardArgs.builder()
            .dashboardJson("""
{
  "displayName": "Grid Layout Example",
  "gridLayout": {
    "columns": "2",
    "widgets": [
      {
        "title": "Widget 1",
        "xyChart": {
          "dataSets": [{
            "timeSeriesQuery": {
              "timeSeriesFilter": {
                "filter": "metric.type=\"agent.googleapis.com/nginx/connections/accepted_count\"",
                "aggregation": {
                  "perSeriesAligner": "ALIGN_RATE"
                }
              },
              "unitOverride": "1"
            },
            "plotType": "LINE"
          }],
          "timeshiftDuration": "0s",
          "yAxis": {
            "label": "y1Axis",
            "scale": "LINEAR"
          }
        }
      },
      {
        "text": {
          "content": "Widget 2",
          "format": "MARKDOWN"
        }
      },
      {
        "title": "Widget 3",
        "xyChart": {
          "dataSets": [{
            "timeSeriesQuery": {
              "timeSeriesFilter": {
                "filter": "metric.type=\"agent.googleapis.com/nginx/connections/accepted_count\"",
                "aggregation": {
                  "perSeriesAligner": "ALIGN_RATE"
                }
              },
              "unitOverride": "1"
            },
            "plotType": "STACKED_BAR"
          }],
          "timeshiftDuration": "0s",
          "yAxis": {
            "label": "y1Axis",
            "scale": "LINEAR"
          }
        }
      }
    ]
  }
}

            """)
            .build());

    }
}
```
```yaml
resources:
  dashboard:
    type: gcp:monitoring:Dashboard
    properties:
      dashboardJson: |+
        {
          "displayName": "Grid Layout Example",
          "gridLayout": {
            "columns": "2",
            "widgets": [
              {
                "title": "Widget 1",
                "xyChart": {
                  "dataSets": [{
                    "timeSeriesQuery": {
                      "timeSeriesFilter": {
                        "filter": "metric.type=\"agent.googleapis.com/nginx/connections/accepted_count\"",
                        "aggregation": {
                          "perSeriesAligner": "ALIGN_RATE"
                        }
                      },
                      "unitOverride": "1"
                    },
                    "plotType": "LINE"
                  }],
                  "timeshiftDuration": "0s",
                  "yAxis": {
                    "label": "y1Axis",
                    "scale": "LINEAR"
                  }
                }
              },
              {
                "text": {
                  "content": "Widget 2",
                  "format": "MARKDOWN"
                }
              },
              {
                "title": "Widget 3",
                "xyChart": {
                  "dataSets": [{
                    "timeSeriesQuery": {
                      "timeSeriesFilter": {
                        "filter": "metric.type=\"agent.googleapis.com/nginx/connections/accepted_count\"",
                        "aggregation": {
                          "perSeriesAligner": "ALIGN_RATE"
                        }
                      },
                      "unitOverride": "1"
                    },
                    "plotType": "STACKED_BAR"
                  }],
                  "timeshiftDuration": "0s",
                  "yAxis": {
                    "label": "y1Axis",
                    "scale": "LINEAR"
                  }
                }
              }
            ]
          }
        }
```
<!--End PulumiCodeChooser -->

## Import

Dashboard can be imported using any of these accepted formats:

* `projects/{{project}}/dashboards/{{dashboard_id}}`

* `{{dashboard_id}}`

When using the `pulumi import` command, Dashboard can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:monitoring/dashboard:Dashboard default projects/{{project}}/dashboards/{{dashboard_id}}
```

```sh
$ pulumi import gcp:monitoring/dashboard:Dashboard default {{dashboard_id}}
```

¢
dashboardJson" åThe JSON representation of a dashboard, following the format at
https://cloud.google.com/monitoring/api/ref_v3/rest/v1/projects.dashboards.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"¢
dashboardJson" åThe JSON representation of a dashboard, following the format at
https://cloud.google.com/monitoring/api/ref_v3/rest/v1/projects.dashboards.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
*ó?
J

monitoringGenericService,gcp:monitoring/genericService:GenericService‹)A Service is a discrete, autonomous, and network-accessible unit,
designed to solve an individual concern. In Cloud Monitoring,
a Service acts as the root resource under which operational aspects of
the service are accessible


To get more information about GenericService, see:

* [API documentation](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/services)
* How-to Guides
    * [Monitoring API Documentation](https://cloud.google.com/monitoring/api/v3/)
    * [Service Monitoring](https://cloud.google.com/monitoring/service-monitoring)
    * [Service-orientation on Wikipedia](https://en.wikipedia.org/wiki/Service-orientation)

## Example Usage

### Monitoring Service Example


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const myService = new gcp.monitoring.GenericService("my_service", {
    serviceId: "my-service",
    displayName: "My Service my-service",
    userLabels: {
        my_key: "my_value",
        my_other_key: "my_other_value",
    },
    basicService: {
        serviceType: "APP_ENGINE",
        serviceLabels: {
            module_id: "another-module-id",
        },
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

my_service = gcp.monitoring.GenericService("my_service",
    service_id="my-service",
    display_name="My Service my-service",
    user_labels={
        "my_key": "my_value",
        "my_other_key": "my_other_value",
    },
    basic_service={
        "service_type": "APP_ENGINE",
        "service_labels": {
            "module_id": "another-module-id",
        },
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var myService = new Gcp.Monitoring.GenericService("my_service", new()
    {
        ServiceId = "my-service",
        DisplayName = "My Service my-service",
        UserLabels = 
        {
            { "my_key", "my_value" },
            { "my_other_key", "my_other_value" },
        },
        BasicService = new Gcp.Monitoring.Inputs.GenericServiceBasicServiceArgs
        {
            ServiceType = "APP_ENGINE",
            ServiceLabels = 
            {
                { "module_id", "another-module-id" },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := monitoring.NewGenericService(ctx, "my_service", &monitoring.GenericServiceArgs{
			ServiceId:   pulumi.String("my-service"),
			DisplayName: pulumi.String("My Service my-service"),
			UserLabels: pulumi.StringMap{
				"my_key":       pulumi.String("my_value"),
				"my_other_key": pulumi.String("my_other_value"),
			},
			BasicService: &monitoring.GenericServiceBasicServiceArgs{
				ServiceType: pulumi.String("APP_ENGINE"),
				ServiceLabels: pulumi.StringMap{
					"module_id": pulumi.String("another-module-id"),
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.GenericService;
import com.pulumi.gcp.monitoring.GenericServiceArgs;
import com.pulumi.gcp.monitoring.inputs.GenericServiceBasicServiceArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var myService = new GenericService("myService", GenericServiceArgs.builder()
            .serviceId("my-service")
            .displayName("My Service my-service")
            .userLabels(Map.ofEntries(
                Map.entry("my_key", "my_value"),
                Map.entry("my_other_key", "my_other_value")
            ))
            .basicService(GenericServiceBasicServiceArgs.builder()
                .serviceType("APP_ENGINE")
                .serviceLabels(Map.of("module_id", "another-module-id"))
                .build())
            .build());

    }
}
```
```yaml
resources:
  myService:
    type: gcp:monitoring:GenericService
    name: my_service
    properties:
      serviceId: my-service
      displayName: My Service my-service
      userLabels:
        my_key: my_value
        my_other_key: my_other_value
      basicService:
        serviceType: APP_ENGINE
        serviceLabels:
          module_id: another-module-id
```
<!--End PulumiCodeChooser -->

## Import

GenericService can be imported using any of these accepted formats:

* `projects/{{project}}/services/{{service_id}}`

* `{{project}}/{{service_id}}`

* `{{service_id}}`

When using the `pulumi import` command, GenericService can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:monitoring/genericService:GenericService default projects/{{project}}/services/{{service_id}}
```

```sh
$ pulumi import gcp:monitoring/genericService:GenericService default {{project}}/{{service_id}}
```

```sh
$ pulumi import gcp:monitoring/genericService:GenericService default {{service_id}}
```

†
basicServicetBr:p
n

monitoringGenericServiceBasicServiceDgcp:monitoring/GenericServiceBasicService:GenericServiceBasicServiceôA well-known service type, defined by its service type and service labels.
Valid values of service types and services labels are described at
https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli
Structure is documented below.
E
displayNameB" 0Name used for UI elements listing this Service.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
m
	serviceId" \An optional service ID to use. If not given, the server will generate a
service ID.


- - -
∫

userLabelsB2" £Labels which have been used to annotate the service. Label keys must start
with a letter. Label keys and values may contain lowercase letters,
numbers, underscores, and dashes. Label keys and values have a maximum
length of 63 characters, and must be less than 128 bytes in size. Up to 64
label entries may be stored. For labels which do not have a semantic value,
the empty string may be supplied for the label value.
"†
basicServicetBr:p
n

monitoringGenericServiceBasicServiceDgcp:monitoring/GenericServiceBasicService:GenericServiceBasicServiceôA well-known service type, defined by its service type and service labels.
Valid values of service types and services labels are described at
https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli
Structure is documented below.
"E
displayNameB" 0Name used for UI elements listing this Service.
"q
name" eThe full resource name for this service. The syntax is:
projects/[PROJECT_ID]/services/[SERVICE_ID].
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"m
	serviceId" \An optional service ID to use. If not given, the server will generate a
service ID.


- - -
"“
telemetriesk*i:g
e

monitoringGenericServiceTelemetry>gcp:monitoring/GenericServiceTelemetry:GenericServiceTelemetryVConfiguration for how to query telemetry on a Service.
Structure is documented below.
"∫

userLabelsB2" £Labels which have been used to annotate the service. Label keys must start
with a letter. Label keys and values may contain lowercase letters,
numbers, underscores, and dashes. Label keys and values have a maximum
length of 63 characters, and must be less than 128 bytes in size. Up to 64
label entries may be stored. For labels which do not have a semantic value,
the empty string may be supplied for the label value.
*êA
/

monitoringGroupgcp:monitoring/group:Groupõ5The description of a dynamic collection of monitored resources. Each group
has a filter that is matched against monitored resources and their
associated metadata. If a group's filter matches an available monitored
resource, then that resource is a member of that group.


To get more information about Group, see:

* [API documentation](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.groups)
* How-to Guides
    * [Official Documentation](https://cloud.google.com/monitoring/groups/)

## Example Usage

### Monitoring Group Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const basic = new gcp.monitoring.Group("basic", {
    displayName: "tf-test MonitoringGroup",
    filter: "resource.metadata.region=\"europe-west2\"",
});
```
```python
import pulumi
import pulumi_gcp as gcp

basic = gcp.monitoring.Group("basic",
    display_name="tf-test MonitoringGroup",
    filter="resource.metadata.region=\"europe-west2\"")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var basic = new Gcp.Monitoring.Group("basic", new()
    {
        DisplayName = "tf-test MonitoringGroup",
        Filter = "resource.metadata.region=\"europe-west2\"",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := monitoring.NewGroup(ctx, "basic", &monitoring.GroupArgs{
			DisplayName: pulumi.String("tf-test MonitoringGroup"),
			Filter:      pulumi.String("resource.metadata.region=\"europe-west2\""),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.Group;
import com.pulumi.gcp.monitoring.GroupArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var basic = new Group("basic", GroupArgs.builder()
            .displayName("tf-test MonitoringGroup")
            .filter("resource.metadata.region=\"europe-west2\"")
            .build());

    }
}
```
```yaml
resources:
  basic:
    type: gcp:monitoring:Group
    properties:
      displayName: tf-test MonitoringGroup
      filter: resource.metadata.region="europe-west2"
```
<!--End PulumiCodeChooser -->
### Monitoring Group Subgroup


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const parent = new gcp.monitoring.Group("parent", {
    displayName: "tf-test MonitoringParentGroup",
    filter: "resource.metadata.region=\"europe-west2\"",
});
const subgroup = new gcp.monitoring.Group("subgroup", {
    displayName: "tf-test MonitoringSubGroup",
    filter: "resource.metadata.region=\"europe-west2\"",
    parentName: parent.name,
});
```
```python
import pulumi
import pulumi_gcp as gcp

parent = gcp.monitoring.Group("parent",
    display_name="tf-test MonitoringParentGroup",
    filter="resource.metadata.region=\"europe-west2\"")
subgroup = gcp.monitoring.Group("subgroup",
    display_name="tf-test MonitoringSubGroup",
    filter="resource.metadata.region=\"europe-west2\"",
    parent_name=parent.name)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var parent = new Gcp.Monitoring.Group("parent", new()
    {
        DisplayName = "tf-test MonitoringParentGroup",
        Filter = "resource.metadata.region=\"europe-west2\"",
    });

    var subgroup = new Gcp.Monitoring.Group("subgroup", new()
    {
        DisplayName = "tf-test MonitoringSubGroup",
        Filter = "resource.metadata.region=\"europe-west2\"",
        ParentName = parent.Name,
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		parent, err := monitoring.NewGroup(ctx, "parent", &monitoring.GroupArgs{
			DisplayName: pulumi.String("tf-test MonitoringParentGroup"),
			Filter:      pulumi.String("resource.metadata.region=\"europe-west2\""),
		})
		if err != nil {
			return err
		}
		_, err = monitoring.NewGroup(ctx, "subgroup", &monitoring.GroupArgs{
			DisplayName: pulumi.String("tf-test MonitoringSubGroup"),
			Filter:      pulumi.String("resource.metadata.region=\"europe-west2\""),
			ParentName:  parent.Name,
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.Group;
import com.pulumi.gcp.monitoring.GroupArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var parent = new Group("parent", GroupArgs.builder()
            .displayName("tf-test MonitoringParentGroup")
            .filter("resource.metadata.region=\"europe-west2\"")
            .build());

        var subgroup = new Group("subgroup", GroupArgs.builder()
            .displayName("tf-test MonitoringSubGroup")
            .filter("resource.metadata.region=\"europe-west2\"")
            .parentName(parent.name())
            .build());

    }
}
```
```yaml
resources:
  parent:
    type: gcp:monitoring:Group
    properties:
      displayName: tf-test MonitoringParentGroup
      filter: resource.metadata.region="europe-west2"
  subgroup:
    type: gcp:monitoring:Group
    properties:
      displayName: tf-test MonitoringSubGroup
      filter: resource.metadata.region="europe-west2"
      parentName: ${parent.name}
```
<!--End PulumiCodeChooser -->

## Import

Group can be imported using any of these accepted formats:

* `{{project}}/{{name}}`

* `{{project}} {{name}}`

* `{{name}}`

When using the `pulumi import` command, Group can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:monitoring/group:Group default {{project}}/{{name}}
```

```sh
$ pulumi import gcp:monitoring/group:Group default "{{project}} {{name}}"
```

```sh
$ pulumi import gcp:monitoring/group:Group default {{name}}
```

X
displayName" EA user-assigned name for this group, used only for display
purposes.
c
filter" UThe filter used to determine which monitored resources
belong to this group.


- - -
ü
	isClusterB
 ãIf true, the members of this group are considered to be a
cluster. The system can perform additional analysis on
groups that are clusters.
∆

parentNameB" ±The name of the group's parent, if it has one. The format is
"projects/{project_id_or_number}/groups/{group_id}". For
groups with no parent, parentName is the empty string, "".
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"X
displayName" EA user-assigned name for this group, used only for display
purposes.
"c
filter" UThe filter used to determine which monitored resources
belong to this group.


- - -
"ü
	isClusterB
 ãIf true, the members of this group are considered to be a
cluster. The system can perform additional analysis on
groups that are clusters.
"s
name" gA unique identifier for this group. The format is
"projects/{project_id_or_number}/groups/{group_id}".
"∆

parentNameB" ±The name of the group's parent, if it has one. The format is
"projects/{project_id_or_number}/groups/{group_id}". For
groups with no parent, parentName is the empty string, "".
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
*œ°
P

monitoringMetricDescriptor0gcp:monitoring/metricDescriptor:MetricDescriptor¸fDefines a metric type and its schema. Once a metric descriptor is created, deleting or altering it stops data collection and makes the metric type's existing data unusable.


To get more information about MetricDescriptor, see:

* [API documentation](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors)
* How-to Guides
    * [Official Documentation](https://cloud.google.com/monitoring/custom-metrics/)

## Example Usage

### Monitoring Metric Descriptor Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const basic = new gcp.monitoring.MetricDescriptor("basic", {
    description: "Daily sales records from all branch stores.",
    displayName: "metric-descriptor",
    type: "custom.googleapis.com/stores/daily_sales",
    metricKind: "GAUGE",
    valueType: "DOUBLE",
    unit: "{USD}",
    labels: [{
        key: "store_id",
        valueType: "STRING",
        description: "The ID of the store.",
    }],
    launchStage: "BETA",
    metadata: {
        samplePeriod: "60s",
        ingestDelay: "30s",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

basic = gcp.monitoring.MetricDescriptor("basic",
    description="Daily sales records from all branch stores.",
    display_name="metric-descriptor",
    type="custom.googleapis.com/stores/daily_sales",
    metric_kind="GAUGE",
    value_type="DOUBLE",
    unit="{USD}",
    labels=[{
        "key": "store_id",
        "value_type": "STRING",
        "description": "The ID of the store.",
    }],
    launch_stage="BETA",
    metadata={
        "sample_period": "60s",
        "ingest_delay": "30s",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var basic = new Gcp.Monitoring.MetricDescriptor("basic", new()
    {
        Description = "Daily sales records from all branch stores.",
        DisplayName = "metric-descriptor",
        Type = "custom.googleapis.com/stores/daily_sales",
        MetricKind = "GAUGE",
        ValueType = "DOUBLE",
        Unit = "{USD}",
        Labels = new[]
        {
            new Gcp.Monitoring.Inputs.MetricDescriptorLabelArgs
            {
                Key = "store_id",
                ValueType = "STRING",
                Description = "The ID of the store.",
            },
        },
        LaunchStage = "BETA",
        Metadata = new Gcp.Monitoring.Inputs.MetricDescriptorMetadataArgs
        {
            SamplePeriod = "60s",
            IngestDelay = "30s",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := monitoring.NewMetricDescriptor(ctx, "basic", &monitoring.MetricDescriptorArgs{
			Description: pulumi.String("Daily sales records from all branch stores."),
			DisplayName: pulumi.String("metric-descriptor"),
			Type:        pulumi.String("custom.googleapis.com/stores/daily_sales"),
			MetricKind:  pulumi.String("GAUGE"),
			ValueType:   pulumi.String("DOUBLE"),
			Unit:        pulumi.String("{USD}"),
			Labels: monitoring.MetricDescriptorLabelArray{
				&monitoring.MetricDescriptorLabelArgs{
					Key:         pulumi.String("store_id"),
					ValueType:   pulumi.String("STRING"),
					Description: pulumi.String("The ID of the store."),
				},
			},
			LaunchStage: pulumi.String("BETA"),
			Metadata: &monitoring.MetricDescriptorMetadataArgs{
				SamplePeriod: pulumi.String("60s"),
				IngestDelay:  pulumi.String("30s"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.MetricDescriptor;
import com.pulumi.gcp.monitoring.MetricDescriptorArgs;
import com.pulumi.gcp.monitoring.inputs.MetricDescriptorLabelArgs;
import com.pulumi.gcp.monitoring.inputs.MetricDescriptorMetadataArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var basic = new MetricDescriptor("basic", MetricDescriptorArgs.builder()
            .description("Daily sales records from all branch stores.")
            .displayName("metric-descriptor")
            .type("custom.googleapis.com/stores/daily_sales")
            .metricKind("GAUGE")
            .valueType("DOUBLE")
            .unit("{USD}")
            .labels(MetricDescriptorLabelArgs.builder()
                .key("store_id")
                .valueType("STRING")
                .description("The ID of the store.")
                .build())
            .launchStage("BETA")
            .metadata(MetricDescriptorMetadataArgs.builder()
                .samplePeriod("60s")
                .ingestDelay("30s")
                .build())
            .build());

    }
}
```
```yaml
resources:
  basic:
    type: gcp:monitoring:MetricDescriptor
    properties:
      description: Daily sales records from all branch stores.
      displayName: metric-descriptor
      type: custom.googleapis.com/stores/daily_sales
      metricKind: GAUGE
      valueType: DOUBLE
      unit: '{USD}'
      labels:
        - key: store_id
          valueType: STRING
          description: The ID of the store.
      launchStage: BETA
      metadata:
        samplePeriod: 60s
        ingestDelay: 30s
```
<!--End PulumiCodeChooser -->
### Monitoring Metric Descriptor Alert


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const withAlert = new gcp.monitoring.MetricDescriptor("with_alert", {
    description: "Daily sales records from all branch stores.",
    displayName: "metric-descriptor",
    type: "custom.googleapis.com/stores/daily_sales",
    metricKind: "GAUGE",
    valueType: "DOUBLE",
    unit: "{USD}",
});
const alertPolicy = new gcp.monitoring.AlertPolicy("alert_policy", {
    displayName: "metric-descriptor",
    combiner: "OR",
    conditions: [{
        displayName: "test condition",
        conditionThreshold: {
            filter: pulumi.interpolate`metric.type="${withAlert.type}" AND resource.type="gce_instance"`,
            duration: "60s",
            comparison: "COMPARISON_GT",
        },
    }],
});
```
```python
import pulumi
import pulumi_gcp as gcp

with_alert = gcp.monitoring.MetricDescriptor("with_alert",
    description="Daily sales records from all branch stores.",
    display_name="metric-descriptor",
    type="custom.googleapis.com/stores/daily_sales",
    metric_kind="GAUGE",
    value_type="DOUBLE",
    unit="{USD}")
alert_policy = gcp.monitoring.AlertPolicy("alert_policy",
    display_name="metric-descriptor",
    combiner="OR",
    conditions=[{
        "display_name": "test condition",
        "condition_threshold": {
            "filter": with_alert.type.apply(lambda type: f"metric.type=\"{type}\" AND resource.type=\"gce_instance\""),
            "duration": "60s",
            "comparison": "COMPARISON_GT",
        },
    }])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var withAlert = new Gcp.Monitoring.MetricDescriptor("with_alert", new()
    {
        Description = "Daily sales records from all branch stores.",
        DisplayName = "metric-descriptor",
        Type = "custom.googleapis.com/stores/daily_sales",
        MetricKind = "GAUGE",
        ValueType = "DOUBLE",
        Unit = "{USD}",
    });

    var alertPolicy = new Gcp.Monitoring.AlertPolicy("alert_policy", new()
    {
        DisplayName = "metric-descriptor",
        Combiner = "OR",
        Conditions = new[]
        {
            new Gcp.Monitoring.Inputs.AlertPolicyConditionArgs
            {
                DisplayName = "test condition",
                ConditionThreshold = new Gcp.Monitoring.Inputs.AlertPolicyConditionConditionThresholdArgs
                {
                    Filter = withAlert.Type.Apply(type => $"metric.type=\"{type}\" AND resource.type=\"gce_instance\""),
                    Duration = "60s",
                    Comparison = "COMPARISON_GT",
                },
            },
        },
    });

});
```
```go
package main

import (
	"fmt"

	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		withAlert, err := monitoring.NewMetricDescriptor(ctx, "with_alert", &monitoring.MetricDescriptorArgs{
			Description: pulumi.String("Daily sales records from all branch stores."),
			DisplayName: pulumi.String("metric-descriptor"),
			Type:        pulumi.String("custom.googleapis.com/stores/daily_sales"),
			MetricKind:  pulumi.String("GAUGE"),
			ValueType:   pulumi.String("DOUBLE"),
			Unit:        pulumi.String("{USD}"),
		})
		if err != nil {
			return err
		}
		_, err = monitoring.NewAlertPolicy(ctx, "alert_policy", &monitoring.AlertPolicyArgs{
			DisplayName: pulumi.String("metric-descriptor"),
			Combiner:    pulumi.String("OR"),
			Conditions: monitoring.AlertPolicyConditionArray{
				&monitoring.AlertPolicyConditionArgs{
					DisplayName: pulumi.String("test condition"),
					ConditionThreshold: &monitoring.AlertPolicyConditionConditionThresholdArgs{
						Filter: withAlert.Type.ApplyT(func(_type string) (string, error) {
							return fmt.Sprintf("metric.type=\"%v\" AND resource.type=\"gce_instance\"", _type), nil
						}).(pulumi.StringOutput),
						Duration:   pulumi.String("60s"),
						Comparison: pulumi.String("COMPARISON_GT"),
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.MetricDescriptor;
import com.pulumi.gcp.monitoring.MetricDescriptorArgs;
import com.pulumi.gcp.monitoring.AlertPolicy;
import com.pulumi.gcp.monitoring.AlertPolicyArgs;
import com.pulumi.gcp.monitoring.inputs.AlertPolicyConditionArgs;
import com.pulumi.gcp.monitoring.inputs.AlertPolicyConditionConditionThresholdArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var withAlert = new MetricDescriptor("withAlert", MetricDescriptorArgs.builder()
            .description("Daily sales records from all branch stores.")
            .displayName("metric-descriptor")
            .type("custom.googleapis.com/stores/daily_sales")
            .metricKind("GAUGE")
            .valueType("DOUBLE")
            .unit("{USD}")
            .build());

        var alertPolicy = new AlertPolicy("alertPolicy", AlertPolicyArgs.builder()
            .displayName("metric-descriptor")
            .combiner("OR")
            .conditions(AlertPolicyConditionArgs.builder()
                .displayName("test condition")
                .conditionThreshold(AlertPolicyConditionConditionThresholdArgs.builder()
                    .filter(withAlert.type().applyValue(type -> String.format("metric.type=\"%s\" AND resource.type=\"gce_instance\"", type)))
                    .duration("60s")
                    .comparison("COMPARISON_GT")
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  withAlert:
    type: gcp:monitoring:MetricDescriptor
    name: with_alert
    properties:
      description: Daily sales records from all branch stores.
      displayName: metric-descriptor
      type: custom.googleapis.com/stores/daily_sales
      metricKind: GAUGE
      valueType: DOUBLE
      unit: '{USD}'
  alertPolicy:
    type: gcp:monitoring:AlertPolicy
    name: alert_policy
    properties:
      displayName: metric-descriptor
      combiner: OR
      conditions:
        - displayName: test condition
          conditionThreshold:
            filter: metric.type="${withAlert.type}" AND resource.type="gce_instance"
            duration: 60s
            comparison: COMPARISON_GT
```
<!--End PulumiCodeChooser -->

## Import

MetricDescriptor can be imported using any of these accepted formats:

* `{{project}}/{{name}}`

* `{{project}} {{name}}`

* `{{name}}`

When using the `pulumi import` command, MetricDescriptor can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:monitoring/metricDescriptor:MetricDescriptor default {{project}}/{{name}}
```

```sh
$ pulumi import gcp:monitoring/metricDescriptor:MetricDescriptor default "{{project}} {{name}}"
```

```sh
$ pulumi import gcp:monitoring/metricDescriptor:MetricDescriptor default {{name}}
```

]
description" JA detailed description of the metric, which can be used in documentation.
Ø
displayName" õA concise name for the metric, which can be displayed in user interfaces. Use sentence case without an ending period, for example "Request count".


- - -
“
labelsgBe*c:a
_

monitoringMetricDescriptorLabel:gcp:monitoring/MetricDescriptorLabel:MetricDescriptorLabelﬁThe set of labels that can be used to describe a specific instance of this metric type. In order to delete a label, the entire resource must be deleted, then created with the desired labels.
Structure is documented below.
≈
launchStageB" ØThe launch stage of the metric definition.
Possible values are: `LAUNCH_STAGE_UNSPECIFIED`, `UNIMPLEMENTED`, `PRELAUNCH`, `EARLY_ACCESS`, `ALPHA`, `BETA`, `GA`, `DEPRECATED`.
‘
metadatanBl:j
h

monitoringMetricDescriptorMetadata@gcp:monitoring/MetricDescriptorMetadata:MetricDescriptorMetadataXMetadata which can be used to guide usage of the metric.
Structure is documented below.
Û

metricKind" ‡Whether the metric records instantaneous values, changes to a value, etc. Some combinations of metricKind and valueType might not be supported.
Possible values are: `METRIC_KIND_UNSPECIFIED`, `GAUGE`, `DELTA`, `CUMULATIVE`.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
‡
type" ”The metric type, including its DNS name prefix. The type is not URL-encoded. All service defined metrics must be prefixed with the service name, in the format of {service name}/{relative metric name}, such as cloudsql.googleapis.com/database/cpu/utilization. The relative metric name must have only upper and lower-case letters, digits, '/' and underscores '_' are allowed. Additionally, the maximum number of characters allowed for the relative_metric_name is 100. All user-defined metric types have the DNS name custom.googleapis.com, external.googleapis.com, or logging.googleapis.com/user/.
—	
unitB" ¬	The units in which the metric value is reported. It is only applicable if the
valueType is INT64, DOUBLE, or DISTRIBUTION. The unit defines the representation of
the stored metric values.
Different systems may scale the values to be more easily displayed (so a value of
0.02KBy might be displayed as 20By, and a value of 3523KBy might be displayed as
3.5MBy). However, if the unit is KBy, then the value of the metric is always in
thousands of bytes, no matter how it may be displayed.
If you want a custom metric to record the exact number of CPU-seconds used by a job,
you can create an INT64 CUMULATIVE metric whose unit is s{CPU} (or equivalently
1s{CPU} or just s). If the job uses 12,005 CPU-seconds, then the value is written as
12005.
Alternatively, if you want a custom metric to record data in a more granular way, you
can create a DOUBLE CUMULATIVE metric whose unit is ks{CPU}, and then write the value
12.005 (which is 12005/1000), or use Kis{CPU} and write 11.723 (which is 12005/1024).
The supported units are a subset of The Unified Code for Units of Measure standard.
More info can be found in the API documentation
(https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors).
Á
	valueType" ’Whether the measurement is an integer, a floating-point number, etc. Some combinations of metricKind and valueType might not be supported.
Possible values are: `BOOL`, `INT64`, `DOUBLE`, `STRING`, `DISTRIBUTION`.
"]
description" JA detailed description of the metric, which can be used in documentation.
"Ø
displayName" õA concise name for the metric, which can be displayed in user interfaces. Use sentence case without an ending period, for example "Request count".


- - -
"“
labelsgBe*c:a
_

monitoringMetricDescriptorLabel:gcp:monitoring/MetricDescriptorLabel:MetricDescriptorLabelﬁThe set of labels that can be used to describe a specific instance of this metric type. In order to delete a label, the entire resource must be deleted, then created with the desired labels.
Structure is documented below.
"≈
launchStageB" ØThe launch stage of the metric definition.
Possible values are: `LAUNCH_STAGE_UNSPECIFIED`, `UNIMPLEMENTED`, `PRELAUNCH`, `EARLY_ACCESS`, `ALPHA`, `BETA`, `GA`, `DEPRECATED`.
"‘
metadatanBl:j
h

monitoringMetricDescriptorMetadata@gcp:monitoring/MetricDescriptorMetadata:MetricDescriptorMetadataXMetadata which can be used to guide usage of the metric.
Structure is documented below.
"Û

metricKind" ‡Whether the metric records instantaneous values, changes to a value, etc. Some combinations of metricKind and valueType might not be supported.
Possible values are: `METRIC_KIND_UNSPECIFIED`, `GAUGE`, `DELTA`, `CUMULATIVE`.
"ë
monitoredResourceTypes*" If present, then a time series, which is identified partially by a metric type and a MonitoredResourceDescriptor, that is associated with this metric type can only be associated with one of the monitored resource types listed here. This field allows time series to be associated with the intersection of this metric type and the monitored resource types in this list.
"8
name" ,The resource name of the metric descriptor.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"‡
type" ”The metric type, including its DNS name prefix. The type is not URL-encoded. All service defined metrics must be prefixed with the service name, in the format of {service name}/{relative metric name}, such as cloudsql.googleapis.com/database/cpu/utilization. The relative metric name must have only upper and lower-case letters, digits, '/' and underscores '_' are allowed. Additionally, the maximum number of characters allowed for the relative_metric_name is 100. All user-defined metric types have the DNS name custom.googleapis.com, external.googleapis.com, or logging.googleapis.com/user/.
"—	
unitB" ¬	The units in which the metric value is reported. It is only applicable if the
valueType is INT64, DOUBLE, or DISTRIBUTION. The unit defines the representation of
the stored metric values.
Different systems may scale the values to be more easily displayed (so a value of
0.02KBy might be displayed as 20By, and a value of 3523KBy might be displayed as
3.5MBy). However, if the unit is KBy, then the value of the metric is always in
thousands of bytes, no matter how it may be displayed.
If you want a custom metric to record the exact number of CPU-seconds used by a job,
you can create an INT64 CUMULATIVE metric whose unit is s{CPU} (or equivalently
1s{CPU} or just s). If the job uses 12,005 CPU-seconds, then the value is written as
12005.
Alternatively, if you want a custom metric to record data in a more granular way, you
can create a DOUBLE CUMULATIVE metric whose unit is ks{CPU}, and then write the value
12.005 (which is 12005/1000), or use Kis{CPU} and write 11.723 (which is 12005/1024).
The supported units are a subset of The Unified Code for Units of Measure standard.
More info can be found in the API documentation
(https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors).
"Á
	valueType" ’Whether the measurement is an integer, a floating-point number, etc. Some combinations of metricKind and valueType might not be supported.
Possible values are: `BOOL`, `INT64`, `DOUBLE`, `STRING`, `DISTRIBUTION`.
*Á+
P

monitoringMonitoredProject0gcp:monitoring/monitoredProject:MonitoredProject™"A [project being monitored](https://cloud.google.com/monitoring/settings/multiple-projects#create-multi) by a Metrics Scope.


To get more information about MonitoredProject, see:

* [API documentation](https://cloud.google.com/monitoring/api/ref_v3/rest/v1/locations.global.metricsScopes.projects)
* How-to Guides
    * [Official Documentation](https://cloud.google.com/monitoring/settings/manage-api)

## Example Usage

### Monitoring Monitored Project Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const basic = new gcp.organizations.Project("basic", {
    projectId: "m-id",
    name: "m-id-display",
    orgId: "123456789",
    deletionPolicy: "DELETE",
});
const primary = new gcp.monitoring.MonitoredProject("primary", {
    metricsScope: "my-project-name",
    name: basic.projectId,
});
```
```python
import pulumi
import pulumi_gcp as gcp

basic = gcp.organizations.Project("basic",
    project_id="m-id",
    name="m-id-display",
    org_id="123456789",
    deletion_policy="DELETE")
primary = gcp.monitoring.MonitoredProject("primary",
    metrics_scope="my-project-name",
    name=basic.project_id)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var basic = new Gcp.Organizations.Project("basic", new()
    {
        ProjectId = "m-id",
        Name = "m-id-display",
        OrgId = "123456789",
        DeletionPolicy = "DELETE",
    });

    var primary = new Gcp.Monitoring.MonitoredProject("primary", new()
    {
        MetricsScope = "my-project-name",
        Name = basic.ProjectId,
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		basic, err := organizations.NewProject(ctx, "basic", &organizations.ProjectArgs{
			ProjectId:      pulumi.String("m-id"),
			Name:           pulumi.String("m-id-display"),
			OrgId:          pulumi.String("123456789"),
			DeletionPolicy: pulumi.String("DELETE"),
		})
		if err != nil {
			return err
		}
		_, err = monitoring.NewMonitoredProject(ctx, "primary", &monitoring.MonitoredProjectArgs{
			MetricsScope: pulumi.String("my-project-name"),
			Name:         basic.ProjectId,
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.organizations.Project;
import com.pulumi.gcp.organizations.ProjectArgs;
import com.pulumi.gcp.monitoring.MonitoredProject;
import com.pulumi.gcp.monitoring.MonitoredProjectArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var basic = new Project("basic", ProjectArgs.builder()
            .projectId("m-id")
            .name("m-id-display")
            .orgId("123456789")
            .deletionPolicy("DELETE")
            .build());

        var primary = new MonitoredProject("primary", MonitoredProjectArgs.builder()
            .metricsScope("my-project-name")
            .name(basic.projectId())
            .build());

    }
}
```
```yaml
resources:
  primary:
    type: gcp:monitoring:MonitoredProject
    properties:
      metricsScope: my-project-name
      name: ${basic.projectId}
  basic:
    type: gcp:organizations:Project
    properties:
      projectId: m-id
      name: m-id-display
      orgId: '123456789'
      deletionPolicy: DELETE
```
<!--End PulumiCodeChooser -->

## Import

MonitoredProject can be imported using any of these accepted formats:

* `v1/locations/global/metricsScopes/{{name}}`

* `{{name}}`

When using the `pulumi import` command, MonitoredProject can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:monitoring/monitoredProject:MonitoredProject default v1/locations/global/metricsScopes/{{name}}
```

```sh
$ pulumi import gcp:monitoring/monitoredProject:MonitoredProject default {{name}}
```

æ
metricsScope" ©Required. The resource name of the existing Metrics Scope that will monitor this project. Example: locations/global/metricsScopes/{SCOPING_PROJECT_ID_OR_NUMBER}


- - -
«
nameB" ∏Immutable. The resource name of the `MonitoredProject`. On input, the resource name includes the scoping project ID and monitored project ID. On output, it contains the equivalent project numbers. Example: `locations/global/metricsScopes/{SCOPING_PROJECT_ID_OR_NUMBER}/projects/{MONITORED_PROJECT_ID_OR_NUMBER}`
"R

createTime" @Output only. The time when this `MonitoredProject` was created.
"æ
metricsScope" ©Required. The resource name of the existing Metrics Scope that will monitor this project. Example: locations/global/metricsScopes/{SCOPING_PROJECT_ID_OR_NUMBER}


- - -
"≈
name" ∏Immutable. The resource name of the `MonitoredProject`. On input, the resource name includes the scoping project ID and monitored project ID. On output, it contains the equivalent project numbers. Example: `locations/global/metricsScopes/{SCOPING_PROJECT_ID_OR_NUMBER}/projects/{MONITORED_PROJECT_ID_OR_NUMBER}`
*„z
Y

monitoringNotificationChannel6gcp:monitoring/notificationChannel:NotificationChannelÇ=A NotificationChannel is a medium through which an alert is delivered
when a policy violation is detected. Examples of channels include email, SMS,
and third-party messaging applications. Fields containing sensitive information
like authentication tokens or contact info are only partially populated on retrieval.

Notification Channels are designed to be flexible and are made up of a supported `type`
and labels to configure that channel. Each `type` has specific labels that need to be
present for that channel to be correctly configured. The labels that are required to be
present for one channel `type` are often different than those required for another.
Due to these loose constraints it's often best to set up a channel through the UI
and import it to the provider when setting up a brand new channel type to determine which
labels are required.

A list of supported channels per project the `list` endpoint can be
accessed programmatically or through the api explorer at  https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.notificationChannelDescriptors/list .
This provides the channel type and all of the required labels that must be passed.


To get more information about NotificationChannel, see:

* [API documentation](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.notificationChannels)
* How-to Guides
    * [Monitoring API Documentation](https://cloud.google.com/monitoring/api/v3/)
    * [Notification Options](https://cloud.google.com/monitoring/support/notification-options)



## Example Usage

### Notification Channel Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const basic = new gcp.monitoring.NotificationChannel("basic", {
    displayName: "Test Notification Channel",
    type: "email",
    labels: {
        email_address: "fake_email@blahblah.com",
    },
    forceDelete: false,
});
```
```python
import pulumi
import pulumi_gcp as gcp

basic = gcp.monitoring.NotificationChannel("basic",
    display_name="Test Notification Channel",
    type="email",
    labels={
        "email_address": "fake_email@blahblah.com",
    },
    force_delete=False)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var basic = new Gcp.Monitoring.NotificationChannel("basic", new()
    {
        DisplayName = "Test Notification Channel",
        Type = "email",
        Labels = 
        {
            { "email_address", "fake_email@blahblah.com" },
        },
        ForceDelete = false,
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := monitoring.NewNotificationChannel(ctx, "basic", &monitoring.NotificationChannelArgs{
			DisplayName: pulumi.String("Test Notification Channel"),
			Type:        pulumi.String("email"),
			Labels: pulumi.StringMap{
				"email_address": pulumi.String("fake_email@blahblah.com"),
			},
			ForceDelete: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.NotificationChannel;
import com.pulumi.gcp.monitoring.NotificationChannelArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var basic = new NotificationChannel("basic", NotificationChannelArgs.builder()
            .displayName("Test Notification Channel")
            .type("email")
            .labels(Map.of("email_address", "fake_email@blahblah.com"))
            .forceDelete(false)
            .build());

    }
}
```
```yaml
resources:
  basic:
    type: gcp:monitoring:NotificationChannel
    properties:
      displayName: Test Notification Channel
      type: email
      labels:
        email_address: fake_email@blahblah.com
      forceDelete: false
```
<!--End PulumiCodeChooser -->
### Notification Channel Sensitive


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.monitoring.NotificationChannel("default", {
    displayName: "Test Slack Channel",
    type: "slack",
    labels: {
        channel_name: "#foobar",
    },
    sensitiveLabels: {
        authToken: "one",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.monitoring.NotificationChannel("default",
    display_name="Test Slack Channel",
    type="slack",
    labels={
        "channel_name": "#foobar",
    },
    sensitive_labels={
        "auth_token": "one",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.Monitoring.NotificationChannel("default", new()
    {
        DisplayName = "Test Slack Channel",
        Type = "slack",
        Labels = 
        {
            { "channel_name", "#foobar" },
        },
        SensitiveLabels = new Gcp.Monitoring.Inputs.NotificationChannelSensitiveLabelsArgs
        {
            AuthToken = "one",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := monitoring.NewNotificationChannel(ctx, "default", &monitoring.NotificationChannelArgs{
			DisplayName: pulumi.String("Test Slack Channel"),
			Type:        pulumi.String("slack"),
			Labels: pulumi.StringMap{
				"channel_name": pulumi.String("#foobar"),
			},
			SensitiveLabels: &monitoring.NotificationChannelSensitiveLabelsArgs{
				AuthToken: pulumi.String("one"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.NotificationChannel;
import com.pulumi.gcp.monitoring.NotificationChannelArgs;
import com.pulumi.gcp.monitoring.inputs.NotificationChannelSensitiveLabelsArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new NotificationChannel("default", NotificationChannelArgs.builder()
            .displayName("Test Slack Channel")
            .type("slack")
            .labels(Map.of("channel_name", "#foobar"))
            .sensitiveLabels(NotificationChannelSensitiveLabelsArgs.builder()
                .authToken("one")
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:monitoring:NotificationChannel
    properties:
      displayName: Test Slack Channel
      type: slack
      labels:
        channel_name: '#foobar'
      sensitiveLabels:
        authToken: one
```
<!--End PulumiCodeChooser -->

## Import

NotificationChannel can be imported using any of these accepted formats:

* `{{name}}`

When using the `pulumi import` command, NotificationChannel can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:monitoring/notificationChannel:NotificationChannel default {{name}}
```

„
descriptionB" ÕAn optional human-readable description of this notification channel. This description may provide additional details, beyond the display name, for the channel. This may not exceed 1024 Unicode characters.
≠
displayNameB" óAn optional human-readable name for this notification channel. It is recommended that you specify a non-empty and unique name in order to make it easier to identify the channels in your project, though this is not enforced. The display name is limited to 512 Unicode characters.
±
enabledB
 üWhether notifications are forwarded to the described channel. This makes it possible to disable delivery of notifications to a particular channel without removing the channel from all alerting policies that reference the channel. This is a more convenient approach when the change is temporary and you want to receive notifications from the same set of alerting policies on the channel at some point in the future.
°
forceDeleteB
 ãIf true, the notification channel will be deleted regardless
of its use in alert policies (the policies will be updated
to remove the channel). If false, channels that are still
referenced by an existing alerting policy will fail to be
deleted in a delete operation.
ø
labelsB2" ¨Configuration fields that define the channel and its behavior. The
permissible and required labels are specified in the
NotificationChannelDescriptor corresponding to the type field.
Labels with sensitive data are obfuscated by the API and therefore the provider cannot
determine if there are upstream changes to these fields. They can also be configured via
the sensitive_labels block, but cannot be configured in both places.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
ÿ
sensitiveLabelsèBå:â
Ü

monitoring"NotificationChannelSensitiveLabelsTgcp:monitoring/NotificationChannelSensitiveLabels:NotificationChannelSensitiveLabels≤Different notification type behaviors are configured primarily using the the `labels` field on this
resource. This block contains the labels which contain secrets or passwords so that they can be marked
sensitive and hidden from plan output. The name of the field, eg: password, will be the key
in the `labels` map in the api request.
Credentials may not be specified in both locations and will cause an error. Changing from one location
to a different credential configuration in the config will require an apply to update state.
Structure is documented below.
≤
type" •The type of the notification channel. This field matches the value of the NotificationChannelDescriptor.type field. See https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.notificationChannelDescriptors/list to get the list of valid values such as "email", "slack", etc...


- - -
Ñ

userLabelsB2" ÌUser-supplied key/value data that does not need to conform to the corresponding NotificationChannelDescriptor's schema, unlike the labels field. This field is intended to be used for organizing and identifying the NotificationChannel objects.The field can contain up to 64 entries. Each key and value is limited to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values can contain only lowercase letters, numerals, underscores, and dashes. Keys must begin with a letter.
"„
descriptionB" ÕAn optional human-readable description of this notification channel. This description may provide additional details, beyond the display name, for the channel. This may not exceed 1024 Unicode characters.
"≠
displayNameB" óAn optional human-readable name for this notification channel. It is recommended that you specify a non-empty and unique name in order to make it easier to identify the channels in your project, though this is not enforced. The display name is limited to 512 Unicode characters.
"±
enabledB
 üWhether notifications are forwarded to the described channel. This makes it possible to disable delivery of notifications to a particular channel without removing the channel from all alerting policies that reference the channel. This is a more convenient approach when the change is temporary and you want to receive notifications from the same set of alerting policies on the channel at some point in the future.
"°
forceDeleteB
 ãIf true, the notification channel will be deleted regardless
of its use in alert policies (the policies will be updated
to remove the channel). If false, channels that are still
referenced by an existing alerting policy will fail to be
deleted in a delete operation.
"ø
labelsB2" ¨Configuration fields that define the channel and its behavior. The
permissible and required labels are specified in the
NotificationChannelDescriptor corresponding to the type field.
Labels with sensitive data are obfuscated by the API and therefore the provider cannot
determine if there are upstream changes to these fields. They can also be configured via
the sensitive_labels block, but cannot be configured in both places.
"»
name" ªThe full REST resource name for this channel. The syntax is:
projects/[PROJECT_ID]/notificationChannels/[CHANNEL_ID]
The [CHANNEL_ID] is automatically assigned by the server on creation.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"ÿ
sensitiveLabelsèBå:â
Ü

monitoring"NotificationChannelSensitiveLabelsTgcp:monitoring/NotificationChannelSensitiveLabels:NotificationChannelSensitiveLabels≤Different notification type behaviors are configured primarily using the the `labels` field on this
resource. This block contains the labels which contain secrets or passwords so that they can be marked
sensitive and hidden from plan output. The name of the field, eg: password, will be the key
in the `labels` map in the api request.
Credentials may not be specified in both locations and will cause an error. Changing from one location
to a different credential configuration in the config will require an apply to update state.
Structure is documented below.
"≤
type" •The type of the notification channel. This field matches the value of the NotificationChannelDescriptor.type field. See https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.notificationChannelDescriptors/list to get the list of valid values such as "email", "slack", etc...


- - -
"Ñ

userLabelsB2" ÌUser-supplied key/value data that does not need to conform to the corresponding NotificationChannelDescriptor's schema, unlike the labels field. This field is intended to be used for organizing and identifying the NotificationChannel objects.The field can contain up to 64 entries. Each key and value is limited to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values can contain only lowercase letters, numerals, underscores, and dashes. Keys must begin with a letter.
"Ø
verificationStatus" îIndicates whether this channel has been verified or not. On a ListNotificationChannels or GetNotificationChannel operation, this field is expected to be populated.If the value is UNVERIFIED, then it indicates that the channel is non-functioning (it both requires verification and lacks verification); otherwise, it is assumed that the channel works.If the channel is neither VERIFIED nor UNVERIFIED, it implies that the channel is of a type that does not require verification or that this specific channel has been exempted from verification because it was created prior to verification being required for channels of this type.This field cannot be modified using a standard UpdateNotificationChannel operation. To change the value of this field, you must call VerifyNotificationChannel.
*“Ö
)

monitoringSlogcp:monitoring/slo:SloÈŸA Service-Level Objective (SLO) describes the level of desired good
service. It consists of a service-level indicator (SLI), a performance
goal, and a period over which the objective is to be evaluated against
that goal. The SLO can use SLIs defined in a number of different manners.
Typical SLOs might include "99% of requests in each rolling week have
latency below 200 milliseconds" or "99.5% of requests in each calendar
month return successfully."


To get more information about Slo, see:

* [API documentation](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/services.serviceLevelObjectives)
* How-to Guides
    * [Monitoring API Documentation](https://cloud.google.com/monitoring/api/v3/)
    * [Service Monitoring](https://cloud.google.com/monitoring/service-monitoring)

## Example Usage

### Monitoring Slo Appengine


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const default = gcp.monitoring.getAppEngineService({
    moduleId: "default",
});
const appengSlo = new gcp.monitoring.Slo("appeng_slo", {
    service: _default.then(_default => _default.serviceId),
    sloId: "ae-slo",
    displayName: "Test SLO for App Engine",
    goal: 0.9,
    calendarPeriod: "DAY",
    basicSli: {
        latency: {
            threshold: "1s",
        },
    },
    userLabels: {
        my_key: "my_value",
        my_other_key: "my_other_value",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.monitoring.get_app_engine_service(module_id="default")
appeng_slo = gcp.monitoring.Slo("appeng_slo",
    service=default.service_id,
    slo_id="ae-slo",
    display_name="Test SLO for App Engine",
    goal=0.9,
    calendar_period="DAY",
    basic_sli={
        "latency": {
            "threshold": "1s",
        },
    },
    user_labels={
        "my_key": "my_value",
        "my_other_key": "my_other_value",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = Gcp.Monitoring.GetAppEngineService.Invoke(new()
    {
        ModuleId = "default",
    });

    var appengSlo = new Gcp.Monitoring.Slo("appeng_slo", new()
    {
        Service = @default.Apply(@default => @default.Apply(getAppEngineServiceResult => getAppEngineServiceResult.ServiceId)),
        SloId = "ae-slo",
        DisplayName = "Test SLO for App Engine",
        Goal = 0.9,
        CalendarPeriod = "DAY",
        BasicSli = new Gcp.Monitoring.Inputs.SloBasicSliArgs
        {
            Latency = new Gcp.Monitoring.Inputs.SloBasicSliLatencyArgs
            {
                Threshold = "1s",
            },
        },
        UserLabels = 
        {
            { "my_key", "my_value" },
            { "my_other_key", "my_other_value" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_default, err := monitoring.GetAppEngineService(ctx, &monitoring.GetAppEngineServiceArgs{
			ModuleId: "default",
		}, nil)
		if err != nil {
			return err
		}
		_, err = monitoring.NewSlo(ctx, "appeng_slo", &monitoring.SloArgs{
			Service:        pulumi.String(_default.ServiceId),
			SloId:          pulumi.String("ae-slo"),
			DisplayName:    pulumi.String("Test SLO for App Engine"),
			Goal:           pulumi.Float64(0.9),
			CalendarPeriod: pulumi.String("DAY"),
			BasicSli: &monitoring.SloBasicSliArgs{
				Latency: &monitoring.SloBasicSliLatencyArgs{
					Threshold: pulumi.String("1s"),
				},
			},
			UserLabels: pulumi.StringMap{
				"my_key":       pulumi.String("my_value"),
				"my_other_key": pulumi.String("my_other_value"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.MonitoringFunctions;
import com.pulumi.gcp.monitoring.inputs.GetAppEngineServiceArgs;
import com.pulumi.gcp.monitoring.Slo;
import com.pulumi.gcp.monitoring.SloArgs;
import com.pulumi.gcp.monitoring.inputs.SloBasicSliArgs;
import com.pulumi.gcp.monitoring.inputs.SloBasicSliLatencyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var default = MonitoringFunctions.getAppEngineService(GetAppEngineServiceArgs.builder()
            .moduleId("default")
            .build());

        var appengSlo = new Slo("appengSlo", SloArgs.builder()
            .service(default_.serviceId())
            .sloId("ae-slo")
            .displayName("Test SLO for App Engine")
            .goal(0.9)
            .calendarPeriod("DAY")
            .basicSli(SloBasicSliArgs.builder()
                .latency(SloBasicSliLatencyArgs.builder()
                    .threshold("1s")
                    .build())
                .build())
            .userLabels(Map.ofEntries(
                Map.entry("my_key", "my_value"),
                Map.entry("my_other_key", "my_other_value")
            ))
            .build());

    }
}
```
```yaml
resources:
  appengSlo:
    type: gcp:monitoring:Slo
    name: appeng_slo
    properties:
      service: ${default.serviceId}
      sloId: ae-slo
      displayName: Test SLO for App Engine
      goal: 0.9
      calendarPeriod: DAY
      basicSli:
        latency:
          threshold: 1s
      userLabels:
        my_key: my_value
        my_other_key: my_other_value
variables:
  default:
    fn::invoke:
      function: gcp:monitoring:getAppEngineService
      arguments:
        moduleId: default
```
<!--End PulumiCodeChooser -->
### Monitoring Slo Request Based


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const customsrv = new gcp.monitoring.CustomService("customsrv", {
    serviceId: "custom-srv-request-slos",
    displayName: "My Custom Service",
});
const requestBasedSlo = new gcp.monitoring.Slo("request_based_slo", {
    service: customsrv.serviceId,
    sloId: "consumed-api-slo",
    displayName: "Test SLO with request based SLI (good total ratio)",
    goal: 0.9,
    rollingPeriodDays: 30,
    requestBasedSli: {
        distributionCut: {
            distributionFilter: "metric.type=\"serviceruntime.googleapis.com/api/request_latencies\" resource.type=\"api\"  ",
            range: {
                max: 0.5,
            },
        },
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

customsrv = gcp.monitoring.CustomService("customsrv",
    service_id="custom-srv-request-slos",
    display_name="My Custom Service")
request_based_slo = gcp.monitoring.Slo("request_based_slo",
    service=customsrv.service_id,
    slo_id="consumed-api-slo",
    display_name="Test SLO with request based SLI (good total ratio)",
    goal=0.9,
    rolling_period_days=30,
    request_based_sli={
        "distribution_cut": {
            "distribution_filter": "metric.type=\"serviceruntime.googleapis.com/api/request_latencies\" resource.type=\"api\"  ",
            "range": {
                "max": 0.5,
            },
        },
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var customsrv = new Gcp.Monitoring.CustomService("customsrv", new()
    {
        ServiceId = "custom-srv-request-slos",
        DisplayName = "My Custom Service",
    });

    var requestBasedSlo = new Gcp.Monitoring.Slo("request_based_slo", new()
    {
        Service = customsrv.ServiceId,
        SloId = "consumed-api-slo",
        DisplayName = "Test SLO with request based SLI (good total ratio)",
        Goal = 0.9,
        RollingPeriodDays = 30,
        RequestBasedSli = new Gcp.Monitoring.Inputs.SloRequestBasedSliArgs
        {
            DistributionCut = new Gcp.Monitoring.Inputs.SloRequestBasedSliDistributionCutArgs
            {
                DistributionFilter = "metric.type=\"serviceruntime.googleapis.com/api/request_latencies\" resource.type=\"api\"  ",
                Range = new Gcp.Monitoring.Inputs.SloRequestBasedSliDistributionCutRangeArgs
                {
                    Max = 0.5,
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		customsrv, err := monitoring.NewCustomService(ctx, "customsrv", &monitoring.CustomServiceArgs{
			ServiceId:   pulumi.String("custom-srv-request-slos"),
			DisplayName: pulumi.String("My Custom Service"),
		})
		if err != nil {
			return err
		}
		_, err = monitoring.NewSlo(ctx, "request_based_slo", &monitoring.SloArgs{
			Service:           customsrv.ServiceId,
			SloId:             pulumi.String("consumed-api-slo"),
			DisplayName:       pulumi.String("Test SLO with request based SLI (good total ratio)"),
			Goal:              pulumi.Float64(0.9),
			RollingPeriodDays: pulumi.Int(30),
			RequestBasedSli: &monitoring.SloRequestBasedSliArgs{
				DistributionCut: &monitoring.SloRequestBasedSliDistributionCutArgs{
					DistributionFilter: pulumi.String("metric.type=\"serviceruntime.googleapis.com/api/request_latencies\" resource.type=\"api\"  "),
					Range: &monitoring.SloRequestBasedSliDistributionCutRangeArgs{
						Max: pulumi.Float64(0.5),
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.CustomService;
import com.pulumi.gcp.monitoring.CustomServiceArgs;
import com.pulumi.gcp.monitoring.Slo;
import com.pulumi.gcp.monitoring.SloArgs;
import com.pulumi.gcp.monitoring.inputs.SloRequestBasedSliArgs;
import com.pulumi.gcp.monitoring.inputs.SloRequestBasedSliDistributionCutArgs;
import com.pulumi.gcp.monitoring.inputs.SloRequestBasedSliDistributionCutRangeArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var customsrv = new CustomService("customsrv", CustomServiceArgs.builder()
            .serviceId("custom-srv-request-slos")
            .displayName("My Custom Service")
            .build());

        var requestBasedSlo = new Slo("requestBasedSlo", SloArgs.builder()
            .service(customsrv.serviceId())
            .sloId("consumed-api-slo")
            .displayName("Test SLO with request based SLI (good total ratio)")
            .goal(0.9)
            .rollingPeriodDays(30)
            .requestBasedSli(SloRequestBasedSliArgs.builder()
                .distributionCut(SloRequestBasedSliDistributionCutArgs.builder()
                    .distributionFilter("metric.type=\"serviceruntime.googleapis.com/api/request_latencies\" resource.type=\"api\"  ")
                    .range(SloRequestBasedSliDistributionCutRangeArgs.builder()
                        .max(0.5)
                        .build())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  customsrv:
    type: gcp:monitoring:CustomService
    properties:
      serviceId: custom-srv-request-slos
      displayName: My Custom Service
  requestBasedSlo:
    type: gcp:monitoring:Slo
    name: request_based_slo
    properties:
      service: ${customsrv.serviceId}
      sloId: consumed-api-slo
      displayName: Test SLO with request based SLI (good total ratio)
      goal: 0.9
      rollingPeriodDays: 30
      requestBasedSli:
        distributionCut:
          distributionFilter: 'metric.type="serviceruntime.googleapis.com/api/request_latencies" resource.type="api"  '
          range:
            max: 0.5
```
<!--End PulumiCodeChooser -->
### Monitoring Slo Windows Based Good Bad Metric Filter


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";
import * as std from "@pulumi/std";

const customsrv = new gcp.monitoring.CustomService("customsrv", {
    serviceId: "custom-srv-windows-slos",
    displayName: "My Custom Service",
});
const windowsBased = new gcp.monitoring.Slo("windows_based", {
    service: customsrv.serviceId,
    displayName: "Test SLO with window based SLI",
    goal: 0.95,
    calendarPeriod: "FORTNIGHT",
    windowsBasedSli: {
        windowPeriod: "400s",
        goodBadMetricFilter: std.join({
            separator: " AND ",
            input: [
                "metric.type=\"monitoring.googleapis.com/uptime_check/check_passed\"",
                "resource.type=\"uptime_url\"",
            ],
        }).then(invoke => invoke.result),
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp
import pulumi_std as std

customsrv = gcp.monitoring.CustomService("customsrv",
    service_id="custom-srv-windows-slos",
    display_name="My Custom Service")
windows_based = gcp.monitoring.Slo("windows_based",
    service=customsrv.service_id,
    display_name="Test SLO with window based SLI",
    goal=0.95,
    calendar_period="FORTNIGHT",
    windows_based_sli={
        "window_period": "400s",
        "good_bad_metric_filter": std.join(separator=" AND ",
            input=[
                "metric.type=\"monitoring.googleapis.com/uptime_check/check_passed\"",
                "resource.type=\"uptime_url\"",
            ]).result,
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;
using Std = Pulumi.Std;

return await Deployment.RunAsync(() => 
{
    var customsrv = new Gcp.Monitoring.CustomService("customsrv", new()
    {
        ServiceId = "custom-srv-windows-slos",
        DisplayName = "My Custom Service",
    });

    var windowsBased = new Gcp.Monitoring.Slo("windows_based", new()
    {
        Service = customsrv.ServiceId,
        DisplayName = "Test SLO with window based SLI",
        Goal = 0.95,
        CalendarPeriod = "FORTNIGHT",
        WindowsBasedSli = new Gcp.Monitoring.Inputs.SloWindowsBasedSliArgs
        {
            WindowPeriod = "400s",
            GoodBadMetricFilter = Std.Join.Invoke(new()
            {
                Separator = " AND ",
                Input = new[]
                {
                    "metric.type=\"monitoring.googleapis.com/uptime_check/check_passed\"",
                    "resource.type=\"uptime_url\"",
                },
            }).Apply(invoke => invoke.Result),
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi-std/sdk/go/std"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		customsrv, err := monitoring.NewCustomService(ctx, "customsrv", &monitoring.CustomServiceArgs{
			ServiceId:   pulumi.String("custom-srv-windows-slos"),
			DisplayName: pulumi.String("My Custom Service"),
		})
		if err != nil {
			return err
		}
		invokeJoin, err := std.Join(ctx, &std.JoinArgs{
			Separator: " AND ",
			Input: []string{
				"metric.type=\"monitoring.googleapis.com/uptime_check/check_passed\"",
				"resource.type=\"uptime_url\"",
			},
		}, nil)
		if err != nil {
			return err
		}
		_, err = monitoring.NewSlo(ctx, "windows_based", &monitoring.SloArgs{
			Service:        customsrv.ServiceId,
			DisplayName:    pulumi.String("Test SLO with window based SLI"),
			Goal:           pulumi.Float64(0.95),
			CalendarPeriod: pulumi.String("FORTNIGHT"),
			WindowsBasedSli: &monitoring.SloWindowsBasedSliArgs{
				WindowPeriod:        pulumi.String("400s"),
				GoodBadMetricFilter: pulumi.String(invokeJoin.Result),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.CustomService;
import com.pulumi.gcp.monitoring.CustomServiceArgs;
import com.pulumi.gcp.monitoring.Slo;
import com.pulumi.gcp.monitoring.SloArgs;
import com.pulumi.gcp.monitoring.inputs.SloWindowsBasedSliArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var customsrv = new CustomService("customsrv", CustomServiceArgs.builder()
            .serviceId("custom-srv-windows-slos")
            .displayName("My Custom Service")
            .build());

        var windowsBased = new Slo("windowsBased", SloArgs.builder()
            .service(customsrv.serviceId())
            .displayName("Test SLO with window based SLI")
            .goal(0.95)
            .calendarPeriod("FORTNIGHT")
            .windowsBasedSli(SloWindowsBasedSliArgs.builder()
                .windowPeriod("400s")
                .goodBadMetricFilter(StdFunctions.join(JoinArgs.builder()
                    .separator(" AND ")
                    .input(                    
                        "metric.type=\"monitoring.googleapis.com/uptime_check/check_passed\"",
                        "resource.type=\"uptime_url\"")
                    .build()).result())
                .build())
            .build());

    }
}
```
```yaml
resources:
  customsrv:
    type: gcp:monitoring:CustomService
    properties:
      serviceId: custom-srv-windows-slos
      displayName: My Custom Service
  windowsBased:
    type: gcp:monitoring:Slo
    name: windows_based
    properties:
      service: ${customsrv.serviceId}
      displayName: Test SLO with window based SLI
      goal: 0.95
      calendarPeriod: FORTNIGHT
      windowsBasedSli:
        windowPeriod: 400s
        goodBadMetricFilter:
          fn::invoke:
            function: std:join
            arguments:
              separator: ' AND '
              input:
                - metric.type="monitoring.googleapis.com/uptime_check/check_passed"
                - resource.type="uptime_url"
            return: result
```
<!--End PulumiCodeChooser -->
### Monitoring Slo Windows Based Metric Mean


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";
import * as std from "@pulumi/std";

const customsrv = new gcp.monitoring.CustomService("customsrv", {
    serviceId: "custom-srv-windows-slos",
    displayName: "My Custom Service",
});
const windowsBased = new gcp.monitoring.Slo("windows_based", {
    service: customsrv.serviceId,
    displayName: "Test SLO with window based SLI",
    goal: 0.9,
    rollingPeriodDays: 20,
    windowsBasedSli: {
        windowPeriod: "600s",
        metricMeanInRange: {
            timeSeries: std.join({
                separator: " AND ",
                input: [
                    "metric.type=\"agent.googleapis.com/cassandra/client_request/latency/95p\"",
                    "resource.type=\"gce_instance\"",
                ],
            }).then(invoke => invoke.result),
            range: {
                max: 5,
            },
        },
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp
import pulumi_std as std

customsrv = gcp.monitoring.CustomService("customsrv",
    service_id="custom-srv-windows-slos",
    display_name="My Custom Service")
windows_based = gcp.monitoring.Slo("windows_based",
    service=customsrv.service_id,
    display_name="Test SLO with window based SLI",
    goal=0.9,
    rolling_period_days=20,
    windows_based_sli={
        "window_period": "600s",
        "metric_mean_in_range": {
            "time_series": std.join(separator=" AND ",
                input=[
                    "metric.type=\"agent.googleapis.com/cassandra/client_request/latency/95p\"",
                    "resource.type=\"gce_instance\"",
                ]).result,
            "range": {
                "max": 5,
            },
        },
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;
using Std = Pulumi.Std;

return await Deployment.RunAsync(() => 
{
    var customsrv = new Gcp.Monitoring.CustomService("customsrv", new()
    {
        ServiceId = "custom-srv-windows-slos",
        DisplayName = "My Custom Service",
    });

    var windowsBased = new Gcp.Monitoring.Slo("windows_based", new()
    {
        Service = customsrv.ServiceId,
        DisplayName = "Test SLO with window based SLI",
        Goal = 0.9,
        RollingPeriodDays = 20,
        WindowsBasedSli = new Gcp.Monitoring.Inputs.SloWindowsBasedSliArgs
        {
            WindowPeriod = "600s",
            MetricMeanInRange = new Gcp.Monitoring.Inputs.SloWindowsBasedSliMetricMeanInRangeArgs
            {
                TimeSeries = Std.Join.Invoke(new()
                {
                    Separator = " AND ",
                    Input = new[]
                    {
                        "metric.type=\"agent.googleapis.com/cassandra/client_request/latency/95p\"",
                        "resource.type=\"gce_instance\"",
                    },
                }).Apply(invoke => invoke.Result),
                Range = new Gcp.Monitoring.Inputs.SloWindowsBasedSliMetricMeanInRangeRangeArgs
                {
                    Max = 5,
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi-std/sdk/go/std"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		customsrv, err := monitoring.NewCustomService(ctx, "customsrv", &monitoring.CustomServiceArgs{
			ServiceId:   pulumi.String("custom-srv-windows-slos"),
			DisplayName: pulumi.String("My Custom Service"),
		})
		if err != nil {
			return err
		}
		invokeJoin, err := std.Join(ctx, &std.JoinArgs{
			Separator: " AND ",
			Input: []string{
				"metric.type=\"agent.googleapis.com/cassandra/client_request/latency/95p\"",
				"resource.type=\"gce_instance\"",
			},
		}, nil)
		if err != nil {
			return err
		}
		_, err = monitoring.NewSlo(ctx, "windows_based", &monitoring.SloArgs{
			Service:           customsrv.ServiceId,
			DisplayName:       pulumi.String("Test SLO with window based SLI"),
			Goal:              pulumi.Float64(0.9),
			RollingPeriodDays: pulumi.Int(20),
			WindowsBasedSli: &monitoring.SloWindowsBasedSliArgs{
				WindowPeriod: pulumi.String("600s"),
				MetricMeanInRange: &monitoring.SloWindowsBasedSliMetricMeanInRangeArgs{
					TimeSeries: pulumi.String(invokeJoin.Result),
					Range: &monitoring.SloWindowsBasedSliMetricMeanInRangeRangeArgs{
						Max: pulumi.Float64(5),
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.CustomService;
import com.pulumi.gcp.monitoring.CustomServiceArgs;
import com.pulumi.gcp.monitoring.Slo;
import com.pulumi.gcp.monitoring.SloArgs;
import com.pulumi.gcp.monitoring.inputs.SloWindowsBasedSliArgs;
import com.pulumi.gcp.monitoring.inputs.SloWindowsBasedSliMetricMeanInRangeArgs;
import com.pulumi.gcp.monitoring.inputs.SloWindowsBasedSliMetricMeanInRangeRangeArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var customsrv = new CustomService("customsrv", CustomServiceArgs.builder()
            .serviceId("custom-srv-windows-slos")
            .displayName("My Custom Service")
            .build());

        var windowsBased = new Slo("windowsBased", SloArgs.builder()
            .service(customsrv.serviceId())
            .displayName("Test SLO with window based SLI")
            .goal(0.9)
            .rollingPeriodDays(20)
            .windowsBasedSli(SloWindowsBasedSliArgs.builder()
                .windowPeriod("600s")
                .metricMeanInRange(SloWindowsBasedSliMetricMeanInRangeArgs.builder()
                    .timeSeries(StdFunctions.join(JoinArgs.builder()
                        .separator(" AND ")
                        .input(                        
                            "metric.type=\"agent.googleapis.com/cassandra/client_request/latency/95p\"",
                            "resource.type=\"gce_instance\"")
                        .build()).result())
                    .range(SloWindowsBasedSliMetricMeanInRangeRangeArgs.builder()
                        .max(5)
                        .build())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  customsrv:
    type: gcp:monitoring:CustomService
    properties:
      serviceId: custom-srv-windows-slos
      displayName: My Custom Service
  windowsBased:
    type: gcp:monitoring:Slo
    name: windows_based
    properties:
      service: ${customsrv.serviceId}
      displayName: Test SLO with window based SLI
      goal: 0.9
      rollingPeriodDays: 20
      windowsBasedSli:
        windowPeriod: 600s
        metricMeanInRange:
          timeSeries:
            fn::invoke:
              function: std:join
              arguments:
                separator: ' AND '
                input:
                  - metric.type="agent.googleapis.com/cassandra/client_request/latency/95p"
                  - resource.type="gce_instance"
              return: result
          range:
            max: 5
```
<!--End PulumiCodeChooser -->
### Monitoring Slo Windows Based Metric Sum


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";
import * as std from "@pulumi/std";

const customsrv = new gcp.monitoring.CustomService("customsrv", {
    serviceId: "custom-srv-windows-slos",
    displayName: "My Custom Service",
});
const windowsBased = new gcp.monitoring.Slo("windows_based", {
    service: customsrv.serviceId,
    displayName: "Test SLO with window based SLI",
    goal: 0.9,
    rollingPeriodDays: 20,
    windowsBasedSli: {
        windowPeriod: "400s",
        metricSumInRange: {
            timeSeries: std.join({
                separator: " AND ",
                input: [
                    "metric.type=\"monitoring.googleapis.com/uptime_check/request_latency\"",
                    "resource.type=\"uptime_url\"",
                ],
            }).then(invoke => invoke.result),
            range: {
                max: 5000,
            },
        },
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp
import pulumi_std as std

customsrv = gcp.monitoring.CustomService("customsrv",
    service_id="custom-srv-windows-slos",
    display_name="My Custom Service")
windows_based = gcp.monitoring.Slo("windows_based",
    service=customsrv.service_id,
    display_name="Test SLO with window based SLI",
    goal=0.9,
    rolling_period_days=20,
    windows_based_sli={
        "window_period": "400s",
        "metric_sum_in_range": {
            "time_series": std.join(separator=" AND ",
                input=[
                    "metric.type=\"monitoring.googleapis.com/uptime_check/request_latency\"",
                    "resource.type=\"uptime_url\"",
                ]).result,
            "range": {
                "max": 5000,
            },
        },
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;
using Std = Pulumi.Std;

return await Deployment.RunAsync(() => 
{
    var customsrv = new Gcp.Monitoring.CustomService("customsrv", new()
    {
        ServiceId = "custom-srv-windows-slos",
        DisplayName = "My Custom Service",
    });

    var windowsBased = new Gcp.Monitoring.Slo("windows_based", new()
    {
        Service = customsrv.ServiceId,
        DisplayName = "Test SLO with window based SLI",
        Goal = 0.9,
        RollingPeriodDays = 20,
        WindowsBasedSli = new Gcp.Monitoring.Inputs.SloWindowsBasedSliArgs
        {
            WindowPeriod = "400s",
            MetricSumInRange = new Gcp.Monitoring.Inputs.SloWindowsBasedSliMetricSumInRangeArgs
            {
                TimeSeries = Std.Join.Invoke(new()
                {
                    Separator = " AND ",
                    Input = new[]
                    {
                        "metric.type=\"monitoring.googleapis.com/uptime_check/request_latency\"",
                        "resource.type=\"uptime_url\"",
                    },
                }).Apply(invoke => invoke.Result),
                Range = new Gcp.Monitoring.Inputs.SloWindowsBasedSliMetricSumInRangeRangeArgs
                {
                    Max = 5000,
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi-std/sdk/go/std"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		customsrv, err := monitoring.NewCustomService(ctx, "customsrv", &monitoring.CustomServiceArgs{
			ServiceId:   pulumi.String("custom-srv-windows-slos"),
			DisplayName: pulumi.String("My Custom Service"),
		})
		if err != nil {
			return err
		}
		invokeJoin, err := std.Join(ctx, &std.JoinArgs{
			Separator: " AND ",
			Input: []string{
				"metric.type=\"monitoring.googleapis.com/uptime_check/request_latency\"",
				"resource.type=\"uptime_url\"",
			},
		}, nil)
		if err != nil {
			return err
		}
		_, err = monitoring.NewSlo(ctx, "windows_based", &monitoring.SloArgs{
			Service:           customsrv.ServiceId,
			DisplayName:       pulumi.String("Test SLO with window based SLI"),
			Goal:              pulumi.Float64(0.9),
			RollingPeriodDays: pulumi.Int(20),
			WindowsBasedSli: &monitoring.SloWindowsBasedSliArgs{
				WindowPeriod: pulumi.String("400s"),
				MetricSumInRange: &monitoring.SloWindowsBasedSliMetricSumInRangeArgs{
					TimeSeries: pulumi.String(invokeJoin.Result),
					Range: &monitoring.SloWindowsBasedSliMetricSumInRangeRangeArgs{
						Max: pulumi.Float64(5000),
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.CustomService;
import com.pulumi.gcp.monitoring.CustomServiceArgs;
import com.pulumi.gcp.monitoring.Slo;
import com.pulumi.gcp.monitoring.SloArgs;
import com.pulumi.gcp.monitoring.inputs.SloWindowsBasedSliArgs;
import com.pulumi.gcp.monitoring.inputs.SloWindowsBasedSliMetricSumInRangeArgs;
import com.pulumi.gcp.monitoring.inputs.SloWindowsBasedSliMetricSumInRangeRangeArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var customsrv = new CustomService("customsrv", CustomServiceArgs.builder()
            .serviceId("custom-srv-windows-slos")
            .displayName("My Custom Service")
            .build());

        var windowsBased = new Slo("windowsBased", SloArgs.builder()
            .service(customsrv.serviceId())
            .displayName("Test SLO with window based SLI")
            .goal(0.9)
            .rollingPeriodDays(20)
            .windowsBasedSli(SloWindowsBasedSliArgs.builder()
                .windowPeriod("400s")
                .metricSumInRange(SloWindowsBasedSliMetricSumInRangeArgs.builder()
                    .timeSeries(StdFunctions.join(JoinArgs.builder()
                        .separator(" AND ")
                        .input(                        
                            "metric.type=\"monitoring.googleapis.com/uptime_check/request_latency\"",
                            "resource.type=\"uptime_url\"")
                        .build()).result())
                    .range(SloWindowsBasedSliMetricSumInRangeRangeArgs.builder()
                        .max(5000)
                        .build())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  customsrv:
    type: gcp:monitoring:CustomService
    properties:
      serviceId: custom-srv-windows-slos
      displayName: My Custom Service
  windowsBased:
    type: gcp:monitoring:Slo
    name: windows_based
    properties:
      service: ${customsrv.serviceId}
      displayName: Test SLO with window based SLI
      goal: 0.9
      rollingPeriodDays: 20
      windowsBasedSli:
        windowPeriod: 400s
        metricSumInRange:
          timeSeries:
            fn::invoke:
              function: std:join
              arguments:
                separator: ' AND '
                input:
                  - metric.type="monitoring.googleapis.com/uptime_check/request_latency"
                  - resource.type="uptime_url"
              return: result
          range:
            max: 5000
```
<!--End PulumiCodeChooser -->
### Monitoring Slo Windows Based Ratio Threshold


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";
import * as std from "@pulumi/std";

const customsrv = new gcp.monitoring.CustomService("customsrv", {
    serviceId: "custom-srv-windows-slos",
    displayName: "My Custom Service",
});
const windowsBased = new gcp.monitoring.Slo("windows_based", {
    service: customsrv.serviceId,
    displayName: "Test SLO with window based SLI",
    goal: 0.9,
    rollingPeriodDays: 20,
    windowsBasedSli: {
        windowPeriod: "100s",
        goodTotalRatioThreshold: {
            threshold: 0.1,
            performance: {
                distributionCut: {
                    distributionFilter: std.join({
                        separator: " AND ",
                        input: [
                            "metric.type=\"serviceruntime.googleapis.com/api/request_latencies\"",
                            "resource.type=\"consumed_api\"",
                        ],
                    }).then(invoke => invoke.result),
                    range: {
                        min: 1,
                        max: 9,
                    },
                },
            },
        },
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp
import pulumi_std as std

customsrv = gcp.monitoring.CustomService("customsrv",
    service_id="custom-srv-windows-slos",
    display_name="My Custom Service")
windows_based = gcp.monitoring.Slo("windows_based",
    service=customsrv.service_id,
    display_name="Test SLO with window based SLI",
    goal=0.9,
    rolling_period_days=20,
    windows_based_sli={
        "window_period": "100s",
        "good_total_ratio_threshold": {
            "threshold": 0.1,
            "performance": {
                "distribution_cut": {
                    "distribution_filter": std.join(separator=" AND ",
                        input=[
                            "metric.type=\"serviceruntime.googleapis.com/api/request_latencies\"",
                            "resource.type=\"consumed_api\"",
                        ]).result,
                    "range": {
                        "min": 1,
                        "max": 9,
                    },
                },
            },
        },
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;
using Std = Pulumi.Std;

return await Deployment.RunAsync(() => 
{
    var customsrv = new Gcp.Monitoring.CustomService("customsrv", new()
    {
        ServiceId = "custom-srv-windows-slos",
        DisplayName = "My Custom Service",
    });

    var windowsBased = new Gcp.Monitoring.Slo("windows_based", new()
    {
        Service = customsrv.ServiceId,
        DisplayName = "Test SLO with window based SLI",
        Goal = 0.9,
        RollingPeriodDays = 20,
        WindowsBasedSli = new Gcp.Monitoring.Inputs.SloWindowsBasedSliArgs
        {
            WindowPeriod = "100s",
            GoodTotalRatioThreshold = new Gcp.Monitoring.Inputs.SloWindowsBasedSliGoodTotalRatioThresholdArgs
            {
                Threshold = 0.1,
                Performance = new Gcp.Monitoring.Inputs.SloWindowsBasedSliGoodTotalRatioThresholdPerformanceArgs
                {
                    DistributionCut = new Gcp.Monitoring.Inputs.SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutArgs
                    {
                        DistributionFilter = Std.Join.Invoke(new()
                        {
                            Separator = " AND ",
                            Input = new[]
                            {
                                "metric.type=\"serviceruntime.googleapis.com/api/request_latencies\"",
                                "resource.type=\"consumed_api\"",
                            },
                        }).Apply(invoke => invoke.Result),
                        Range = new Gcp.Monitoring.Inputs.SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeArgs
                        {
                            Min = 1,
                            Max = 9,
                        },
                    },
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi-std/sdk/go/std"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		customsrv, err := monitoring.NewCustomService(ctx, "customsrv", &monitoring.CustomServiceArgs{
			ServiceId:   pulumi.String("custom-srv-windows-slos"),
			DisplayName: pulumi.String("My Custom Service"),
		})
		if err != nil {
			return err
		}
		invokeJoin, err := std.Join(ctx, &std.JoinArgs{
			Separator: " AND ",
			Input: []string{
				"metric.type=\"serviceruntime.googleapis.com/api/request_latencies\"",
				"resource.type=\"consumed_api\"",
			},
		}, nil)
		if err != nil {
			return err
		}
		_, err = monitoring.NewSlo(ctx, "windows_based", &monitoring.SloArgs{
			Service:           customsrv.ServiceId,
			DisplayName:       pulumi.String("Test SLO with window based SLI"),
			Goal:              pulumi.Float64(0.9),
			RollingPeriodDays: pulumi.Int(20),
			WindowsBasedSli: &monitoring.SloWindowsBasedSliArgs{
				WindowPeriod: pulumi.String("100s"),
				GoodTotalRatioThreshold: &monitoring.SloWindowsBasedSliGoodTotalRatioThresholdArgs{
					Threshold: pulumi.Float64(0.1),
					Performance: &monitoring.SloWindowsBasedSliGoodTotalRatioThresholdPerformanceArgs{
						DistributionCut: &monitoring.SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutArgs{
							DistributionFilter: pulumi.String(invokeJoin.Result),
							Range: &monitoring.SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeArgs{
								Min: pulumi.Float64(1),
								Max: pulumi.Float64(9),
							},
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.CustomService;
import com.pulumi.gcp.monitoring.CustomServiceArgs;
import com.pulumi.gcp.monitoring.Slo;
import com.pulumi.gcp.monitoring.SloArgs;
import com.pulumi.gcp.monitoring.inputs.SloWindowsBasedSliArgs;
import com.pulumi.gcp.monitoring.inputs.SloWindowsBasedSliGoodTotalRatioThresholdArgs;
import com.pulumi.gcp.monitoring.inputs.SloWindowsBasedSliGoodTotalRatioThresholdPerformanceArgs;
import com.pulumi.gcp.monitoring.inputs.SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutArgs;
import com.pulumi.gcp.monitoring.inputs.SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var customsrv = new CustomService("customsrv", CustomServiceArgs.builder()
            .serviceId("custom-srv-windows-slos")
            .displayName("My Custom Service")
            .build());

        var windowsBased = new Slo("windowsBased", SloArgs.builder()
            .service(customsrv.serviceId())
            .displayName("Test SLO with window based SLI")
            .goal(0.9)
            .rollingPeriodDays(20)
            .windowsBasedSli(SloWindowsBasedSliArgs.builder()
                .windowPeriod("100s")
                .goodTotalRatioThreshold(SloWindowsBasedSliGoodTotalRatioThresholdArgs.builder()
                    .threshold(0.1)
                    .performance(SloWindowsBasedSliGoodTotalRatioThresholdPerformanceArgs.builder()
                        .distributionCut(SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutArgs.builder()
                            .distributionFilter(StdFunctions.join(JoinArgs.builder()
                                .separator(" AND ")
                                .input(                                
                                    "metric.type=\"serviceruntime.googleapis.com/api/request_latencies\"",
                                    "resource.type=\"consumed_api\"")
                                .build()).result())
                            .range(SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeArgs.builder()
                                .min(1)
                                .max(9)
                                .build())
                            .build())
                        .build())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  customsrv:
    type: gcp:monitoring:CustomService
    properties:
      serviceId: custom-srv-windows-slos
      displayName: My Custom Service
  windowsBased:
    type: gcp:monitoring:Slo
    name: windows_based
    properties:
      service: ${customsrv.serviceId}
      displayName: Test SLO with window based SLI
      goal: 0.9
      rollingPeriodDays: 20
      windowsBasedSli:
        windowPeriod: 100s
        goodTotalRatioThreshold:
          threshold: 0.1
          performance:
            distributionCut:
              distributionFilter:
                fn::invoke:
                  function: std:join
                  arguments:
                    separator: ' AND '
                    input:
                      - metric.type="serviceruntime.googleapis.com/api/request_latencies"
                      - resource.type="consumed_api"
                  return: result
              range:
                min: 1
                max: 9
```
<!--End PulumiCodeChooser -->

## Import

Slo can be imported using any of these accepted formats:

* `{{project}}/{{name}}`

* `{{project}} {{name}}`

* `{{name}}`

When using the `pulumi import` command, Slo can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:monitoring/slo:Slo default {{project}}/{{name}}
```

```sh
$ pulumi import gcp:monitoring/slo:Slo default "{{project}} {{name}}"
```

```sh
$ pulumi import gcp:monitoring/slo:Slo default {{name}}
```

›
basicSliGBE:C
A

monitoringSloBasicSli&gcp:monitoring/SloBasicSli:SloBasicSliáBasic Service-Level Indicator (SLI) on a well-known service type.
Performance will be computed on the basis of pre-defined metrics.
SLIs are used to measure and calculate the quality of the Service's
performance with respect to a single aspect of service quality.
Exactly one of the following must be set:
`basic_sli`, `request_based_sli`, `windows_based_sli`
Structure is documented below.
¶
calendarPeriodB" çA calendar period, semantically "since the start of the current
<calendarPeriod>".
Possible values are: `DAY`, `WEEK`, `FORTNIGHT`, `MONTH`.
A
displayNameB" ,Name used for UI elements listing this SLO.
o
goal cThe fraction of service that must be good in order for this objective
to be met. 0 < goal <= 0.999
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
Ï
requestBasedSli\BZ:X
V

monitoringSloRequestBasedSli4gcp:monitoring/SloRequestBasedSli:SloRequestBasedSli˙A request-based SLI defines a SLI for which atomic units of
service are counted directly.
A SLI describes a good service.
It is used to measure and calculate the quality of the Service's
performance with respect to a single aspect of service quality.
Exactly one of the following must be set:
`basic_sli`, `request_based_sli`, `windows_based_sli`
Structure is documented below.
~
rollingPeriodDaysB cA rolling time period, semantically "in the past X days".
Must be between 1 to 30 days, inclusive.
D
service" 5ID of the service to which this SLO belongs.


- - -
j
sloIdB" [The id to use for this ServiceLevelObjective. If omitted, an id will be generated instead.
Î

userLabelsB2" ‘This field is intended to be used for organizing and identifying the AlertPolicy
objects.The field can contain up to 64 entries. Each key and value is limited
to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values
can contain only lowercase letters, numerals, underscores, and dashes. Keys
must begin with a letter.
√
windowsBasedSli\BZ:X
V

monitoringSloWindowsBasedSli4gcp:monitoring/SloWindowsBasedSli:SloWindowsBasedSli—A windows-based SLI defines the criteria for time windows.
good_service is defined based off the count of these time windows
for which the provided service was of good quality.
A SLI describes a good service. It is used to measure and calculate
the quality of the Service's performance with respect to a single
aspect of service quality.
Exactly one of the following must be set:
`basic_sli`, `request_based_sli`, `windows_based_sli`
Structure is documented below.
"›
basicSliGBE:C
A

monitoringSloBasicSli&gcp:monitoring/SloBasicSli:SloBasicSliáBasic Service-Level Indicator (SLI) on a well-known service type.
Performance will be computed on the basis of pre-defined metrics.
SLIs are used to measure and calculate the quality of the Service's
performance with respect to a single aspect of service quality.
Exactly one of the following must be set:
`basic_sli`, `request_based_sli`, `windows_based_sli`
Structure is documented below.
"¶
calendarPeriodB" çA calendar period, semantically "since the start of the current
<calendarPeriod>".
Possible values are: `DAY`, `WEEK`, `FORTNIGHT`, `MONTH`.
"A
displayNameB" ,Name used for UI elements listing this SLO.
"o
goal cThe fraction of service that must be good in order for this objective
to be met. 0 < goal <= 0.999
"ù
name" êThe full resource name for this service. The syntax is:
projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"Ï
requestBasedSli\BZ:X
V

monitoringSloRequestBasedSli4gcp:monitoring/SloRequestBasedSli:SloRequestBasedSli˙A request-based SLI defines a SLI for which atomic units of
service are counted directly.
A SLI describes a good service.
It is used to measure and calculate the quality of the Service's
performance with respect to a single aspect of service quality.
Exactly one of the following must be set:
`basic_sli`, `request_based_sli`, `windows_based_sli`
Structure is documented below.
"~
rollingPeriodDaysB cA rolling time period, semantically "in the past X days".
Must be between 1 to 30 days, inclusive.
"D
service" 5ID of the service to which this SLO belongs.


- - -
"h
sloId" [The id to use for this ServiceLevelObjective. If omitted, an id will be generated instead.
"Î

userLabelsB2" ‘This field is intended to be used for organizing and identifying the AlertPolicy
objects.The field can contain up to 64 entries. Each key and value is limited
to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values
can contain only lowercase letters, numerals, underscores, and dashes. Keys
must begin with a letter.
"√
windowsBasedSli\BZ:X
V

monitoringSloWindowsBasedSli4gcp:monitoring/SloWindowsBasedSli:SloWindowsBasedSli—A windows-based SLI defines the criteria for time windows.
good_service is defined based off the count of these time windows
for which the provided service was of good quality.
A SLI describes a good service. It is used to measure and calculate
the quality of the Service's performance with respect to a single
aspect of service quality.
Exactly one of the following must be set:
`basic_sli`, `request_based_sli`, `windows_based_sli`
Structure is documented below.
*ŒÖ
S

monitoringUptimeCheckConfig2gcp:monitoring/uptimeCheckConfig:UptimeCheckConfigÎÃThis message configures which resources and services to monitor for availability.


To get more information about UptimeCheckConfig, see:

* [API documentation](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.uptimeCheckConfigs)
* How-to Guides
    * [Official Documentation](https://cloud.google.com/monitoring/uptime-checks/)



## Example Usage

### Uptime Check Config Http


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const http = new gcp.monitoring.UptimeCheckConfig("http", {
    displayName: "http-uptime-check",
    timeout: "60s",
    userLabels: {
        "example-key": "example-value",
    },
    httpCheck: {
        path: "some-path",
        port: 8010,
        requestMethod: "POST",
        contentType: "USER_PROVIDED",
        customContentType: "application/json",
        body: "Zm9vJTI1M0RiYXI=",
        pingConfig: {
            pingsCount: 1,
        },
    },
    monitoredResource: {
        type: "uptime_url",
        labels: {
            project_id: "my-project-name",
            host: "192.168.1.1",
        },
    },
    contentMatchers: [{
        content: "\"example\"",
        matcher: "MATCHES_JSON_PATH",
        jsonPathMatcher: {
            jsonPath: "$.path",
            jsonMatcher: "EXACT_MATCH",
        },
    }],
    checkerType: "STATIC_IP_CHECKERS",
});
```
```python
import pulumi
import pulumi_gcp as gcp

http = gcp.monitoring.UptimeCheckConfig("http",
    display_name="http-uptime-check",
    timeout="60s",
    user_labels={
        "example-key": "example-value",
    },
    http_check={
        "path": "some-path",
        "port": 8010,
        "request_method": "POST",
        "content_type": "USER_PROVIDED",
        "custom_content_type": "application/json",
        "body": "Zm9vJTI1M0RiYXI=",
        "ping_config": {
            "pings_count": 1,
        },
    },
    monitored_resource={
        "type": "uptime_url",
        "labels": {
            "project_id": "my-project-name",
            "host": "192.168.1.1",
        },
    },
    content_matchers=[{
        "content": "\"example\"",
        "matcher": "MATCHES_JSON_PATH",
        "json_path_matcher": {
            "json_path": "$.path",
            "json_matcher": "EXACT_MATCH",
        },
    }],
    checker_type="STATIC_IP_CHECKERS")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var http = new Gcp.Monitoring.UptimeCheckConfig("http", new()
    {
        DisplayName = "http-uptime-check",
        Timeout = "60s",
        UserLabels = 
        {
            { "example-key", "example-value" },
        },
        HttpCheck = new Gcp.Monitoring.Inputs.UptimeCheckConfigHttpCheckArgs
        {
            Path = "some-path",
            Port = 8010,
            RequestMethod = "POST",
            ContentType = "USER_PROVIDED",
            CustomContentType = "application/json",
            Body = "Zm9vJTI1M0RiYXI=",
            PingConfig = new Gcp.Monitoring.Inputs.UptimeCheckConfigHttpCheckPingConfigArgs
            {
                PingsCount = 1,
            },
        },
        MonitoredResource = new Gcp.Monitoring.Inputs.UptimeCheckConfigMonitoredResourceArgs
        {
            Type = "uptime_url",
            Labels = 
            {
                { "project_id", "my-project-name" },
                { "host", "192.168.1.1" },
            },
        },
        ContentMatchers = new[]
        {
            new Gcp.Monitoring.Inputs.UptimeCheckConfigContentMatcherArgs
            {
                Content = "\"example\"",
                Matcher = "MATCHES_JSON_PATH",
                JsonPathMatcher = new Gcp.Monitoring.Inputs.UptimeCheckConfigContentMatcherJsonPathMatcherArgs
                {
                    JsonPath = "$.path",
                    JsonMatcher = "EXACT_MATCH",
                },
            },
        },
        CheckerType = "STATIC_IP_CHECKERS",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := monitoring.NewUptimeCheckConfig(ctx, "http", &monitoring.UptimeCheckConfigArgs{
			DisplayName: pulumi.String("http-uptime-check"),
			Timeout:     pulumi.String("60s"),
			UserLabels: pulumi.StringMap{
				"example-key": pulumi.String("example-value"),
			},
			HttpCheck: &monitoring.UptimeCheckConfigHttpCheckArgs{
				Path:              pulumi.String("some-path"),
				Port:              pulumi.Int(8010),
				RequestMethod:     pulumi.String("POST"),
				ContentType:       pulumi.String("USER_PROVIDED"),
				CustomContentType: pulumi.String("application/json"),
				Body:              pulumi.String("Zm9vJTI1M0RiYXI="),
				PingConfig: &monitoring.UptimeCheckConfigHttpCheckPingConfigArgs{
					PingsCount: pulumi.Int(1),
				},
			},
			MonitoredResource: &monitoring.UptimeCheckConfigMonitoredResourceArgs{
				Type: pulumi.String("uptime_url"),
				Labels: pulumi.StringMap{
					"project_id": pulumi.String("my-project-name"),
					"host":       pulumi.String("192.168.1.1"),
				},
			},
			ContentMatchers: monitoring.UptimeCheckConfigContentMatcherArray{
				&monitoring.UptimeCheckConfigContentMatcherArgs{
					Content: pulumi.String("\"example\""),
					Matcher: pulumi.String("MATCHES_JSON_PATH"),
					JsonPathMatcher: &monitoring.UptimeCheckConfigContentMatcherJsonPathMatcherArgs{
						JsonPath:    pulumi.String("$.path"),
						JsonMatcher: pulumi.String("EXACT_MATCH"),
					},
				},
			},
			CheckerType: pulumi.String("STATIC_IP_CHECKERS"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.UptimeCheckConfig;
import com.pulumi.gcp.monitoring.UptimeCheckConfigArgs;
import com.pulumi.gcp.monitoring.inputs.UptimeCheckConfigHttpCheckArgs;
import com.pulumi.gcp.monitoring.inputs.UptimeCheckConfigHttpCheckPingConfigArgs;
import com.pulumi.gcp.monitoring.inputs.UptimeCheckConfigMonitoredResourceArgs;
import com.pulumi.gcp.monitoring.inputs.UptimeCheckConfigContentMatcherArgs;
import com.pulumi.gcp.monitoring.inputs.UptimeCheckConfigContentMatcherJsonPathMatcherArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var http = new UptimeCheckConfig("http", UptimeCheckConfigArgs.builder()
            .displayName("http-uptime-check")
            .timeout("60s")
            .userLabels(Map.of("example-key", "example-value"))
            .httpCheck(UptimeCheckConfigHttpCheckArgs.builder()
                .path("some-path")
                .port("8010")
                .requestMethod("POST")
                .contentType("USER_PROVIDED")
                .customContentType("application/json")
                .body("Zm9vJTI1M0RiYXI=")
                .pingConfig(UptimeCheckConfigHttpCheckPingConfigArgs.builder()
                    .pingsCount(1)
                    .build())
                .build())
            .monitoredResource(UptimeCheckConfigMonitoredResourceArgs.builder()
                .type("uptime_url")
                .labels(Map.ofEntries(
                    Map.entry("project_id", "my-project-name"),
                    Map.entry("host", "192.168.1.1")
                ))
                .build())
            .contentMatchers(UptimeCheckConfigContentMatcherArgs.builder()
                .content("\"example\"")
                .matcher("MATCHES_JSON_PATH")
                .jsonPathMatcher(UptimeCheckConfigContentMatcherJsonPathMatcherArgs.builder()
                    .jsonPath("$.path")
                    .jsonMatcher("EXACT_MATCH")
                    .build())
                .build())
            .checkerType("STATIC_IP_CHECKERS")
            .build());

    }
}
```
```yaml
resources:
  http:
    type: gcp:monitoring:UptimeCheckConfig
    properties:
      displayName: http-uptime-check
      timeout: 60s
      userLabels:
        example-key: example-value
      httpCheck:
        path: some-path
        port: '8010'
        requestMethod: POST
        contentType: USER_PROVIDED
        customContentType: application/json
        body: Zm9vJTI1M0RiYXI=
        pingConfig:
          pingsCount: 1
      monitoredResource:
        type: uptime_url
        labels:
          project_id: my-project-name
          host: 192.168.1.1
      contentMatchers:
        - content: '"example"'
          matcher: MATCHES_JSON_PATH
          jsonPathMatcher:
            jsonPath: $.path
            jsonMatcher: EXACT_MATCH
      checkerType: STATIC_IP_CHECKERS
```
<!--End PulumiCodeChooser -->
### Uptime Check Config Status Code


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const statusCode = new gcp.monitoring.UptimeCheckConfig("status_code", {
    displayName: "http-uptime-check",
    timeout: "60s",
    httpCheck: {
        path: "some-path",
        port: 8010,
        requestMethod: "POST",
        contentType: "URL_ENCODED",
        body: "Zm9vJTI1M0RiYXI=",
        acceptedResponseStatusCodes: [
            {
                statusClass: "STATUS_CLASS_2XX",
            },
            {
                statusValue: 301,
            },
            {
                statusValue: 302,
            },
        ],
    },
    monitoredResource: {
        type: "uptime_url",
        labels: {
            project_id: "my-project-name",
            host: "192.168.1.1",
        },
    },
    contentMatchers: [{
        content: "\"example\"",
        matcher: "MATCHES_JSON_PATH",
        jsonPathMatcher: {
            jsonPath: "$.path",
            jsonMatcher: "EXACT_MATCH",
        },
    }],
    checkerType: "STATIC_IP_CHECKERS",
});
```
```python
import pulumi
import pulumi_gcp as gcp

status_code = gcp.monitoring.UptimeCheckConfig("status_code",
    display_name="http-uptime-check",
    timeout="60s",
    http_check={
        "path": "some-path",
        "port": 8010,
        "request_method": "POST",
        "content_type": "URL_ENCODED",
        "body": "Zm9vJTI1M0RiYXI=",
        "accepted_response_status_codes": [
            {
                "status_class": "STATUS_CLASS_2XX",
            },
            {
                "status_value": 301,
            },
            {
                "status_value": 302,
            },
        ],
    },
    monitored_resource={
        "type": "uptime_url",
        "labels": {
            "project_id": "my-project-name",
            "host": "192.168.1.1",
        },
    },
    content_matchers=[{
        "content": "\"example\"",
        "matcher": "MATCHES_JSON_PATH",
        "json_path_matcher": {
            "json_path": "$.path",
            "json_matcher": "EXACT_MATCH",
        },
    }],
    checker_type="STATIC_IP_CHECKERS")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var statusCode = new Gcp.Monitoring.UptimeCheckConfig("status_code", new()
    {
        DisplayName = "http-uptime-check",
        Timeout = "60s",
        HttpCheck = new Gcp.Monitoring.Inputs.UptimeCheckConfigHttpCheckArgs
        {
            Path = "some-path",
            Port = 8010,
            RequestMethod = "POST",
            ContentType = "URL_ENCODED",
            Body = "Zm9vJTI1M0RiYXI=",
            AcceptedResponseStatusCodes = new[]
            {
                new Gcp.Monitoring.Inputs.UptimeCheckConfigHttpCheckAcceptedResponseStatusCodeArgs
                {
                    StatusClass = "STATUS_CLASS_2XX",
                },
                new Gcp.Monitoring.Inputs.UptimeCheckConfigHttpCheckAcceptedResponseStatusCodeArgs
                {
                    StatusValue = 301,
                },
                new Gcp.Monitoring.Inputs.UptimeCheckConfigHttpCheckAcceptedResponseStatusCodeArgs
                {
                    StatusValue = 302,
                },
            },
        },
        MonitoredResource = new Gcp.Monitoring.Inputs.UptimeCheckConfigMonitoredResourceArgs
        {
            Type = "uptime_url",
            Labels = 
            {
                { "project_id", "my-project-name" },
                { "host", "192.168.1.1" },
            },
        },
        ContentMatchers = new[]
        {
            new Gcp.Monitoring.Inputs.UptimeCheckConfigContentMatcherArgs
            {
                Content = "\"example\"",
                Matcher = "MATCHES_JSON_PATH",
                JsonPathMatcher = new Gcp.Monitoring.Inputs.UptimeCheckConfigContentMatcherJsonPathMatcherArgs
                {
                    JsonPath = "$.path",
                    JsonMatcher = "EXACT_MATCH",
                },
            },
        },
        CheckerType = "STATIC_IP_CHECKERS",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := monitoring.NewUptimeCheckConfig(ctx, "status_code", &monitoring.UptimeCheckConfigArgs{
			DisplayName: pulumi.String("http-uptime-check"),
			Timeout:     pulumi.String("60s"),
			HttpCheck: &monitoring.UptimeCheckConfigHttpCheckArgs{
				Path:          pulumi.String("some-path"),
				Port:          pulumi.Int(8010),
				RequestMethod: pulumi.String("POST"),
				ContentType:   pulumi.String("URL_ENCODED"),
				Body:          pulumi.String("Zm9vJTI1M0RiYXI="),
				AcceptedResponseStatusCodes: monitoring.UptimeCheckConfigHttpCheckAcceptedResponseStatusCodeArray{
					&monitoring.UptimeCheckConfigHttpCheckAcceptedResponseStatusCodeArgs{
						StatusClass: pulumi.String("STATUS_CLASS_2XX"),
					},
					&monitoring.UptimeCheckConfigHttpCheckAcceptedResponseStatusCodeArgs{
						StatusValue: pulumi.Int(301),
					},
					&monitoring.UptimeCheckConfigHttpCheckAcceptedResponseStatusCodeArgs{
						StatusValue: pulumi.Int(302),
					},
				},
			},
			MonitoredResource: &monitoring.UptimeCheckConfigMonitoredResourceArgs{
				Type: pulumi.String("uptime_url"),
				Labels: pulumi.StringMap{
					"project_id": pulumi.String("my-project-name"),
					"host":       pulumi.String("192.168.1.1"),
				},
			},
			ContentMatchers: monitoring.UptimeCheckConfigContentMatcherArray{
				&monitoring.UptimeCheckConfigContentMatcherArgs{
					Content: pulumi.String("\"example\""),
					Matcher: pulumi.String("MATCHES_JSON_PATH"),
					JsonPathMatcher: &monitoring.UptimeCheckConfigContentMatcherJsonPathMatcherArgs{
						JsonPath:    pulumi.String("$.path"),
						JsonMatcher: pulumi.String("EXACT_MATCH"),
					},
				},
			},
			CheckerType: pulumi.String("STATIC_IP_CHECKERS"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.UptimeCheckConfig;
import com.pulumi.gcp.monitoring.UptimeCheckConfigArgs;
import com.pulumi.gcp.monitoring.inputs.UptimeCheckConfigHttpCheckArgs;
import com.pulumi.gcp.monitoring.inputs.UptimeCheckConfigMonitoredResourceArgs;
import com.pulumi.gcp.monitoring.inputs.UptimeCheckConfigContentMatcherArgs;
import com.pulumi.gcp.monitoring.inputs.UptimeCheckConfigContentMatcherJsonPathMatcherArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var statusCode = new UptimeCheckConfig("statusCode", UptimeCheckConfigArgs.builder()
            .displayName("http-uptime-check")
            .timeout("60s")
            .httpCheck(UptimeCheckConfigHttpCheckArgs.builder()
                .path("some-path")
                .port("8010")
                .requestMethod("POST")
                .contentType("URL_ENCODED")
                .body("Zm9vJTI1M0RiYXI=")
                .acceptedResponseStatusCodes(                
                    UptimeCheckConfigHttpCheckAcceptedResponseStatusCodeArgs.builder()
                        .statusClass("STATUS_CLASS_2XX")
                        .build(),
                    UptimeCheckConfigHttpCheckAcceptedResponseStatusCodeArgs.builder()
                        .statusValue(301)
                        .build(),
                    UptimeCheckConfigHttpCheckAcceptedResponseStatusCodeArgs.builder()
                        .statusValue(302)
                        .build())
                .build())
            .monitoredResource(UptimeCheckConfigMonitoredResourceArgs.builder()
                .type("uptime_url")
                .labels(Map.ofEntries(
                    Map.entry("project_id", "my-project-name"),
                    Map.entry("host", "192.168.1.1")
                ))
                .build())
            .contentMatchers(UptimeCheckConfigContentMatcherArgs.builder()
                .content("\"example\"")
                .matcher("MATCHES_JSON_PATH")
                .jsonPathMatcher(UptimeCheckConfigContentMatcherJsonPathMatcherArgs.builder()
                    .jsonPath("$.path")
                    .jsonMatcher("EXACT_MATCH")
                    .build())
                .build())
            .checkerType("STATIC_IP_CHECKERS")
            .build());

    }
}
```
```yaml
resources:
  statusCode:
    type: gcp:monitoring:UptimeCheckConfig
    name: status_code
    properties:
      displayName: http-uptime-check
      timeout: 60s
      httpCheck:
        path: some-path
        port: '8010'
        requestMethod: POST
        contentType: URL_ENCODED
        body: Zm9vJTI1M0RiYXI=
        acceptedResponseStatusCodes:
          - statusClass: STATUS_CLASS_2XX
          - statusValue: 301
          - statusValue: 302
      monitoredResource:
        type: uptime_url
        labels:
          project_id: my-project-name
          host: 192.168.1.1
      contentMatchers:
        - content: '"example"'
          matcher: MATCHES_JSON_PATH
          jsonPathMatcher:
            jsonPath: $.path
            jsonMatcher: EXACT_MATCH
      checkerType: STATIC_IP_CHECKERS
```
<!--End PulumiCodeChooser -->
### Uptime Check Config Https


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const https = new gcp.monitoring.UptimeCheckConfig("https", {
    displayName: "https-uptime-check",
    timeout: "60s",
    httpCheck: {
        path: "/some-path",
        port: 443,
        useSsl: true,
        validateSsl: true,
        serviceAgentAuthentication: {
            type: "OIDC_TOKEN",
        },
    },
    monitoredResource: {
        type: "uptime_url",
        labels: {
            project_id: "my-project-name",
            host: "192.168.1.1",
        },
    },
    contentMatchers: [{
        content: "example",
        matcher: "MATCHES_JSON_PATH",
        jsonPathMatcher: {
            jsonPath: "$.path",
            jsonMatcher: "REGEX_MATCH",
        },
    }],
});
```
```python
import pulumi
import pulumi_gcp as gcp

https = gcp.monitoring.UptimeCheckConfig("https",
    display_name="https-uptime-check",
    timeout="60s",
    http_check={
        "path": "/some-path",
        "port": 443,
        "use_ssl": True,
        "validate_ssl": True,
        "service_agent_authentication": {
            "type": "OIDC_TOKEN",
        },
    },
    monitored_resource={
        "type": "uptime_url",
        "labels": {
            "project_id": "my-project-name",
            "host": "192.168.1.1",
        },
    },
    content_matchers=[{
        "content": "example",
        "matcher": "MATCHES_JSON_PATH",
        "json_path_matcher": {
            "json_path": "$.path",
            "json_matcher": "REGEX_MATCH",
        },
    }])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var https = new Gcp.Monitoring.UptimeCheckConfig("https", new()
    {
        DisplayName = "https-uptime-check",
        Timeout = "60s",
        HttpCheck = new Gcp.Monitoring.Inputs.UptimeCheckConfigHttpCheckArgs
        {
            Path = "/some-path",
            Port = 443,
            UseSsl = true,
            ValidateSsl = true,
            ServiceAgentAuthentication = new Gcp.Monitoring.Inputs.UptimeCheckConfigHttpCheckServiceAgentAuthenticationArgs
            {
                Type = "OIDC_TOKEN",
            },
        },
        MonitoredResource = new Gcp.Monitoring.Inputs.UptimeCheckConfigMonitoredResourceArgs
        {
            Type = "uptime_url",
            Labels = 
            {
                { "project_id", "my-project-name" },
                { "host", "192.168.1.1" },
            },
        },
        ContentMatchers = new[]
        {
            new Gcp.Monitoring.Inputs.UptimeCheckConfigContentMatcherArgs
            {
                Content = "example",
                Matcher = "MATCHES_JSON_PATH",
                JsonPathMatcher = new Gcp.Monitoring.Inputs.UptimeCheckConfigContentMatcherJsonPathMatcherArgs
                {
                    JsonPath = "$.path",
                    JsonMatcher = "REGEX_MATCH",
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := monitoring.NewUptimeCheckConfig(ctx, "https", &monitoring.UptimeCheckConfigArgs{
			DisplayName: pulumi.String("https-uptime-check"),
			Timeout:     pulumi.String("60s"),
			HttpCheck: &monitoring.UptimeCheckConfigHttpCheckArgs{
				Path:        pulumi.String("/some-path"),
				Port:        pulumi.Int(443),
				UseSsl:      pulumi.Bool(true),
				ValidateSsl: pulumi.Bool(true),
				ServiceAgentAuthentication: &monitoring.UptimeCheckConfigHttpCheckServiceAgentAuthenticationArgs{
					Type: pulumi.String("OIDC_TOKEN"),
				},
			},
			MonitoredResource: &monitoring.UptimeCheckConfigMonitoredResourceArgs{
				Type: pulumi.String("uptime_url"),
				Labels: pulumi.StringMap{
					"project_id": pulumi.String("my-project-name"),
					"host":       pulumi.String("192.168.1.1"),
				},
			},
			ContentMatchers: monitoring.UptimeCheckConfigContentMatcherArray{
				&monitoring.UptimeCheckConfigContentMatcherArgs{
					Content: pulumi.String("example"),
					Matcher: pulumi.String("MATCHES_JSON_PATH"),
					JsonPathMatcher: &monitoring.UptimeCheckConfigContentMatcherJsonPathMatcherArgs{
						JsonPath:    pulumi.String("$.path"),
						JsonMatcher: pulumi.String("REGEX_MATCH"),
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.UptimeCheckConfig;
import com.pulumi.gcp.monitoring.UptimeCheckConfigArgs;
import com.pulumi.gcp.monitoring.inputs.UptimeCheckConfigHttpCheckArgs;
import com.pulumi.gcp.monitoring.inputs.UptimeCheckConfigHttpCheckServiceAgentAuthenticationArgs;
import com.pulumi.gcp.monitoring.inputs.UptimeCheckConfigMonitoredResourceArgs;
import com.pulumi.gcp.monitoring.inputs.UptimeCheckConfigContentMatcherArgs;
import com.pulumi.gcp.monitoring.inputs.UptimeCheckConfigContentMatcherJsonPathMatcherArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var https = new UptimeCheckConfig("https", UptimeCheckConfigArgs.builder()
            .displayName("https-uptime-check")
            .timeout("60s")
            .httpCheck(UptimeCheckConfigHttpCheckArgs.builder()
                .path("/some-path")
                .port("443")
                .useSsl(true)
                .validateSsl(true)
                .serviceAgentAuthentication(UptimeCheckConfigHttpCheckServiceAgentAuthenticationArgs.builder()
                    .type("OIDC_TOKEN")
                    .build())
                .build())
            .monitoredResource(UptimeCheckConfigMonitoredResourceArgs.builder()
                .type("uptime_url")
                .labels(Map.ofEntries(
                    Map.entry("project_id", "my-project-name"),
                    Map.entry("host", "192.168.1.1")
                ))
                .build())
            .contentMatchers(UptimeCheckConfigContentMatcherArgs.builder()
                .content("example")
                .matcher("MATCHES_JSON_PATH")
                .jsonPathMatcher(UptimeCheckConfigContentMatcherJsonPathMatcherArgs.builder()
                    .jsonPath("$.path")
                    .jsonMatcher("REGEX_MATCH")
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  https:
    type: gcp:monitoring:UptimeCheckConfig
    properties:
      displayName: https-uptime-check
      timeout: 60s
      httpCheck:
        path: /some-path
        port: '443'
        useSsl: true
        validateSsl: true
        serviceAgentAuthentication:
          type: OIDC_TOKEN
      monitoredResource:
        type: uptime_url
        labels:
          project_id: my-project-name
          host: 192.168.1.1
      contentMatchers:
        - content: example
          matcher: MATCHES_JSON_PATH
          jsonPathMatcher:
            jsonPath: $.path
            jsonMatcher: REGEX_MATCH
```
<!--End PulumiCodeChooser -->
### Uptime Check Tcp


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const check = new gcp.monitoring.Group("check", {
    displayName: "uptime-check-group",
    filter: "resource.metadata.name=has_substring(\"foo\")",
});
const tcpGroup = new gcp.monitoring.UptimeCheckConfig("tcp_group", {
    displayName: "tcp-uptime-check",
    timeout: "60s",
    tcpCheck: {
        port: 888,
        pingConfig: {
            pingsCount: 2,
        },
    },
    resourceGroup: {
        resourceType: "INSTANCE",
        groupId: check.name,
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

check = gcp.monitoring.Group("check",
    display_name="uptime-check-group",
    filter="resource.metadata.name=has_substring(\"foo\")")
tcp_group = gcp.monitoring.UptimeCheckConfig("tcp_group",
    display_name="tcp-uptime-check",
    timeout="60s",
    tcp_check={
        "port": 888,
        "ping_config": {
            "pings_count": 2,
        },
    },
    resource_group={
        "resource_type": "INSTANCE",
        "group_id": check.name,
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var check = new Gcp.Monitoring.Group("check", new()
    {
        DisplayName = "uptime-check-group",
        Filter = "resource.metadata.name=has_substring(\"foo\")",
    });

    var tcpGroup = new Gcp.Monitoring.UptimeCheckConfig("tcp_group", new()
    {
        DisplayName = "tcp-uptime-check",
        Timeout = "60s",
        TcpCheck = new Gcp.Monitoring.Inputs.UptimeCheckConfigTcpCheckArgs
        {
            Port = 888,
            PingConfig = new Gcp.Monitoring.Inputs.UptimeCheckConfigTcpCheckPingConfigArgs
            {
                PingsCount = 2,
            },
        },
        ResourceGroup = new Gcp.Monitoring.Inputs.UptimeCheckConfigResourceGroupArgs
        {
            ResourceType = "INSTANCE",
            GroupId = check.Name,
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		check, err := monitoring.NewGroup(ctx, "check", &monitoring.GroupArgs{
			DisplayName: pulumi.String("uptime-check-group"),
			Filter:      pulumi.String("resource.metadata.name=has_substring(\"foo\")"),
		})
		if err != nil {
			return err
		}
		_, err = monitoring.NewUptimeCheckConfig(ctx, "tcp_group", &monitoring.UptimeCheckConfigArgs{
			DisplayName: pulumi.String("tcp-uptime-check"),
			Timeout:     pulumi.String("60s"),
			TcpCheck: &monitoring.UptimeCheckConfigTcpCheckArgs{
				Port: pulumi.Int(888),
				PingConfig: &monitoring.UptimeCheckConfigTcpCheckPingConfigArgs{
					PingsCount: pulumi.Int(2),
				},
			},
			ResourceGroup: &monitoring.UptimeCheckConfigResourceGroupArgs{
				ResourceType: pulumi.String("INSTANCE"),
				GroupId:      check.Name,
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.Group;
import com.pulumi.gcp.monitoring.GroupArgs;
import com.pulumi.gcp.monitoring.UptimeCheckConfig;
import com.pulumi.gcp.monitoring.UptimeCheckConfigArgs;
import com.pulumi.gcp.monitoring.inputs.UptimeCheckConfigTcpCheckArgs;
import com.pulumi.gcp.monitoring.inputs.UptimeCheckConfigTcpCheckPingConfigArgs;
import com.pulumi.gcp.monitoring.inputs.UptimeCheckConfigResourceGroupArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var check = new Group("check", GroupArgs.builder()
            .displayName("uptime-check-group")
            .filter("resource.metadata.name=has_substring(\"foo\")")
            .build());

        var tcpGroup = new UptimeCheckConfig("tcpGroup", UptimeCheckConfigArgs.builder()
            .displayName("tcp-uptime-check")
            .timeout("60s")
            .tcpCheck(UptimeCheckConfigTcpCheckArgs.builder()
                .port(888)
                .pingConfig(UptimeCheckConfigTcpCheckPingConfigArgs.builder()
                    .pingsCount(2)
                    .build())
                .build())
            .resourceGroup(UptimeCheckConfigResourceGroupArgs.builder()
                .resourceType("INSTANCE")
                .groupId(check.name())
                .build())
            .build());

    }
}
```
```yaml
resources:
  tcpGroup:
    type: gcp:monitoring:UptimeCheckConfig
    name: tcp_group
    properties:
      displayName: tcp-uptime-check
      timeout: 60s
      tcpCheck:
        port: 888
        pingConfig:
          pingsCount: 2
      resourceGroup:
        resourceType: INSTANCE
        groupId: ${check.name}
  check:
    type: gcp:monitoring:Group
    properties:
      displayName: uptime-check-group
      filter: resource.metadata.name=has_substring("foo")
```
<!--End PulumiCodeChooser -->
### Uptime Check Config Synthetic Monitor


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const bucket = new gcp.storage.Bucket("bucket", {
    name: "my-project-name-gcf-source",
    location: "US",
    uniformBucketLevelAccess: true,
});
const object = new gcp.storage.BucketObject("object", {
    name: "function-source.zip",
    bucket: bucket.name,
    source: new pulumi.asset.FileAsset("synthetic-fn-source.zip"),
});
const _function = new gcp.cloudfunctionsv2.Function("function", {
    name: "synthetic_function",
    location: "us-central1",
    buildConfig: {
        runtime: "nodejs16",
        entryPoint: "SyntheticFunction",
        source: {
            storageSource: {
                bucket: bucket.name,
                object: object.name,
            },
        },
    },
    serviceConfig: {
        maxInstanceCount: 1,
        availableMemory: "256M",
        timeoutSeconds: 60,
    },
});
const syntheticMonitor = new gcp.monitoring.UptimeCheckConfig("synthetic_monitor", {
    displayName: "synthetic_monitor",
    timeout: "60s",
    syntheticMonitor: {
        cloudFunctionV2: {
            name: _function.id,
        },
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

bucket = gcp.storage.Bucket("bucket",
    name="my-project-name-gcf-source",
    location="US",
    uniform_bucket_level_access=True)
object = gcp.storage.BucketObject("object",
    name="function-source.zip",
    bucket=bucket.name,
    source=pulumi.FileAsset("synthetic-fn-source.zip"))
function = gcp.cloudfunctionsv2.Function("function",
    name="synthetic_function",
    location="us-central1",
    build_config={
        "runtime": "nodejs16",
        "entry_point": "SyntheticFunction",
        "source": {
            "storage_source": {
                "bucket": bucket.name,
                "object": object.name,
            },
        },
    },
    service_config={
        "max_instance_count": 1,
        "available_memory": "256M",
        "timeout_seconds": 60,
    })
synthetic_monitor = gcp.monitoring.UptimeCheckConfig("synthetic_monitor",
    display_name="synthetic_monitor",
    timeout="60s",
    synthetic_monitor={
        "cloud_function_v2": {
            "name": function.id,
        },
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var bucket = new Gcp.Storage.Bucket("bucket", new()
    {
        Name = "my-project-name-gcf-source",
        Location = "US",
        UniformBucketLevelAccess = true,
    });

    var @object = new Gcp.Storage.BucketObject("object", new()
    {
        Name = "function-source.zip",
        Bucket = bucket.Name,
        Source = new FileAsset("synthetic-fn-source.zip"),
    });

    var function = new Gcp.CloudFunctionsV2.Function("function", new()
    {
        Name = "synthetic_function",
        Location = "us-central1",
        BuildConfig = new Gcp.CloudFunctionsV2.Inputs.FunctionBuildConfigArgs
        {
            Runtime = "nodejs16",
            EntryPoint = "SyntheticFunction",
            Source = new Gcp.CloudFunctionsV2.Inputs.FunctionBuildConfigSourceArgs
            {
                StorageSource = new Gcp.CloudFunctionsV2.Inputs.FunctionBuildConfigSourceStorageSourceArgs
                {
                    Bucket = bucket.Name,
                    Object = @object.Name,
                },
            },
        },
        ServiceConfig = new Gcp.CloudFunctionsV2.Inputs.FunctionServiceConfigArgs
        {
            MaxInstanceCount = 1,
            AvailableMemory = "256M",
            TimeoutSeconds = 60,
        },
    });

    var syntheticMonitor = new Gcp.Monitoring.UptimeCheckConfig("synthetic_monitor", new()
    {
        DisplayName = "synthetic_monitor",
        Timeout = "60s",
        SyntheticMonitor = new Gcp.Monitoring.Inputs.UptimeCheckConfigSyntheticMonitorArgs
        {
            CloudFunctionV2 = new Gcp.Monitoring.Inputs.UptimeCheckConfigSyntheticMonitorCloudFunctionV2Args
            {
                Name = function.Id,
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/cloudfunctionsv2"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/storage"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		bucket, err := storage.NewBucket(ctx, "bucket", &storage.BucketArgs{
			Name:                     pulumi.String("my-project-name-gcf-source"),
			Location:                 pulumi.String("US"),
			UniformBucketLevelAccess: pulumi.Bool(true),
		})
		if err != nil {
			return err
		}
		object, err := storage.NewBucketObject(ctx, "object", &storage.BucketObjectArgs{
			Name:   pulumi.String("function-source.zip"),
			Bucket: bucket.Name,
			Source: pulumi.NewFileAsset("synthetic-fn-source.zip"),
		})
		if err != nil {
			return err
		}
		function, err := cloudfunctionsv2.NewFunction(ctx, "function", &cloudfunctionsv2.FunctionArgs{
			Name:     pulumi.String("synthetic_function"),
			Location: pulumi.String("us-central1"),
			BuildConfig: &cloudfunctionsv2.FunctionBuildConfigArgs{
				Runtime:    pulumi.String("nodejs16"),
				EntryPoint: pulumi.String("SyntheticFunction"),
				Source: &cloudfunctionsv2.FunctionBuildConfigSourceArgs{
					StorageSource: &cloudfunctionsv2.FunctionBuildConfigSourceStorageSourceArgs{
						Bucket: bucket.Name,
						Object: object.Name,
					},
				},
			},
			ServiceConfig: &cloudfunctionsv2.FunctionServiceConfigArgs{
				MaxInstanceCount: pulumi.Int(1),
				AvailableMemory:  pulumi.String("256M"),
				TimeoutSeconds:   pulumi.Int(60),
			},
		})
		if err != nil {
			return err
		}
		_, err = monitoring.NewUptimeCheckConfig(ctx, "synthetic_monitor", &monitoring.UptimeCheckConfigArgs{
			DisplayName: pulumi.String("synthetic_monitor"),
			Timeout:     pulumi.String("60s"),
			SyntheticMonitor: &monitoring.UptimeCheckConfigSyntheticMonitorArgs{
				CloudFunctionV2: &monitoring.UptimeCheckConfigSyntheticMonitorCloudFunctionV2Args{
					Name: function.ID(),
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.storage.Bucket;
import com.pulumi.gcp.storage.BucketArgs;
import com.pulumi.gcp.storage.BucketObject;
import com.pulumi.gcp.storage.BucketObjectArgs;
import com.pulumi.gcp.cloudfunctionsv2.Function;
import com.pulumi.gcp.cloudfunctionsv2.FunctionArgs;
import com.pulumi.gcp.cloudfunctionsv2.inputs.FunctionBuildConfigArgs;
import com.pulumi.gcp.cloudfunctionsv2.inputs.FunctionBuildConfigSourceArgs;
import com.pulumi.gcp.cloudfunctionsv2.inputs.FunctionBuildConfigSourceStorageSourceArgs;
import com.pulumi.gcp.cloudfunctionsv2.inputs.FunctionServiceConfigArgs;
import com.pulumi.gcp.monitoring.UptimeCheckConfig;
import com.pulumi.gcp.monitoring.UptimeCheckConfigArgs;
import com.pulumi.gcp.monitoring.inputs.UptimeCheckConfigSyntheticMonitorArgs;
import com.pulumi.gcp.monitoring.inputs.UptimeCheckConfigSyntheticMonitorCloudFunctionV2Args;
import com.pulumi.asset.FileAsset;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var bucket = new Bucket("bucket", BucketArgs.builder()
            .name("my-project-name-gcf-source")
            .location("US")
            .uniformBucketLevelAccess(true)
            .build());

        var object = new BucketObject("object", BucketObjectArgs.builder()
            .name("function-source.zip")
            .bucket(bucket.name())
            .source(new FileAsset("synthetic-fn-source.zip"))
            .build());

        var function = new Function("function", FunctionArgs.builder()
            .name("synthetic_function")
            .location("us-central1")
            .buildConfig(FunctionBuildConfigArgs.builder()
                .runtime("nodejs16")
                .entryPoint("SyntheticFunction")
                .source(FunctionBuildConfigSourceArgs.builder()
                    .storageSource(FunctionBuildConfigSourceStorageSourceArgs.builder()
                        .bucket(bucket.name())
                        .object(object.name())
                        .build())
                    .build())
                .build())
            .serviceConfig(FunctionServiceConfigArgs.builder()
                .maxInstanceCount(1)
                .availableMemory("256M")
                .timeoutSeconds(60)
                .build())
            .build());

        var syntheticMonitor = new UptimeCheckConfig("syntheticMonitor", UptimeCheckConfigArgs.builder()
            .displayName("synthetic_monitor")
            .timeout("60s")
            .syntheticMonitor(UptimeCheckConfigSyntheticMonitorArgs.builder()
                .cloudFunctionV2(UptimeCheckConfigSyntheticMonitorCloudFunctionV2Args.builder()
                    .name(function.id())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  bucket:
    type: gcp:storage:Bucket
    properties:
      name: my-project-name-gcf-source
      location: US
      uniformBucketLevelAccess: true
  object:
    type: gcp:storage:BucketObject
    properties:
      name: function-source.zip
      bucket: ${bucket.name}
      source:
        fn::FileAsset: synthetic-fn-source.zip
  function:
    type: gcp:cloudfunctionsv2:Function
    properties:
      name: synthetic_function
      location: us-central1
      buildConfig:
        runtime: nodejs16
        entryPoint: SyntheticFunction
        source:
          storageSource:
            bucket: ${bucket.name}
            object: ${object.name}
      serviceConfig:
        maxInstanceCount: 1
        availableMemory: 256M
        timeoutSeconds: 60
  syntheticMonitor:
    type: gcp:monitoring:UptimeCheckConfig
    name: synthetic_monitor
    properties:
      displayName: synthetic_monitor
      timeout: 60s
      syntheticMonitor:
        cloudFunctionV2:
          name: ${function.id}
```
<!--End PulumiCodeChooser -->

## Import

UptimeCheckConfig can be imported using any of these accepted formats:

* `{{project}}/{{name}}`

* `{{project}} {{name}}`

* `{{name}}`

When using the `pulumi import` command, UptimeCheckConfig can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:monitoring/uptimeCheckConfig:UptimeCheckConfig default {{project}}/{{name}}
```

```sh
$ pulumi import gcp:monitoring/uptimeCheckConfig:UptimeCheckConfig default "{{project}} {{name}}"
```

```sh
$ pulumi import gcp:monitoring/uptimeCheckConfig:UptimeCheckConfig default {{name}}
```

‰
checkerTypeB" ŒThe checker type to use for the check. If the monitored resource type is `servicedirectory_service`, `checker_type` must be set to `VPC_CHECKERS`.
Possible values are: `STATIC_IP_CHECKERS`, `VPC_CHECKERS`.
ˇ
contentMatchersáBÑ*Å:
}

monitoringUptimeCheckConfigContentMatcherNgcp:monitoring/UptimeCheckConfigContentMatcher:UptimeCheckConfigContentMatcher·The expected content on the page the check is run against. Currently, only the first entry in the list is supported, and other entries will be ignored. The server will look for an exact match of the string in the page response's content. This field is optional and should only be specified if a content match is required.
Structure is documented below.
‹
displayName" »A human-friendly name for the uptime check configuration. The display name should be unique within a Stackdriver Workspace in order to make it easier to identify; however, uniqueness is not enforced.
ﬁ
	httpChecktBr:p
n

monitoringUptimeCheckConfigHttpCheckDgcp:monitoring/UptimeCheckConfigHttpCheck:UptimeCheckConfigHttpCheck[Contains information needed to make an HTTP or HTTPS check.
Structure is documented below.
‡
monitoredResourceèBå:â
Ü

monitoring"UptimeCheckConfigMonitoredResourceTgcp:monitoring/UptimeCheckConfigMonitoredResource:UptimeCheckConfigMonitoredResource∏The [monitored resource]
(https://cloud.google.com/monitoring/api/resources) associated with the
configuration. The following monitored resource types are supported for
uptime checks:
ÿ
periodB" «How often, in seconds, the uptime check is performed. Currently, the only supported values are 60s (1 minute), 300s (5 minutes), 600s (10 minutes), and 900s (15 minutes). Optional, defaults to 300s.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
È
resourceGroupÄB~:|
z

monitoringUptimeCheckConfigResourceGroupLgcp:monitoring/UptimeCheckConfigResourceGroup:UptimeCheckConfigResourceGroupUThe group resource associated with the configuration.
Structure is documented below.
Í
selectedRegionsB*" ŒThe list of regions from which the check will be run. Some regions contain one location, and others contain more than one. If this field is specified, enough regions to include a minimum of 3 locations must be provided, or an error message is returned. Not specifying this field will result in uptime checks running from all regions.
Å
syntheticMonitoråBâ:Ü
É

monitoring!UptimeCheckConfigSyntheticMonitorRgcp:monitoring/UptimeCheckConfigSyntheticMonitor:UptimeCheckConfigSyntheticMonitor^A Synthetic Monitor deployed to a Cloud Functions V2 instance.
Structure is documented below.
œ
tcpCheckqBo:m
k

monitoringUptimeCheckConfigTcpCheckBgcp:monitoring/UptimeCheckConfigTcpCheck:UptimeCheckConfigTcpCheckPContains information needed to make a TCP check.
Structure is documented below.
î
timeout" ÑThe maximum amount of time to wait for the request to complete (must be between 1 and 60 seconds). See the accepted formats


- - -
˙

userLabelsB2" „User-supplied key/value data to be used for organizing and identifying the `UptimeCheckConfig` objects. The field can contain up to 64 entries. Each key and value is limited to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values can contain only lowercase letters, numerals, underscores, and dashes. Keys must begin with a letter.
"‚
checkerType" ŒThe checker type to use for the check. If the monitored resource type is `servicedirectory_service`, `checker_type` must be set to `VPC_CHECKERS`.
Possible values are: `STATIC_IP_CHECKERS`, `VPC_CHECKERS`.
"ˇ
contentMatchersáBÑ*Å:
}

monitoringUptimeCheckConfigContentMatcherNgcp:monitoring/UptimeCheckConfigContentMatcher:UptimeCheckConfigContentMatcher·The expected content on the page the check is run against. Currently, only the first entry in the list is supported, and other entries will be ignored. The server will look for an exact match of the string in the page response's content. This field is optional and should only be specified if a content match is required.
Structure is documented below.
"‹
displayName" »A human-friendly name for the uptime check configuration. The display name should be unique within a Stackdriver Workspace in order to make it easier to identify; however, uniqueness is not enforced.
"ﬁ
	httpChecktBr:p
n

monitoringUptimeCheckConfigHttpCheckDgcp:monitoring/UptimeCheckConfigHttpCheck:UptimeCheckConfigHttpCheck[Contains information needed to make an HTTP or HTTPS check.
Structure is documented below.
"‡
monitoredResourceèBå:â
Ü

monitoring"UptimeCheckConfigMonitoredResourceTgcp:monitoring/UptimeCheckConfigMonitoredResource:UptimeCheckConfigMonitoredResource∏The [monitored resource]
(https://cloud.google.com/monitoring/api/resources) associated with the
configuration. The following monitored resource types are supported for
uptime checks:
"ã
name" A unique resource name for this UptimeCheckConfig. The format is `projects/[PROJECT_ID]/uptimeCheckConfigs/[UPTIME_CHECK_ID]`.
"ÿ
periodB" «How often, in seconds, the uptime check is performed. Currently, the only supported values are 60s (1 minute), 300s (5 minutes), 600s (10 minutes), and 900s (15 minutes). Optional, defaults to 300s.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"È
resourceGroupÄB~:|
z

monitoringUptimeCheckConfigResourceGroupLgcp:monitoring/UptimeCheckConfigResourceGroup:UptimeCheckConfigResourceGroupUThe group resource associated with the configuration.
Structure is documented below.
"Í
selectedRegionsB*" ŒThe list of regions from which the check will be run. Some regions contain one location, and others contain more than one. If this field is specified, enough regions to include a minimum of 3 locations must be provided, or an error message is returned. Not specifying this field will result in uptime checks running from all regions.
"Å
syntheticMonitoråBâ:Ü
É

monitoring!UptimeCheckConfigSyntheticMonitorRgcp:monitoring/UptimeCheckConfigSyntheticMonitor:UptimeCheckConfigSyntheticMonitor^A Synthetic Monitor deployed to a Cloud Functions V2 instance.
Structure is documented below.
"œ
tcpCheckqBo:m
k

monitoringUptimeCheckConfigTcpCheckBgcp:monitoring/UptimeCheckConfigTcpCheck:UptimeCheckConfigTcpCheckPContains information needed to make a TCP check.
Structure is documented below.
"î
timeout" ÑThe maximum amount of time to wait for the request to complete (must be between 1 and 60 seconds). See the accepted formats


- - -
"0
uptimeCheckId" The id of the uptime check
"˙

userLabelsB2" „User-supplied key/value data to be used for organizing and identifying the `UptimeCheckConfig` objects. The field can contain up to 64 entries. Each key and value is limited to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values can contain only lowercase letters, numerals, underscores, and dashes. Keys must begin with a letter.
*éy
E
netappActiveDirectory*gcp:netapp/activeDirectory:ActiveDirectoryˇ@ActiveDirectory is the public representation of the active directory config.


To get more information about ActiveDirectory, see:

* [API documentation](https://cloud.google.com/netapp/volumes/docs/reference/rest/v1/projects.locations.activeDirectories)
* How-to Guides
    * [Official Documentation](https://cloud.google.com/netapp/volumes/docs/configure-and-use/active-directory/about-ad)



## Example Usage

### Netapp Active Directory Full


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const testActiveDirectoryFull = new gcp.netapp.ActiveDirectory("test_active_directory_full", {
    name: "test-active-directory-full",
    location: "us-central1",
    domain: "ad.internal",
    dns: "172.30.64.3",
    netBiosPrefix: "smbserver",
    username: "user",
    password: "pass",
    aesEncryption: false,
    backupOperators: [
        "test1",
        "test2",
    ],
    administrators: [
        "test1",
        "test2",
    ],
    description: "ActiveDirectory is the public representation of the active directory config.",
    encryptDcConnections: false,
    kdcHostname: "hostname",
    kdcIp: "10.10.0.11",
    labels: {
        foo: "bar",
    },
    ldapSigning: false,
    nfsUsersWithLdap: false,
    organizationalUnit: "CN=Computers",
    securityOperators: [
        "test1",
        "test2",
    ],
    site: "test-site",
});
```
```python
import pulumi
import pulumi_gcp as gcp

test_active_directory_full = gcp.netapp.ActiveDirectory("test_active_directory_full",
    name="test-active-directory-full",
    location="us-central1",
    domain="ad.internal",
    dns="172.30.64.3",
    net_bios_prefix="smbserver",
    username="user",
    password="pass",
    aes_encryption=False,
    backup_operators=[
        "test1",
        "test2",
    ],
    administrators=[
        "test1",
        "test2",
    ],
    description="ActiveDirectory is the public representation of the active directory config.",
    encrypt_dc_connections=False,
    kdc_hostname="hostname",
    kdc_ip="10.10.0.11",
    labels={
        "foo": "bar",
    },
    ldap_signing=False,
    nfs_users_with_ldap=False,
    organizational_unit="CN=Computers",
    security_operators=[
        "test1",
        "test2",
    ],
    site="test-site")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var testActiveDirectoryFull = new Gcp.Netapp.ActiveDirectory("test_active_directory_full", new()
    {
        Name = "test-active-directory-full",
        Location = "us-central1",
        Domain = "ad.internal",
        Dns = "172.30.64.3",
        NetBiosPrefix = "smbserver",
        Username = "user",
        Password = "pass",
        AesEncryption = false,
        BackupOperators = new[]
        {
            "test1",
            "test2",
        },
        Administrators = new[]
        {
            "test1",
            "test2",
        },
        Description = "ActiveDirectory is the public representation of the active directory config.",
        EncryptDcConnections = false,
        KdcHostname = "hostname",
        KdcIp = "10.10.0.11",
        Labels = 
        {
            { "foo", "bar" },
        },
        LdapSigning = false,
        NfsUsersWithLdap = false,
        OrganizationalUnit = "CN=Computers",
        SecurityOperators = new[]
        {
            "test1",
            "test2",
        },
        Site = "test-site",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/netapp"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := netapp.NewActiveDirectory(ctx, "test_active_directory_full", &netapp.ActiveDirectoryArgs{
			Name:          pulumi.String("test-active-directory-full"),
			Location:      pulumi.String("us-central1"),
			Domain:        pulumi.String("ad.internal"),
			Dns:           pulumi.String("172.30.64.3"),
			NetBiosPrefix: pulumi.String("smbserver"),
			Username:      pulumi.String("user"),
			Password:      pulumi.String("pass"),
			AesEncryption: pulumi.Bool(false),
			BackupOperators: pulumi.StringArray{
				pulumi.String("test1"),
				pulumi.String("test2"),
			},
			Administrators: pulumi.StringArray{
				pulumi.String("test1"),
				pulumi.String("test2"),
			},
			Description:          pulumi.String("ActiveDirectory is the public representation of the active directory config."),
			EncryptDcConnections: pulumi.Bool(false),
			KdcHostname:          pulumi.String("hostname"),
			KdcIp:                pulumi.String("10.10.0.11"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			LdapSigning:        pulumi.Bool(false),
			NfsUsersWithLdap:   pulumi.Bool(false),
			OrganizationalUnit: pulumi.String("CN=Computers"),
			SecurityOperators: pulumi.StringArray{
				pulumi.String("test1"),
				pulumi.String("test2"),
			},
			Site: pulumi.String("test-site"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.netapp.ActiveDirectory;
import com.pulumi.gcp.netapp.ActiveDirectoryArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var testActiveDirectoryFull = new ActiveDirectory("testActiveDirectoryFull", ActiveDirectoryArgs.builder()
            .name("test-active-directory-full")
            .location("us-central1")
            .domain("ad.internal")
            .dns("172.30.64.3")
            .netBiosPrefix("smbserver")
            .username("user")
            .password("pass")
            .aesEncryption(false)
            .backupOperators(            
                "test1",
                "test2")
            .administrators(            
                "test1",
                "test2")
            .description("ActiveDirectory is the public representation of the active directory config.")
            .encryptDcConnections(false)
            .kdcHostname("hostname")
            .kdcIp("10.10.0.11")
            .labels(Map.of("foo", "bar"))
            .ldapSigning(false)
            .nfsUsersWithLdap(false)
            .organizationalUnit("CN=Computers")
            .securityOperators(            
                "test1",
                "test2")
            .site("test-site")
            .build());

    }
}
```
```yaml
resources:
  testActiveDirectoryFull:
    type: gcp:netapp:ActiveDirectory
    name: test_active_directory_full
    properties:
      name: test-active-directory-full
      location: us-central1
      domain: ad.internal
      dns: 172.30.64.3
      netBiosPrefix: smbserver
      username: user
      password: pass
      aesEncryption: false
      backupOperators:
        - test1
        - test2
      administrators:
        - test1
        - test2
      description: ActiveDirectory is the public representation of the active directory config.
      encryptDcConnections: false
      kdcHostname: hostname
      kdcIp: 10.10.0.11
      labels:
        foo: bar
      ldapSigning: false
      nfsUsersWithLdap: false
      organizationalUnit: CN=Computers
      securityOperators:
        - test1
        - test2
      site: test-site
```
<!--End PulumiCodeChooser -->

## Import

ActiveDirectory can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/activeDirectories/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

When using the `pulumi import` command, ActiveDirectory can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:netapp/activeDirectory:ActiveDirectory default projects/{{project}}/locations/{{location}}/activeDirectories/{{name}}
```

```sh
$ pulumi import gcp:netapp/activeDirectory:ActiveDirectory default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:netapp/activeDirectory:ActiveDirectory default {{location}}/{{name}}
```

Ü
administratorsB*" ÎDomain user accounts to be added to the local Administrators group of the SMB service. Comma-separated list of domain users or groups. The Domain Admin group is automatically added when the service joins your domain as a hidden group.
v
aesEncryptionB
 _Enables AES-128 and AES-256 encryption for Kerberos-based communication with Active Directory.
î
backupOperatorsB*" ¯Domain user/group accounts to be added to the Backup Operators group of the SMB service. The Backup Operators group allows members to backup and restore files regardless of whether they have read or write access to the files. Comma-separated list.
?
descriptionB" *An optional description of this resource.
\
dns" QComma separated list of DNS server IP addresses for the Active Directory domain.
K
domain" =Fully qualified domain name for the Active Directory domain.
v
encryptDcConnectionsB
 XIf enabled, traffic between the SMB server to Domain Controller (DC) will be encrypted.
õ
kdcHostnameB" ÖHostname of the Active Directory server used as Kerberos Key Distribution Center. Only required for volumes using kerberized NFSv4.1
c
kdcIpB" TIP address of the Active Directory server used as Kerberos Key Distribution Center.
√
labelsB2" ∞Labels as key value pairs. Example: `{ "owner": "Bob", "department": "finance", "purpose": "testing" }`.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
S
ldapSigningB
 >Specifies whether or not the LDAP traffic needs to be signed.
?
location" /Name of the region for the policy to apply to.
g
nameB" YThe resource name of the Active Directory pool. Needs to be unique per location.


- - -
ï
netBiosPrefix" ˇNetBIOS name prefix of the server to be created.
A five-character random ID is generated automatically, for example, -6f9a, and appended to the prefix. The full UNC share path will have the following format:
`\\NetBIOS_PREFIX-ABCD.DOMAIN_NAME\SHARE_NAME`
ä
nfsUsersWithLdapB
 ÔLocal UNIX users on clients without valid user information in Active Directory are blocked from access to LDAP enabled volumes.
This option can be used to temporarily switch such volumes to AUTH_SYS authentication (user ID + 1-16 groups).
´
organizationalUnitB" éName of the Organizational Unit where you intend to create the computer account for NetApp Volumes.
Defaults to `CN=Computers` if left empty.

password" {
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
õ
securityOperatorsB*" ~Domain accounts that require elevated privileges such as `SeSecurityPrivilege` to manage security logs. Comma-separated list.
ﬂ
siteB" –Specifies an Active Directory site to manage domain controller selection.
Use when Active Directory domain controllers in multiple regions are configured. Defaults to `Default-First-Site-Name` if left empty.
î
username" ÉUsername for the Active Directory account with permissions to create the compute account within the specified organizational unit.
"Ü
administratorsB*" ÎDomain user accounts to be added to the local Administrators group of the SMB service. Comma-separated list of domain users or groups. The Domain Admin group is automatically added when the service joins your domain as a hidden group.
"v
aesEncryptionB
 _Enables AES-128 and AES-256 encryption for Kerberos-based communication with Active Directory.
"î
backupOperatorsB*" ¯Domain user/group accounts to be added to the Backup Operators group of the SMB service. The Backup Operators group allows members to backup and restore files regardless of whether they have read or write access to the files. Comma-separated list.
"á

createTime" uCreate time of the active directory. A timestamp in RFC3339 UTC "Zulu" format. Examples: "2023-06-22T09:13:01.617Z".
"?
descriptionB" *An optional description of this resource.
"\
dns" QComma separated list of DNS server IP addresses for the Active Directory domain.
"K
domain" =Fully qualified domain name for the Active Directory domain.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"v
encryptDcConnectionsB
 XIf enabled, traffic between the SMB server to Domain Controller (DC) will be encrypted.
"õ
kdcHostnameB" ÖHostname of the Active Directory server used as Kerberos Key Distribution Center. Only required for volumes using kerberized NFSv4.1
"c
kdcIpB" TIP address of the Active Directory server used as Kerberos Key Distribution Center.
"√
labelsB2" ∞Labels as key value pairs. Example: `{ "owner": "Bob", "department": "finance", "purpose": "testing" }`.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"S
ldapSigningB
 >Specifies whether or not the LDAP traffic needs to be signed.
"?
location" /Name of the region for the policy to apply to.
"e
name" YThe resource name of the Active Directory pool. Needs to be unique per location.


- - -
"ï
netBiosPrefix" ˇNetBIOS name prefix of the server to be created.
A five-character random ID is generated automatically, for example, -6f9a, and appended to the prefix. The full UNC share path will have the following format:
`\\NetBIOS_PREFIX-ABCD.DOMAIN_NAME\SHARE_NAME`
"ä
nfsUsersWithLdapB
 ÔLocal UNIX users on clients without valid user information in Active Directory are blocked from access to LDAP enabled volumes.
This option can be used to temporarily switch such volumes to AUTH_SYS authentication (user ID + 1-16 groups).
"©
organizationalUnit" éName of the Organizational Unit where you intend to create the computer account for NetApp Volumes.
Defaults to `CN=Computers` if left empty.
"
password" "y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"õ
securityOperatorsB*" ~Domain accounts that require elevated privileges such as `SeSecurityPrivilege` to manage security logs. Comma-separated list.
"ﬂ
siteB" –Specifies an Active Directory site to manage domain controller selection.
Use when Active Directory domain controllers in multiple regions are configured. Defaults to `Default-First-Site-Name` if left empty.
"Y
state" LThe state of the Active Directory policy (not the Active Directory itself).
"?
stateDetails" +The state details of the Active Directory.
"î
username" ÉUsername for the Active Directory account with permissions to create the compute account within the specified organizational unit.
*•o
*
netappBackupgcp:netapp/backup:Backup∏SNetApp Volumes supports volume backups, which are copies of your volumes
stored independently from the volume. Backups are stored in backup vaults,
which are containers for backups. If a volume is lost or deleted, you can
use backups to restore your data to a new volume.

When you create the first backup of a volume, all of the volume's used
data is sent to the backup vault. Subsequent backups of the same volume
only include data that has changed from the previous backup. This allows
for fast incremental-forever backups and reduces the required capacity
inside the backup vault.

You can create manual and scheduled backups. Manual backups can be taken
from a volume or from an existing volume snapshot. Scheduled backups
require a backup policy.


To get more information about Backup, see:

* [API documentation](https://cloud.google.com/netapp/volumes/docs/reference/rest/v1/projects.locations.backupVaults.backups)
* How-to Guides
    * [Documentation](https://cloud.google.com/netapp/volumes/docs/protect-data/about-volume-backups)

## Example Usage

### Netapp Backup


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const default = gcp.compute.getNetwork({
    name: "",
});
const defaultStoragePool = new gcp.netapp.StoragePool("default", {
    name: "backup-pool",
    location: "us-central1",
    serviceLevel: "PREMIUM",
    capacityGib: "2048",
    network: _default.then(_default => _default.id),
});
const defaultBackupVault = new gcp.netapp.BackupVault("default", {
    name: "backup-vault",
    location: defaultStoragePool.location,
});
const defaultVolume = new gcp.netapp.Volume("default", {
    name: "backup-volume",
    location: defaultStoragePool.location,
    capacityGib: "100",
    shareName: "backup-volume",
    storagePool: defaultStoragePool.name,
    protocols: ["NFSV3"],
    deletionPolicy: "FORCE",
    backupConfig: {
        backupVault: defaultBackupVault.id,
    },
});
const testBackup = new gcp.netapp.Backup("test_backup", {
    name: "test-backup",
    location: defaultBackupVault.location,
    vaultName: defaultBackupVault.name,
    sourceVolume: defaultVolume.id,
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.compute.get_network(name="")
default_storage_pool = gcp.netapp.StoragePool("default",
    name="backup-pool",
    location="us-central1",
    service_level="PREMIUM",
    capacity_gib="2048",
    network=default.id)
default_backup_vault = gcp.netapp.BackupVault("default",
    name="backup-vault",
    location=default_storage_pool.location)
default_volume = gcp.netapp.Volume("default",
    name="backup-volume",
    location=default_storage_pool.location,
    capacity_gib="100",
    share_name="backup-volume",
    storage_pool=default_storage_pool.name,
    protocols=["NFSV3"],
    deletion_policy="FORCE",
    backup_config={
        "backup_vault": default_backup_vault.id,
    })
test_backup = gcp.netapp.Backup("test_backup",
    name="test-backup",
    location=default_backup_vault.location,
    vault_name=default_backup_vault.name,
    source_volume=default_volume.id)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = Gcp.Compute.GetNetwork.Invoke(new()
    {
        Name = "",
    });

    var defaultStoragePool = new Gcp.Netapp.StoragePool("default", new()
    {
        Name = "backup-pool",
        Location = "us-central1",
        ServiceLevel = "PREMIUM",
        CapacityGib = "2048",
        Network = @default.Apply(@default => @default.Apply(getNetworkResult => getNetworkResult.Id)),
    });

    var defaultBackupVault = new Gcp.Netapp.BackupVault("default", new()
    {
        Name = "backup-vault",
        Location = defaultStoragePool.Location,
    });

    var defaultVolume = new Gcp.Netapp.Volume("default", new()
    {
        Name = "backup-volume",
        Location = defaultStoragePool.Location,
        CapacityGib = "100",
        ShareName = "backup-volume",
        StoragePool = defaultStoragePool.Name,
        Protocols = new[]
        {
            "NFSV3",
        },
        DeletionPolicy = "FORCE",
        BackupConfig = new Gcp.Netapp.Inputs.VolumeBackupConfigArgs
        {
            BackupVault = defaultBackupVault.Id,
        },
    });

    var testBackup = new Gcp.Netapp.Backup("test_backup", new()
    {
        Name = "test-backup",
        Location = defaultBackupVault.Location,
        VaultName = defaultBackupVault.Name,
        SourceVolume = defaultVolume.Id,
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/netapp"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_default, err := compute.LookupNetwork(ctx, &compute.LookupNetworkArgs{
			Name: "",
		}, nil)
		if err != nil {
			return err
		}
		defaultStoragePool, err := netapp.NewStoragePool(ctx, "default", &netapp.StoragePoolArgs{
			Name:         pulumi.String("backup-pool"),
			Location:     pulumi.String("us-central1"),
			ServiceLevel: pulumi.String("PREMIUM"),
			CapacityGib:  pulumi.String("2048"),
			Network:      pulumi.String(_default.Id),
		})
		if err != nil {
			return err
		}
		defaultBackupVault, err := netapp.NewBackupVault(ctx, "default", &netapp.BackupVaultArgs{
			Name:     pulumi.String("backup-vault"),
			Location: defaultStoragePool.Location,
		})
		if err != nil {
			return err
		}
		defaultVolume, err := netapp.NewVolume(ctx, "default", &netapp.VolumeArgs{
			Name:        pulumi.String("backup-volume"),
			Location:    defaultStoragePool.Location,
			CapacityGib: pulumi.String("100"),
			ShareName:   pulumi.String("backup-volume"),
			StoragePool: defaultStoragePool.Name,
			Protocols: pulumi.StringArray{
				pulumi.String("NFSV3"),
			},
			DeletionPolicy: pulumi.String("FORCE"),
			BackupConfig: &netapp.VolumeBackupConfigArgs{
				BackupVault: defaultBackupVault.ID(),
			},
		})
		if err != nil {
			return err
		}
		_, err = netapp.NewBackup(ctx, "test_backup", &netapp.BackupArgs{
			Name:         pulumi.String("test-backup"),
			Location:     defaultBackupVault.Location,
			VaultName:    defaultBackupVault.Name,
			SourceVolume: defaultVolume.ID(),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.ComputeFunctions;
import com.pulumi.gcp.compute.inputs.GetNetworkArgs;
import com.pulumi.gcp.netapp.StoragePool;
import com.pulumi.gcp.netapp.StoragePoolArgs;
import com.pulumi.gcp.netapp.BackupVault;
import com.pulumi.gcp.netapp.BackupVaultArgs;
import com.pulumi.gcp.netapp.Volume;
import com.pulumi.gcp.netapp.VolumeArgs;
import com.pulumi.gcp.netapp.inputs.VolumeBackupConfigArgs;
import com.pulumi.gcp.netapp.Backup;
import com.pulumi.gcp.netapp.BackupArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var default = ComputeFunctions.getNetwork(GetNetworkArgs.builder()
            .name("")
            .build());

        var defaultStoragePool = new StoragePool("defaultStoragePool", StoragePoolArgs.builder()
            .name("backup-pool")
            .location("us-central1")
            .serviceLevel("PREMIUM")
            .capacityGib("2048")
            .network(default_.id())
            .build());

        var defaultBackupVault = new BackupVault("defaultBackupVault", BackupVaultArgs.builder()
            .name("backup-vault")
            .location(defaultStoragePool.location())
            .build());

        var defaultVolume = new Volume("defaultVolume", VolumeArgs.builder()
            .name("backup-volume")
            .location(defaultStoragePool.location())
            .capacityGib("100")
            .shareName("backup-volume")
            .storagePool(defaultStoragePool.name())
            .protocols("NFSV3")
            .deletionPolicy("FORCE")
            .backupConfig(VolumeBackupConfigArgs.builder()
                .backupVault(defaultBackupVault.id())
                .build())
            .build());

        var testBackup = new Backup("testBackup", BackupArgs.builder()
            .name("test-backup")
            .location(defaultBackupVault.location())
            .vaultName(defaultBackupVault.name())
            .sourceVolume(defaultVolume.id())
            .build());

    }
}
```
```yaml
resources:
  defaultStoragePool:
    type: gcp:netapp:StoragePool
    name: default
    properties:
      name: backup-pool
      location: us-central1
      serviceLevel: PREMIUM
      capacityGib: '2048'
      network: ${default.id}
  defaultVolume:
    type: gcp:netapp:Volume
    name: default
    properties:
      name: backup-volume
      location: ${defaultStoragePool.location}
      capacityGib: '100'
      shareName: backup-volume
      storagePool: ${defaultStoragePool.name}
      protocols:
        - NFSV3
      deletionPolicy: FORCE
      backupConfig:
        backupVault: ${defaultBackupVault.id}
  defaultBackupVault:
    type: gcp:netapp:BackupVault
    name: default
    properties:
      name: backup-vault
      location: ${defaultStoragePool.location}
  testBackup:
    type: gcp:netapp:Backup
    name: test_backup
    properties:
      name: test-backup
      location: ${defaultBackupVault.location}
      vaultName: ${defaultBackupVault.name}
      sourceVolume: ${defaultVolume.id}
variables:
  default:
    fn::invoke:
      function: gcp:compute:getNetwork
      arguments:
        name: ""
```
<!--End PulumiCodeChooser -->

## Import

Backup can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/backupVaults/{{vault_name}}/backups/{{name}}`

* `{{project}}/{{location}}/{{vault_name}}/{{name}}`

* `{{location}}/{{vault_name}}/{{name}}`

When using the `pulumi import` command, Backup can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:netapp/backup:Backup default projects/{{project}}/locations/{{location}}/backupVaults/{{vault_name}}/backups/{{name}}
```

```sh
$ pulumi import gcp:netapp/backup:Backup default {{project}}/{{location}}/{{vault_name}}/{{name}}
```

```sh
$ pulumi import gcp:netapp/backup:Backup default {{location}}/{{vault_name}}/{{name}}
```

É
descriptionB" nA description of the backup with 2048 characters or less. Requests with longer descriptions will be rejected.
√
labelsB2" ∞Labels as key value pairs. Example: `{ "owner": "Bob", "department": "finance", "purpose": "testing" }`.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
(
location" Location of the backup.
X
nameB" JThe resource name of the backup. Needs to be unique per location.


- - -
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
ò
sourceSnapshotB" ˇIf specified, backup will be created from the given snapshot. If not specified,
there will be a new snapshot taken to initiate the backup creation.
Format: `projects/{{projectId}}/locations/{{location}}/volumes/{{volumename}}/snapshots/{{snapshotname}}``
à
sourceVolumeB" rID of volumes this backup belongs to. Format: `projects/{{projects_id}}/locations/{{location}}/volumes/{{name}}``
B
	vaultName" 1Name of the backup vault to store the backup in.
"ä

backupType" xType of backup, manually created or created by a backup policy. Possible Values : [TYPE_UNSPECIFIED, MANUAL, SCHEDULED]
"ÿ
chainStorageBytes" æBackups of a volume build incrementally on top of each other. They form a "backup chain".
Total size of all backups in a chain in bytes = baseline backup size + sum(incremental backup size)
"}

createTime" kCreate time of the backup. A timestamp in RFC3339 UTC "Zulu" format. Examples: "2023-06-22T09:13:01.617Z".
"É
descriptionB" nA description of the backup with 2048 characters or less. Requests with longer descriptions will be rejected.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"√
labelsB2" ∞Labels as key value pairs. Example: `{ "owner": "Bob", "department": "finance", "purpose": "testing" }`.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"(
location" Location of the backup.
"V
name" JThe resource name of the backup. Needs to be unique per location.


- - -
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"ò
sourceSnapshotB" ˇIf specified, backup will be created from the given snapshot. If not specified,
there will be a new snapshot taken to initiate the backup creation.
Format: `projects/{{projectId}}/locations/{{location}}/volumes/{{volumename}}/snapshots/{{snapshotname}}``
"à
sourceVolumeB" rID of volumes this backup belongs to. Format: `projects/{{projects_id}}/locations/{{location}}/volumes/{{name}}``
"â
state" |The state of the Backup Vault. Possible Values : [STATE_UNSPECIFIED, CREATING, UPLOADING, READY, DELETING, ERROR, UPDATING]
"B
	vaultName" 1Name of the backup vault to store the backup in.
"Ø
volumeUsageBytes" ñSize of the file system when the backup was created. When creating a new volume from the backup, the volume capacity will have to be at least as big.
*˛=
<
netappBackupPolicy$gcp:netapp/backupPolicy:BackupPolicy√%A backup policy is used to schedule backups at regular daily, weekly, or monthly intervals.
Backup policies allow you to attach a backup schedule to a volume.
The policy defines how many backups to retain at daily, weekly, or monthly intervals.


To get more information about BackupPolicy, see:

* [API documentation](https://cloud.google.com/netapp/volumes/docs/reference/rest/v1/projects.locations.backupPolicies)
* How-to Guides
    * [Documentation](https://cloud.google.com/netapp/volumes/docs/protect-data/about-volume-backups#about_backup_policies)

## Example Usage

### Netapp Backup Policy Full


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const testBackupPolicyFull = new gcp.netapp.BackupPolicy("test_backup_policy_full", {
    name: "test-backup-policy-full",
    location: "us-central1",
    dailyBackupLimit: 2,
    weeklyBackupLimit: 1,
    monthlyBackupLimit: 1,
    description: "TF test backup schedule",
    enabled: true,
    labels: {
        foo: "bar",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

test_backup_policy_full = gcp.netapp.BackupPolicy("test_backup_policy_full",
    name="test-backup-policy-full",
    location="us-central1",
    daily_backup_limit=2,
    weekly_backup_limit=1,
    monthly_backup_limit=1,
    description="TF test backup schedule",
    enabled=True,
    labels={
        "foo": "bar",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var testBackupPolicyFull = new Gcp.Netapp.BackupPolicy("test_backup_policy_full", new()
    {
        Name = "test-backup-policy-full",
        Location = "us-central1",
        DailyBackupLimit = 2,
        WeeklyBackupLimit = 1,
        MonthlyBackupLimit = 1,
        Description = "TF test backup schedule",
        Enabled = true,
        Labels = 
        {
            { "foo", "bar" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/netapp"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := netapp.NewBackupPolicy(ctx, "test_backup_policy_full", &netapp.BackupPolicyArgs{
			Name:               pulumi.String("test-backup-policy-full"),
			Location:           pulumi.String("us-central1"),
			DailyBackupLimit:   pulumi.Int(2),
			WeeklyBackupLimit:  pulumi.Int(1),
			MonthlyBackupLimit: pulumi.Int(1),
			Description:        pulumi.String("TF test backup schedule"),
			Enabled:            pulumi.Bool(true),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.netapp.BackupPolicy;
import com.pulumi.gcp.netapp.BackupPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var testBackupPolicyFull = new BackupPolicy("testBackupPolicyFull", BackupPolicyArgs.builder()
            .name("test-backup-policy-full")
            .location("us-central1")
            .dailyBackupLimit(2)
            .weeklyBackupLimit(1)
            .monthlyBackupLimit(1)
            .description("TF test backup schedule")
            .enabled(true)
            .labels(Map.of("foo", "bar"))
            .build());

    }
}
```
```yaml
resources:
  testBackupPolicyFull:
    type: gcp:netapp:BackupPolicy
    name: test_backup_policy_full
    properties:
      name: test-backup-policy-full
      location: us-central1
      dailyBackupLimit: 2
      weeklyBackupLimit: 1
      monthlyBackupLimit: 1
      description: TF test backup schedule
      enabled: true
      labels:
        foo: bar
```
<!--End PulumiCodeChooser -->

## Import

BackupPolicy can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/backupPolicies/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

When using the `pulumi import` command, BackupPolicy can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:netapp/backupPolicy:BackupPolicy default projects/{{project}}/locations/{{location}}/backupPolicies/{{name}}
```

```sh
$ pulumi import gcp:netapp/backupPolicy:BackupPolicy default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:netapp/backupPolicy:BackupPolicy default {{location}}/{{name}}
```

h
dailyBackupLimit PNumber of daily backups to keep. Note that the minimum daily backup limit is 2.
?
descriptionB" *An optional description of this resource.
∂
enabledB
 §If enabled, make backups automatically according to the schedules.
This will be applied to all volumes that have this policy attached and enforced on volume level.
√
labelsB2" ∞Labels as key value pairs. Example: `{ "owner": "Bob", "department": "finance", "purpose": "testing" }`.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
?
location" /Name of the region for the policy to apply to.
é
monthlyBackupLimit tNumber of monthly backups to keep. Note that the sum of daily, weekly and monthly backups should be greater than 1.
V
nameB" HThe name of the backup policy. Needs to be unique per location.


- - -
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
å
weeklyBackupLimit sNumber of weekly backups to keep. Note that the sum of daily, weekly and monthly backups should be greater than 1.
"W
assignedVolumeCount <The total number of volumes assigned by this backup policy.
"Ñ

createTime" rCreate time of the backup policy. A timestamp in RFC3339 UTC "Zulu" format. Examples: "2023-06-22T09:13:01.617Z".
"h
dailyBackupLimit PNumber of daily backups to keep. Note that the minimum daily backup limit is 2.
"?
descriptionB" *An optional description of this resource.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"∂
enabledB
 §If enabled, make backups automatically according to the schedules.
This will be applied to all volumes that have this policy attached and enforced on volume level.
"√
labelsB2" ∞Labels as key value pairs. Example: `{ "owner": "Bob", "department": "finance", "purpose": "testing" }`.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"?
location" /Name of the region for the policy to apply to.
"é
monthlyBackupLimit tNumber of monthly backups to keep. Note that the sum of daily, weekly and monthly backups should be greater than 1.
"T
name" HThe name of the backup policy. Needs to be unique per location.


- - -
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"-
state"  The state of the backup policy.
"å
weeklyBackupLimit sNumber of weekly backups to keep. Note that the sum of daily, weekly and monthly backups should be greater than 1.
*î-
9
netappBackupVault"gcp:netapp/backupVault:BackupVaultΩA backup vault is the location where backups are stored. You can only create one backup vault per region.
A vault can hold multiple backups for multiple volumes in that region.


To get more information about BackupVault, see:

* [API documentation](https://cloud.google.com/netapp/volumes/docs/reference/rest/v1/projects.locations.backupVaults)
* How-to Guides
    * [Documentation](https://cloud.google.com/netapp/volumes/docs/protect-data/about-volume-backups)

## Example Usage

### Netapp Backup Vault


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const testBackupVault = new gcp.netapp.BackupVault("test_backup_vault", {
    name: "test-backup-vault",
    location: "us-west1",
    description: "Terraform created vault",
    labels: {
        creator: "testuser",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

test_backup_vault = gcp.netapp.BackupVault("test_backup_vault",
    name="test-backup-vault",
    location="us-west1",
    description="Terraform created vault",
    labels={
        "creator": "testuser",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var testBackupVault = new Gcp.Netapp.BackupVault("test_backup_vault", new()
    {
        Name = "test-backup-vault",
        Location = "us-west1",
        Description = "Terraform created vault",
        Labels = 
        {
            { "creator", "testuser" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/netapp"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := netapp.NewBackupVault(ctx, "test_backup_vault", &netapp.BackupVaultArgs{
			Name:        pulumi.String("test-backup-vault"),
			Location:    pulumi.String("us-west1"),
			Description: pulumi.String("Terraform created vault"),
			Labels: pulumi.StringMap{
				"creator": pulumi.String("testuser"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.netapp.BackupVault;
import com.pulumi.gcp.netapp.BackupVaultArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var testBackupVault = new BackupVault("testBackupVault", BackupVaultArgs.builder()
            .name("test-backup-vault")
            .location("us-west1")
            .description("Terraform created vault")
            .labels(Map.of("creator", "testuser"))
            .build());

    }
}
```
```yaml
resources:
  testBackupVault:
    type: gcp:netapp:BackupVault
    name: test_backup_vault
    properties:
      name: test-backup-vault
      location: us-west1
      description: Terraform created vault
      labels:
        creator: testuser
```
<!--End PulumiCodeChooser -->

## Import

BackupVault can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/backupVaults/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

When using the `pulumi import` command, BackupVault can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:netapp/backupVault:BackupVault default projects/{{project}}/locations/{{location}}/backupVaults/{{name}}
```

```sh
$ pulumi import gcp:netapp/backupVault:BackupVault default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:netapp/backupVault:BackupVault default {{location}}/{{name}}
```

?
descriptionB" *An optional description of this resource.
√
labelsB2" ∞Labels as key value pairs. Example: `{ "owner": "Bob", "department": "finance", "purpose": "testing" }`.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
7
location" 'Location (region) of the backup vault.
^
nameB" PThe resource name of the backup vault. Needs to be unique per location.


- - -
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É

createTime" qCreate time of the backup vault. A timestamp in RFC3339 UTC "Zulu" format. Examples: "2023-06-22T09:13:01.617Z".
"?
descriptionB" *An optional description of this resource.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"√
labelsB2" ∞Labels as key value pairs. Example: `{ "owner": "Bob", "department": "finance", "purpose": "testing" }`.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"7
location" 'Location (region) of the backup vault.
"\
name" PThe resource name of the backup vault. Needs to be unique per location.


- - -
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
",
state" The state of the Backup Vault.
*<
3
netapp	Kmsconfiggcp:netapp/kmsconfig:Kmsconfigœ*NetApp Volumes always encrypts your data at rest using volume-specific keys.

A CMEK policy (customer-managed encryption key) warps such volume-specific keys in a key stored in Cloud Key Management Service (KMS).


To get more information about kmsconfig, see:

* [API documentation](https://cloud.google.com/netapp/volumes/docs/reference/rest/v1/projects.locations.kmsConfigs)
* How-to Guides
    * [Documentation](https://cloud.google.com/netapp/volumes/docs/configure-and-use/cmek/cmek-overview)

## Example Usage

### Kms Config Create


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const keyring = new gcp.kms.KeyRing("keyring", {
    name: "key-ring",
    location: "us-central1",
});
const cryptoKey = new gcp.kms.CryptoKey("crypto_key", {
    name: "crypto-name",
    keyRing: keyring.id,
});
const kmsConfig = new gcp.netapp.Kmsconfig("kmsConfig", {
    name: "kms-test",
    description: "this is a test description",
    cryptoKeyName: cryptoKey.id,
    location: "us-central1",
});
```
```python
import pulumi
import pulumi_gcp as gcp

keyring = gcp.kms.KeyRing("keyring",
    name="key-ring",
    location="us-central1")
crypto_key = gcp.kms.CryptoKey("crypto_key",
    name="crypto-name",
    key_ring=keyring.id)
kms_config = gcp.netapp.Kmsconfig("kmsConfig",
    name="kms-test",
    description="this is a test description",
    crypto_key_name=crypto_key.id,
    location="us-central1")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var keyring = new Gcp.Kms.KeyRing("keyring", new()
    {
        Name = "key-ring",
        Location = "us-central1",
    });

    var cryptoKey = new Gcp.Kms.CryptoKey("crypto_key", new()
    {
        Name = "crypto-name",
        KeyRing = keyring.Id,
    });

    var kmsConfig = new Gcp.Netapp.Kmsconfig("kmsConfig", new()
    {
        Name = "kms-test",
        Description = "this is a test description",
        CryptoKeyName = cryptoKey.Id,
        Location = "us-central1",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/kms"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/netapp"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		keyring, err := kms.NewKeyRing(ctx, "keyring", &kms.KeyRingArgs{
			Name:     pulumi.String("key-ring"),
			Location: pulumi.String("us-central1"),
		})
		if err != nil {
			return err
		}
		cryptoKey, err := kms.NewCryptoKey(ctx, "crypto_key", &kms.CryptoKeyArgs{
			Name:    pulumi.String("crypto-name"),
			KeyRing: keyring.ID(),
		})
		if err != nil {
			return err
		}
		_, err = netapp.NewKmsconfig(ctx, "kmsConfig", &netapp.KmsconfigArgs{
			Name:          pulumi.String("kms-test"),
			Description:   pulumi.String("this is a test description"),
			CryptoKeyName: cryptoKey.ID(),
			Location:      pulumi.String("us-central1"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.kms.KeyRing;
import com.pulumi.gcp.kms.KeyRingArgs;
import com.pulumi.gcp.kms.CryptoKey;
import com.pulumi.gcp.kms.CryptoKeyArgs;
import com.pulumi.gcp.netapp.Kmsconfig;
import com.pulumi.gcp.netapp.KmsconfigArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var keyring = new KeyRing("keyring", KeyRingArgs.builder()
            .name("key-ring")
            .location("us-central1")
            .build());

        var cryptoKey = new CryptoKey("cryptoKey", CryptoKeyArgs.builder()
            .name("crypto-name")
            .keyRing(keyring.id())
            .build());

        var kmsConfig = new Kmsconfig("kmsConfig", KmsconfigArgs.builder()
            .name("kms-test")
            .description("this is a test description")
            .cryptoKeyName(cryptoKey.id())
            .location("us-central1")
            .build());

    }
}
```
```yaml
resources:
  keyring:
    type: gcp:kms:KeyRing
    properties:
      name: key-ring
      location: us-central1
  cryptoKey:
    type: gcp:kms:CryptoKey
    name: crypto_key
    properties:
      name: crypto-name
      keyRing: ${keyring.id}
  kmsConfig:
    type: gcp:netapp:Kmsconfig
    properties:
      name: kms-test
      description: this is a test description
      cryptoKeyName: ${cryptoKey.id}
      location: us-central1
```
<!--End PulumiCodeChooser -->

## Import

kmsconfig can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/kmsConfigs/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

When using the `pulumi import` command, kmsconfig can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:netapp/kmsconfig:Kmsconfig default projects/{{project}}/locations/{{location}}/kmsConfigs/{{name}}
```

```sh
$ pulumi import gcp:netapp/kmsconfig:Kmsconfig default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:netapp/kmsconfig:Kmsconfig default {{location}}/{{name}}
```

Ω
cryptoKeyName" ßResource name of the KMS key to use. Only regional keys are supported. Format: `projects/{{project}}/locations/{{location}}/keyRings/{{key_ring}}/cryptoKeys/{{key}}`.
6
descriptionB" !Description for the CMEK policy.
√
labelsB2" ∞Labels as key value pairs. Example: `{ "owner": "Bob", "department": "finance", "purpose": "testing" }`.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
V
location" FName of the policy location. CMEK policies apply to the whole region.
/
nameB" !Name of the CMEK policy.


- - -
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"Ω
cryptoKeyName" ßResource name of the KMS key to use. Only regional keys are supported. Format: `projects/{{project}}/locations/{{location}}/keyRings/{{key_ring}}/cryptoKeys/{{key}}`.
"6
descriptionB" !Description for the CMEK policy.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"“
instructions" ΩAccess to the key needs to be granted. The instructions contain gcloud commands to run to grant access.
To make the policy work, a CMEK policy check is required, which verifies key access.
"√
labelsB2" ∞Labels as key value pairs. Example: `{ "owner": "Bob", "department": "finance", "purpose": "testing" }`.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"V
location" FName of the policy location. CMEK policies apply to the whole region.
"-
name" !Name of the CMEK policy.


- - -
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"_
serviceAccount" IThe Service account which needs to have access to the  provided KMS key.
*ãè
9
netappStoragePool"gcp:netapp/storagePool:StoragePool‘a## Example Usage

### Storage Pool Create


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

// Create a network or use datasource to reference existing network
const peeringNetwork = new gcp.compute.Network("peering_network", {name: "test-network"});
// Reserve a CIDR for NetApp Volumes to use
// When using shared-VPCs, this resource needs to be created in host project
const privateIpAlloc = new gcp.compute.GlobalAddress("private_ip_alloc", {
    name: "test-address",
    purpose: "VPC_PEERING",
    addressType: "INTERNAL",
    prefixLength: 16,
    network: peeringNetwork.id,
});
// Create a Private Service Access connection
// When using shared-VPCs, this resource needs to be created in host project
const _default = new gcp.servicenetworking.Connection("default", {
    network: peeringNetwork.id,
    service: "netapp.servicenetworking.goog",
    reservedPeeringRanges: [privateIpAlloc.name],
});
// Modify the PSA Connection to allow import/export of custom routes
// When using shared-VPCs, this resource needs to be created in host project
const routeUpdates = new gcp.compute.NetworkPeeringRoutesConfig("route_updates", {
    peering: _default.peering,
    network: peeringNetwork.name,
    importCustomRoutes: true,
    exportCustomRoutes: true,
});
// Create a storage pool
// Create this resource in the project which is expected to own the volumes
const testPool = new gcp.netapp.StoragePool("test_pool", {
    name: "test-pool",
    location: "us-central1",
    serviceLevel: "PREMIUM",
    capacityGib: "2048",
    network: peeringNetwork.id,
});
```
```python
import pulumi
import pulumi_gcp as gcp

# Create a network or use datasource to reference existing network
peering_network = gcp.compute.Network("peering_network", name="test-network")
# Reserve a CIDR for NetApp Volumes to use
# When using shared-VPCs, this resource needs to be created in host project
private_ip_alloc = gcp.compute.GlobalAddress("private_ip_alloc",
    name="test-address",
    purpose="VPC_PEERING",
    address_type="INTERNAL",
    prefix_length=16,
    network=peering_network.id)
# Create a Private Service Access connection
# When using shared-VPCs, this resource needs to be created in host project
default = gcp.servicenetworking.Connection("default",
    network=peering_network.id,
    service="netapp.servicenetworking.goog",
    reserved_peering_ranges=[private_ip_alloc.name])
# Modify the PSA Connection to allow import/export of custom routes
# When using shared-VPCs, this resource needs to be created in host project
route_updates = gcp.compute.NetworkPeeringRoutesConfig("route_updates",
    peering=default.peering,
    network=peering_network.name,
    import_custom_routes=True,
    export_custom_routes=True)
# Create a storage pool
# Create this resource in the project which is expected to own the volumes
test_pool = gcp.netapp.StoragePool("test_pool",
    name="test-pool",
    location="us-central1",
    service_level="PREMIUM",
    capacity_gib="2048",
    network=peering_network.id)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    // Create a network or use datasource to reference existing network
    var peeringNetwork = new Gcp.Compute.Network("peering_network", new()
    {
        Name = "test-network",
    });

    // Reserve a CIDR for NetApp Volumes to use
    // When using shared-VPCs, this resource needs to be created in host project
    var privateIpAlloc = new Gcp.Compute.GlobalAddress("private_ip_alloc", new()
    {
        Name = "test-address",
        Purpose = "VPC_PEERING",
        AddressType = "INTERNAL",
        PrefixLength = 16,
        Network = peeringNetwork.Id,
    });

    // Create a Private Service Access connection
    // When using shared-VPCs, this resource needs to be created in host project
    var @default = new Gcp.ServiceNetworking.Connection("default", new()
    {
        Network = peeringNetwork.Id,
        Service = "netapp.servicenetworking.goog",
        ReservedPeeringRanges = new[]
        {
            privateIpAlloc.Name,
        },
    });

    // Modify the PSA Connection to allow import/export of custom routes
    // When using shared-VPCs, this resource needs to be created in host project
    var routeUpdates = new Gcp.Compute.NetworkPeeringRoutesConfig("route_updates", new()
    {
        Peering = @default.Peering,
        Network = peeringNetwork.Name,
        ImportCustomRoutes = true,
        ExportCustomRoutes = true,
    });

    // Create a storage pool
    // Create this resource in the project which is expected to own the volumes
    var testPool = new Gcp.Netapp.StoragePool("test_pool", new()
    {
        Name = "test-pool",
        Location = "us-central1",
        ServiceLevel = "PREMIUM",
        CapacityGib = "2048",
        Network = peeringNetwork.Id,
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/netapp"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/servicenetworking"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		// Create a network or use datasource to reference existing network
		peeringNetwork, err := compute.NewNetwork(ctx, "peering_network", &compute.NetworkArgs{
			Name: pulumi.String("test-network"),
		})
		if err != nil {
			return err
		}
		// Reserve a CIDR for NetApp Volumes to use
		// When using shared-VPCs, this resource needs to be created in host project
		privateIpAlloc, err := compute.NewGlobalAddress(ctx, "private_ip_alloc", &compute.GlobalAddressArgs{
			Name:         pulumi.String("test-address"),
			Purpose:      pulumi.String("VPC_PEERING"),
			AddressType:  pulumi.String("INTERNAL"),
			PrefixLength: pulumi.Int(16),
			Network:      peeringNetwork.ID(),
		})
		if err != nil {
			return err
		}
		// Create a Private Service Access connection
		// When using shared-VPCs, this resource needs to be created in host project
		_, err = servicenetworking.NewConnection(ctx, "default", &servicenetworking.ConnectionArgs{
			Network: peeringNetwork.ID(),
			Service: pulumi.String("netapp.servicenetworking.goog"),
			ReservedPeeringRanges: pulumi.StringArray{
				privateIpAlloc.Name,
			},
		})
		if err != nil {
			return err
		}
		// Modify the PSA Connection to allow import/export of custom routes
		// When using shared-VPCs, this resource needs to be created in host project
		_, err = compute.NewNetworkPeeringRoutesConfig(ctx, "route_updates", &compute.NetworkPeeringRoutesConfigArgs{
			Peering:            _default.Peering,
			Network:            peeringNetwork.Name,
			ImportCustomRoutes: pulumi.Bool(true),
			ExportCustomRoutes: pulumi.Bool(true),
		})
		if err != nil {
			return err
		}
		// Create a storage pool
		// Create this resource in the project which is expected to own the volumes
		_, err = netapp.NewStoragePool(ctx, "test_pool", &netapp.StoragePoolArgs{
			Name:         pulumi.String("test-pool"),
			Location:     pulumi.String("us-central1"),
			ServiceLevel: pulumi.String("PREMIUM"),
			CapacityGib:  pulumi.String("2048"),
			Network:      peeringNetwork.ID(),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.GlobalAddress;
import com.pulumi.gcp.compute.GlobalAddressArgs;
import com.pulumi.gcp.servicenetworking.Connection;
import com.pulumi.gcp.servicenetworking.ConnectionArgs;
import com.pulumi.gcp.compute.NetworkPeeringRoutesConfig;
import com.pulumi.gcp.compute.NetworkPeeringRoutesConfigArgs;
import com.pulumi.gcp.netapp.StoragePool;
import com.pulumi.gcp.netapp.StoragePoolArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        // Create a network or use datasource to reference existing network
        var peeringNetwork = new Network("peeringNetwork", NetworkArgs.builder()
            .name("test-network")
            .build());

        // Reserve a CIDR for NetApp Volumes to use
        // When using shared-VPCs, this resource needs to be created in host project
        var privateIpAlloc = new GlobalAddress("privateIpAlloc", GlobalAddressArgs.builder()
            .name("test-address")
            .purpose("VPC_PEERING")
            .addressType("INTERNAL")
            .prefixLength(16)
            .network(peeringNetwork.id())
            .build());

        // Create a Private Service Access connection
        // When using shared-VPCs, this resource needs to be created in host project
        var default_ = new Connection("default", ConnectionArgs.builder()
            .network(peeringNetwork.id())
            .service("netapp.servicenetworking.goog")
            .reservedPeeringRanges(privateIpAlloc.name())
            .build());

        // Modify the PSA Connection to allow import/export of custom routes
        // When using shared-VPCs, this resource needs to be created in host project
        var routeUpdates = new NetworkPeeringRoutesConfig("routeUpdates", NetworkPeeringRoutesConfigArgs.builder()
            .peering(default_.peering())
            .network(peeringNetwork.name())
            .importCustomRoutes(true)
            .exportCustomRoutes(true)
            .build());

        // Create a storage pool
        // Create this resource in the project which is expected to own the volumes
        var testPool = new StoragePool("testPool", StoragePoolArgs.builder()
            .name("test-pool")
            .location("us-central1")
            .serviceLevel("PREMIUM")
            .capacityGib("2048")
            .network(peeringNetwork.id())
            .build());

    }
}
```
```yaml
resources:
  # Create a network or use datasource to reference existing network
  peeringNetwork:
    type: gcp:compute:Network
    name: peering_network
    properties:
      name: test-network
  # Reserve a CIDR for NetApp Volumes to use
  # When using shared-VPCs, this resource needs to be created in host project
  privateIpAlloc:
    type: gcp:compute:GlobalAddress
    name: private_ip_alloc
    properties:
      name: test-address
      purpose: VPC_PEERING
      addressType: INTERNAL
      prefixLength: 16
      network: ${peeringNetwork.id}
  # Create a Private Service Access connection
  # When using shared-VPCs, this resource needs to be created in host project
  default:
    type: gcp:servicenetworking:Connection
    properties:
      network: ${peeringNetwork.id}
      service: netapp.servicenetworking.goog
      reservedPeeringRanges:
        - ${privateIpAlloc.name}
  # Modify the PSA Connection to allow import/export of custom routes
  # When using shared-VPCs, this resource needs to be created in host project
  routeUpdates:
    type: gcp:compute:NetworkPeeringRoutesConfig
    name: route_updates
    properties:
      peering: ${default.peering}
      network: ${peeringNetwork.name}
      importCustomRoutes: true
      exportCustomRoutes: true
  # Create a storage pool
  # Create this resource in the project which is expected to own the volumes
  testPool:
    type: gcp:netapp:StoragePool
    name: test_pool
    properties:
      name: test-pool
      location: us-central1
      serviceLevel: PREMIUM
      capacityGib: '2048'
      network: ${peeringNetwork.id}
```
<!--End PulumiCodeChooser -->

## Import

StoragePool can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/storagePools/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

When using the `pulumi import` command, StoragePool can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:netapp/storagePool:StoragePool default projects/{{project}}/locations/{{location}}/storagePools/{{name}}
```

```sh
$ pulumi import gcp:netapp/storagePool:StoragePool default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:netapp/storagePool:StoragePool default {{location}}/{{name}}
```

ﬂ
activeDirectoryB" ≈Specifies the Active Directory policy to be used. Format: `projects/{{project}}/locations/{{location}}/activeDirectories/{{name}}`.
The policy needs to be in the same location as the storage pool.
÷
allowAutoTieringB
 ªOptional. True if the storage pool supports Auto Tiering enabled volumes. Default is false.
Auto-tiering can be enabled after storage pool creation but it can't be disabled once enabled.
:
capacityGib" 'Capacity of the storage pool (in GiB).
?
descriptionB" *An optional description of this resource.
‹
	kmsConfigB" »Specifies the CMEK policy to be used for volume encryption. Format: `projects/{{project}}/locations/{{location}}/kmsConfigs/{{name}}`.
The policy needs to be in the same location as the storage pool.
√
labelsB2" ∞Labels as key value pairs. Example: `{ "owner": "Bob", "department": "finance", "purpose": "testing" }`.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
˜
ldapEnabledB
 ·When enabled, the volumes uses Active Directory as LDAP name service for UID/GID lookups. Required to enable extended group support for NFSv3,
using security identifiers for NFSv4.1 or principal names for kerberized NFSv4.1.
r
location" bName of the location. For zonal Flex pools specify a zone name, in all other cases a region name.
e
nameB" WThe resource name of the storage pool. Needs to be unique per location/region.


- - -
`
network" QVPC network name with format: `projects/{{project}}/global/networks/{{network}}`
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
°
replicaZoneB" ãSpecifies the replica zone for regional Flex pools. `zone` and `replica_zone` values can be swapped to initiate a
[zone switch](https://cloud.google.com/netapp/volumes/docs/configure-and-use/storage-pools/edit-or-delete-storage-pool#switch_active_and_replica_zones).
v
serviceLevel" bService level of the storage pool.
Possible values are: `PREMIUM`, `EXTREME`, `STANDARD`, `FLEX`.
ˆ
zoneB" ÁSpecifies the active zone for regional Flex pools. `zone` and `replica_zone` values can be swapped to initiate a
[zone switch](https://cloud.google.com/netapp/volumes/docs/configure-and-use/storage-pools/edit-or-delete-storage-pool#switch_active_and_replica_zones).
If you want to create a zonal Flex pool, specify a zone name for `location` and omit `zone`.
"ﬂ
activeDirectoryB" ≈Specifies the Active Directory policy to be used. Format: `projects/{{project}}/locations/{{location}}/activeDirectories/{{name}}`.
The policy needs to be in the same location as the storage pool.
"÷
allowAutoTieringB
 ªOptional. True if the storage pool supports Auto Tiering enabled volumes. Default is false.
Auto-tiering can be enabled after storage pool creation but it can't be disabled once enabled.
":
capacityGib" 'Capacity of the storage pool (in GiB).
"?
descriptionB" *An optional description of this resource.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"r
encryptionType" \Reports if volumes in the pool are encrypted using a Google-managed encryption key or CMEK.
"‹
	kmsConfigB" »Specifies the CMEK policy to be used for volume encryption. Format: `projects/{{project}}/locations/{{location}}/kmsConfigs/{{name}}`.
The policy needs to be in the same location as the storage pool.
"√
labelsB2" ∞Labels as key value pairs. Example: `{ "owner": "Bob", "department": "finance", "purpose": "testing" }`.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"˜
ldapEnabledB
 ·When enabled, the volumes uses Active Directory as LDAP name service for UID/GID lookups. Required to enable extended group support for NFSv3,
using security identifiers for NFSv4.1 or principal names for kerberized NFSv4.1.
"r
location" bName of the location. For zonal Flex pools specify a zone name, in all other cases a region name.
"c
name" WThe resource name of the storage pool. Needs to be unique per location/region.


- - -
"`
network" QVPC network name with format: `projects/{{project}}/global/networks/{{network}}`
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"°
replicaZoneB" ãSpecifies the replica zone for regional Flex pools. `zone` and `replica_zone` values can be swapped to initiate a
[zone switch](https://cloud.google.com/netapp/volumes/docs/configure-and-use/storage-pools/edit-or-delete-storage-pool#switch_active_and_replica_zones).
"v
serviceLevel" bService level of the storage pool.
Possible values are: `PREMIUM`, `EXTREME`, `STANDARD`, `FLEX`.
"Q
volumeCapacityGib" 8Size allocated to volumes in the storage pool (in GiB).
"9
volumeCount &Number of volume in the storage pool.
"ˆ
zoneB" ÁSpecifies the active zone for regional Flex pools. `zone` and `replica_zone` values can be swapped to initiate a
[zone switch](https://cloud.google.com/netapp/volumes/docs/configure-and-use/storage-pools/edit-or-delete-storage-pool#switch_active_and_replica_zones).
If you want to create a zonal Flex pool, specify a zone name for `location` and omit `zone`.
*çÜ
*
netappVolumegcp:netapp/volume:Volume˝5A volume is a file system container in a storage pool that stores application, database, and user data.

You can create a volume's capacity using the available capacity in the storage pool and you can define and resize the capacity without disruption to any processes.

Storage pool settings apply to the volumes contained within them automatically.


To get more information about Volume, see:

* [API documentation](https://cloud.google.com/netapp/volumes/docs/reference/rest/v1/projects.locations.volumes)
* How-to Guides
    * [Documentation](https://cloud.google.com/netapp/volumes/docs/configure-and-use/volumes/overview)
    * [Quickstart](https://cloud.google.com/netapp/volumes/docs/get-started/quickstarts/create-volume)

## Example Usage

### Netapp Volume Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const default = gcp.compute.getNetwork({
    name: "test-network",
});
const defaultStoragePool = new gcp.netapp.StoragePool("default", {
    name: "test-pool",
    location: "us-west2",
    serviceLevel: "PREMIUM",
    capacityGib: "2048",
    network: _default.then(_default => _default.id),
});
const testVolume = new gcp.netapp.Volume("test_volume", {
    location: "us-west2",
    name: "test-volume",
    capacityGib: "100",
    shareName: "test-volume",
    storagePool: defaultStoragePool.name,
    protocols: ["NFSV3"],
    deletionPolicy: "DEFAULT",
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.compute.get_network(name="test-network")
default_storage_pool = gcp.netapp.StoragePool("default",
    name="test-pool",
    location="us-west2",
    service_level="PREMIUM",
    capacity_gib="2048",
    network=default.id)
test_volume = gcp.netapp.Volume("test_volume",
    location="us-west2",
    name="test-volume",
    capacity_gib="100",
    share_name="test-volume",
    storage_pool=default_storage_pool.name,
    protocols=["NFSV3"],
    deletion_policy="DEFAULT")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = Gcp.Compute.GetNetwork.Invoke(new()
    {
        Name = "test-network",
    });

    var defaultStoragePool = new Gcp.Netapp.StoragePool("default", new()
    {
        Name = "test-pool",
        Location = "us-west2",
        ServiceLevel = "PREMIUM",
        CapacityGib = "2048",
        Network = @default.Apply(@default => @default.Apply(getNetworkResult => getNetworkResult.Id)),
    });

    var testVolume = new Gcp.Netapp.Volume("test_volume", new()
    {
        Location = "us-west2",
        Name = "test-volume",
        CapacityGib = "100",
        ShareName = "test-volume",
        StoragePool = defaultStoragePool.Name,
        Protocols = new[]
        {
            "NFSV3",
        },
        DeletionPolicy = "DEFAULT",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/netapp"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_default, err := compute.LookupNetwork(ctx, &compute.LookupNetworkArgs{
			Name: "test-network",
		}, nil)
		if err != nil {
			return err
		}
		defaultStoragePool, err := netapp.NewStoragePool(ctx, "default", &netapp.StoragePoolArgs{
			Name:         pulumi.String("test-pool"),
			Location:     pulumi.String("us-west2"),
			ServiceLevel: pulumi.String("PREMIUM"),
			CapacityGib:  pulumi.String("2048"),
			Network:      pulumi.String(_default.Id),
		})
		if err != nil {
			return err
		}
		_, err = netapp.NewVolume(ctx, "test_volume", &netapp.VolumeArgs{
			Location:    pulumi.String("us-west2"),
			Name:        pulumi.String("test-volume"),
			CapacityGib: pulumi.String("100"),
			ShareName:   pulumi.String("test-volume"),
			StoragePool: defaultStoragePool.Name,
			Protocols: pulumi.StringArray{
				pulumi.String("NFSV3"),
			},
			DeletionPolicy: pulumi.String("DEFAULT"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.ComputeFunctions;
import com.pulumi.gcp.compute.inputs.GetNetworkArgs;
import com.pulumi.gcp.netapp.StoragePool;
import com.pulumi.gcp.netapp.StoragePoolArgs;
import com.pulumi.gcp.netapp.Volume;
import com.pulumi.gcp.netapp.VolumeArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var default = ComputeFunctions.getNetwork(GetNetworkArgs.builder()
            .name("test-network")
            .build());

        var defaultStoragePool = new StoragePool("defaultStoragePool", StoragePoolArgs.builder()
            .name("test-pool")
            .location("us-west2")
            .serviceLevel("PREMIUM")
            .capacityGib("2048")
            .network(default_.id())
            .build());

        var testVolume = new Volume("testVolume", VolumeArgs.builder()
            .location("us-west2")
            .name("test-volume")
            .capacityGib("100")
            .shareName("test-volume")
            .storagePool(defaultStoragePool.name())
            .protocols("NFSV3")
            .deletionPolicy("DEFAULT")
            .build());

    }
}
```
```yaml
resources:
  defaultStoragePool:
    type: gcp:netapp:StoragePool
    name: default
    properties:
      name: test-pool
      location: us-west2
      serviceLevel: PREMIUM
      capacityGib: '2048'
      network: ${default.id}
  testVolume:
    type: gcp:netapp:Volume
    name: test_volume
    properties:
      location: us-west2
      name: test-volume
      capacityGib: '100'
      shareName: test-volume
      storagePool: ${defaultStoragePool.name}
      protocols:
        - NFSV3
      deletionPolicy: DEFAULT
variables:
  default:
    fn::invoke:
      function: gcp:compute:getNetwork
      arguments:
        name: test-network
```
<!--End PulumiCodeChooser -->

## Import

Volume can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/volumes/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

When using the `pulumi import` command, Volume can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:netapp/volume:Volume default projects/{{project}}/locations/{{location}}/volumes/{{name}}
```

```sh
$ pulumi import gcp:netapp/volume:Volume default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:netapp/volume:Volume default {{location}}/{{name}}
```

™
backupConfigTBR:P
N
netappVolumeBackupConfig0gcp:netapp/VolumeBackupConfig:VolumeBackupConfigDBackup configuration for the volume.
Structure is documented below.
4
capacityGib" !Capacity of the volume (in GiB).
ò
deletionPolicyB" ˇPolicy to determine if the volume should be deleted forcefully.
Volumes may have nested snapshot resources. Deleting such a volume will fail.
Setting this parameter to FORCE will delete volumes including nested snapshots.
Possible values: DEFAULT, FORCE.
?
descriptionB" *An optional description of this resource.
¬
exportPolicyTBR:P
N
netappVolumeExportPolicy0gcp:netapp/VolumeExportPolicy:VolumeExportPolicy\Export policy of the volume for NFSV3 and/or NFSV4.1 access.
Structure is documented below.
ü
kerberosEnabledB
 ÖFlag indicating if the volume is a kerberos volume or not, export policy rules control kerberos security modes (krb5, krb5i, krb5p).
√
labelsB2" ∞Labels as key value pairs. Example: `{ "owner": "Bob", "department": "finance", "purpose": "testing" }`.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
t
largeCapacityB
 ]Optional. Flag indicating if the volume will be a large capacity volume or a regular volume.
ä
location" zName of the pool location. Usually a region name, expect for some STANDARD service level pools which require a zone name.
‚
multipleEndpointsB
 ∆Optional. Flag indicating if the volume will have an IP address per node for volumes supporting multiple IP endpoints.
Only the volume with largeCapacity will be allowed to have multiple endpoints.
O
nameB" AThe name of the volume. Needs to be unique per location.


- - -
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
‚
	protocols*" ŒThe protocol of the volume. Allowed combinations are `['NFSV3']`, `['NFSV4']`, `['SMB']`, `['NFSV3', 'NFSV4']`, `['SMB', 'NFSV3']` and `['SMB', 'NFSV4']`.
Each value may be one of: `NFSV3`, `NFSV4`, `SMB`.
ﬁ
restoreParameterscBa:_
]
netappVolumeRestoreParameters:gcp:netapp/VolumeRestoreParameters:VolumeRestoreParametersdUsed to create this volume from a snapshot (= cloning) or an backup.
Structure is documented below.
u
restrictedActionsB*" XList of actions that are restricted on this volume.
Each value may be one of: `DELETE`.
ç
securityStyleB" ıSecurity Style of the Volume. Use UNIX to use UNIX or NFSV4 ACLs for file permissions.
Use NTFS to use NTFS ACLs for file permissions. Can only be set for volumes which use SMB together with NFS as protocol.
Possible values are: `NTFS`, `UNIX`.
g
	shareName" VShare name (SMB) or export path (NFS) of the volume. Needs to be unique per location.
É
smbSettingsB*" ÎSettings for volumes with SMB access.
Each value may be one of: `ENCRYPT_DATA`, `BROWSABLE`, `CHANGE_NOTIFY`, `NON_BROWSABLE`, `OPLOCKS`, `SHOW_SNAPSHOT`, `SHOW_PREVIOUS_VERSIONS`, `ACCESS_BASED_ENUMERATION`, `CONTINUOUSLY_AVAILABLE`.
Ã
snapshotDirectoryB
 ∞If enabled, a NFS volume will contain a read-only .snapshot directory which provides access to each of the volume's snapshots. Will enable "Previous Versions" support for SMB.
Ø
snapshotPolicyZBX:V
T
netappVolumeSnapshotPolicy4gcp:netapp/VolumeSnapshotPolicy:VolumeSnapshotPolicy¿Snapshot policy defines the schedule for automatic snapshot creation.
To disable automatic snapshot creation you have to remove the whole snapshot_policy block.
Structure is documented below.
Å
storagePool" nName of the storage pool to create the volume in. Pool needs enough spare capacity to accommodate the volume.
®
tieringPolicyWBU:S
Q
netappVolumeTieringPolicy2gcp:netapp/VolumeTieringPolicy:VolumeTieringPolicy>Tiering policy for the volume.
Structure is documented below.
ë
unixPermissionsB" xUnix permission the mount point will be created with. Default is 0770. Applicable for UNIX security style volumes only.
"y
activeDirectory" bReports the resource name of the Active Directory policy being used. Inherited from storage pool.
"™
backupConfigTBR:P
N
netappVolumeBackupConfig0gcp:netapp/VolumeBackupConfig:VolumeBackupConfigDBackup configuration for the volume.
Structure is documented below.
"4
capacityGib" !Capacity of the volume (in GiB).
"N
coldTierSizeGib" 7Output only. Size of the volume cold tier data in GiB.
"}

createTime" kCreate time of the volume. A timestamp in RFC3339 UTC "Zulu" format. Examples: "2023-06-22T09:13:01.617Z".
"ò
deletionPolicyB" ˇPolicy to determine if the volume should be deleted forcefully.
Volumes may have nested snapshot resources. Deleting such a volume will fail.
Setting this parameter to FORCE will delete volumes including nested snapshots.
Possible values: DEFAULT, FORCE.
"?
descriptionB" *An optional description of this resource.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"k
encryptionType" UReports the data-at-rest encryption type of the volume. Inherited from storage pool.
"¬
exportPolicyTBR:P
N
netappVolumeExportPolicy0gcp:netapp/VolumeExportPolicy:VolumeExportPolicy\Export policy of the volume for NFSV3 and/or NFSV4.1 access.
Structure is documented below.
"a
hasReplication
 KIndicates whether the volume is part of a volume replication relationship.
"ü
kerberosEnabledB
 ÖFlag indicating if the volume is a kerberos volume or not, export policy rules control kerberos security modes (krb5, krb5i, krb5p).
"u
	kmsConfig" dReports the CMEK policy resurce name being used for volume encryption. Inherited from storage pool.
"√
labelsB2" ∞Labels as key value pairs. Example: `{ "owner": "Bob", "department": "finance", "purpose": "testing" }`.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"t
largeCapacityB
 ]Optional. Flag indicating if the volume will be a large capacity volume or a regular volume.
"j
ldapEnabled
 WFlag indicating if the volume is NFS LDAP enabled or not. Inherited from storage pool.
"ä
location" zName of the pool location. Usually a region name, expect for some STANDARD service level pools which require a zone name.
"Æ
mountOptionsQ*O:M
K
netappVolumeMountOption.gcp:netapp/VolumeMountOption:VolumeMountOptionKReports mount instructions for this volume.
Structure is documented below.
"‚
multipleEndpointsB
 ∆Optional. Flag indicating if the volume will have an IP address per node for volumes supporting multiple IP endpoints.
Only the volume with largeCapacity will be allowed to have multiple endpoints.
"M
name" AThe name of the volume. Needs to be unique per location.


- - -
"~
network" oVPC network name with format: `projects/{{project}}/global/networks/{{network}}`. Inherited from storage pool.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"‚
	protocols*" ŒThe protocol of the volume. Allowed combinations are `['NFSV3']`, `['NFSV4']`, `['SMB']`, `['NFSV3', 'NFSV4']`, `['SMB', 'NFSV3']` and `['SMB', 'NFSV4']`.
Each value may be one of: `NFSV3`, `NFSV4`, `SMB`.
"a
psaRange" QName of the Private Service Access allocated range. Inherited from storage pool.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"C
replicaZone" 0Specifies the replica zone for regional volume.
"ﬁ
restoreParameterscBa:_
]
netappVolumeRestoreParameters:gcp:netapp/VolumeRestoreParameters:VolumeRestoreParametersdUsed to create this volume from a snapshot (= cloning) or an backup.
Structure is documented below.
"u
restrictedActionsB*" XList of actions that are restricted on this volume.
Each value may be one of: `DELETE`.
"ã
securityStyle" ıSecurity Style of the Volume. Use UNIX to use UNIX or NFSV4 ACLs for file permissions.
Use NTFS to use NTFS ACLs for file permissions. Can only be set for volumes which use SMB together with NFS as protocol.
Possible values are: `NTFS`, `UNIX`.
"á
serviceLevel" sService level of the volume. Inherited from storage pool. Supported values are : PREMIUM, EXTREME, STANDARD, FLEX.
"g
	shareName" VShare name (SMB) or export path (NFS) of the volume. Needs to be unique per location.
"Å
smbSettings*" ÎSettings for volumes with SMB access.
Each value may be one of: `ENCRYPT_DATA`, `BROWSABLE`, `CHANGE_NOTIFY`, `NON_BROWSABLE`, `OPLOCKS`, `SHOW_SNAPSHOT`, `SHOW_PREVIOUS_VERSIONS`, `ACCESS_BASED_ENUMERATION`, `CONTINUOUSLY_AVAILABLE`.
"Ã
snapshotDirectoryB
 ∞If enabled, a NFS volume will contain a read-only .snapshot directory which provides access to each of the volume's snapshots. Will enable "Previous Versions" support for SMB.
"Ø
snapshotPolicyZBX:V
T
netappVolumeSnapshotPolicy4gcp:netapp/VolumeSnapshotPolicy:VolumeSnapshotPolicy¿Snapshot policy defines the schedule for automatic snapshot creation.
To disable automatic snapshot creation you have to remove the whole snapshot_policy block.
Structure is documented below.
""
state" State of the volume.
"1
stateDetails" State details of the volume.
"Å
storagePool" nName of the storage pool to create the volume in. Pool needs enough spare capacity to accommodate the volume.
"®
tieringPolicyWBU:S
Q
netappVolumeTieringPolicy2gcp:netapp/VolumeTieringPolicy:VolumeTieringPolicy>Tiering policy for the volume.
Structure is documented below.
"è
unixPermissions" xUnix permission the mount point will be created with. Default is 0770. Applicable for UNIX security style volumes only.
"Å
usedGib" rUsed capacity of the volume (in GiB). This is computed periodically and it does not represent the realtime usage.
";
zone" /Specifies the active zone for regional volume.
*‘ì
K
netappVolumeReplication.gcp:netapp/volumeReplication:VolumeReplicationñc## Example Usage

### Netapp Volume Replication Create


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const default = gcp.compute.getNetwork({
    name: "test-network",
});
const sourcePool = new gcp.netapp.StoragePool("source_pool", {
    name: "source-pool",
    location: "us-central1",
    serviceLevel: "PREMIUM",
    capacityGib: "2048",
    network: _default.then(_default => _default.id),
});
const destinationPool = new gcp.netapp.StoragePool("destination_pool", {
    name: "destination-pool",
    location: "us-west2",
    serviceLevel: "PREMIUM",
    capacityGib: "2048",
    network: _default.then(_default => _default.id),
});
const sourceVolume = new gcp.netapp.Volume("source_volume", {
    location: sourcePool.location,
    name: "source-volume",
    capacityGib: "100",
    shareName: "source-volume",
    storagePool: sourcePool.name,
    protocols: ["NFSV3"],
    deletionPolicy: "FORCE",
});
const testReplication = new gcp.netapp.VolumeReplication("test_replication", {
    location: sourceVolume.location,
    volumeName: sourceVolume.name,
    name: "test-replication",
    replicationSchedule: "EVERY_10_MINUTES",
    description: "This is a replication resource",
    destinationVolumeParameters: {
        storagePool: destinationPool.id,
        volumeId: "destination-volume",
        shareName: "source-volume",
        description: "This is a replicated volume",
    },
    deleteDestinationVolume: true,
    waitForMirror: true,
}, {
    dependsOn: [sourceVolume],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.compute.get_network(name="test-network")
source_pool = gcp.netapp.StoragePool("source_pool",
    name="source-pool",
    location="us-central1",
    service_level="PREMIUM",
    capacity_gib="2048",
    network=default.id)
destination_pool = gcp.netapp.StoragePool("destination_pool",
    name="destination-pool",
    location="us-west2",
    service_level="PREMIUM",
    capacity_gib="2048",
    network=default.id)
source_volume = gcp.netapp.Volume("source_volume",
    location=source_pool.location,
    name="source-volume",
    capacity_gib="100",
    share_name="source-volume",
    storage_pool=source_pool.name,
    protocols=["NFSV3"],
    deletion_policy="FORCE")
test_replication = gcp.netapp.VolumeReplication("test_replication",
    location=source_volume.location,
    volume_name=source_volume.name,
    name="test-replication",
    replication_schedule="EVERY_10_MINUTES",
    description="This is a replication resource",
    destination_volume_parameters={
        "storage_pool": destination_pool.id,
        "volume_id": "destination-volume",
        "share_name": "source-volume",
        "description": "This is a replicated volume",
    },
    delete_destination_volume=True,
    wait_for_mirror=True,
    opts = pulumi.ResourceOptions(depends_on=[source_volume]))
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = Gcp.Compute.GetNetwork.Invoke(new()
    {
        Name = "test-network",
    });

    var sourcePool = new Gcp.Netapp.StoragePool("source_pool", new()
    {
        Name = "source-pool",
        Location = "us-central1",
        ServiceLevel = "PREMIUM",
        CapacityGib = "2048",
        Network = @default.Apply(@default => @default.Apply(getNetworkResult => getNetworkResult.Id)),
    });

    var destinationPool = new Gcp.Netapp.StoragePool("destination_pool", new()
    {
        Name = "destination-pool",
        Location = "us-west2",
        ServiceLevel = "PREMIUM",
        CapacityGib = "2048",
        Network = @default.Apply(@default => @default.Apply(getNetworkResult => getNetworkResult.Id)),
    });

    var sourceVolume = new Gcp.Netapp.Volume("source_volume", new()
    {
        Location = sourcePool.Location,
        Name = "source-volume",
        CapacityGib = "100",
        ShareName = "source-volume",
        StoragePool = sourcePool.Name,
        Protocols = new[]
        {
            "NFSV3",
        },
        DeletionPolicy = "FORCE",
    });

    var testReplication = new Gcp.Netapp.VolumeReplication("test_replication", new()
    {
        Location = sourceVolume.Location,
        VolumeName = sourceVolume.Name,
        Name = "test-replication",
        ReplicationSchedule = "EVERY_10_MINUTES",
        Description = "This is a replication resource",
        DestinationVolumeParameters = new Gcp.Netapp.Inputs.VolumeReplicationDestinationVolumeParametersArgs
        {
            StoragePool = destinationPool.Id,
            VolumeId = "destination-volume",
            ShareName = "source-volume",
            Description = "This is a replicated volume",
        },
        DeleteDestinationVolume = true,
        WaitForMirror = true,
    }, new CustomResourceOptions
    {
        DependsOn =
        {
            sourceVolume,
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/netapp"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_default, err := compute.LookupNetwork(ctx, &compute.LookupNetworkArgs{
			Name: "test-network",
		}, nil)
		if err != nil {
			return err
		}
		sourcePool, err := netapp.NewStoragePool(ctx, "source_pool", &netapp.StoragePoolArgs{
			Name:         pulumi.String("source-pool"),
			Location:     pulumi.String("us-central1"),
			ServiceLevel: pulumi.String("PREMIUM"),
			CapacityGib:  pulumi.String("2048"),
			Network:      pulumi.String(_default.Id),
		})
		if err != nil {
			return err
		}
		destinationPool, err := netapp.NewStoragePool(ctx, "destination_pool", &netapp.StoragePoolArgs{
			Name:         pulumi.String("destination-pool"),
			Location:     pulumi.String("us-west2"),
			ServiceLevel: pulumi.String("PREMIUM"),
			CapacityGib:  pulumi.String("2048"),
			Network:      pulumi.String(_default.Id),
		})
		if err != nil {
			return err
		}
		sourceVolume, err := netapp.NewVolume(ctx, "source_volume", &netapp.VolumeArgs{
			Location:    sourcePool.Location,
			Name:        pulumi.String("source-volume"),
			CapacityGib: pulumi.String("100"),
			ShareName:   pulumi.String("source-volume"),
			StoragePool: sourcePool.Name,
			Protocols: pulumi.StringArray{
				pulumi.String("NFSV3"),
			},
			DeletionPolicy: pulumi.String("FORCE"),
		})
		if err != nil {
			return err
		}
		_, err = netapp.NewVolumeReplication(ctx, "test_replication", &netapp.VolumeReplicationArgs{
			Location:            sourceVolume.Location,
			VolumeName:          sourceVolume.Name,
			Name:                pulumi.String("test-replication"),
			ReplicationSchedule: pulumi.String("EVERY_10_MINUTES"),
			Description:         pulumi.String("This is a replication resource"),
			DestinationVolumeParameters: &netapp.VolumeReplicationDestinationVolumeParametersArgs{
				StoragePool: destinationPool.ID(),
				VolumeId:    pulumi.String("destination-volume"),
				ShareName:   pulumi.String("source-volume"),
				Description: pulumi.String("This is a replicated volume"),
			},
			DeleteDestinationVolume: pulumi.Bool(true),
			WaitForMirror:           pulumi.Bool(true),
		}, pulumi.DependsOn([]pulumi.Resource{
			sourceVolume,
		}))
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.ComputeFunctions;
import com.pulumi.gcp.compute.inputs.GetNetworkArgs;
import com.pulumi.gcp.netapp.StoragePool;
import com.pulumi.gcp.netapp.StoragePoolArgs;
import com.pulumi.gcp.netapp.Volume;
import com.pulumi.gcp.netapp.VolumeArgs;
import com.pulumi.gcp.netapp.VolumeReplication;
import com.pulumi.gcp.netapp.VolumeReplicationArgs;
import com.pulumi.gcp.netapp.inputs.VolumeReplicationDestinationVolumeParametersArgs;
import com.pulumi.resources.CustomResourceOptions;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var default = ComputeFunctions.getNetwork(GetNetworkArgs.builder()
            .name("test-network")
            .build());

        var sourcePool = new StoragePool("sourcePool", StoragePoolArgs.builder()
            .name("source-pool")
            .location("us-central1")
            .serviceLevel("PREMIUM")
            .capacityGib(2048)
            .network(default_.id())
            .build());

        var destinationPool = new StoragePool("destinationPool", StoragePoolArgs.builder()
            .name("destination-pool")
            .location("us-west2")
            .serviceLevel("PREMIUM")
            .capacityGib(2048)
            .network(default_.id())
            .build());

        var sourceVolume = new Volume("sourceVolume", VolumeArgs.builder()
            .location(sourcePool.location())
            .name("source-volume")
            .capacityGib(100)
            .shareName("source-volume")
            .storagePool(sourcePool.name())
            .protocols("NFSV3")
            .deletionPolicy("FORCE")
            .build());

        var testReplication = new VolumeReplication("testReplication", VolumeReplicationArgs.builder()
            .location(sourceVolume.location())
            .volumeName(sourceVolume.name())
            .name("test-replication")
            .replicationSchedule("EVERY_10_MINUTES")
            .description("This is a replication resource")
            .destinationVolumeParameters(VolumeReplicationDestinationVolumeParametersArgs.builder()
                .storagePool(destinationPool.id())
                .volumeId("destination-volume")
                .shareName("source-volume")
                .description("This is a replicated volume")
                .build())
            .deleteDestinationVolume(true)
            .waitForMirror(true)
            .build(), CustomResourceOptions.builder()
                .dependsOn(sourceVolume)
                .build());

    }
}
```
```yaml
resources:
  sourcePool:
    type: gcp:netapp:StoragePool
    name: source_pool
    properties:
      name: source-pool
      location: us-central1
      serviceLevel: PREMIUM
      capacityGib: 2048
      network: ${default.id}
  destinationPool:
    type: gcp:netapp:StoragePool
    name: destination_pool
    properties:
      name: destination-pool
      location: us-west2
      serviceLevel: PREMIUM
      capacityGib: 2048
      network: ${default.id}
  sourceVolume:
    type: gcp:netapp:Volume
    name: source_volume
    properties:
      location: ${sourcePool.location}
      name: source-volume
      capacityGib: 100
      shareName: source-volume
      storagePool: ${sourcePool.name}
      protocols:
        - NFSV3
      deletionPolicy: FORCE
  testReplication:
    type: gcp:netapp:VolumeReplication
    name: test_replication
    properties:
      location: ${sourceVolume.location}
      volumeName: ${sourceVolume.name}
      name: test-replication
      replicationSchedule: EVERY_10_MINUTES
      description: This is a replication resource
      destinationVolumeParameters:
        storagePool: ${destinationPool.id}
        volumeId: destination-volume
        shareName: source-volume
        description: This is a replicated volume
      deleteDestinationVolume: true
      waitForMirror: true
    options:
      dependsOn:
        - ${sourceVolume}
variables:
  default:
    fn::invoke:
      function: gcp:compute:getNetwork
      arguments:
        name: test-network
```
<!--End PulumiCodeChooser -->

## Import

VolumeReplication can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/volumes/{{volume_name}}/replications/{{name}}`

* `{{project}}/{{location}}/{{volume_name}}/{{name}}`

* `{{location}}/{{volume_name}}/{{name}}`

When using the `pulumi import` command, VolumeReplication can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:netapp/volumeReplication:VolumeReplication default projects/{{project}}/locations/{{location}}/volumes/{{volume_name}}/replications/{{name}}
```

```sh
$ pulumi import gcp:netapp/volumeReplication:VolumeReplication default {{project}}/{{location}}/{{volume_name}}/{{name}}
```

```sh
$ pulumi import gcp:netapp/volumeReplication:VolumeReplication default {{location}}/{{volume_name}}/{{name}}
```


deleteDestinationVolumeB
 6
descriptionB" !An description of this resource.
Ö
destinationVolumeParameters•B¢:ü
ú
netapp,VolumeReplicationDestinationVolumeParametersdgcp:netapp/VolumeReplicationDestinationVolumeParameters:VolumeReplicationDestinationVolumeParameters>Destination volume parameters.
Structure is documented below.
ú
forceStoppingB
 ÑOnly replications with mirror_state=MIRRORED can be stopped. A replication in mirror_state=TRANSFERRING
currently receives an update and stopping the update might be undesirable. Set this parameter to true
to stop anyway. All data transferred to the destination will be discarded and content of destination
volume will remain at the state of the last successful update. Default is false.
¬
labelsB2" ØLabels as key value pairs. Example: `{ "owner": "Bob", "department": "finance", "purpose": "testing" }`

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
|
location" lName of region for this resource. The resource needs to be created in the region of the destination volume.
T
nameB" FThe name of the replication. Needs to be unique per location.


- - -
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
œ
replicationEnabledB
 ≤Set to false to stop/break the mirror. Stopping the mirror makes the destination volume read-write
and act independently from the source volume.
Set to true to enable/resume the mirror. WARNING: Resuming a mirror overwrites any changes
done to the destination volume with the content of the source volume.
{
replicationSchedule" `Specifies the replication interval.
Possible values are: `EVERY_10_MINUTES`, `HOURLY`, `DAILY`.
:

volumeName" (The name of the existing source volume.

waitForMirrorB
 "á

createTime" uCreate time of the active directory. A timestamp in RFC3339 UTC "Zulu" format. Examples: "2023-06-22T09:13:01.617Z".
"
deleteDestinationVolumeB
 "6
descriptionB" !An description of this resource.
"í
destinationVolume" yFull resource name of destination volume with format: `projects/{{project}}/locations/{{location}}/volumes/{{volumeId}}`
"Ö
destinationVolumeParameters•B¢:ü
ú
netapp,VolumeReplicationDestinationVolumeParametersdgcp:netapp/VolumeReplicationDestinationVolumeParameters:VolumeReplicationDestinationVolumeParameters>Destination volume parameters.
Structure is documented below.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"ú
forceStoppingB
 ÑOnly replications with mirror_state=MIRRORED can be stopped. A replication in mirror_state=TRANSFERRING
currently receives an update and stopping the update might be undesirable. Set this parameter to true
to stop anyway. All data transferred to the destination will be discarded and content of destination
volume will remain at the state of the last successful update. Default is false.
"õ
healthy
 ãCondition of the relationship. Can be one of the following:
- true: The replication relationship is healthy. It has not missed the most recent scheduled transfer.
- false: The replication relationship is not healthy. It has missed the most recent scheduled transfer.
"¬
labelsB2" ØLabels as key value pairs. Example: `{ "owner": "Bob", "department": "finance", "purpose": "testing" }`

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"|
location" lName of region for this resource. The resource needs to be created in the region of the destination volume.
"ã
mirrorState" ˜Indicates the state of the mirror between source and destination volumes. Depending on the amount of data
in your source volume, PREPARING phase can take hours or days. mirrorState = MIRRORED indicates your baseline
transfer ended and destination volume became accessible read-only. TRANSFERRING means a MIRRORED volume
currently receives an update. Updated every 5 minutes.
"R
name" FThe name of the replication. Needs to be unique per location.


- - -
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"œ
replicationEnabledB
 ≤Set to false to stop/break the mirror. Stopping the mirror makes the destination volume read-write
and act independently from the source volume.
Set to true to enable/resume the mirror. WARNING: Resuming a mirror overwrites any changes
done to the destination volume with the content of the source volume.
"{
replicationSchedule" `Specifies the replication interval.
Possible values are: `EVERY_10_MINUTES`, `HOURLY`, `DAILY`.
"Œ
role" ¡Reverting a replication can swap source and destination volume roles. This field indicates if the `location` hosts
the source or destination volume. For resume and revert and resume operations it is critical to understand
which volume is the source volume, since it will overwrite changes done to the destination volume.
"à
sourceVolume" tFull resource name of source volume with format: `projects/{{project}}/locations/{{location}}/volumes/{{volumeId}}`
"r
state" eIndicates the state of replication resource. State of the mirror itself is indicated in mirrorState.
"?
stateDetails" +State details of the replication resource.
"Ù
transferStatsu*s:q
o
netappVolumeReplicationTransferStatFgcp:netapp/VolumeReplicationTransferStat:VolumeReplicationTransferStatlReplication transfer statistics. All statistics are updated every 5 minutes.
Structure is documented below.
":

volumeName" (The name of the existing source volume.
"
waitForMirrorB
 *©T
B
netappVolumeSnapshot(gcp:netapp/volumeSnapshot:VolumeSnapshotúENetApp Volumes helps you manage your data usage with snapshots that can quickly restore lost data.
Snapshots are point-in-time versions of your volume's content. They are resources of volumes and are
instant captures of your data that consume space only for modified data. Because data changes over
time, snapshots usually consume more space as they get older.
NetApp Volumes volumes use just-in-time copy-on-write so that unmodified files in snapshots don't
consume any of the volume's capacity.


To get more information about VolumeSnapshot, see:

* [API documentation](https://cloud.google.com/netapp/volumes/docs/reference/rest/v1/projects.locations.volumes.snapshots)
* How-to Guides
    * [Documentation](https://cloud.google.com/netapp/volumes/docs/configure-and-use/volume-snapshots/overview)

## Example Usage

### Volume Snapshot Create


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const default = gcp.compute.getNetwork({
    name: "test-network",
});
const defaultStoragePool = new gcp.netapp.StoragePool("default", {
    name: "test-pool",
    location: "us-west2",
    serviceLevel: "PREMIUM",
    capacityGib: "2048",
    network: _default.then(_default => _default.id),
});
const defaultVolume = new gcp.netapp.Volume("default", {
    location: defaultStoragePool.location,
    name: "test-volume",
    capacityGib: "100",
    shareName: "test-volume",
    storagePool: defaultStoragePool.name,
    protocols: ["NFSV3"],
});
const testSnapshot = new gcp.netapp.VolumeSnapshot("test_snapshot", {
    location: defaultVolume.location,
    volumeName: defaultVolume.name,
    name: "testvolumesnap",
}, {
    dependsOn: [defaultVolume],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.compute.get_network(name="test-network")
default_storage_pool = gcp.netapp.StoragePool("default",
    name="test-pool",
    location="us-west2",
    service_level="PREMIUM",
    capacity_gib="2048",
    network=default.id)
default_volume = gcp.netapp.Volume("default",
    location=default_storage_pool.location,
    name="test-volume",
    capacity_gib="100",
    share_name="test-volume",
    storage_pool=default_storage_pool.name,
    protocols=["NFSV3"])
test_snapshot = gcp.netapp.VolumeSnapshot("test_snapshot",
    location=default_volume.location,
    volume_name=default_volume.name,
    name="testvolumesnap",
    opts = pulumi.ResourceOptions(depends_on=[default_volume]))
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = Gcp.Compute.GetNetwork.Invoke(new()
    {
        Name = "test-network",
    });

    var defaultStoragePool = new Gcp.Netapp.StoragePool("default", new()
    {
        Name = "test-pool",
        Location = "us-west2",
        ServiceLevel = "PREMIUM",
        CapacityGib = "2048",
        Network = @default.Apply(@default => @default.Apply(getNetworkResult => getNetworkResult.Id)),
    });

    var defaultVolume = new Gcp.Netapp.Volume("default", new()
    {
        Location = defaultStoragePool.Location,
        Name = "test-volume",
        CapacityGib = "100",
        ShareName = "test-volume",
        StoragePool = defaultStoragePool.Name,
        Protocols = new[]
        {
            "NFSV3",
        },
    });

    var testSnapshot = new Gcp.Netapp.VolumeSnapshot("test_snapshot", new()
    {
        Location = defaultVolume.Location,
        VolumeName = defaultVolume.Name,
        Name = "testvolumesnap",
    }, new CustomResourceOptions
    {
        DependsOn =
        {
            defaultVolume,
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/netapp"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_default, err := compute.LookupNetwork(ctx, &compute.LookupNetworkArgs{
			Name: "test-network",
		}, nil)
		if err != nil {
			return err
		}
		defaultStoragePool, err := netapp.NewStoragePool(ctx, "default", &netapp.StoragePoolArgs{
			Name:         pulumi.String("test-pool"),
			Location:     pulumi.String("us-west2"),
			ServiceLevel: pulumi.String("PREMIUM"),
			CapacityGib:  pulumi.String("2048"),
			Network:      pulumi.String(_default.Id),
		})
		if err != nil {
			return err
		}
		defaultVolume, err := netapp.NewVolume(ctx, "default", &netapp.VolumeArgs{
			Location:    defaultStoragePool.Location,
			Name:        pulumi.String("test-volume"),
			CapacityGib: pulumi.String("100"),
			ShareName:   pulumi.String("test-volume"),
			StoragePool: defaultStoragePool.Name,
			Protocols: pulumi.StringArray{
				pulumi.String("NFSV3"),
			},
		})
		if err != nil {
			return err
		}
		_, err = netapp.NewVolumeSnapshot(ctx, "test_snapshot", &netapp.VolumeSnapshotArgs{
			Location:   defaultVolume.Location,
			VolumeName: defaultVolume.Name,
			Name:       pulumi.String("testvolumesnap"),
		}, pulumi.DependsOn([]pulumi.Resource{
			defaultVolume,
		}))
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.ComputeFunctions;
import com.pulumi.gcp.compute.inputs.GetNetworkArgs;
import com.pulumi.gcp.netapp.StoragePool;
import com.pulumi.gcp.netapp.StoragePoolArgs;
import com.pulumi.gcp.netapp.Volume;
import com.pulumi.gcp.netapp.VolumeArgs;
import com.pulumi.gcp.netapp.VolumeSnapshot;
import com.pulumi.gcp.netapp.VolumeSnapshotArgs;
import com.pulumi.resources.CustomResourceOptions;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var default = ComputeFunctions.getNetwork(GetNetworkArgs.builder()
            .name("test-network")
            .build());

        var defaultStoragePool = new StoragePool("defaultStoragePool", StoragePoolArgs.builder()
            .name("test-pool")
            .location("us-west2")
            .serviceLevel("PREMIUM")
            .capacityGib(2048)
            .network(default_.id())
            .build());

        var defaultVolume = new Volume("defaultVolume", VolumeArgs.builder()
            .location(defaultStoragePool.location())
            .name("test-volume")
            .capacityGib(100)
            .shareName("test-volume")
            .storagePool(defaultStoragePool.name())
            .protocols("NFSV3")
            .build());

        var testSnapshot = new VolumeSnapshot("testSnapshot", VolumeSnapshotArgs.builder()
            .location(defaultVolume.location())
            .volumeName(defaultVolume.name())
            .name("testvolumesnap")
            .build(), CustomResourceOptions.builder()
                .dependsOn(defaultVolume)
                .build());

    }
}
```
```yaml
resources:
  defaultStoragePool:
    type: gcp:netapp:StoragePool
    name: default
    properties:
      name: test-pool
      location: us-west2
      serviceLevel: PREMIUM
      capacityGib: 2048
      network: ${default.id}
  defaultVolume:
    type: gcp:netapp:Volume
    name: default
    properties:
      location: ${defaultStoragePool.location}
      name: test-volume
      capacityGib: 100
      shareName: test-volume
      storagePool: ${defaultStoragePool.name}
      protocols:
        - NFSV3
  testSnapshot:
    type: gcp:netapp:VolumeSnapshot
    name: test_snapshot
    properties:
      location: ${defaultVolume.location}
      volumeName: ${defaultVolume.name}
      name: testvolumesnap
    options:
      dependsOn:
        - ${defaultVolume}
variables:
  default:
    fn::invoke:
      function: gcp:compute:getNetwork
      arguments:
        name: test-network
```
<!--End PulumiCodeChooser -->

## Import

VolumeSnapshot can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/volumes/{{volume_name}}/snapshots/{{name}}`

* `{{project}}/{{location}}/{{volume_name}}/{{name}}`

* `{{location}}/{{volume_name}}/{{name}}`

When using the `pulumi import` command, VolumeSnapshot can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:netapp/volumeSnapshot:VolumeSnapshot default projects/{{project}}/locations/{{location}}/volumes/{{volume_name}}/snapshots/{{name}}
```

```sh
$ pulumi import gcp:netapp/volumeSnapshot:VolumeSnapshot default {{project}}/{{location}}/{{volume_name}}/{{name}}
```

```sh
$ pulumi import gcp:netapp/volumeSnapshot:VolumeSnapshot default {{location}}/{{volume_name}}/{{name}}
```

3
descriptionB" Description for the snapshot.
√
labelsB2" ∞Labels as key value pairs. Example: `{ "owner": "Bob", "department": "finance", "purpose": "testing" }`.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
w
location" gName of the snapshot location. Snapshots are child resources of volumes and live in the same location.
0
nameB" "The name of the snapshot.


- - -
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
D

volumeName" 2The name of the volume to create the snapshot in.
"3
descriptionB" Description for the snapshot.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"√
labelsB2" ∞Labels as key value pairs. Example: `{ "owner": "Bob", "department": "finance", "purpose": "testing" }`.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"w
location" gName of the snapshot location. Snapshots are child resources of volumes and live in the same location.
".
name" "The name of the snapshot.


- - -
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"G
	usedBytes 6Storage used to store blocks unique to this snapshot.
"D

volumeName" 2The name of the volume to create the snapshot in.
*⁄G
A
networkconnectivityGroup#gcp:networkconnectivity/group:Groupå/The NetworkConnectivity Group resource


To get more information about Group, see:

* [API documentation](https://cloud.google.com/network-connectivity/docs/reference/networkconnectivity/rest/v1beta/projects.locations.global.hubs.groups)
* How-to Guides
    * [Official Documentation](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/overview)

## Example Usage

### Network Connectivity Group Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const basicHub = new gcp.networkconnectivity.Hub("basic_hub", {
    name: "network-connectivity-hub1",
    description: "A sample hub",
    labels: {
        "label-one": "value-one",
    },
});
const primary = new gcp.networkconnectivity.Group("primary", {
    hub: basicHub.id,
    name: "default",
    labels: {
        "label-one": "value-one",
    },
    description: "A sample hub group",
    autoAccept: {
        autoAcceptProjects: [
            "foo",
            "bar",
        ],
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

basic_hub = gcp.networkconnectivity.Hub("basic_hub",
    name="network-connectivity-hub1",
    description="A sample hub",
    labels={
        "label-one": "value-one",
    })
primary = gcp.networkconnectivity.Group("primary",
    hub=basic_hub.id,
    name="default",
    labels={
        "label-one": "value-one",
    },
    description="A sample hub group",
    auto_accept={
        "auto_accept_projects": [
            "foo",
            "bar",
        ],
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var basicHub = new Gcp.NetworkConnectivity.Hub("basic_hub", new()
    {
        Name = "network-connectivity-hub1",
        Description = "A sample hub",
        Labels = 
        {
            { "label-one", "value-one" },
        },
    });

    var primary = new Gcp.NetworkConnectivity.Group("primary", new()
    {
        Hub = basicHub.Id,
        Name = "default",
        Labels = 
        {
            { "label-one", "value-one" },
        },
        Description = "A sample hub group",
        AutoAccept = new Gcp.NetworkConnectivity.Inputs.GroupAutoAcceptArgs
        {
            AutoAcceptProjects = new[]
            {
                "foo",
                "bar",
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkconnectivity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		basicHub, err := networkconnectivity.NewHub(ctx, "basic_hub", &networkconnectivity.HubArgs{
			Name:        pulumi.String("network-connectivity-hub1"),
			Description: pulumi.String("A sample hub"),
			Labels: pulumi.StringMap{
				"label-one": pulumi.String("value-one"),
			},
		})
		if err != nil {
			return err
		}
		_, err = networkconnectivity.NewGroup(ctx, "primary", &networkconnectivity.GroupArgs{
			Hub:  basicHub.ID(),
			Name: pulumi.String("default"),
			Labels: pulumi.StringMap{
				"label-one": pulumi.String("value-one"),
			},
			Description: pulumi.String("A sample hub group"),
			AutoAccept: &networkconnectivity.GroupAutoAcceptArgs{
				AutoAcceptProjects: pulumi.StringArray{
					pulumi.String("foo"),
					pulumi.String("bar"),
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networkconnectivity.Hub;
import com.pulumi.gcp.networkconnectivity.HubArgs;
import com.pulumi.gcp.networkconnectivity.Group;
import com.pulumi.gcp.networkconnectivity.GroupArgs;
import com.pulumi.gcp.networkconnectivity.inputs.GroupAutoAcceptArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var basicHub = new Hub("basicHub", HubArgs.builder()
            .name("network-connectivity-hub1")
            .description("A sample hub")
            .labels(Map.of("label-one", "value-one"))
            .build());

        var primary = new Group("primary", GroupArgs.builder()
            .hub(basicHub.id())
            .name("default")
            .labels(Map.of("label-one", "value-one"))
            .description("A sample hub group")
            .autoAccept(GroupAutoAcceptArgs.builder()
                .autoAcceptProjects(                
                    "foo",
                    "bar")
                .build())
            .build());

    }
}
```
```yaml
resources:
  basicHub:
    type: gcp:networkconnectivity:Hub
    name: basic_hub
    properties:
      name: network-connectivity-hub1
      description: A sample hub
      labels:
        label-one: value-one
  primary:
    type: gcp:networkconnectivity:Group
    properties:
      hub: ${basicHub.id}
      name: default
      labels:
        label-one: value-one
      description: A sample hub group
      autoAccept:
        autoAcceptProjects:
          - foo
          - bar
```
<!--End PulumiCodeChooser -->

## Import

Group can be imported using any of these accepted formats:

* `projects/{{project}}/locations/global/hubs/{{hub}}/groups/{{name}}`

* `{{project}}/{{hub}}/{{name}}`

* `{{hub}}/{{name}}`

When using the `pulumi import` command, Group can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkconnectivity/group:Group default projects/{{project}}/locations/global/hubs/{{hub}}/groups/{{name}}
```

```sh
$ pulumi import gcp:networkconnectivity/group:Group default {{project}}/{{hub}}/{{name}}
```

```sh
$ pulumi import gcp:networkconnectivity/group:Group default {{hub}}/{{name}}
```

∆

autoAccepteBc:a
_
networkconnectivityGroupAutoAccept7gcp:networkconnectivity/GroupAutoAccept:GroupAutoAcceptQOptional. The auto-accept setting for this group.
Structure is documented below.
;
descriptionB" &An optional description of the group.
ó
hub" ãThe name of the hub. Hub names must be unique. They use the following form: projects/{projectNumber}/locations/global/hubs/{hubId}


- - -
ñ
labelsB2" ÉOptional labels in key:value format. For more information about labels, see [Requirements for labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
s
nameB" eThe name of the group. Group names must be unique.
Possible values are: `default`, `center`, `edge`.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"∆

autoAccepteBc:a
_
networkconnectivityGroupAutoAccept7gcp:networkconnectivity/GroupAutoAccept:GroupAutoAcceptQOptional. The auto-accept setting for this group.
Structure is documented below.
"=

createTime" +Output only. The time the hub was created.
";
descriptionB" &An optional description of the group.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"ó
hub" ãThe name of the hub. Hub names must be unique. They use the following form: projects/{projectNumber}/locations/global/hubs/{hubId}


- - -
"ñ
labelsB2" ÉOptional labels in key:value format. For more information about labels, see [Requirements for labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"q
name" eThe name of the group. Group names must be unique.
Possible values are: `default`, `center`, `edge`.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"œ

routeTable" ºOutput only. The name of the route table that corresponds to this group. They use the following form: `projects/{projectNumber}/locations/global/hubs/{hubId}/routeTables/{route_table_id}`
"C
state" 6Output only. The current lifecycle state of this hub.
"Í
uid" ﬁOutput only. The Google-generated UUID for the group. This value is unique across all group resources. If a group is deleted and another with the same name is created, the new route table is assigned a different uniqueId.
"B

updateTime" 0Output only. The time the hub was last updated.
*¨G
;
networkconnectivityHubgcp:networkconnectivity/hub:Hub»-The NetworkConnectivity Hub resource


To get more information about Hub, see:

* [API documentation](https://cloud.google.com/network-connectivity/docs/reference/networkconnectivity/rest/v1beta/projects.locations.global.hubs)
* How-to Guides
    * [Official Documentation](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/overview)

## Example Usage

### Network Connectivity Hub Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const primary = new gcp.networkconnectivity.Hub("primary", {
    name: "basic",
    description: "A sample hub",
    labels: {
        "label-one": "value-one",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

primary = gcp.networkconnectivity.Hub("primary",
    name="basic",
    description="A sample hub",
    labels={
        "label-one": "value-one",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var primary = new Gcp.NetworkConnectivity.Hub("primary", new()
    {
        Name = "basic",
        Description = "A sample hub",
        Labels = 
        {
            { "label-one", "value-one" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkconnectivity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networkconnectivity.NewHub(ctx, "primary", &networkconnectivity.HubArgs{
			Name:        pulumi.String("basic"),
			Description: pulumi.String("A sample hub"),
			Labels: pulumi.StringMap{
				"label-one": pulumi.String("value-one"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networkconnectivity.Hub;
import com.pulumi.gcp.networkconnectivity.HubArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var primary = new Hub("primary", HubArgs.builder()
            .name("basic")
            .description("A sample hub")
            .labels(Map.of("label-one", "value-one"))
            .build());

    }
}
```
```yaml
resources:
  primary:
    type: gcp:networkconnectivity:Hub
    properties:
      name: basic
      description: A sample hub
      labels:
        label-one: value-one
```
<!--End PulumiCodeChooser -->
### Network Connectivity Hub With Export Psc


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const primary = new gcp.networkconnectivity.Hub("primary", {
    name: "basic",
    description: "A sample hub with Private Service Connect transitivity is enabled",
    exportPsc: true,
});
```
```python
import pulumi
import pulumi_gcp as gcp

primary = gcp.networkconnectivity.Hub("primary",
    name="basic",
    description="A sample hub with Private Service Connect transitivity is enabled",
    export_psc=True)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var primary = new Gcp.NetworkConnectivity.Hub("primary", new()
    {
        Name = "basic",
        Description = "A sample hub with Private Service Connect transitivity is enabled",
        ExportPsc = true,
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkconnectivity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networkconnectivity.NewHub(ctx, "primary", &networkconnectivity.HubArgs{
			Name:        pulumi.String("basic"),
			Description: pulumi.String("A sample hub with Private Service Connect transitivity is enabled"),
			ExportPsc:   pulumi.Bool(true),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networkconnectivity.Hub;
import com.pulumi.gcp.networkconnectivity.HubArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var primary = new Hub("primary", HubArgs.builder()
            .name("basic")
            .description("A sample hub with Private Service Connect transitivity is enabled")
            .exportPsc(true)
            .build());

    }
}
```
```yaml
resources:
  primary:
    type: gcp:networkconnectivity:Hub
    properties:
      name: basic
      description: A sample hub with Private Service Connect transitivity is enabled
      exportPsc: true
```
<!--End PulumiCodeChooser -->

## Import

Hub can be imported using any of these accepted formats:

* `projects/{{project}}/locations/global/hubs/{{name}}`

* `{{project}}/{{name}}`

* `{{name}}`

When using the `pulumi import` command, Hub can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkconnectivity/hub:Hub default projects/{{project}}/locations/global/hubs/{{name}}
```

```sh
$ pulumi import gcp:networkconnectivity/hub:Hub default {{project}}/{{name}}
```

```sh
$ pulumi import gcp:networkconnectivity/hub:Hub default {{name}}
```

9
descriptionB" $An optional description of the hub.
ˇ
	exportPscB
 ÎWhether Private Service Connect transitivity is enabled for the hub. If true, Private Service Connect endpoints in VPC spokes attached to the hub are made accessible to other VPC spokes attached to the hub. The default value is false.
ñ
labelsB2" ÉOptional labels in key:value format. For more information about labels, see [Requirements for labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
©
nameB" öImmutable. The name of the hub. Hub names must be unique. They use the following form: `projects/{project_number}/locations/global/hubs/{hub_id}`


- - -
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"=

createTime" +Output only. The time the hub was created.
"9
descriptionB" $An optional description of the hub.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"˝
	exportPsc
 ÎWhether Private Service Connect transitivity is enabled for the hub. If true, Private Service Connect endpoints in VPC spokes attached to the hub are made accessible to other VPC spokes attached to the hub. The default value is false.
"ñ
labelsB2" ÉOptional labels in key:value format. For more information about labels, see [Requirements for labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"ß
name" öImmutable. The name of the hub. Hub names must be unique. They use the following form: `projects/{project_number}/locations/global/hubs/{hub_id}`


- - -
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"Õ
routingVpcs_*]:[
Y
networkconnectivityHubRoutingVpc3gcp:networkconnectivity/HubRoutingVpc:HubRoutingVpc‹The VPC network associated with this hub's spokes. All of the VPN tunnels, VLAN attachments, and router appliance instances referenced by this hub's spokes must belong to this VPC network. This field is read-only. Network Connectivity Center automatically populates it based on the set of spokes attached to the hub.
Structure is documented below.
"C
state" 6Output only. The current lifecycle state of this hub.
"‚
uniqueId" —Output only. The Google-generated UUID for the hub. This value is unique across all hub resources. If a hub is deleted and another with the same name is created, the new hub is assigned a different unique_id.
"B

updateTime" 0Output only. The time the hub was last updated.
*·Ç
Y
networkconnectivityInternalRange3gcp:networkconnectivity/internalRange:InternalRange√‹The internal range resource for IPAM operations within a VPC network. Used to represent a private address range along with behavioral characterstics of that range (its usage and peering behavior). Networking resources can link to this range if they are created as belonging to it.


To get more information about InternalRange, see:

* [API documentation](https://cloud.google.com/network-connectivity/docs/reference/networkconnectivity/rest/v1/projects.locations.internalRanges)
* How-to Guides
    * [Use internal ranges](https://cloud.google.com/vpc/docs/create-use-internal-ranges)

## Example Usage

### Network Connectivity Internal Ranges Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const defaultNetwork = new gcp.compute.Network("default", {
    name: "internal-ranges",
    autoCreateSubnetworks: false,
});
const _default = new gcp.networkconnectivity.InternalRange("default", {
    name: "basic",
    description: "Test internal range",
    network: defaultNetwork.selfLink,
    usage: "FOR_VPC",
    peering: "FOR_SELF",
    ipCidrRange: "10.0.0.0/24",
    labels: {
        "label-a": "b",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

default_network = gcp.compute.Network("default",
    name="internal-ranges",
    auto_create_subnetworks=False)
default = gcp.networkconnectivity.InternalRange("default",
    name="basic",
    description="Test internal range",
    network=default_network.self_link,
    usage="FOR_VPC",
    peering="FOR_SELF",
    ip_cidr_range="10.0.0.0/24",
    labels={
        "label-a": "b",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var defaultNetwork = new Gcp.Compute.Network("default", new()
    {
        Name = "internal-ranges",
        AutoCreateSubnetworks = false,
    });

    var @default = new Gcp.NetworkConnectivity.InternalRange("default", new()
    {
        Name = "basic",
        Description = "Test internal range",
        Network = defaultNetwork.SelfLink,
        Usage = "FOR_VPC",
        Peering = "FOR_SELF",
        IpCidrRange = "10.0.0.0/24",
        Labels = 
        {
            { "label-a", "b" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkconnectivity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		defaultNetwork, err := compute.NewNetwork(ctx, "default", &compute.NetworkArgs{
			Name:                  pulumi.String("internal-ranges"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		_, err = networkconnectivity.NewInternalRange(ctx, "default", &networkconnectivity.InternalRangeArgs{
			Name:        pulumi.String("basic"),
			Description: pulumi.String("Test internal range"),
			Network:     defaultNetwork.SelfLink,
			Usage:       pulumi.String("FOR_VPC"),
			Peering:     pulumi.String("FOR_SELF"),
			IpCidrRange: pulumi.String("10.0.0.0/24"),
			Labels: pulumi.StringMap{
				"label-a": pulumi.String("b"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.networkconnectivity.InternalRange;
import com.pulumi.gcp.networkconnectivity.InternalRangeArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var defaultNetwork = new Network("defaultNetwork", NetworkArgs.builder()
            .name("internal-ranges")
            .autoCreateSubnetworks(false)
            .build());

        var default_ = new InternalRange("default", InternalRangeArgs.builder()
            .name("basic")
            .description("Test internal range")
            .network(defaultNetwork.selfLink())
            .usage("FOR_VPC")
            .peering("FOR_SELF")
            .ipCidrRange("10.0.0.0/24")
            .labels(Map.of("label-a", "b"))
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkconnectivity:InternalRange
    properties:
      name: basic
      description: Test internal range
      network: ${defaultNetwork.selfLink}
      usage: FOR_VPC
      peering: FOR_SELF
      ipCidrRange: 10.0.0.0/24
      labels:
        label-a: b
  defaultNetwork:
    type: gcp:compute:Network
    name: default
    properties:
      name: internal-ranges
      autoCreateSubnetworks: false
```
<!--End PulumiCodeChooser -->
### Network Connectivity Internal Ranges Automatic Reservation


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const defaultNetwork = new gcp.compute.Network("default", {
    name: "internal-ranges",
    autoCreateSubnetworks: false,
});
const _default = new gcp.networkconnectivity.InternalRange("default", {
    name: "automatic-reservation",
    network: defaultNetwork.id,
    usage: "FOR_VPC",
    peering: "FOR_SELF",
    prefixLength: 24,
    targetCidrRanges: ["192.16.0.0/16"],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default_network = gcp.compute.Network("default",
    name="internal-ranges",
    auto_create_subnetworks=False)
default = gcp.networkconnectivity.InternalRange("default",
    name="automatic-reservation",
    network=default_network.id,
    usage="FOR_VPC",
    peering="FOR_SELF",
    prefix_length=24,
    target_cidr_ranges=["192.16.0.0/16"])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var defaultNetwork = new Gcp.Compute.Network("default", new()
    {
        Name = "internal-ranges",
        AutoCreateSubnetworks = false,
    });

    var @default = new Gcp.NetworkConnectivity.InternalRange("default", new()
    {
        Name = "automatic-reservation",
        Network = defaultNetwork.Id,
        Usage = "FOR_VPC",
        Peering = "FOR_SELF",
        PrefixLength = 24,
        TargetCidrRanges = new[]
        {
            "192.16.0.0/16",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkconnectivity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		defaultNetwork, err := compute.NewNetwork(ctx, "default", &compute.NetworkArgs{
			Name:                  pulumi.String("internal-ranges"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		_, err = networkconnectivity.NewInternalRange(ctx, "default", &networkconnectivity.InternalRangeArgs{
			Name:         pulumi.String("automatic-reservation"),
			Network:      defaultNetwork.ID(),
			Usage:        pulumi.String("FOR_VPC"),
			Peering:      pulumi.String("FOR_SELF"),
			PrefixLength: pulumi.Int(24),
			TargetCidrRanges: pulumi.StringArray{
				pulumi.String("192.16.0.0/16"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.networkconnectivity.InternalRange;
import com.pulumi.gcp.networkconnectivity.InternalRangeArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var defaultNetwork = new Network("defaultNetwork", NetworkArgs.builder()
            .name("internal-ranges")
            .autoCreateSubnetworks(false)
            .build());

        var default_ = new InternalRange("default", InternalRangeArgs.builder()
            .name("automatic-reservation")
            .network(defaultNetwork.id())
            .usage("FOR_VPC")
            .peering("FOR_SELF")
            .prefixLength(24)
            .targetCidrRanges("192.16.0.0/16")
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkconnectivity:InternalRange
    properties:
      name: automatic-reservation
      network: ${defaultNetwork.id}
      usage: FOR_VPC
      peering: FOR_SELF
      prefixLength: 24
      targetCidrRanges:
        - 192.16.0.0/16
  defaultNetwork:
    type: gcp:compute:Network
    name: default
    properties:
      name: internal-ranges
      autoCreateSubnetworks: false
```
<!--End PulumiCodeChooser -->
### Network Connectivity Internal Ranges External Ranges


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const defaultNetwork = new gcp.compute.Network("default", {
    name: "internal-ranges",
    autoCreateSubnetworks: false,
});
const _default = new gcp.networkconnectivity.InternalRange("default", {
    name: "external-ranges",
    network: defaultNetwork.id,
    usage: "EXTERNAL_TO_VPC",
    peering: "FOR_SELF",
    ipCidrRange: "172.16.0.0/24",
    labels: {
        "external-reserved-range": "on-premises",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

default_network = gcp.compute.Network("default",
    name="internal-ranges",
    auto_create_subnetworks=False)
default = gcp.networkconnectivity.InternalRange("default",
    name="external-ranges",
    network=default_network.id,
    usage="EXTERNAL_TO_VPC",
    peering="FOR_SELF",
    ip_cidr_range="172.16.0.0/24",
    labels={
        "external-reserved-range": "on-premises",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var defaultNetwork = new Gcp.Compute.Network("default", new()
    {
        Name = "internal-ranges",
        AutoCreateSubnetworks = false,
    });

    var @default = new Gcp.NetworkConnectivity.InternalRange("default", new()
    {
        Name = "external-ranges",
        Network = defaultNetwork.Id,
        Usage = "EXTERNAL_TO_VPC",
        Peering = "FOR_SELF",
        IpCidrRange = "172.16.0.0/24",
        Labels = 
        {
            { "external-reserved-range", "on-premises" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkconnectivity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		defaultNetwork, err := compute.NewNetwork(ctx, "default", &compute.NetworkArgs{
			Name:                  pulumi.String("internal-ranges"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		_, err = networkconnectivity.NewInternalRange(ctx, "default", &networkconnectivity.InternalRangeArgs{
			Name:        pulumi.String("external-ranges"),
			Network:     defaultNetwork.ID(),
			Usage:       pulumi.String("EXTERNAL_TO_VPC"),
			Peering:     pulumi.String("FOR_SELF"),
			IpCidrRange: pulumi.String("172.16.0.0/24"),
			Labels: pulumi.StringMap{
				"external-reserved-range": pulumi.String("on-premises"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.networkconnectivity.InternalRange;
import com.pulumi.gcp.networkconnectivity.InternalRangeArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var defaultNetwork = new Network("defaultNetwork", NetworkArgs.builder()
            .name("internal-ranges")
            .autoCreateSubnetworks(false)
            .build());

        var default_ = new InternalRange("default", InternalRangeArgs.builder()
            .name("external-ranges")
            .network(defaultNetwork.id())
            .usage("EXTERNAL_TO_VPC")
            .peering("FOR_SELF")
            .ipCidrRange("172.16.0.0/24")
            .labels(Map.of("external-reserved-range", "on-premises"))
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkconnectivity:InternalRange
    properties:
      name: external-ranges
      network: ${defaultNetwork.id}
      usage: EXTERNAL_TO_VPC
      peering: FOR_SELF
      ipCidrRange: 172.16.0.0/24
      labels:
        external-reserved-range: on-premises
  defaultNetwork:
    type: gcp:compute:Network
    name: default
    properties:
      name: internal-ranges
      autoCreateSubnetworks: false
```
<!--End PulumiCodeChooser -->
### Network Connectivity Internal Ranges Reserve With Overlap


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const defaultNetwork = new gcp.compute.Network("default", {
    name: "internal-ranges",
    autoCreateSubnetworks: false,
});
const defaultSubnetwork = new gcp.compute.Subnetwork("default", {
    name: "overlapping-subnet",
    ipCidrRange: "10.0.0.0/24",
    region: "us-central1",
    network: defaultNetwork.id,
});
const _default = new gcp.networkconnectivity.InternalRange("default", {
    name: "overlap-range",
    description: "Test internal range",
    network: defaultNetwork.id,
    usage: "FOR_VPC",
    peering: "FOR_SELF",
    ipCidrRange: "10.0.0.0/30",
    overlaps: ["OVERLAP_EXISTING_SUBNET_RANGE"],
}, {
    dependsOn: [defaultSubnetwork],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default_network = gcp.compute.Network("default",
    name="internal-ranges",
    auto_create_subnetworks=False)
default_subnetwork = gcp.compute.Subnetwork("default",
    name="overlapping-subnet",
    ip_cidr_range="10.0.0.0/24",
    region="us-central1",
    network=default_network.id)
default = gcp.networkconnectivity.InternalRange("default",
    name="overlap-range",
    description="Test internal range",
    network=default_network.id,
    usage="FOR_VPC",
    peering="FOR_SELF",
    ip_cidr_range="10.0.0.0/30",
    overlaps=["OVERLAP_EXISTING_SUBNET_RANGE"],
    opts = pulumi.ResourceOptions(depends_on=[default_subnetwork]))
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var defaultNetwork = new Gcp.Compute.Network("default", new()
    {
        Name = "internal-ranges",
        AutoCreateSubnetworks = false,
    });

    var defaultSubnetwork = new Gcp.Compute.Subnetwork("default", new()
    {
        Name = "overlapping-subnet",
        IpCidrRange = "10.0.0.0/24",
        Region = "us-central1",
        Network = defaultNetwork.Id,
    });

    var @default = new Gcp.NetworkConnectivity.InternalRange("default", new()
    {
        Name = "overlap-range",
        Description = "Test internal range",
        Network = defaultNetwork.Id,
        Usage = "FOR_VPC",
        Peering = "FOR_SELF",
        IpCidrRange = "10.0.0.0/30",
        Overlaps = new[]
        {
            "OVERLAP_EXISTING_SUBNET_RANGE",
        },
    }, new CustomResourceOptions
    {
        DependsOn =
        {
            defaultSubnetwork,
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkconnectivity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		defaultNetwork, err := compute.NewNetwork(ctx, "default", &compute.NetworkArgs{
			Name:                  pulumi.String("internal-ranges"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		defaultSubnetwork, err := compute.NewSubnetwork(ctx, "default", &compute.SubnetworkArgs{
			Name:        pulumi.String("overlapping-subnet"),
			IpCidrRange: pulumi.String("10.0.0.0/24"),
			Region:      pulumi.String("us-central1"),
			Network:     defaultNetwork.ID(),
		})
		if err != nil {
			return err
		}
		_, err = networkconnectivity.NewInternalRange(ctx, "default", &networkconnectivity.InternalRangeArgs{
			Name:        pulumi.String("overlap-range"),
			Description: pulumi.String("Test internal range"),
			Network:     defaultNetwork.ID(),
			Usage:       pulumi.String("FOR_VPC"),
			Peering:     pulumi.String("FOR_SELF"),
			IpCidrRange: pulumi.String("10.0.0.0/30"),
			Overlaps: pulumi.StringArray{
				pulumi.String("OVERLAP_EXISTING_SUBNET_RANGE"),
			},
		}, pulumi.DependsOn([]pulumi.Resource{
			defaultSubnetwork,
		}))
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.Subnetwork;
import com.pulumi.gcp.compute.SubnetworkArgs;
import com.pulumi.gcp.networkconnectivity.InternalRange;
import com.pulumi.gcp.networkconnectivity.InternalRangeArgs;
import com.pulumi.resources.CustomResourceOptions;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var defaultNetwork = new Network("defaultNetwork", NetworkArgs.builder()
            .name("internal-ranges")
            .autoCreateSubnetworks(false)
            .build());

        var defaultSubnetwork = new Subnetwork("defaultSubnetwork", SubnetworkArgs.builder()
            .name("overlapping-subnet")
            .ipCidrRange("10.0.0.0/24")
            .region("us-central1")
            .network(defaultNetwork.id())
            .build());

        var default_ = new InternalRange("default", InternalRangeArgs.builder()
            .name("overlap-range")
            .description("Test internal range")
            .network(defaultNetwork.id())
            .usage("FOR_VPC")
            .peering("FOR_SELF")
            .ipCidrRange("10.0.0.0/30")
            .overlaps("OVERLAP_EXISTING_SUBNET_RANGE")
            .build(), CustomResourceOptions.builder()
                .dependsOn(defaultSubnetwork)
                .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkconnectivity:InternalRange
    properties:
      name: overlap-range
      description: Test internal range
      network: ${defaultNetwork.id}
      usage: FOR_VPC
      peering: FOR_SELF
      ipCidrRange: 10.0.0.0/30
      overlaps:
        - OVERLAP_EXISTING_SUBNET_RANGE
    options:
      dependsOn:
        - ${defaultSubnetwork}
  defaultNetwork:
    type: gcp:compute:Network
    name: default
    properties:
      name: internal-ranges
      autoCreateSubnetworks: false
  defaultSubnetwork:
    type: gcp:compute:Subnetwork
    name: default
    properties:
      name: overlapping-subnet
      ipCidrRange: 10.0.0.0/24
      region: us-central1
      network: ${defaultNetwork.id}
```
<!--End PulumiCodeChooser -->
### Network Connectivity Internal Ranges Migration


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const defaultNetwork = new gcp.compute.Network("default", {
    name: "internal-ranges",
    autoCreateSubnetworks: false,
});
const source = new gcp.compute.Subnetwork("source", {
    name: "source-subnet",
    ipCidrRange: "10.1.0.0/16",
    region: "us-central1",
    network: defaultNetwork.name,
});
const targetProject = gcp.organizations.getProject({});
const _default = new gcp.networkconnectivity.InternalRange("default", {
    name: "migration",
    description: "Test internal range",
    network: defaultNetwork.selfLink,
    usage: "FOR_MIGRATION",
    peering: "FOR_SELF",
    ipCidrRange: "10.1.0.0/16",
    migration: {
        source: source.selfLink,
        target: targetProject.then(targetProject => `projects/${targetProject.projectId}/regions/us-central1/subnetworks/target-subnet`),
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

default_network = gcp.compute.Network("default",
    name="internal-ranges",
    auto_create_subnetworks=False)
source = gcp.compute.Subnetwork("source",
    name="source-subnet",
    ip_cidr_range="10.1.0.0/16",
    region="us-central1",
    network=default_network.name)
target_project = gcp.organizations.get_project()
default = gcp.networkconnectivity.InternalRange("default",
    name="migration",
    description="Test internal range",
    network=default_network.self_link,
    usage="FOR_MIGRATION",
    peering="FOR_SELF",
    ip_cidr_range="10.1.0.0/16",
    migration={
        "source": source.self_link,
        "target": f"projects/{target_project.project_id}/regions/us-central1/subnetworks/target-subnet",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var defaultNetwork = new Gcp.Compute.Network("default", new()
    {
        Name = "internal-ranges",
        AutoCreateSubnetworks = false,
    });

    var source = new Gcp.Compute.Subnetwork("source", new()
    {
        Name = "source-subnet",
        IpCidrRange = "10.1.0.0/16",
        Region = "us-central1",
        Network = defaultNetwork.Name,
    });

    var targetProject = Gcp.Organizations.GetProject.Invoke();

    var @default = new Gcp.NetworkConnectivity.InternalRange("default", new()
    {
        Name = "migration",
        Description = "Test internal range",
        Network = defaultNetwork.SelfLink,
        Usage = "FOR_MIGRATION",
        Peering = "FOR_SELF",
        IpCidrRange = "10.1.0.0/16",
        Migration = new Gcp.NetworkConnectivity.Inputs.InternalRangeMigrationArgs
        {
            Source = source.SelfLink,
            Target = $"projects/{targetProject.Apply(getProjectResult => getProjectResult.ProjectId)}/regions/us-central1/subnetworks/target-subnet",
        },
    });

});
```
```go
package main

import (
	"fmt"

	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkconnectivity"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		defaultNetwork, err := compute.NewNetwork(ctx, "default", &compute.NetworkArgs{
			Name:                  pulumi.String("internal-ranges"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		source, err := compute.NewSubnetwork(ctx, "source", &compute.SubnetworkArgs{
			Name:        pulumi.String("source-subnet"),
			IpCidrRange: pulumi.String("10.1.0.0/16"),
			Region:      pulumi.String("us-central1"),
			Network:     defaultNetwork.Name,
		})
		if err != nil {
			return err
		}
		targetProject, err := organizations.LookupProject(ctx, &organizations.LookupProjectArgs{}, nil)
		if err != nil {
			return err
		}
		_, err = networkconnectivity.NewInternalRange(ctx, "default", &networkconnectivity.InternalRangeArgs{
			Name:        pulumi.String("migration"),
			Description: pulumi.String("Test internal range"),
			Network:     defaultNetwork.SelfLink,
			Usage:       pulumi.String("FOR_MIGRATION"),
			Peering:     pulumi.String("FOR_SELF"),
			IpCidrRange: pulumi.String("10.1.0.0/16"),
			Migration: &networkconnectivity.InternalRangeMigrationArgs{
				Source: source.SelfLink,
				Target: pulumi.Sprintf("projects/%v/regions/us-central1/subnetworks/target-subnet", targetProject.ProjectId),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.Subnetwork;
import com.pulumi.gcp.compute.SubnetworkArgs;
import com.pulumi.gcp.organizations.OrganizationsFunctions;
import com.pulumi.gcp.organizations.inputs.GetProjectArgs;
import com.pulumi.gcp.networkconnectivity.InternalRange;
import com.pulumi.gcp.networkconnectivity.InternalRangeArgs;
import com.pulumi.gcp.networkconnectivity.inputs.InternalRangeMigrationArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var defaultNetwork = new Network("defaultNetwork", NetworkArgs.builder()
            .name("internal-ranges")
            .autoCreateSubnetworks(false)
            .build());

        var source = new Subnetwork("source", SubnetworkArgs.builder()
            .name("source-subnet")
            .ipCidrRange("10.1.0.0/16")
            .region("us-central1")
            .network(defaultNetwork.name())
            .build());

        final var targetProject = OrganizationsFunctions.getProject();

        var default_ = new InternalRange("default", InternalRangeArgs.builder()
            .name("migration")
            .description("Test internal range")
            .network(defaultNetwork.selfLink())
            .usage("FOR_MIGRATION")
            .peering("FOR_SELF")
            .ipCidrRange("10.1.0.0/16")
            .migration(InternalRangeMigrationArgs.builder()
                .source(source.selfLink())
                .target(String.format("projects/%s/regions/us-central1/subnetworks/target-subnet", targetProject.applyValue(getProjectResult -> getProjectResult.projectId())))
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkconnectivity:InternalRange
    properties:
      name: migration
      description: Test internal range
      network: ${defaultNetwork.selfLink}
      usage: FOR_MIGRATION
      peering: FOR_SELF
      ipCidrRange: 10.1.0.0/16
      migration:
        source: ${source.selfLink}
        target: projects/${targetProject.projectId}/regions/us-central1/subnetworks/target-subnet
  defaultNetwork:
    type: gcp:compute:Network
    name: default
    properties:
      name: internal-ranges
      autoCreateSubnetworks: false
  source:
    type: gcp:compute:Subnetwork
    properties:
      name: source-subnet
      ipCidrRange: 10.1.0.0/16
      region: us-central1
      network: ${defaultNetwork.name}
variables:
  targetProject:
    fn::invoke:
      function: gcp:organizations:getProject
      arguments: {}
```
<!--End PulumiCodeChooser -->

## Import

InternalRange can be imported using any of these accepted formats:

* `projects/{{project}}/locations/global/internalRanges/{{name}}`

* `{{project}}/{{name}}`

* `{{name}}`

When using the `pulumi import` command, InternalRange can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkconnectivity/internalRange:InternalRange default projects/{{project}}/locations/global/internalRanges/{{name}}
```

```sh
$ pulumi import gcp:networkconnectivity/internalRange:InternalRange default {{project}}/{{name}}
```

```sh
$ pulumi import gcp:networkconnectivity/internalRange:InternalRange default {{name}}
```

?
descriptionB" *An optional description of this resource.
D
ipCidrRangeB" /The IP range that this internal range defines.
Ô
labelsB2" ‹User-defined labels.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
Î
	migrationzBx:v
t
networkconnectivityInternalRangeMigrationEgcp:networkconnectivity/InternalRangeMigration:InternalRangeMigrationbSpecification for migration with source and target resource names.
Structure is documented below.
2
nameB" $The name of the policy based route.
ã
network" |Fully-qualified URL of the network that this route applies to, for example: projects/my-project/global/networks/my-network.
¡
overlapsB*" ¨Optional. Types of resources that are allowed to overlap with the current internal range.
Each value may be one of: `OVERLAP_ROUTE_RANGE`, `OVERLAP_EXISTING_SUBNET_RANGE`.
É
peering" tThe type of peering set for this internal range.
Possible values are: `FOR_SELF`, `FOR_PEER`, `NOT_SHARED`.


- - -
∑
prefixLengthB †An alternate to ipCidrRange. Can be set when trying to create a reservation that automatically finds a free range of the given size.
If both ipCidrRange and prefixLength are set, there is an error if the range sizes do not match. Can also be used during updates to change the range size.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
”
targetCidrRangesB*" ∂Optional. Can be set to narrow down or pick a different address space while searching for a free range.
If not set, defaults to the "10.0.0.0/8" address space. This can be used to search in other rfc-1918 address spaces like "172.16.0.0/12" and "192.168.0.0/16" or non-rfc-1918 address spaces used in the VPC.

usage" rThe type of usage set for this InternalRange.
Possible values are: `FOR_VPC`, `EXTERNAL_TO_VPC`, `FOR_MIGRATION`.
"?
descriptionB" *An optional description of this resource.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"B
ipCidrRange" /The IP range that this internal range defines.
"Ô
labelsB2" ‹User-defined labels.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"Î
	migrationzBx:v
t
networkconnectivityInternalRangeMigrationEgcp:networkconnectivity/InternalRangeMigration:InternalRangeMigrationbSpecification for migration with source and target resource names.
Structure is documented below.
"0
name" $The name of the policy based route.
"ã
network" |Fully-qualified URL of the network that this route applies to, for example: projects/my-project/global/networks/my-network.
"¡
overlapsB*" ¨Optional. Types of resources that are allowed to overlap with the current internal range.
Each value may be one of: `OVERLAP_ROUTE_RANGE`, `OVERLAP_EXISTING_SUBNET_RANGE`.
"É
peering" tThe type of peering set for this internal range.
Possible values are: `FOR_SELF`, `FOR_PEER`, `NOT_SHARED`.


- - -
"∑
prefixLengthB †An alternate to ipCidrRange. Can be set when trying to create a reservation that automatically finds a free range of the given size.
If both ipCidrRange and prefixLength are set, there is an error if the range sizes do not match. Can also be used during updates to change the range size.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"”
targetCidrRangesB*" ∂Optional. Can be set to narrow down or pick a different address space while searching for a free range.
If not set, defaults to the "10.0.0.0/8" address space. This can be used to search in other rfc-1918 address spaces like "172.16.0.0/12" and "192.168.0.0/16" or non-rfc-1918 address spaces used in the VPC.
"
usage" rThe type of usage set for this InternalRange.
Possible values are: `FOR_VPC`, `EXTERNAL_TO_VPC`, `FOR_MIGRATION`.
"ë
users*" ÅOutput only. The list of resources that refer to this internal range.
Resources that use the internal range for their range allocation are referred to as users of the range.
Other resources mark themselves as users while doing so by creating a reference to this internal range. Having a user, based on this reference, prevents deletion of the internal range referred to. Can be empty.
*˚ä
b
networkconnectivityPolicyBasedRoute9gcp:networkconnectivity/policyBasedRoute:PolicyBasedRoute∏gPolicy-based Routes are more powerful routes that route L4 network traffic based on not just destination IP, but also source IP, protocol and more. A Policy-based Route always take precedence when it conflicts with other types of routes.


To get more information about PolicyBasedRoute, see:

* [API documentation](https://cloud.google.com/network-connectivity/docs/reference/networkconnectivity/rest/v1/projects.locations.global.policyBasedRoutes)
* How-to Guides
    * [Use policy-based routes](https://cloud.google.com/vpc/docs/use-policy-based-routes#api)

## Example Usage

### Network Connectivity Policy Based Route Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const myNetwork = new gcp.compute.Network("my_network", {
    name: "my-network",
    autoCreateSubnetworks: false,
});
const _default = new gcp.networkconnectivity.PolicyBasedRoute("default", {
    name: "my-pbr",
    network: myNetwork.id,
    filter: {
        protocolVersion: "IPV4",
    },
    nextHopOtherRoutes: "DEFAULT_ROUTING",
});
```
```python
import pulumi
import pulumi_gcp as gcp

my_network = gcp.compute.Network("my_network",
    name="my-network",
    auto_create_subnetworks=False)
default = gcp.networkconnectivity.PolicyBasedRoute("default",
    name="my-pbr",
    network=my_network.id,
    filter={
        "protocol_version": "IPV4",
    },
    next_hop_other_routes="DEFAULT_ROUTING")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var myNetwork = new Gcp.Compute.Network("my_network", new()
    {
        Name = "my-network",
        AutoCreateSubnetworks = false,
    });

    var @default = new Gcp.NetworkConnectivity.PolicyBasedRoute("default", new()
    {
        Name = "my-pbr",
        Network = myNetwork.Id,
        Filter = new Gcp.NetworkConnectivity.Inputs.PolicyBasedRouteFilterArgs
        {
            ProtocolVersion = "IPV4",
        },
        NextHopOtherRoutes = "DEFAULT_ROUTING",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkconnectivity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		myNetwork, err := compute.NewNetwork(ctx, "my_network", &compute.NetworkArgs{
			Name:                  pulumi.String("my-network"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		_, err = networkconnectivity.NewPolicyBasedRoute(ctx, "default", &networkconnectivity.PolicyBasedRouteArgs{
			Name:    pulumi.String("my-pbr"),
			Network: myNetwork.ID(),
			Filter: &networkconnectivity.PolicyBasedRouteFilterArgs{
				ProtocolVersion: pulumi.String("IPV4"),
			},
			NextHopOtherRoutes: pulumi.String("DEFAULT_ROUTING"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.networkconnectivity.PolicyBasedRoute;
import com.pulumi.gcp.networkconnectivity.PolicyBasedRouteArgs;
import com.pulumi.gcp.networkconnectivity.inputs.PolicyBasedRouteFilterArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var myNetwork = new Network("myNetwork", NetworkArgs.builder()
            .name("my-network")
            .autoCreateSubnetworks(false)
            .build());

        var default_ = new PolicyBasedRoute("default", PolicyBasedRouteArgs.builder()
            .name("my-pbr")
            .network(myNetwork.id())
            .filter(PolicyBasedRouteFilterArgs.builder()
                .protocolVersion("IPV4")
                .build())
            .nextHopOtherRoutes("DEFAULT_ROUTING")
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkconnectivity:PolicyBasedRoute
    properties:
      name: my-pbr
      network: ${myNetwork.id}
      filter:
        protocolVersion: IPV4
      nextHopOtherRoutes: DEFAULT_ROUTING
  myNetwork:
    type: gcp:compute:Network
    name: my_network
    properties:
      name: my-network
      autoCreateSubnetworks: false
```
<!--End PulumiCodeChooser -->
### Network Connectivity Policy Based Route Full


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const myNetwork = new gcp.compute.Network("my_network", {
    name: "my-network",
    autoCreateSubnetworks: false,
});
// This example substitutes an arbitrary internal IP for an internal network
// load balancer for brevity. Consult https://cloud.google.com/load-balancing/docs/internal
// to set one up.
const ilb = new gcp.compute.GlobalAddress("ilb", {name: "my-ilb"});
const _default = new gcp.networkconnectivity.PolicyBasedRoute("default", {
    name: "my-pbr",
    description: "My routing policy",
    network: myNetwork.id,
    priority: 2302,
    filter: {
        protocolVersion: "IPV4",
        ipProtocol: "UDP",
        srcRange: "10.0.0.0/24",
        destRange: "0.0.0.0/0",
    },
    nextHopIlbIp: ilb.address,
    virtualMachine: {
        tags: ["restricted"],
    },
    labels: {
        env: "default",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

my_network = gcp.compute.Network("my_network",
    name="my-network",
    auto_create_subnetworks=False)
# This example substitutes an arbitrary internal IP for an internal network
# load balancer for brevity. Consult https://cloud.google.com/load-balancing/docs/internal
# to set one up.
ilb = gcp.compute.GlobalAddress("ilb", name="my-ilb")
default = gcp.networkconnectivity.PolicyBasedRoute("default",
    name="my-pbr",
    description="My routing policy",
    network=my_network.id,
    priority=2302,
    filter={
        "protocol_version": "IPV4",
        "ip_protocol": "UDP",
        "src_range": "10.0.0.0/24",
        "dest_range": "0.0.0.0/0",
    },
    next_hop_ilb_ip=ilb.address,
    virtual_machine={
        "tags": ["restricted"],
    },
    labels={
        "env": "default",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var myNetwork = new Gcp.Compute.Network("my_network", new()
    {
        Name = "my-network",
        AutoCreateSubnetworks = false,
    });

    // This example substitutes an arbitrary internal IP for an internal network
    // load balancer for brevity. Consult https://cloud.google.com/load-balancing/docs/internal
    // to set one up.
    var ilb = new Gcp.Compute.GlobalAddress("ilb", new()
    {
        Name = "my-ilb",
    });

    var @default = new Gcp.NetworkConnectivity.PolicyBasedRoute("default", new()
    {
        Name = "my-pbr",
        Description = "My routing policy",
        Network = myNetwork.Id,
        Priority = 2302,
        Filter = new Gcp.NetworkConnectivity.Inputs.PolicyBasedRouteFilterArgs
        {
            ProtocolVersion = "IPV4",
            IpProtocol = "UDP",
            SrcRange = "10.0.0.0/24",
            DestRange = "0.0.0.0/0",
        },
        NextHopIlbIp = ilb.Address,
        VirtualMachine = new Gcp.NetworkConnectivity.Inputs.PolicyBasedRouteVirtualMachineArgs
        {
            Tags = new[]
            {
                "restricted",
            },
        },
        Labels = 
        {
            { "env", "default" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkconnectivity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		myNetwork, err := compute.NewNetwork(ctx, "my_network", &compute.NetworkArgs{
			Name:                  pulumi.String("my-network"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		// This example substitutes an arbitrary internal IP for an internal network
		// load balancer for brevity. Consult https://cloud.google.com/load-balancing/docs/internal
		// to set one up.
		ilb, err := compute.NewGlobalAddress(ctx, "ilb", &compute.GlobalAddressArgs{
			Name: pulumi.String("my-ilb"),
		})
		if err != nil {
			return err
		}
		_, err = networkconnectivity.NewPolicyBasedRoute(ctx, "default", &networkconnectivity.PolicyBasedRouteArgs{
			Name:        pulumi.String("my-pbr"),
			Description: pulumi.String("My routing policy"),
			Network:     myNetwork.ID(),
			Priority:    pulumi.Int(2302),
			Filter: &networkconnectivity.PolicyBasedRouteFilterArgs{
				ProtocolVersion: pulumi.String("IPV4"),
				IpProtocol:      pulumi.String("UDP"),
				SrcRange:        pulumi.String("10.0.0.0/24"),
				DestRange:       pulumi.String("0.0.0.0/0"),
			},
			NextHopIlbIp: ilb.Address,
			VirtualMachine: &networkconnectivity.PolicyBasedRouteVirtualMachineArgs{
				Tags: pulumi.StringArray{
					pulumi.String("restricted"),
				},
			},
			Labels: pulumi.StringMap{
				"env": pulumi.String("default"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.GlobalAddress;
import com.pulumi.gcp.compute.GlobalAddressArgs;
import com.pulumi.gcp.networkconnectivity.PolicyBasedRoute;
import com.pulumi.gcp.networkconnectivity.PolicyBasedRouteArgs;
import com.pulumi.gcp.networkconnectivity.inputs.PolicyBasedRouteFilterArgs;
import com.pulumi.gcp.networkconnectivity.inputs.PolicyBasedRouteVirtualMachineArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var myNetwork = new Network("myNetwork", NetworkArgs.builder()
            .name("my-network")
            .autoCreateSubnetworks(false)
            .build());

        // This example substitutes an arbitrary internal IP for an internal network
        // load balancer for brevity. Consult https://cloud.google.com/load-balancing/docs/internal
        // to set one up.
        var ilb = new GlobalAddress("ilb", GlobalAddressArgs.builder()
            .name("my-ilb")
            .build());

        var default_ = new PolicyBasedRoute("default", PolicyBasedRouteArgs.builder()
            .name("my-pbr")
            .description("My routing policy")
            .network(myNetwork.id())
            .priority(2302)
            .filter(PolicyBasedRouteFilterArgs.builder()
                .protocolVersion("IPV4")
                .ipProtocol("UDP")
                .srcRange("10.0.0.0/24")
                .destRange("0.0.0.0/0")
                .build())
            .nextHopIlbIp(ilb.address())
            .virtualMachine(PolicyBasedRouteVirtualMachineArgs.builder()
                .tags("restricted")
                .build())
            .labels(Map.of("env", "default"))
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkconnectivity:PolicyBasedRoute
    properties:
      name: my-pbr
      description: My routing policy
      network: ${myNetwork.id}
      priority: 2302
      filter:
        protocolVersion: IPV4
        ipProtocol: UDP
        srcRange: 10.0.0.0/24
        destRange: 0.0.0.0/0
      nextHopIlbIp: ${ilb.address}
      virtualMachine:
        tags:
          - restricted
      labels:
        env: default
  myNetwork:
    type: gcp:compute:Network
    name: my_network
    properties:
      name: my-network
      autoCreateSubnetworks: false
  # This example substitutes an arbitrary internal IP for an internal network
  # load balancer for brevity. Consult https://cloud.google.com/load-balancing/docs/internal
  # to set one up.
  ilb:
    type: gcp:compute:GlobalAddress
    properties:
      name: my-ilb
```
<!--End PulumiCodeChooser -->

## Import

PolicyBasedRoute can be imported using any of these accepted formats:

* `projects/{{project}}/locations/global/policyBasedRoutes/{{name}}`

* `{{project}}/{{name}}`

* `{{name}}`

When using the `pulumi import` command, PolicyBasedRoute can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkconnectivity/policyBasedRoute:PolicyBasedRoute default projects/{{project}}/locations/global/policyBasedRoutes/{{name}}
```

```sh
$ pulumi import gcp:networkconnectivity/policyBasedRoute:PolicyBasedRoute default {{project}}/{{name}}
```

```sh
$ pulumi import gcp:networkconnectivity/policyBasedRoute:PolicyBasedRoute default {{name}}
```

?
descriptionB" *An optional description of this resource.
√
filterx:v
t
networkconnectivityPolicyBasedRouteFilterEgcp:networkconnectivity/PolicyBasedRouteFilter:PolicyBasedRouteFilter?The filter to match L4 traffic.
Structure is documented below.
ê
interconnectAttachment≠B™:ß
§
networkconnectivity&PolicyBasedRouteInterconnectAttachmentegcp:networkconnectivity/PolicyBasedRouteInterconnectAttachment:PolicyBasedRouteInterconnectAttachmentFThe interconnect attachments that this policy-based route applies to.
Ó
labelsB2" €User-defined labels. **Note**: This field is non-authoritative, and will only manage the labels present in your
configuration. Please refer to the field 'effective_labels' for all of the labels present on the resource.
2
nameB" $The name of the policy based route.
ã
network" |Fully-qualified URL of the network that this route applies to, for example: projects/my-project/global/networks/my-network.
r
nextHopIlbIpB" \The IP address of a global-access-enabled L4 ILB that is the next hop for matching packets.
è
nextHopOtherRoutesB" sOther routes that will be referenced to determine the next hop of the packet. Possible values: ["DEFAULT_ROUTING"]
Á
priorityB ‘The priority of this policy-based route. Priority is used to break ties in cases where there are more than one matching
policy-based routes found. In cases where multiple policy-based routes are matched, the one with the lowest-numbered
priority value wins. The default value is 1000. The priority value must be from 1 to 65535, inclusive.

projectB" ‰
virtualMachineïBí:è
å
networkconnectivityPolicyBasedRouteVirtualMachineUgcp:networkconnectivity/PolicyBasedRouteVirtualMachine:PolicyBasedRouteVirtualMachine:VM instances to which this policy-based route applies to.
"@

createTime" .Time when the policy-based route was created.
"?
descriptionB" *An optional description of this resource.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"√
filterx:v
t
networkconnectivityPolicyBasedRouteFilterEgcp:networkconnectivity/PolicyBasedRouteFilter:PolicyBasedRouteFilter?The filter to match L4 traffic.
Structure is documented below.
"ê
interconnectAttachment≠B™:ß
§
networkconnectivity&PolicyBasedRouteInterconnectAttachmentegcp:networkconnectivity/PolicyBasedRouteInterconnectAttachment:PolicyBasedRouteInterconnectAttachmentFThe interconnect attachments that this policy-based route applies to.
"#
kind" Type of this resource.
"Ó
labelsB2" €User-defined labels. **Note**: This field is non-authoritative, and will only manage the labels present in your
configuration. Please refer to the field 'effective_labels' for all of the labels present on the resource.
"0
name" $The name of the policy based route.
"ã
network" |Fully-qualified URL of the network that this route applies to, for example: projects/my-project/global/networks/my-network.
"r
nextHopIlbIpB" \The IP address of a global-access-enabled L4 ILB that is the next hop for matching packets.
"è
nextHopOtherRoutesB" sOther routes that will be referenced to determine the next hop of the packet. Possible values: ["DEFAULT_ROUTING"]
"Á
priorityB ‘The priority of this policy-based route. Priority is used to break ties in cases where there are more than one matching
policy-based routes found. In cases where multiple policy-based routes are matched, the one with the lowest-numbered
priority value wins. The default value is 1000. The priority value must be from 1 to 65535, inclusive.
"
project" "É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"@

updateTime" .Time when the policy-based route was created.
"‰
virtualMachineïBí:è
å
networkconnectivityPolicyBasedRouteVirtualMachineUgcp:networkconnectivity/PolicyBasedRouteVirtualMachine:PolicyBasedRouteVirtualMachine:VM instances to which this policy-based route applies to.
"õ
warnings}*{:y
w
networkconnectivityPolicyBasedRouteWarningGgcp:networkconnectivity/PolicyBasedRouteWarning:PolicyBasedRouteWarningèIf potential misconfigurations are detected for this route, this field will be populated with warning messages.
Structure is documented below.
*˚ë
b
networkconnectivityRegionalEndpoint9gcp:networkconnectivity/regionalEndpoint:RegionalEndpoint≠lRegional Private Service Connect (PSC) endpoint resource.


To get more information about RegionalEndpoint, see:

* [API documentation](https://cloud.google.com/network-connectivity/docs/reference/networkconnectivity/rest/v1/projects.locations.regionalEndpoints)
* How-to Guides
    * [Access regional Google APIs through endpoints](https://cloud.google.com/vpc/docs/access-regional-google-apis-endpoints)

## Example Usage

### Network Connectivity Regional Endpoint Regional Access


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const myNetwork = new gcp.compute.Network("my_network", {
    name: "my-network",
    autoCreateSubnetworks: false,
});
const mySubnetwork = new gcp.compute.Subnetwork("my_subnetwork", {
    name: "my-subnetwork",
    ipCidrRange: "192.168.0.0/24",
    region: "us-central1",
    network: myNetwork.id,
});
const _default = new gcp.networkconnectivity.RegionalEndpoint("default", {
    name: "my-rep",
    location: "us-central1",
    targetGoogleApi: "storage.us-central1.p.rep.googleapis.com",
    accessType: "REGIONAL",
    address: "192.168.0.5",
    network: myNetwork.id,
    subnetwork: mySubnetwork.id,
    description: "My RegionalEndpoint targeting Google API storage.us-central1.p.rep.googleapis.com",
    labels: {
        env: "default",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

my_network = gcp.compute.Network("my_network",
    name="my-network",
    auto_create_subnetworks=False)
my_subnetwork = gcp.compute.Subnetwork("my_subnetwork",
    name="my-subnetwork",
    ip_cidr_range="192.168.0.0/24",
    region="us-central1",
    network=my_network.id)
default = gcp.networkconnectivity.RegionalEndpoint("default",
    name="my-rep",
    location="us-central1",
    target_google_api="storage.us-central1.p.rep.googleapis.com",
    access_type="REGIONAL",
    address="192.168.0.5",
    network=my_network.id,
    subnetwork=my_subnetwork.id,
    description="My RegionalEndpoint targeting Google API storage.us-central1.p.rep.googleapis.com",
    labels={
        "env": "default",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var myNetwork = new Gcp.Compute.Network("my_network", new()
    {
        Name = "my-network",
        AutoCreateSubnetworks = false,
    });

    var mySubnetwork = new Gcp.Compute.Subnetwork("my_subnetwork", new()
    {
        Name = "my-subnetwork",
        IpCidrRange = "192.168.0.0/24",
        Region = "us-central1",
        Network = myNetwork.Id,
    });

    var @default = new Gcp.NetworkConnectivity.RegionalEndpoint("default", new()
    {
        Name = "my-rep",
        Location = "us-central1",
        TargetGoogleApi = "storage.us-central1.p.rep.googleapis.com",
        AccessType = "REGIONAL",
        Address = "192.168.0.5",
        Network = myNetwork.Id,
        Subnetwork = mySubnetwork.Id,
        Description = "My RegionalEndpoint targeting Google API storage.us-central1.p.rep.googleapis.com",
        Labels = 
        {
            { "env", "default" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkconnectivity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		myNetwork, err := compute.NewNetwork(ctx, "my_network", &compute.NetworkArgs{
			Name:                  pulumi.String("my-network"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		mySubnetwork, err := compute.NewSubnetwork(ctx, "my_subnetwork", &compute.SubnetworkArgs{
			Name:        pulumi.String("my-subnetwork"),
			IpCidrRange: pulumi.String("192.168.0.0/24"),
			Region:      pulumi.String("us-central1"),
			Network:     myNetwork.ID(),
		})
		if err != nil {
			return err
		}
		_, err = networkconnectivity.NewRegionalEndpoint(ctx, "default", &networkconnectivity.RegionalEndpointArgs{
			Name:            pulumi.String("my-rep"),
			Location:        pulumi.String("us-central1"),
			TargetGoogleApi: pulumi.String("storage.us-central1.p.rep.googleapis.com"),
			AccessType:      pulumi.String("REGIONAL"),
			Address:         pulumi.String("192.168.0.5"),
			Network:         myNetwork.ID(),
			Subnetwork:      mySubnetwork.ID(),
			Description:     pulumi.String("My RegionalEndpoint targeting Google API storage.us-central1.p.rep.googleapis.com"),
			Labels: pulumi.StringMap{
				"env": pulumi.String("default"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.Subnetwork;
import com.pulumi.gcp.compute.SubnetworkArgs;
import com.pulumi.gcp.networkconnectivity.RegionalEndpoint;
import com.pulumi.gcp.networkconnectivity.RegionalEndpointArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var myNetwork = new Network("myNetwork", NetworkArgs.builder()
            .name("my-network")
            .autoCreateSubnetworks(false)
            .build());

        var mySubnetwork = new Subnetwork("mySubnetwork", SubnetworkArgs.builder()
            .name("my-subnetwork")
            .ipCidrRange("192.168.0.0/24")
            .region("us-central1")
            .network(myNetwork.id())
            .build());

        var default_ = new RegionalEndpoint("default", RegionalEndpointArgs.builder()
            .name("my-rep")
            .location("us-central1")
            .targetGoogleApi("storage.us-central1.p.rep.googleapis.com")
            .accessType("REGIONAL")
            .address("192.168.0.5")
            .network(myNetwork.id())
            .subnetwork(mySubnetwork.id())
            .description("My RegionalEndpoint targeting Google API storage.us-central1.p.rep.googleapis.com")
            .labels(Map.of("env", "default"))
            .build());

    }
}
```
```yaml
resources:
  myNetwork:
    type: gcp:compute:Network
    name: my_network
    properties:
      name: my-network
      autoCreateSubnetworks: false
  mySubnetwork:
    type: gcp:compute:Subnetwork
    name: my_subnetwork
    properties:
      name: my-subnetwork
      ipCidrRange: 192.168.0.0/24
      region: us-central1
      network: ${myNetwork.id}
  default:
    type: gcp:networkconnectivity:RegionalEndpoint
    properties:
      name: my-rep
      location: us-central1
      targetGoogleApi: storage.us-central1.p.rep.googleapis.com
      accessType: REGIONAL
      address: 192.168.0.5
      network: ${myNetwork.id}
      subnetwork: ${mySubnetwork.id}
      description: My RegionalEndpoint targeting Google API storage.us-central1.p.rep.googleapis.com
      labels:
        env: default
```
<!--End PulumiCodeChooser -->
### Network Connectivity Regional Endpoint Global Access


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const myNetwork = new gcp.compute.Network("my_network", {
    name: "my-network",
    autoCreateSubnetworks: false,
});
const mySubnetwork = new gcp.compute.Subnetwork("my_subnetwork", {
    name: "my-subnetwork",
    ipCidrRange: "192.168.0.0/24",
    region: "us-central1",
    network: myNetwork.id,
});
const _default = new gcp.networkconnectivity.RegionalEndpoint("default", {
    name: "my-rep",
    location: "us-central1",
    targetGoogleApi: "storage.us-central1.p.rep.googleapis.com",
    accessType: "GLOBAL",
    address: "192.168.0.4",
    network: myNetwork.id,
    subnetwork: mySubnetwork.id,
});
```
```python
import pulumi
import pulumi_gcp as gcp

my_network = gcp.compute.Network("my_network",
    name="my-network",
    auto_create_subnetworks=False)
my_subnetwork = gcp.compute.Subnetwork("my_subnetwork",
    name="my-subnetwork",
    ip_cidr_range="192.168.0.0/24",
    region="us-central1",
    network=my_network.id)
default = gcp.networkconnectivity.RegionalEndpoint("default",
    name="my-rep",
    location="us-central1",
    target_google_api="storage.us-central1.p.rep.googleapis.com",
    access_type="GLOBAL",
    address="192.168.0.4",
    network=my_network.id,
    subnetwork=my_subnetwork.id)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var myNetwork = new Gcp.Compute.Network("my_network", new()
    {
        Name = "my-network",
        AutoCreateSubnetworks = false,
    });

    var mySubnetwork = new Gcp.Compute.Subnetwork("my_subnetwork", new()
    {
        Name = "my-subnetwork",
        IpCidrRange = "192.168.0.0/24",
        Region = "us-central1",
        Network = myNetwork.Id,
    });

    var @default = new Gcp.NetworkConnectivity.RegionalEndpoint("default", new()
    {
        Name = "my-rep",
        Location = "us-central1",
        TargetGoogleApi = "storage.us-central1.p.rep.googleapis.com",
        AccessType = "GLOBAL",
        Address = "192.168.0.4",
        Network = myNetwork.Id,
        Subnetwork = mySubnetwork.Id,
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkconnectivity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		myNetwork, err := compute.NewNetwork(ctx, "my_network", &compute.NetworkArgs{
			Name:                  pulumi.String("my-network"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		mySubnetwork, err := compute.NewSubnetwork(ctx, "my_subnetwork", &compute.SubnetworkArgs{
			Name:        pulumi.String("my-subnetwork"),
			IpCidrRange: pulumi.String("192.168.0.0/24"),
			Region:      pulumi.String("us-central1"),
			Network:     myNetwork.ID(),
		})
		if err != nil {
			return err
		}
		_, err = networkconnectivity.NewRegionalEndpoint(ctx, "default", &networkconnectivity.RegionalEndpointArgs{
			Name:            pulumi.String("my-rep"),
			Location:        pulumi.String("us-central1"),
			TargetGoogleApi: pulumi.String("storage.us-central1.p.rep.googleapis.com"),
			AccessType:      pulumi.String("GLOBAL"),
			Address:         pulumi.String("192.168.0.4"),
			Network:         myNetwork.ID(),
			Subnetwork:      mySubnetwork.ID(),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.Subnetwork;
import com.pulumi.gcp.compute.SubnetworkArgs;
import com.pulumi.gcp.networkconnectivity.RegionalEndpoint;
import com.pulumi.gcp.networkconnectivity.RegionalEndpointArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var myNetwork = new Network("myNetwork", NetworkArgs.builder()
            .name("my-network")
            .autoCreateSubnetworks(false)
            .build());

        var mySubnetwork = new Subnetwork("mySubnetwork", SubnetworkArgs.builder()
            .name("my-subnetwork")
            .ipCidrRange("192.168.0.0/24")
            .region("us-central1")
            .network(myNetwork.id())
            .build());

        var default_ = new RegionalEndpoint("default", RegionalEndpointArgs.builder()
            .name("my-rep")
            .location("us-central1")
            .targetGoogleApi("storage.us-central1.p.rep.googleapis.com")
            .accessType("GLOBAL")
            .address("192.168.0.4")
            .network(myNetwork.id())
            .subnetwork(mySubnetwork.id())
            .build());

    }
}
```
```yaml
resources:
  myNetwork:
    type: gcp:compute:Network
    name: my_network
    properties:
      name: my-network
      autoCreateSubnetworks: false
  mySubnetwork:
    type: gcp:compute:Subnetwork
    name: my_subnetwork
    properties:
      name: my-subnetwork
      ipCidrRange: 192.168.0.0/24
      region: us-central1
      network: ${myNetwork.id}
  default:
    type: gcp:networkconnectivity:RegionalEndpoint
    properties:
      name: my-rep
      location: us-central1
      targetGoogleApi: storage.us-central1.p.rep.googleapis.com
      accessType: GLOBAL
      address: 192.168.0.4
      network: ${myNetwork.id}
      subnetwork: ${mySubnetwork.id}
```
<!--End PulumiCodeChooser -->

## Import

RegionalEndpoint can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/regionalEndpoints/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

When using the `pulumi import` command, RegionalEndpoint can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkconnectivity/regionalEndpoint:RegionalEndpoint default projects/{{project}}/locations/{{location}}/regionalEndpoints/{{name}}
```

```sh
$ pulumi import gcp:networkconnectivity/regionalEndpoint:RegionalEndpoint default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:networkconnectivity/regionalEndpoint:RegionalEndpoint default {{location}}/{{name}}
```

√

accessType" ∞The access type of this regional endpoint. This field is reflected in the PSC Forwarding Rule configuration to enable global access.
Possible values are: `GLOBAL`, `REGIONAL`.
ò
addressB" ÜThe IP Address of the Regional Endpoint. When no address is provided, an IP from the subnetwork is allocated. Use one of the following formats: * IPv4 address as in `10.0.0.1` * Address resource URI as in `projects/{project}/regions/{region}/addresses/{address_name}`
> **Note:** This field accepts both a reference to a Compute Address resource, which is the resource name of which format is given in the description, and IP literal value. If the user chooses to input a reserved address value; they need to make sure that the reserved address is in IPv4 version, its purpose is GCE_ENDPOINT, its type is INTERNAL and its status is RESERVED. If the user chooses to input an IP literal, they need to make sure that it's a valid IPv4 address (x.x.x.x) within the subnetwork.
5
descriptionB"  A description of this resource.
Ô
labelsB2" ‹User-defined labels.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
>
location" .The location of the RegionalEndpoint.


- - -
0
nameB" "The name of the RegionalEndpoint.
à
networkB" wThe name of the VPC network for this private regional endpoint. Format: `projects/{project}/global/networks/{network}`
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
§

subnetworkB" èThe name of the subnetwork from which the IP address will be allocated. Format: `projects/{project}/regions/{region}/subnetworks/{subnetwork}`
√
targetGoogleApi" ´The service endpoint this private regional endpoint connects to. Format: `{apiname}.{region}.p.rep.googleapis.com` Example: \"cloudkms.us-central1.p.rep.googleapis.com\".
"√

accessType" ∞The access type of this regional endpoint. This field is reflected in the PSC Forwarding Rule configuration to enable global access.
Possible values are: `GLOBAL`, `REGIONAL`.
"ñ
address" ÜThe IP Address of the Regional Endpoint. When no address is provided, an IP from the subnetwork is allocated. Use one of the following formats: * IPv4 address as in `10.0.0.1` * Address resource URI as in `projects/{project}/regions/{region}/addresses/{address_name}`
> **Note:** This field accepts both a reference to a Compute Address resource, which is the resource name of which format is given in the description, and IP literal value. If the user chooses to input a reserved address value; they need to make sure that the reserved address is in IPv4 version, its purpose is GCE_ENDPOINT, its type is INTERNAL and its status is RESERVED. If the user chooses to input an IP literal, they need to make sure that it's a valid IPv4 address (x.x.x.x) within the subnetwork.
">

createTime" ,Time when the RegionalEndpoint was created.
"5
descriptionB"  A description of this resource.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"Ô
labelsB2" ‹User-defined labels.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
">
location" .The location of the RegionalEndpoint.


- - -
".
name" "The name of the RegionalEndpoint.
"Ü
network" wThe name of the VPC network for this private regional endpoint. Format: `projects/{project}/global/networks/{network}`
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"›
pscForwardingRule" √The resource reference of the PSC Forwarding Rule created on behalf of the customer. Format: `//compute.googleapis.com/projects/{project}/regions/{region}/forwardingRules/{forwarding_rule_name}`
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"¢

subnetwork" èThe name of the subnetwork from which the IP address will be allocated. Format: `projects/{project}/regions/{region}/subnetworks/{subnetwork}`
"√
targetGoogleApi" ´The service endpoint this private regional endpoint connects to. Format: `{apiname}.{region}.p.rep.googleapis.com` Example: \"cloudkms.us-central1.p.rep.googleapis.com\".
">

updateTime" ,Time when the RegionalEndpoint was updated.
*Ë]
w
networkconnectivityServiceConnectionPolicyGgcp:networkconnectivity/serviceConnectionPolicy:ServiceConnectionPolicyÓ=Manage Service Connection Policies.


To get more information about ServiceConnectionPolicy, see:

* [API documentation](https://cloud.google.com/secure-web-proxy/docs/reference/networkconnectivity/rest/v1/projects.locations.networkConnectionPolicies)
* How-to Guides
    * [About Service Connection Policies](https://cloud.google.com/vpc/docs/about-service-connection-policies#service-policies)

## Example Usage

### Network Connectivity Policy Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const producerNet = new gcp.compute.Network("producer_net", {
    name: "producer-net",
    autoCreateSubnetworks: false,
});
const producerSubnet = new gcp.compute.Subnetwork("producer_subnet", {
    name: "producer-subnet",
    ipCidrRange: "10.0.0.0/16",
    region: "us-central1",
    network: producerNet.id,
});
const _default = new gcp.networkconnectivity.ServiceConnectionPolicy("default", {
    name: "my-network-connectivity-policy",
    location: "us-central1",
    serviceClass: "my-basic-service-class",
    description: "my basic service connection policy",
    network: producerNet.id,
    pscConfig: {
        subnetworks: [producerSubnet.id],
        limit: "2",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

producer_net = gcp.compute.Network("producer_net",
    name="producer-net",
    auto_create_subnetworks=False)
producer_subnet = gcp.compute.Subnetwork("producer_subnet",
    name="producer-subnet",
    ip_cidr_range="10.0.0.0/16",
    region="us-central1",
    network=producer_net.id)
default = gcp.networkconnectivity.ServiceConnectionPolicy("default",
    name="my-network-connectivity-policy",
    location="us-central1",
    service_class="my-basic-service-class",
    description="my basic service connection policy",
    network=producer_net.id,
    psc_config={
        "subnetworks": [producer_subnet.id],
        "limit": "2",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var producerNet = new Gcp.Compute.Network("producer_net", new()
    {
        Name = "producer-net",
        AutoCreateSubnetworks = false,
    });

    var producerSubnet = new Gcp.Compute.Subnetwork("producer_subnet", new()
    {
        Name = "producer-subnet",
        IpCidrRange = "10.0.0.0/16",
        Region = "us-central1",
        Network = producerNet.Id,
    });

    var @default = new Gcp.NetworkConnectivity.ServiceConnectionPolicy("default", new()
    {
        Name = "my-network-connectivity-policy",
        Location = "us-central1",
        ServiceClass = "my-basic-service-class",
        Description = "my basic service connection policy",
        Network = producerNet.Id,
        PscConfig = new Gcp.NetworkConnectivity.Inputs.ServiceConnectionPolicyPscConfigArgs
        {
            Subnetworks = new[]
            {
                producerSubnet.Id,
            },
            Limit = "2",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkconnectivity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		producerNet, err := compute.NewNetwork(ctx, "producer_net", &compute.NetworkArgs{
			Name:                  pulumi.String("producer-net"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		producerSubnet, err := compute.NewSubnetwork(ctx, "producer_subnet", &compute.SubnetworkArgs{
			Name:        pulumi.String("producer-subnet"),
			IpCidrRange: pulumi.String("10.0.0.0/16"),
			Region:      pulumi.String("us-central1"),
			Network:     producerNet.ID(),
		})
		if err != nil {
			return err
		}
		_, err = networkconnectivity.NewServiceConnectionPolicy(ctx, "default", &networkconnectivity.ServiceConnectionPolicyArgs{
			Name:         pulumi.String("my-network-connectivity-policy"),
			Location:     pulumi.String("us-central1"),
			ServiceClass: pulumi.String("my-basic-service-class"),
			Description:  pulumi.String("my basic service connection policy"),
			Network:      producerNet.ID(),
			PscConfig: &networkconnectivity.ServiceConnectionPolicyPscConfigArgs{
				Subnetworks: pulumi.StringArray{
					producerSubnet.ID(),
				},
				Limit: pulumi.String("2"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.Subnetwork;
import com.pulumi.gcp.compute.SubnetworkArgs;
import com.pulumi.gcp.networkconnectivity.ServiceConnectionPolicy;
import com.pulumi.gcp.networkconnectivity.ServiceConnectionPolicyArgs;
import com.pulumi.gcp.networkconnectivity.inputs.ServiceConnectionPolicyPscConfigArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var producerNet = new Network("producerNet", NetworkArgs.builder()
            .name("producer-net")
            .autoCreateSubnetworks(false)
            .build());

        var producerSubnet = new Subnetwork("producerSubnet", SubnetworkArgs.builder()
            .name("producer-subnet")
            .ipCidrRange("10.0.0.0/16")
            .region("us-central1")
            .network(producerNet.id())
            .build());

        var default_ = new ServiceConnectionPolicy("default", ServiceConnectionPolicyArgs.builder()
            .name("my-network-connectivity-policy")
            .location("us-central1")
            .serviceClass("my-basic-service-class")
            .description("my basic service connection policy")
            .network(producerNet.id())
            .pscConfig(ServiceConnectionPolicyPscConfigArgs.builder()
                .subnetworks(producerSubnet.id())
                .limit(2)
                .build())
            .build());

    }
}
```
```yaml
resources:
  producerNet:
    type: gcp:compute:Network
    name: producer_net
    properties:
      name: producer-net
      autoCreateSubnetworks: false
  producerSubnet:
    type: gcp:compute:Subnetwork
    name: producer_subnet
    properties:
      name: producer-subnet
      ipCidrRange: 10.0.0.0/16
      region: us-central1
      network: ${producerNet.id}
  default:
    type: gcp:networkconnectivity:ServiceConnectionPolicy
    properties:
      name: my-network-connectivity-policy
      location: us-central1
      serviceClass: my-basic-service-class
      description: my basic service connection policy
      network: ${producerNet.id}
      pscConfig:
        subnetworks:
          - ${producerSubnet.id}
        limit: 2
```
<!--End PulumiCodeChooser -->

## Import

ServiceConnectionPolicy can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/serviceConnectionPolicies/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

When using the `pulumi import` command, ServiceConnectionPolicy can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkconnectivity/serviceConnectionPolicy:ServiceConnectionPolicy default projects/{{project}}/locations/{{location}}/serviceConnectionPolicies/{{name}}
```

```sh
$ pulumi import gcp:networkconnectivity/serviceConnectionPolicy:ServiceConnectionPolicy default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:networkconnectivity/serviceConnectionPolicy:ServiceConnectionPolicy default {{location}}/{{name}}
```

<
descriptionB" 'Free-text description of the resource.
Ô
labelsB2" ‹User-defined labels.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
E
location" 5The location of the ServiceConnectionPolicy.


- - -
ﬂ
nameB" –The name of a ServiceConnectionPolicy. Format: projects/{project}/locations/{location}/serviceConnectionPolicies/{service_connection_policy} See: https://google.aip.dev/122#fields-representing-resource-names
}
network" nThe resource path of the consumer network. Example: - projects/{projectNumOrId}/global/networks/{resourceId}.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
ß
	pscConfigõBò:ï
í
networkconnectivity ServiceConnectionPolicyPscConfigYgcp:networkconnectivity/ServiceConnectionPolicyPscConfig:ServiceConnectionPolicyPscConfig|Configuration used for Private Service Connect connections. Used when Infrastructure is PSC.
Structure is documented below.
›
serviceClass" »The service class identifier for which this ServiceConnectionPolicy is for. The service class identifier is a unique, symbolic representation of a ServiceClass.
It is provided by the Service Producer. Google services have a prefix of gcp. For example, gcp-cloud-sql. 3rd party services do not. For example, test-service-a3dfcx.
"?

createTime" -The timestamp when the resource was created.
"<
descriptionB" 'Free-text description of the resource.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"ü
etag" íThe etag is computed by the server, and may be sent on update and delete requests to ensure the client has an up-to-date value before proceeding.
"V
infrastructure" @The type of underlying resources used to create the connection.
"Ô
labelsB2" ‹User-defined labels.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"E
location" 5The location of the ServiceConnectionPolicy.


- - -
"›
name" –The name of a ServiceConnectionPolicy. Format: projects/{project}/locations/{location}/serviceConnectionPolicies/{service_connection_policy} See: https://google.aip.dev/122#fields-representing-resource-names
"}
network" nThe resource path of the consumer network. Example: - projects/{projectNumOrId}/global/networks/{resourceId}.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"ß
	pscConfigõBò:ï
í
networkconnectivity ServiceConnectionPolicyPscConfigYgcp:networkconnectivity/ServiceConnectionPolicyPscConfig:ServiceConnectionPolicyPscConfig|Configuration used for Private Service Connect connections. Used when Infrastructure is PSC.
Structure is documented below.
"ñ
pscConnectionsß*§:°
û
networkconnectivity$ServiceConnectionPolicyPscConnectionagcp:networkconnectivity/ServiceConnectionPolicyPscConnection:ServiceConnectionPolicyPscConnectionZInformation about each Private Service Connect connection.
Structure is documented below.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"›
serviceClass" »The service class identifier for which this ServiceConnectionPolicy is for. The service class identifier is a unique, symbolic representation of a ServiceClass.
It is provided by the Service Producer. Google services have a prefix of gcp. For example, gcp-cloud-sql. 3rd party services do not. For example, test-service-a3dfcx.
"?

updateTime" -The timestamp when the resource was updated.
*¥Ê
A
networkconnectivitySpoke#gcp:networkconnectivity/spoke:Spoke±ºThe NetworkConnectivity Spoke resource


To get more information about Spoke, see:

* [API documentation](https://cloud.google.com/network-connectivity/docs/reference/networkconnectivity/rest/v1beta/projects.locations.spokes)
* How-to Guides
    * [Official Documentation](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/overview)

## Example Usage

### Network Connectivity Spoke Linked Vpc Network Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const network = new gcp.compute.Network("network", {
    name: "net",
    autoCreateSubnetworks: false,
});
const basicHub = new gcp.networkconnectivity.Hub("basic_hub", {
    name: "hub1",
    description: "A sample hub",
    labels: {
        "label-two": "value-one",
    },
});
const primary = new gcp.networkconnectivity.Spoke("primary", {
    name: "spoke1",
    location: "global",
    description: "A sample spoke with a linked router appliance instance",
    labels: {
        "label-one": "value-one",
    },
    hub: basicHub.id,
    linkedVpcNetwork: {
        excludeExportRanges: [
            "198.51.100.0/24",
            "10.10.0.0/16",
        ],
        includeExportRanges: [
            "198.51.100.0/23",
            "10.0.0.0/8",
        ],
        uri: network.selfLink,
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

network = gcp.compute.Network("network",
    name="net",
    auto_create_subnetworks=False)
basic_hub = gcp.networkconnectivity.Hub("basic_hub",
    name="hub1",
    description="A sample hub",
    labels={
        "label-two": "value-one",
    })
primary = gcp.networkconnectivity.Spoke("primary",
    name="spoke1",
    location="global",
    description="A sample spoke with a linked router appliance instance",
    labels={
        "label-one": "value-one",
    },
    hub=basic_hub.id,
    linked_vpc_network={
        "exclude_export_ranges": [
            "198.51.100.0/24",
            "10.10.0.0/16",
        ],
        "include_export_ranges": [
            "198.51.100.0/23",
            "10.0.0.0/8",
        ],
        "uri": network.self_link,
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var network = new Gcp.Compute.Network("network", new()
    {
        Name = "net",
        AutoCreateSubnetworks = false,
    });

    var basicHub = new Gcp.NetworkConnectivity.Hub("basic_hub", new()
    {
        Name = "hub1",
        Description = "A sample hub",
        Labels = 
        {
            { "label-two", "value-one" },
        },
    });

    var primary = new Gcp.NetworkConnectivity.Spoke("primary", new()
    {
        Name = "spoke1",
        Location = "global",
        Description = "A sample spoke with a linked router appliance instance",
        Labels = 
        {
            { "label-one", "value-one" },
        },
        Hub = basicHub.Id,
        LinkedVpcNetwork = new Gcp.NetworkConnectivity.Inputs.SpokeLinkedVpcNetworkArgs
        {
            ExcludeExportRanges = new[]
            {
                "198.51.100.0/24",
                "10.10.0.0/16",
            },
            IncludeExportRanges = new[]
            {
                "198.51.100.0/23",
                "10.0.0.0/8",
            },
            Uri = network.SelfLink,
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkconnectivity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
			Name:                  pulumi.String("net"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		basicHub, err := networkconnectivity.NewHub(ctx, "basic_hub", &networkconnectivity.HubArgs{
			Name:        pulumi.String("hub1"),
			Description: pulumi.String("A sample hub"),
			Labels: pulumi.StringMap{
				"label-two": pulumi.String("value-one"),
			},
		})
		if err != nil {
			return err
		}
		_, err = networkconnectivity.NewSpoke(ctx, "primary", &networkconnectivity.SpokeArgs{
			Name:        pulumi.String("spoke1"),
			Location:    pulumi.String("global"),
			Description: pulumi.String("A sample spoke with a linked router appliance instance"),
			Labels: pulumi.StringMap{
				"label-one": pulumi.String("value-one"),
			},
			Hub: basicHub.ID(),
			LinkedVpcNetwork: &networkconnectivity.SpokeLinkedVpcNetworkArgs{
				ExcludeExportRanges: pulumi.StringArray{
					pulumi.String("198.51.100.0/24"),
					pulumi.String("10.10.0.0/16"),
				},
				IncludeExportRanges: pulumi.StringArray{
					pulumi.String("198.51.100.0/23"),
					pulumi.String("10.0.0.0/8"),
				},
				Uri: network.SelfLink,
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.networkconnectivity.Hub;
import com.pulumi.gcp.networkconnectivity.HubArgs;
import com.pulumi.gcp.networkconnectivity.Spoke;
import com.pulumi.gcp.networkconnectivity.SpokeArgs;
import com.pulumi.gcp.networkconnectivity.inputs.SpokeLinkedVpcNetworkArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var network = new Network("network", NetworkArgs.builder()
            .name("net")
            .autoCreateSubnetworks(false)
            .build());

        var basicHub = new Hub("basicHub", HubArgs.builder()
            .name("hub1")
            .description("A sample hub")
            .labels(Map.of("label-two", "value-one"))
            .build());

        var primary = new Spoke("primary", SpokeArgs.builder()
            .name("spoke1")
            .location("global")
            .description("A sample spoke with a linked router appliance instance")
            .labels(Map.of("label-one", "value-one"))
            .hub(basicHub.id())
            .linkedVpcNetwork(SpokeLinkedVpcNetworkArgs.builder()
                .excludeExportRanges(                
                    "198.51.100.0/24",
                    "10.10.0.0/16")
                .includeExportRanges(                
                    "198.51.100.0/23",
                    "10.0.0.0/8")
                .uri(network.selfLink())
                .build())
            .build());

    }
}
```
```yaml
resources:
  network:
    type: gcp:compute:Network
    properties:
      name: net
      autoCreateSubnetworks: false
  basicHub:
    type: gcp:networkconnectivity:Hub
    name: basic_hub
    properties:
      name: hub1
      description: A sample hub
      labels:
        label-two: value-one
  primary:
    type: gcp:networkconnectivity:Spoke
    properties:
      name: spoke1
      location: global
      description: A sample spoke with a linked router appliance instance
      labels:
        label-one: value-one
      hub: ${basicHub.id}
      linkedVpcNetwork:
        excludeExportRanges:
          - 198.51.100.0/24
          - 10.10.0.0/16
        includeExportRanges:
          - 198.51.100.0/23
          - 10.0.0.0/8
        uri: ${network.selfLink}
```
<!--End PulumiCodeChooser -->
### Network Connectivity Spoke Router Appliance Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const network = new gcp.compute.Network("network", {
    name: "tf-test-network_55138",
    autoCreateSubnetworks: false,
});
const subnetwork = new gcp.compute.Subnetwork("subnetwork", {
    name: "tf-test-subnet_37559",
    ipCidrRange: "10.0.0.0/28",
    region: "us-central1",
    network: network.selfLink,
});
const instance = new gcp.compute.Instance("instance", {
    name: "tf-test-instance_91980",
    machineType: "e2-medium",
    canIpForward: true,
    zone: "us-central1-a",
    bootDisk: {
        initializeParams: {
            image: "projects/debian-cloud/global/images/debian-10-buster-v20210817",
        },
    },
    networkInterfaces: [{
        subnetwork: subnetwork.name,
        networkIp: "10.0.0.2",
        accessConfigs: [{
            networkTier: "PREMIUM",
        }],
    }],
});
const basicHub = new gcp.networkconnectivity.Hub("basic_hub", {
    name: "tf-test-hub_37118",
    description: "A sample hub",
    labels: {
        "label-two": "value-one",
    },
});
const primary = new gcp.networkconnectivity.Spoke("primary", {
    name: "tf-test-name_80332",
    location: "us-central1",
    description: "A sample spoke with a linked routher appliance instance",
    labels: {
        "label-one": "value-one",
    },
    hub: basicHub.id,
    linkedRouterApplianceInstances: {
        instances: [{
            virtualMachine: instance.selfLink,
            ipAddress: "10.0.0.2",
        }],
        siteToSiteDataTransfer: true,
        includeImportRanges: ["ALL_IPV4_RANGES"],
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

network = gcp.compute.Network("network",
    name="tf-test-network_55138",
    auto_create_subnetworks=False)
subnetwork = gcp.compute.Subnetwork("subnetwork",
    name="tf-test-subnet_37559",
    ip_cidr_range="10.0.0.0/28",
    region="us-central1",
    network=network.self_link)
instance = gcp.compute.Instance("instance",
    name="tf-test-instance_91980",
    machine_type="e2-medium",
    can_ip_forward=True,
    zone="us-central1-a",
    boot_disk={
        "initialize_params": {
            "image": "projects/debian-cloud/global/images/debian-10-buster-v20210817",
        },
    },
    network_interfaces=[{
        "subnetwork": subnetwork.name,
        "network_ip": "10.0.0.2",
        "access_configs": [{
            "network_tier": "PREMIUM",
        }],
    }])
basic_hub = gcp.networkconnectivity.Hub("basic_hub",
    name="tf-test-hub_37118",
    description="A sample hub",
    labels={
        "label-two": "value-one",
    })
primary = gcp.networkconnectivity.Spoke("primary",
    name="tf-test-name_80332",
    location="us-central1",
    description="A sample spoke with a linked routher appliance instance",
    labels={
        "label-one": "value-one",
    },
    hub=basic_hub.id,
    linked_router_appliance_instances={
        "instances": [{
            "virtual_machine": instance.self_link,
            "ip_address": "10.0.0.2",
        }],
        "site_to_site_data_transfer": True,
        "include_import_ranges": ["ALL_IPV4_RANGES"],
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var network = new Gcp.Compute.Network("network", new()
    {
        Name = "tf-test-network_55138",
        AutoCreateSubnetworks = false,
    });

    var subnetwork = new Gcp.Compute.Subnetwork("subnetwork", new()
    {
        Name = "tf-test-subnet_37559",
        IpCidrRange = "10.0.0.0/28",
        Region = "us-central1",
        Network = network.SelfLink,
    });

    var instance = new Gcp.Compute.Instance("instance", new()
    {
        Name = "tf-test-instance_91980",
        MachineType = "e2-medium",
        CanIpForward = true,
        Zone = "us-central1-a",
        BootDisk = new Gcp.Compute.Inputs.InstanceBootDiskArgs
        {
            InitializeParams = new Gcp.Compute.Inputs.InstanceBootDiskInitializeParamsArgs
            {
                Image = "projects/debian-cloud/global/images/debian-10-buster-v20210817",
            },
        },
        NetworkInterfaces = new[]
        {
            new Gcp.Compute.Inputs.InstanceNetworkInterfaceArgs
            {
                Subnetwork = subnetwork.Name,
                NetworkIp = "10.0.0.2",
                AccessConfigs = new[]
                {
                    new Gcp.Compute.Inputs.InstanceNetworkInterfaceAccessConfigArgs
                    {
                        NetworkTier = "PREMIUM",
                    },
                },
            },
        },
    });

    var basicHub = new Gcp.NetworkConnectivity.Hub("basic_hub", new()
    {
        Name = "tf-test-hub_37118",
        Description = "A sample hub",
        Labels = 
        {
            { "label-two", "value-one" },
        },
    });

    var primary = new Gcp.NetworkConnectivity.Spoke("primary", new()
    {
        Name = "tf-test-name_80332",
        Location = "us-central1",
        Description = "A sample spoke with a linked routher appliance instance",
        Labels = 
        {
            { "label-one", "value-one" },
        },
        Hub = basicHub.Id,
        LinkedRouterApplianceInstances = new Gcp.NetworkConnectivity.Inputs.SpokeLinkedRouterApplianceInstancesArgs
        {
            Instances = new[]
            {
                new Gcp.NetworkConnectivity.Inputs.SpokeLinkedRouterApplianceInstancesInstanceArgs
                {
                    VirtualMachine = instance.SelfLink,
                    IpAddress = "10.0.0.2",
                },
            },
            SiteToSiteDataTransfer = true,
            IncludeImportRanges = new[]
            {
                "ALL_IPV4_RANGES",
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkconnectivity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
			Name:                  pulumi.String("tf-test-network_55138"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		subnetwork, err := compute.NewSubnetwork(ctx, "subnetwork", &compute.SubnetworkArgs{
			Name:        pulumi.String("tf-test-subnet_37559"),
			IpCidrRange: pulumi.String("10.0.0.0/28"),
			Region:      pulumi.String("us-central1"),
			Network:     network.SelfLink,
		})
		if err != nil {
			return err
		}
		instance, err := compute.NewInstance(ctx, "instance", &compute.InstanceArgs{
			Name:         pulumi.String("tf-test-instance_91980"),
			MachineType:  pulumi.String("e2-medium"),
			CanIpForward: pulumi.Bool(true),
			Zone:         pulumi.String("us-central1-a"),
			BootDisk: &compute.InstanceBootDiskArgs{
				InitializeParams: &compute.InstanceBootDiskInitializeParamsArgs{
					Image: pulumi.String("projects/debian-cloud/global/images/debian-10-buster-v20210817"),
				},
			},
			NetworkInterfaces: compute.InstanceNetworkInterfaceArray{
				&compute.InstanceNetworkInterfaceArgs{
					Subnetwork: subnetwork.Name,
					NetworkIp:  pulumi.String("10.0.0.2"),
					AccessConfigs: compute.InstanceNetworkInterfaceAccessConfigArray{
						&compute.InstanceNetworkInterfaceAccessConfigArgs{
							NetworkTier: pulumi.String("PREMIUM"),
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		basicHub, err := networkconnectivity.NewHub(ctx, "basic_hub", &networkconnectivity.HubArgs{
			Name:        pulumi.String("tf-test-hub_37118"),
			Description: pulumi.String("A sample hub"),
			Labels: pulumi.StringMap{
				"label-two": pulumi.String("value-one"),
			},
		})
		if err != nil {
			return err
		}
		_, err = networkconnectivity.NewSpoke(ctx, "primary", &networkconnectivity.SpokeArgs{
			Name:        pulumi.String("tf-test-name_80332"),
			Location:    pulumi.String("us-central1"),
			Description: pulumi.String("A sample spoke with a linked routher appliance instance"),
			Labels: pulumi.StringMap{
				"label-one": pulumi.String("value-one"),
			},
			Hub: basicHub.ID(),
			LinkedRouterApplianceInstances: &networkconnectivity.SpokeLinkedRouterApplianceInstancesArgs{
				Instances: networkconnectivity.SpokeLinkedRouterApplianceInstancesInstanceArray{
					&networkconnectivity.SpokeLinkedRouterApplianceInstancesInstanceArgs{
						VirtualMachine: instance.SelfLink,
						IpAddress:      pulumi.String("10.0.0.2"),
					},
				},
				SiteToSiteDataTransfer: pulumi.Bool(true),
				IncludeImportRanges: pulumi.StringArray{
					pulumi.String("ALL_IPV4_RANGES"),
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.Subnetwork;
import com.pulumi.gcp.compute.SubnetworkArgs;
import com.pulumi.gcp.compute.Instance;
import com.pulumi.gcp.compute.InstanceArgs;
import com.pulumi.gcp.compute.inputs.InstanceBootDiskArgs;
import com.pulumi.gcp.compute.inputs.InstanceBootDiskInitializeParamsArgs;
import com.pulumi.gcp.compute.inputs.InstanceNetworkInterfaceArgs;
import com.pulumi.gcp.networkconnectivity.Hub;
import com.pulumi.gcp.networkconnectivity.HubArgs;
import com.pulumi.gcp.networkconnectivity.Spoke;
import com.pulumi.gcp.networkconnectivity.SpokeArgs;
import com.pulumi.gcp.networkconnectivity.inputs.SpokeLinkedRouterApplianceInstancesArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var network = new Network("network", NetworkArgs.builder()
            .name("tf-test-network_55138")
            .autoCreateSubnetworks(false)
            .build());

        var subnetwork = new Subnetwork("subnetwork", SubnetworkArgs.builder()
            .name("tf-test-subnet_37559")
            .ipCidrRange("10.0.0.0/28")
            .region("us-central1")
            .network(network.selfLink())
            .build());

        var instance = new Instance("instance", InstanceArgs.builder()
            .name("tf-test-instance_91980")
            .machineType("e2-medium")
            .canIpForward(true)
            .zone("us-central1-a")
            .bootDisk(InstanceBootDiskArgs.builder()
                .initializeParams(InstanceBootDiskInitializeParamsArgs.builder()
                    .image("projects/debian-cloud/global/images/debian-10-buster-v20210817")
                    .build())
                .build())
            .networkInterfaces(InstanceNetworkInterfaceArgs.builder()
                .subnetwork(subnetwork.name())
                .networkIp("10.0.0.2")
                .accessConfigs(InstanceNetworkInterfaceAccessConfigArgs.builder()
                    .networkTier("PREMIUM")
                    .build())
                .build())
            .build());

        var basicHub = new Hub("basicHub", HubArgs.builder()
            .name("tf-test-hub_37118")
            .description("A sample hub")
            .labels(Map.of("label-two", "value-one"))
            .build());

        var primary = new Spoke("primary", SpokeArgs.builder()
            .name("tf-test-name_80332")
            .location("us-central1")
            .description("A sample spoke with a linked routher appliance instance")
            .labels(Map.of("label-one", "value-one"))
            .hub(basicHub.id())
            .linkedRouterApplianceInstances(SpokeLinkedRouterApplianceInstancesArgs.builder()
                .instances(SpokeLinkedRouterApplianceInstancesInstanceArgs.builder()
                    .virtualMachine(instance.selfLink())
                    .ipAddress("10.0.0.2")
                    .build())
                .siteToSiteDataTransfer(true)
                .includeImportRanges("ALL_IPV4_RANGES")
                .build())
            .build());

    }
}
```
```yaml
resources:
  network:
    type: gcp:compute:Network
    properties:
      name: tf-test-network_55138
      autoCreateSubnetworks: false
  subnetwork:
    type: gcp:compute:Subnetwork
    properties:
      name: tf-test-subnet_37559
      ipCidrRange: 10.0.0.0/28
      region: us-central1
      network: ${network.selfLink}
  instance:
    type: gcp:compute:Instance
    properties:
      name: tf-test-instance_91980
      machineType: e2-medium
      canIpForward: true
      zone: us-central1-a
      bootDisk:
        initializeParams:
          image: projects/debian-cloud/global/images/debian-10-buster-v20210817
      networkInterfaces:
        - subnetwork: ${subnetwork.name}
          networkIp: 10.0.0.2
          accessConfigs:
            - networkTier: PREMIUM
  basicHub:
    type: gcp:networkconnectivity:Hub
    name: basic_hub
    properties:
      name: tf-test-hub_37118
      description: A sample hub
      labels:
        label-two: value-one
  primary:
    type: gcp:networkconnectivity:Spoke
    properties:
      name: tf-test-name_80332
      location: us-central1
      description: A sample spoke with a linked routher appliance instance
      labels:
        label-one: value-one
      hub: ${basicHub.id}
      linkedRouterApplianceInstances:
        instances:
          - virtualMachine: ${instance.selfLink}
            ipAddress: 10.0.0.2
        siteToSiteDataTransfer: true
        includeImportRanges:
          - ALL_IPV4_RANGES
```
<!--End PulumiCodeChooser -->
### Network Connectivity Spoke Vpn Tunnel Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const basicHub = new gcp.networkconnectivity.Hub("basic_hub", {
    name: "basic-hub1",
    description: "A sample hub",
    labels: {
        "label-two": "value-one",
    },
});
const network = new gcp.compute.Network("network", {
    name: "basic-network",
    autoCreateSubnetworks: false,
});
const subnetwork = new gcp.compute.Subnetwork("subnetwork", {
    name: "basic-subnetwork",
    ipCidrRange: "10.0.0.0/28",
    region: "us-central1",
    network: network.selfLink,
});
const gateway = new gcp.compute.HaVpnGateway("gateway", {
    name: "vpn-gateway",
    network: network.id,
});
const externalVpnGw = new gcp.compute.ExternalVpnGateway("external_vpn_gw", {
    name: "external-vpn-gateway",
    redundancyType: "SINGLE_IP_INTERNALLY_REDUNDANT",
    description: "An externally managed VPN gateway",
    interfaces: [{
        id: 0,
        ipAddress: "8.8.8.8",
    }],
});
const router = new gcp.compute.Router("router", {
    name: "external-vpn-gateway",
    region: "us-central1",
    network: network.name,
    bgp: {
        asn: 64514,
    },
});
const tunnel1 = new gcp.compute.VPNTunnel("tunnel1", {
    name: "tunnel1",
    region: "us-central1",
    vpnGateway: gateway.id,
    peerExternalGateway: externalVpnGw.id,
    peerExternalGatewayInterface: 0,
    sharedSecret: "a secret message",
    router: router.id,
    vpnGatewayInterface: 0,
});
const tunnel2 = new gcp.compute.VPNTunnel("tunnel2", {
    name: "tunnel2",
    region: "us-central1",
    vpnGateway: gateway.id,
    peerExternalGateway: externalVpnGw.id,
    peerExternalGatewayInterface: 0,
    sharedSecret: "a secret message",
    router: pulumi.interpolate` ${router.id}`,
    vpnGatewayInterface: 1,
});
const routerInterface1 = new gcp.compute.RouterInterface("router_interface1", {
    name: "router-interface1",
    router: router.name,
    region: "us-central1",
    ipRange: "169.254.0.1/30",
    vpnTunnel: tunnel1.name,
});
const routerPeer1 = new gcp.compute.RouterPeer("router_peer1", {
    name: "router-peer1",
    router: router.name,
    region: "us-central1",
    peerIpAddress: "169.254.0.2",
    peerAsn: 64515,
    advertisedRoutePriority: 100,
    "interface": routerInterface1.name,
});
const routerInterface2 = new gcp.compute.RouterInterface("router_interface2", {
    name: "router-interface2",
    router: router.name,
    region: "us-central1",
    ipRange: "169.254.1.1/30",
    vpnTunnel: tunnel2.name,
});
const routerPeer2 = new gcp.compute.RouterPeer("router_peer2", {
    name: "router-peer2",
    router: router.name,
    region: "us-central1",
    peerIpAddress: "169.254.1.2",
    peerAsn: 64515,
    advertisedRoutePriority: 100,
    "interface": routerInterface2.name,
});
const tunnel1Spoke = new gcp.networkconnectivity.Spoke("tunnel1", {
    name: "vpn-tunnel-1-spoke",
    location: "us-central1",
    description: "A sample spoke with a linked VPN Tunnel",
    labels: {
        "label-one": "value-one",
    },
    hub: basicHub.id,
    linkedVpnTunnels: {
        uris: [tunnel1.selfLink],
        siteToSiteDataTransfer: true,
        includeImportRanges: ["ALL_IPV4_RANGES"],
    },
});
const tunnel2Spoke = new gcp.networkconnectivity.Spoke("tunnel2", {
    name: "vpn-tunnel-2-spoke",
    location: "us-central1",
    description: "A sample spoke with a linked VPN Tunnel",
    labels: {
        "label-one": "value-one",
    },
    hub: basicHub.id,
    linkedVpnTunnels: {
        uris: [tunnel2.selfLink],
        siteToSiteDataTransfer: true,
        includeImportRanges: ["ALL_IPV4_RANGES"],
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

basic_hub = gcp.networkconnectivity.Hub("basic_hub",
    name="basic-hub1",
    description="A sample hub",
    labels={
        "label-two": "value-one",
    })
network = gcp.compute.Network("network",
    name="basic-network",
    auto_create_subnetworks=False)
subnetwork = gcp.compute.Subnetwork("subnetwork",
    name="basic-subnetwork",
    ip_cidr_range="10.0.0.0/28",
    region="us-central1",
    network=network.self_link)
gateway = gcp.compute.HaVpnGateway("gateway",
    name="vpn-gateway",
    network=network.id)
external_vpn_gw = gcp.compute.ExternalVpnGateway("external_vpn_gw",
    name="external-vpn-gateway",
    redundancy_type="SINGLE_IP_INTERNALLY_REDUNDANT",
    description="An externally managed VPN gateway",
    interfaces=[{
        "id": 0,
        "ip_address": "8.8.8.8",
    }])
router = gcp.compute.Router("router",
    name="external-vpn-gateway",
    region="us-central1",
    network=network.name,
    bgp={
        "asn": 64514,
    })
tunnel1 = gcp.compute.VPNTunnel("tunnel1",
    name="tunnel1",
    region="us-central1",
    vpn_gateway=gateway.id,
    peer_external_gateway=external_vpn_gw.id,
    peer_external_gateway_interface=0,
    shared_secret="a secret message",
    router=router.id,
    vpn_gateway_interface=0)
tunnel2 = gcp.compute.VPNTunnel("tunnel2",
    name="tunnel2",
    region="us-central1",
    vpn_gateway=gateway.id,
    peer_external_gateway=external_vpn_gw.id,
    peer_external_gateway_interface=0,
    shared_secret="a secret message",
    router=router.id.apply(lambda id: f" {id}"),
    vpn_gateway_interface=1)
router_interface1 = gcp.compute.RouterInterface("router_interface1",
    name="router-interface1",
    router=router.name,
    region="us-central1",
    ip_range="169.254.0.1/30",
    vpn_tunnel=tunnel1.name)
router_peer1 = gcp.compute.RouterPeer("router_peer1",
    name="router-peer1",
    router=router.name,
    region="us-central1",
    peer_ip_address="169.254.0.2",
    peer_asn=64515,
    advertised_route_priority=100,
    interface=router_interface1.name)
router_interface2 = gcp.compute.RouterInterface("router_interface2",
    name="router-interface2",
    router=router.name,
    region="us-central1",
    ip_range="169.254.1.1/30",
    vpn_tunnel=tunnel2.name)
router_peer2 = gcp.compute.RouterPeer("router_peer2",
    name="router-peer2",
    router=router.name,
    region="us-central1",
    peer_ip_address="169.254.1.2",
    peer_asn=64515,
    advertised_route_priority=100,
    interface=router_interface2.name)
tunnel1_spoke = gcp.networkconnectivity.Spoke("tunnel1",
    name="vpn-tunnel-1-spoke",
    location="us-central1",
    description="A sample spoke with a linked VPN Tunnel",
    labels={
        "label-one": "value-one",
    },
    hub=basic_hub.id,
    linked_vpn_tunnels={
        "uris": [tunnel1.self_link],
        "site_to_site_data_transfer": True,
        "include_import_ranges": ["ALL_IPV4_RANGES"],
    })
tunnel2_spoke = gcp.networkconnectivity.Spoke("tunnel2",
    name="vpn-tunnel-2-spoke",
    location="us-central1",
    description="A sample spoke with a linked VPN Tunnel",
    labels={
        "label-one": "value-one",
    },
    hub=basic_hub.id,
    linked_vpn_tunnels={
        "uris": [tunnel2.self_link],
        "site_to_site_data_transfer": True,
        "include_import_ranges": ["ALL_IPV4_RANGES"],
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var basicHub = new Gcp.NetworkConnectivity.Hub("basic_hub", new()
    {
        Name = "basic-hub1",
        Description = "A sample hub",
        Labels = 
        {
            { "label-two", "value-one" },
        },
    });

    var network = new Gcp.Compute.Network("network", new()
    {
        Name = "basic-network",
        AutoCreateSubnetworks = false,
    });

    var subnetwork = new Gcp.Compute.Subnetwork("subnetwork", new()
    {
        Name = "basic-subnetwork",
        IpCidrRange = "10.0.0.0/28",
        Region = "us-central1",
        Network = network.SelfLink,
    });

    var gateway = new Gcp.Compute.HaVpnGateway("gateway", new()
    {
        Name = "vpn-gateway",
        Network = network.Id,
    });

    var externalVpnGw = new Gcp.Compute.ExternalVpnGateway("external_vpn_gw", new()
    {
        Name = "external-vpn-gateway",
        RedundancyType = "SINGLE_IP_INTERNALLY_REDUNDANT",
        Description = "An externally managed VPN gateway",
        Interfaces = new[]
        {
            new Gcp.Compute.Inputs.ExternalVpnGatewayInterfaceArgs
            {
                Id = 0,
                IpAddress = "8.8.8.8",
            },
        },
    });

    var router = new Gcp.Compute.Router("router", new()
    {
        Name = "external-vpn-gateway",
        Region = "us-central1",
        Network = network.Name,
        Bgp = new Gcp.Compute.Inputs.RouterBgpArgs
        {
            Asn = 64514,
        },
    });

    var tunnel1 = new Gcp.Compute.VPNTunnel("tunnel1", new()
    {
        Name = "tunnel1",
        Region = "us-central1",
        VpnGateway = gateway.Id,
        PeerExternalGateway = externalVpnGw.Id,
        PeerExternalGatewayInterface = 0,
        SharedSecret = "a secret message",
        Router = router.Id,
        VpnGatewayInterface = 0,
    });

    var tunnel2 = new Gcp.Compute.VPNTunnel("tunnel2", new()
    {
        Name = "tunnel2",
        Region = "us-central1",
        VpnGateway = gateway.Id,
        PeerExternalGateway = externalVpnGw.Id,
        PeerExternalGatewayInterface = 0,
        SharedSecret = "a secret message",
        Router = router.Id.Apply(id => $" {id}"),
        VpnGatewayInterface = 1,
    });

    var routerInterface1 = new Gcp.Compute.RouterInterface("router_interface1", new()
    {
        Name = "router-interface1",
        Router = router.Name,
        Region = "us-central1",
        IpRange = "169.254.0.1/30",
        VpnTunnel = tunnel1.Name,
    });

    var routerPeer1 = new Gcp.Compute.RouterPeer("router_peer1", new()
    {
        Name = "router-peer1",
        Router = router.Name,
        Region = "us-central1",
        PeerIpAddress = "169.254.0.2",
        PeerAsn = 64515,
        AdvertisedRoutePriority = 100,
        Interface = routerInterface1.Name,
    });

    var routerInterface2 = new Gcp.Compute.RouterInterface("router_interface2", new()
    {
        Name = "router-interface2",
        Router = router.Name,
        Region = "us-central1",
        IpRange = "169.254.1.1/30",
        VpnTunnel = tunnel2.Name,
    });

    var routerPeer2 = new Gcp.Compute.RouterPeer("router_peer2", new()
    {
        Name = "router-peer2",
        Router = router.Name,
        Region = "us-central1",
        PeerIpAddress = "169.254.1.2",
        PeerAsn = 64515,
        AdvertisedRoutePriority = 100,
        Interface = routerInterface2.Name,
    });

    var tunnel1Spoke = new Gcp.NetworkConnectivity.Spoke("tunnel1", new()
    {
        Name = "vpn-tunnel-1-spoke",
        Location = "us-central1",
        Description = "A sample spoke with a linked VPN Tunnel",
        Labels = 
        {
            { "label-one", "value-one" },
        },
        Hub = basicHub.Id,
        LinkedVpnTunnels = new Gcp.NetworkConnectivity.Inputs.SpokeLinkedVpnTunnelsArgs
        {
            Uris = new[]
            {
                tunnel1.SelfLink,
            },
            SiteToSiteDataTransfer = true,
            IncludeImportRanges = new[]
            {
                "ALL_IPV4_RANGES",
            },
        },
    });

    var tunnel2Spoke = new Gcp.NetworkConnectivity.Spoke("tunnel2", new()
    {
        Name = "vpn-tunnel-2-spoke",
        Location = "us-central1",
        Description = "A sample spoke with a linked VPN Tunnel",
        Labels = 
        {
            { "label-one", "value-one" },
        },
        Hub = basicHub.Id,
        LinkedVpnTunnels = new Gcp.NetworkConnectivity.Inputs.SpokeLinkedVpnTunnelsArgs
        {
            Uris = new[]
            {
                tunnel2.SelfLink,
            },
            SiteToSiteDataTransfer = true,
            IncludeImportRanges = new[]
            {
                "ALL_IPV4_RANGES",
            },
        },
    });

});
```
```go
package main

import (
	"fmt"

	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkconnectivity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		basicHub, err := networkconnectivity.NewHub(ctx, "basic_hub", &networkconnectivity.HubArgs{
			Name:        pulumi.String("basic-hub1"),
			Description: pulumi.String("A sample hub"),
			Labels: pulumi.StringMap{
				"label-two": pulumi.String("value-one"),
			},
		})
		if err != nil {
			return err
		}
		network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
			Name:                  pulumi.String("basic-network"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		_, err = compute.NewSubnetwork(ctx, "subnetwork", &compute.SubnetworkArgs{
			Name:        pulumi.String("basic-subnetwork"),
			IpCidrRange: pulumi.String("10.0.0.0/28"),
			Region:      pulumi.String("us-central1"),
			Network:     network.SelfLink,
		})
		if err != nil {
			return err
		}
		gateway, err := compute.NewHaVpnGateway(ctx, "gateway", &compute.HaVpnGatewayArgs{
			Name:    pulumi.String("vpn-gateway"),
			Network: network.ID(),
		})
		if err != nil {
			return err
		}
		externalVpnGw, err := compute.NewExternalVpnGateway(ctx, "external_vpn_gw", &compute.ExternalVpnGatewayArgs{
			Name:           pulumi.String("external-vpn-gateway"),
			RedundancyType: pulumi.String("SINGLE_IP_INTERNALLY_REDUNDANT"),
			Description:    pulumi.String("An externally managed VPN gateway"),
			Interfaces: compute.ExternalVpnGatewayInterfaceArray{
				&compute.ExternalVpnGatewayInterfaceArgs{
					Id:        pulumi.Int(0),
					IpAddress: pulumi.String("8.8.8.8"),
				},
			},
		})
		if err != nil {
			return err
		}
		router, err := compute.NewRouter(ctx, "router", &compute.RouterArgs{
			Name:    pulumi.String("external-vpn-gateway"),
			Region:  pulumi.String("us-central1"),
			Network: network.Name,
			Bgp: &compute.RouterBgpArgs{
				Asn: pulumi.Int(64514),
			},
		})
		if err != nil {
			return err
		}
		tunnel1, err := compute.NewVPNTunnel(ctx, "tunnel1", &compute.VPNTunnelArgs{
			Name:                         pulumi.String("tunnel1"),
			Region:                       pulumi.String("us-central1"),
			VpnGateway:                   gateway.ID(),
			PeerExternalGateway:          externalVpnGw.ID(),
			PeerExternalGatewayInterface: pulumi.Int(0),
			SharedSecret:                 pulumi.String("a secret message"),
			Router:                       router.ID(),
			VpnGatewayInterface:          pulumi.Int(0),
		})
		if err != nil {
			return err
		}
		tunnel2, err := compute.NewVPNTunnel(ctx, "tunnel2", &compute.VPNTunnelArgs{
			Name:                         pulumi.String("tunnel2"),
			Region:                       pulumi.String("us-central1"),
			VpnGateway:                   gateway.ID(),
			PeerExternalGateway:          externalVpnGw.ID(),
			PeerExternalGatewayInterface: pulumi.Int(0),
			SharedSecret:                 pulumi.String("a secret message"),
			Router: router.ID().ApplyT(func(id string) (string, error) {
				return fmt.Sprintf(" %v", id), nil
			}).(pulumi.StringOutput),
			VpnGatewayInterface: pulumi.Int(1),
		})
		if err != nil {
			return err
		}
		routerInterface1, err := compute.NewRouterInterface(ctx, "router_interface1", &compute.RouterInterfaceArgs{
			Name:      pulumi.String("router-interface1"),
			Router:    router.Name,
			Region:    pulumi.String("us-central1"),
			IpRange:   pulumi.String("169.254.0.1/30"),
			VpnTunnel: tunnel1.Name,
		})
		if err != nil {
			return err
		}
		_, err = compute.NewRouterPeer(ctx, "router_peer1", &compute.RouterPeerArgs{
			Name:                    pulumi.String("router-peer1"),
			Router:                  router.Name,
			Region:                  pulumi.String("us-central1"),
			PeerIpAddress:           pulumi.String("169.254.0.2"),
			PeerAsn:                 pulumi.Int(64515),
			AdvertisedRoutePriority: pulumi.Int(100),
			Interface:               routerInterface1.Name,
		})
		if err != nil {
			return err
		}
		routerInterface2, err := compute.NewRouterInterface(ctx, "router_interface2", &compute.RouterInterfaceArgs{
			Name:      pulumi.String("router-interface2"),
			Router:    router.Name,
			Region:    pulumi.String("us-central1"),
			IpRange:   pulumi.String("169.254.1.1/30"),
			VpnTunnel: tunnel2.Name,
		})
		if err != nil {
			return err
		}
		_, err = compute.NewRouterPeer(ctx, "router_peer2", &compute.RouterPeerArgs{
			Name:                    pulumi.String("router-peer2"),
			Router:                  router.Name,
			Region:                  pulumi.String("us-central1"),
			PeerIpAddress:           pulumi.String("169.254.1.2"),
			PeerAsn:                 pulumi.Int(64515),
			AdvertisedRoutePriority: pulumi.Int(100),
			Interface:               routerInterface2.Name,
		})
		if err != nil {
			return err
		}
		_, err = networkconnectivity.NewSpoke(ctx, "tunnel1", &networkconnectivity.SpokeArgs{
			Name:        pulumi.String("vpn-tunnel-1-spoke"),
			Location:    pulumi.String("us-central1"),
			Description: pulumi.String("A sample spoke with a linked VPN Tunnel"),
			Labels: pulumi.StringMap{
				"label-one": pulumi.String("value-one"),
			},
			Hub: basicHub.ID(),
			LinkedVpnTunnels: &networkconnectivity.SpokeLinkedVpnTunnelsArgs{
				Uris: pulumi.StringArray{
					tunnel1.SelfLink,
				},
				SiteToSiteDataTransfer: pulumi.Bool(true),
				IncludeImportRanges: pulumi.StringArray{
					pulumi.String("ALL_IPV4_RANGES"),
				},
			},
		})
		if err != nil {
			return err
		}
		_, err = networkconnectivity.NewSpoke(ctx, "tunnel2", &networkconnectivity.SpokeArgs{
			Name:        pulumi.String("vpn-tunnel-2-spoke"),
			Location:    pulumi.String("us-central1"),
			Description: pulumi.String("A sample spoke with a linked VPN Tunnel"),
			Labels: pulumi.StringMap{
				"label-one": pulumi.String("value-one"),
			},
			Hub: basicHub.ID(),
			LinkedVpnTunnels: &networkconnectivity.SpokeLinkedVpnTunnelsArgs{
				Uris: pulumi.StringArray{
					tunnel2.SelfLink,
				},
				SiteToSiteDataTransfer: pulumi.Bool(true),
				IncludeImportRanges: pulumi.StringArray{
					pulumi.String("ALL_IPV4_RANGES"),
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networkconnectivity.Hub;
import com.pulumi.gcp.networkconnectivity.HubArgs;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.Subnetwork;
import com.pulumi.gcp.compute.SubnetworkArgs;
import com.pulumi.gcp.compute.HaVpnGateway;
import com.pulumi.gcp.compute.HaVpnGatewayArgs;
import com.pulumi.gcp.compute.ExternalVpnGateway;
import com.pulumi.gcp.compute.ExternalVpnGatewayArgs;
import com.pulumi.gcp.compute.inputs.ExternalVpnGatewayInterfaceArgs;
import com.pulumi.gcp.compute.Router;
import com.pulumi.gcp.compute.RouterArgs;
import com.pulumi.gcp.compute.inputs.RouterBgpArgs;
import com.pulumi.gcp.compute.VPNTunnel;
import com.pulumi.gcp.compute.VPNTunnelArgs;
import com.pulumi.gcp.compute.RouterInterface;
import com.pulumi.gcp.compute.RouterInterfaceArgs;
import com.pulumi.gcp.compute.RouterPeer;
import com.pulumi.gcp.compute.RouterPeerArgs;
import com.pulumi.gcp.networkconnectivity.Spoke;
import com.pulumi.gcp.networkconnectivity.SpokeArgs;
import com.pulumi.gcp.networkconnectivity.inputs.SpokeLinkedVpnTunnelsArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var basicHub = new Hub("basicHub", HubArgs.builder()
            .name("basic-hub1")
            .description("A sample hub")
            .labels(Map.of("label-two", "value-one"))
            .build());

        var network = new Network("network", NetworkArgs.builder()
            .name("basic-network")
            .autoCreateSubnetworks(false)
            .build());

        var subnetwork = new Subnetwork("subnetwork", SubnetworkArgs.builder()
            .name("basic-subnetwork")
            .ipCidrRange("10.0.0.0/28")
            .region("us-central1")
            .network(network.selfLink())
            .build());

        var gateway = new HaVpnGateway("gateway", HaVpnGatewayArgs.builder()
            .name("vpn-gateway")
            .network(network.id())
            .build());

        var externalVpnGw = new ExternalVpnGateway("externalVpnGw", ExternalVpnGatewayArgs.builder()
            .name("external-vpn-gateway")
            .redundancyType("SINGLE_IP_INTERNALLY_REDUNDANT")
            .description("An externally managed VPN gateway")
            .interfaces(ExternalVpnGatewayInterfaceArgs.builder()
                .id(0)
                .ipAddress("8.8.8.8")
                .build())
            .build());

        var router = new Router("router", RouterArgs.builder()
            .name("external-vpn-gateway")
            .region("us-central1")
            .network(network.name())
            .bgp(RouterBgpArgs.builder()
                .asn(64514)
                .build())
            .build());

        var tunnel1 = new VPNTunnel("tunnel1", VPNTunnelArgs.builder()
            .name("tunnel1")
            .region("us-central1")
            .vpnGateway(gateway.id())
            .peerExternalGateway(externalVpnGw.id())
            .peerExternalGatewayInterface(0)
            .sharedSecret("a secret message")
            .router(router.id())
            .vpnGatewayInterface(0)
            .build());

        var tunnel2 = new VPNTunnel("tunnel2", VPNTunnelArgs.builder()
            .name("tunnel2")
            .region("us-central1")
            .vpnGateway(gateway.id())
            .peerExternalGateway(externalVpnGw.id())
            .peerExternalGatewayInterface(0)
            .sharedSecret("a secret message")
            .router(router.id().applyValue(id -> String.format(" %s", id)))
            .vpnGatewayInterface(1)
            .build());

        var routerInterface1 = new RouterInterface("routerInterface1", RouterInterfaceArgs.builder()
            .name("router-interface1")
            .router(router.name())
            .region("us-central1")
            .ipRange("169.254.0.1/30")
            .vpnTunnel(tunnel1.name())
            .build());

        var routerPeer1 = new RouterPeer("routerPeer1", RouterPeerArgs.builder()
            .name("router-peer1")
            .router(router.name())
            .region("us-central1")
            .peerIpAddress("169.254.0.2")
            .peerAsn(64515)
            .advertisedRoutePriority(100)
            .interface_(routerInterface1.name())
            .build());

        var routerInterface2 = new RouterInterface("routerInterface2", RouterInterfaceArgs.builder()
            .name("router-interface2")
            .router(router.name())
            .region("us-central1")
            .ipRange("169.254.1.1/30")
            .vpnTunnel(tunnel2.name())
            .build());

        var routerPeer2 = new RouterPeer("routerPeer2", RouterPeerArgs.builder()
            .name("router-peer2")
            .router(router.name())
            .region("us-central1")
            .peerIpAddress("169.254.1.2")
            .peerAsn(64515)
            .advertisedRoutePriority(100)
            .interface_(routerInterface2.name())
            .build());

        var tunnel1Spoke = new Spoke("tunnel1Spoke", SpokeArgs.builder()
            .name("vpn-tunnel-1-spoke")
            .location("us-central1")
            .description("A sample spoke with a linked VPN Tunnel")
            .labels(Map.of("label-one", "value-one"))
            .hub(basicHub.id())
            .linkedVpnTunnels(SpokeLinkedVpnTunnelsArgs.builder()
                .uris(tunnel1.selfLink())
                .siteToSiteDataTransfer(true)
                .includeImportRanges("ALL_IPV4_RANGES")
                .build())
            .build());

        var tunnel2Spoke = new Spoke("tunnel2Spoke", SpokeArgs.builder()
            .name("vpn-tunnel-2-spoke")
            .location("us-central1")
            .description("A sample spoke with a linked VPN Tunnel")
            .labels(Map.of("label-one", "value-one"))
            .hub(basicHub.id())
            .linkedVpnTunnels(SpokeLinkedVpnTunnelsArgs.builder()
                .uris(tunnel2.selfLink())
                .siteToSiteDataTransfer(true)
                .includeImportRanges("ALL_IPV4_RANGES")
                .build())
            .build());

    }
}
```
```yaml
resources:
  basicHub:
    type: gcp:networkconnectivity:Hub
    name: basic_hub
    properties:
      name: basic-hub1
      description: A sample hub
      labels:
        label-two: value-one
  network:
    type: gcp:compute:Network
    properties:
      name: basic-network
      autoCreateSubnetworks: false
  subnetwork:
    type: gcp:compute:Subnetwork
    properties:
      name: basic-subnetwork
      ipCidrRange: 10.0.0.0/28
      region: us-central1
      network: ${network.selfLink}
  gateway:
    type: gcp:compute:HaVpnGateway
    properties:
      name: vpn-gateway
      network: ${network.id}
  externalVpnGw:
    type: gcp:compute:ExternalVpnGateway
    name: external_vpn_gw
    properties:
      name: external-vpn-gateway
      redundancyType: SINGLE_IP_INTERNALLY_REDUNDANT
      description: An externally managed VPN gateway
      interfaces:
        - id: 0
          ipAddress: 8.8.8.8
  router:
    type: gcp:compute:Router
    properties:
      name: external-vpn-gateway
      region: us-central1
      network: ${network.name}
      bgp:
        asn: 64514
  tunnel1:
    type: gcp:compute:VPNTunnel
    properties:
      name: tunnel1
      region: us-central1
      vpnGateway: ${gateway.id}
      peerExternalGateway: ${externalVpnGw.id}
      peerExternalGatewayInterface: 0
      sharedSecret: a secret message
      router: ${router.id}
      vpnGatewayInterface: 0
  tunnel2:
    type: gcp:compute:VPNTunnel
    properties:
      name: tunnel2
      region: us-central1
      vpnGateway: ${gateway.id}
      peerExternalGateway: ${externalVpnGw.id}
      peerExternalGatewayInterface: 0
      sharedSecret: a secret message
      router: ' ${router.id}'
      vpnGatewayInterface: 1
  routerInterface1:
    type: gcp:compute:RouterInterface
    name: router_interface1
    properties:
      name: router-interface1
      router: ${router.name}
      region: us-central1
      ipRange: 169.254.0.1/30
      vpnTunnel: ${tunnel1.name}
  routerPeer1:
    type: gcp:compute:RouterPeer
    name: router_peer1
    properties:
      name: router-peer1
      router: ${router.name}
      region: us-central1
      peerIpAddress: 169.254.0.2
      peerAsn: 64515
      advertisedRoutePriority: 100
      interface: ${routerInterface1.name}
  routerInterface2:
    type: gcp:compute:RouterInterface
    name: router_interface2
    properties:
      name: router-interface2
      router: ${router.name}
      region: us-central1
      ipRange: 169.254.1.1/30
      vpnTunnel: ${tunnel2.name}
  routerPeer2:
    type: gcp:compute:RouterPeer
    name: router_peer2
    properties:
      name: router-peer2
      router: ${router.name}
      region: us-central1
      peerIpAddress: 169.254.1.2
      peerAsn: 64515
      advertisedRoutePriority: 100
      interface: ${routerInterface2.name}
  tunnel1Spoke:
    type: gcp:networkconnectivity:Spoke
    name: tunnel1
    properties:
      name: vpn-tunnel-1-spoke
      location: us-central1
      description: A sample spoke with a linked VPN Tunnel
      labels:
        label-one: value-one
      hub: ${basicHub.id}
      linkedVpnTunnels:
        uris:
          - ${tunnel1.selfLink}
        siteToSiteDataTransfer: true
        includeImportRanges:
          - ALL_IPV4_RANGES
  tunnel2Spoke:
    type: gcp:networkconnectivity:Spoke
    name: tunnel2
    properties:
      name: vpn-tunnel-2-spoke
      location: us-central1
      description: A sample spoke with a linked VPN Tunnel
      labels:
        label-one: value-one
      hub: ${basicHub.id}
      linkedVpnTunnels:
        uris:
          - ${tunnel2.selfLink}
        siteToSiteDataTransfer: true
        includeImportRanges:
          - ALL_IPV4_RANGES
```
<!--End PulumiCodeChooser -->
### Network Connectivity Spoke Interconnect Attachment Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const basicHub = new gcp.networkconnectivity.Hub("basic_hub", {
    name: "basic-hub1",
    description: "A sample hub",
    labels: {
        "label-two": "value-one",
    },
});
const network = new gcp.compute.Network("network", {
    name: "basic-network",
    autoCreateSubnetworks: false,
});
const router = new gcp.compute.Router("router", {
    name: "external-vpn-gateway",
    region: "us-central1",
    network: network.name,
    bgp: {
        asn: 16550,
    },
});
const interconnect_attachment = new gcp.compute.InterconnectAttachment("interconnect-attachment", {
    name: "partner-interconnect1",
    edgeAvailabilityDomain: "AVAILABILITY_DOMAIN_1",
    type: "PARTNER",
    router: router.id,
    mtu: "1500",
    region: "us-central1",
});
const primary = new gcp.networkconnectivity.Spoke("primary", {
    name: "interconnect-attachment-spoke",
    location: "us-central1",
    description: "A sample spoke with a linked Interconnect Attachment",
    labels: {
        "label-one": "value-one",
    },
    hub: basicHub.id,
    linkedInterconnectAttachments: {
        uris: [interconnect_attachment.selfLink],
        siteToSiteDataTransfer: true,
        includeImportRanges: ["ALL_IPV4_RANGES"],
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

basic_hub = gcp.networkconnectivity.Hub("basic_hub",
    name="basic-hub1",
    description="A sample hub",
    labels={
        "label-two": "value-one",
    })
network = gcp.compute.Network("network",
    name="basic-network",
    auto_create_subnetworks=False)
router = gcp.compute.Router("router",
    name="external-vpn-gateway",
    region="us-central1",
    network=network.name,
    bgp={
        "asn": 16550,
    })
interconnect_attachment = gcp.compute.InterconnectAttachment("interconnect-attachment",
    name="partner-interconnect1",
    edge_availability_domain="AVAILABILITY_DOMAIN_1",
    type="PARTNER",
    router=router.id,
    mtu="1500",
    region="us-central1")
primary = gcp.networkconnectivity.Spoke("primary",
    name="interconnect-attachment-spoke",
    location="us-central1",
    description="A sample spoke with a linked Interconnect Attachment",
    labels={
        "label-one": "value-one",
    },
    hub=basic_hub.id,
    linked_interconnect_attachments={
        "uris": [interconnect_attachment.self_link],
        "site_to_site_data_transfer": True,
        "include_import_ranges": ["ALL_IPV4_RANGES"],
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var basicHub = new Gcp.NetworkConnectivity.Hub("basic_hub", new()
    {
        Name = "basic-hub1",
        Description = "A sample hub",
        Labels = 
        {
            { "label-two", "value-one" },
        },
    });

    var network = new Gcp.Compute.Network("network", new()
    {
        Name = "basic-network",
        AutoCreateSubnetworks = false,
    });

    var router = new Gcp.Compute.Router("router", new()
    {
        Name = "external-vpn-gateway",
        Region = "us-central1",
        Network = network.Name,
        Bgp = new Gcp.Compute.Inputs.RouterBgpArgs
        {
            Asn = 16550,
        },
    });

    var interconnect_attachment = new Gcp.Compute.InterconnectAttachment("interconnect-attachment", new()
    {
        Name = "partner-interconnect1",
        EdgeAvailabilityDomain = "AVAILABILITY_DOMAIN_1",
        Type = "PARTNER",
        Router = router.Id,
        Mtu = "1500",
        Region = "us-central1",
    });

    var primary = new Gcp.NetworkConnectivity.Spoke("primary", new()
    {
        Name = "interconnect-attachment-spoke",
        Location = "us-central1",
        Description = "A sample spoke with a linked Interconnect Attachment",
        Labels = 
        {
            { "label-one", "value-one" },
        },
        Hub = basicHub.Id,
        LinkedInterconnectAttachments = new Gcp.NetworkConnectivity.Inputs.SpokeLinkedInterconnectAttachmentsArgs
        {
            Uris = new[]
            {
                interconnect_attachment.SelfLink,
            },
            SiteToSiteDataTransfer = true,
            IncludeImportRanges = new[]
            {
                "ALL_IPV4_RANGES",
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkconnectivity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		basicHub, err := networkconnectivity.NewHub(ctx, "basic_hub", &networkconnectivity.HubArgs{
			Name:        pulumi.String("basic-hub1"),
			Description: pulumi.String("A sample hub"),
			Labels: pulumi.StringMap{
				"label-two": pulumi.String("value-one"),
			},
		})
		if err != nil {
			return err
		}
		network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
			Name:                  pulumi.String("basic-network"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		router, err := compute.NewRouter(ctx, "router", &compute.RouterArgs{
			Name:    pulumi.String("external-vpn-gateway"),
			Region:  pulumi.String("us-central1"),
			Network: network.Name,
			Bgp: &compute.RouterBgpArgs{
				Asn: pulumi.Int(16550),
			},
		})
		if err != nil {
			return err
		}
		_, err = compute.NewInterconnectAttachment(ctx, "interconnect-attachment", &compute.InterconnectAttachmentArgs{
			Name:                   pulumi.String("partner-interconnect1"),
			EdgeAvailabilityDomain: pulumi.String("AVAILABILITY_DOMAIN_1"),
			Type:                   pulumi.String("PARTNER"),
			Router:                 router.ID(),
			Mtu:                    pulumi.String("1500"),
			Region:                 pulumi.String("us-central1"),
		})
		if err != nil {
			return err
		}
		_, err = networkconnectivity.NewSpoke(ctx, "primary", &networkconnectivity.SpokeArgs{
			Name:        pulumi.String("interconnect-attachment-spoke"),
			Location:    pulumi.String("us-central1"),
			Description: pulumi.String("A sample spoke with a linked Interconnect Attachment"),
			Labels: pulumi.StringMap{
				"label-one": pulumi.String("value-one"),
			},
			Hub: basicHub.ID(),
			LinkedInterconnectAttachments: &networkconnectivity.SpokeLinkedInterconnectAttachmentsArgs{
				Uris: pulumi.StringArray{
					interconnect_attachment.SelfLink,
				},
				SiteToSiteDataTransfer: pulumi.Bool(true),
				IncludeImportRanges: pulumi.StringArray{
					pulumi.String("ALL_IPV4_RANGES"),
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networkconnectivity.Hub;
import com.pulumi.gcp.networkconnectivity.HubArgs;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.Router;
import com.pulumi.gcp.compute.RouterArgs;
import com.pulumi.gcp.compute.inputs.RouterBgpArgs;
import com.pulumi.gcp.compute.InterconnectAttachment;
import com.pulumi.gcp.compute.InterconnectAttachmentArgs;
import com.pulumi.gcp.networkconnectivity.Spoke;
import com.pulumi.gcp.networkconnectivity.SpokeArgs;
import com.pulumi.gcp.networkconnectivity.inputs.SpokeLinkedInterconnectAttachmentsArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var basicHub = new Hub("basicHub", HubArgs.builder()
            .name("basic-hub1")
            .description("A sample hub")
            .labels(Map.of("label-two", "value-one"))
            .build());

        var network = new Network("network", NetworkArgs.builder()
            .name("basic-network")
            .autoCreateSubnetworks(false)
            .build());

        var router = new Router("router", RouterArgs.builder()
            .name("external-vpn-gateway")
            .region("us-central1")
            .network(network.name())
            .bgp(RouterBgpArgs.builder()
                .asn(16550)
                .build())
            .build());

        var interconnect_attachment = new InterconnectAttachment("interconnect-attachment", InterconnectAttachmentArgs.builder()
            .name("partner-interconnect1")
            .edgeAvailabilityDomain("AVAILABILITY_DOMAIN_1")
            .type("PARTNER")
            .router(router.id())
            .mtu(1500)
            .region("us-central1")
            .build());

        var primary = new Spoke("primary", SpokeArgs.builder()
            .name("interconnect-attachment-spoke")
            .location("us-central1")
            .description("A sample spoke with a linked Interconnect Attachment")
            .labels(Map.of("label-one", "value-one"))
            .hub(basicHub.id())
            .linkedInterconnectAttachments(SpokeLinkedInterconnectAttachmentsArgs.builder()
                .uris(interconnect_attachment.selfLink())
                .siteToSiteDataTransfer(true)
                .includeImportRanges("ALL_IPV4_RANGES")
                .build())
            .build());

    }
}
```
```yaml
resources:
  basicHub:
    type: gcp:networkconnectivity:Hub
    name: basic_hub
    properties:
      name: basic-hub1
      description: A sample hub
      labels:
        label-two: value-one
  network:
    type: gcp:compute:Network
    properties:
      name: basic-network
      autoCreateSubnetworks: false
  router:
    type: gcp:compute:Router
    properties:
      name: external-vpn-gateway
      region: us-central1
      network: ${network.name}
      bgp:
        asn: 16550
  interconnect-attachment:
    type: gcp:compute:InterconnectAttachment
    properties:
      name: partner-interconnect1
      edgeAvailabilityDomain: AVAILABILITY_DOMAIN_1
      type: PARTNER
      router: ${router.id}
      mtu: 1500
      region: us-central1
  primary:
    type: gcp:networkconnectivity:Spoke
    properties:
      name: interconnect-attachment-spoke
      location: us-central1
      description: A sample spoke with a linked Interconnect Attachment
      labels:
        label-one: value-one
      hub: ${basicHub.id}
      linkedInterconnectAttachments:
        uris:
          - ${["interconnect-attachment"].selfLink}
        siteToSiteDataTransfer: true
        includeImportRanges:
          - ALL_IPV4_RANGES
```
<!--End PulumiCodeChooser -->
### Network Connectivity Spoke Linked Producer Vpc Network Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const network = new gcp.compute.Network("network", {
    name: "net-spoke",
    autoCreateSubnetworks: false,
});
const address = new gcp.compute.GlobalAddress("address", {
    name: "test-address",
    purpose: "VPC_PEERING",
    addressType: "INTERNAL",
    prefixLength: 16,
    network: network.id,
});
const peering = new gcp.servicenetworking.Connection("peering", {
    network: network.id,
    service: "servicenetworking.googleapis.com",
    reservedPeeringRanges: [address.name],
});
const basicHub = new gcp.networkconnectivity.Hub("basic_hub", {name: "hub-basic"});
const linkedVpcSpoke = new gcp.networkconnectivity.Spoke("linked_vpc_spoke", {
    name: "vpc-spoke",
    location: "global",
    hub: basicHub.id,
    linkedVpcNetwork: {
        uri: network.selfLink,
    },
});
const primary = new gcp.networkconnectivity.Spoke("primary", {
    name: "producer-spoke",
    location: "global",
    description: "A sample spoke with a linked router appliance instance",
    labels: {
        "label-one": "value-one",
    },
    hub: basicHub.id,
    linkedProducerVpcNetwork: {
        network: network.name,
        peering: peering.peering,
        excludeExportRanges: [
            "198.51.100.0/24",
            "10.10.0.0/16",
        ],
    },
}, {
    dependsOn: [linkedVpcSpoke],
});
```
```python
import pulumi
import pulumi_gcp as gcp

network = gcp.compute.Network("network",
    name="net-spoke",
    auto_create_subnetworks=False)
address = gcp.compute.GlobalAddress("address",
    name="test-address",
    purpose="VPC_PEERING",
    address_type="INTERNAL",
    prefix_length=16,
    network=network.id)
peering = gcp.servicenetworking.Connection("peering",
    network=network.id,
    service="servicenetworking.googleapis.com",
    reserved_peering_ranges=[address.name])
basic_hub = gcp.networkconnectivity.Hub("basic_hub", name="hub-basic")
linked_vpc_spoke = gcp.networkconnectivity.Spoke("linked_vpc_spoke",
    name="vpc-spoke",
    location="global",
    hub=basic_hub.id,
    linked_vpc_network={
        "uri": network.self_link,
    })
primary = gcp.networkconnectivity.Spoke("primary",
    name="producer-spoke",
    location="global",
    description="A sample spoke with a linked router appliance instance",
    labels={
        "label-one": "value-one",
    },
    hub=basic_hub.id,
    linked_producer_vpc_network={
        "network": network.name,
        "peering": peering.peering,
        "exclude_export_ranges": [
            "198.51.100.0/24",
            "10.10.0.0/16",
        ],
    },
    opts = pulumi.ResourceOptions(depends_on=[linked_vpc_spoke]))
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var network = new Gcp.Compute.Network("network", new()
    {
        Name = "net-spoke",
        AutoCreateSubnetworks = false,
    });

    var address = new Gcp.Compute.GlobalAddress("address", new()
    {
        Name = "test-address",
        Purpose = "VPC_PEERING",
        AddressType = "INTERNAL",
        PrefixLength = 16,
        Network = network.Id,
    });

    var peering = new Gcp.ServiceNetworking.Connection("peering", new()
    {
        Network = network.Id,
        Service = "servicenetworking.googleapis.com",
        ReservedPeeringRanges = new[]
        {
            address.Name,
        },
    });

    var basicHub = new Gcp.NetworkConnectivity.Hub("basic_hub", new()
    {
        Name = "hub-basic",
    });

    var linkedVpcSpoke = new Gcp.NetworkConnectivity.Spoke("linked_vpc_spoke", new()
    {
        Name = "vpc-spoke",
        Location = "global",
        Hub = basicHub.Id,
        LinkedVpcNetwork = new Gcp.NetworkConnectivity.Inputs.SpokeLinkedVpcNetworkArgs
        {
            Uri = network.SelfLink,
        },
    });

    var primary = new Gcp.NetworkConnectivity.Spoke("primary", new()
    {
        Name = "producer-spoke",
        Location = "global",
        Description = "A sample spoke with a linked router appliance instance",
        Labels = 
        {
            { "label-one", "value-one" },
        },
        Hub = basicHub.Id,
        LinkedProducerVpcNetwork = new Gcp.NetworkConnectivity.Inputs.SpokeLinkedProducerVpcNetworkArgs
        {
            Network = network.Name,
            Peering = peering.Peering,
            ExcludeExportRanges = new[]
            {
                "198.51.100.0/24",
                "10.10.0.0/16",
            },
        },
    }, new CustomResourceOptions
    {
        DependsOn =
        {
            linkedVpcSpoke,
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkconnectivity"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/servicenetworking"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
			Name:                  pulumi.String("net-spoke"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		address, err := compute.NewGlobalAddress(ctx, "address", &compute.GlobalAddressArgs{
			Name:         pulumi.String("test-address"),
			Purpose:      pulumi.String("VPC_PEERING"),
			AddressType:  pulumi.String("INTERNAL"),
			PrefixLength: pulumi.Int(16),
			Network:      network.ID(),
		})
		if err != nil {
			return err
		}
		peering, err := servicenetworking.NewConnection(ctx, "peering", &servicenetworking.ConnectionArgs{
			Network: network.ID(),
			Service: pulumi.String("servicenetworking.googleapis.com"),
			ReservedPeeringRanges: pulumi.StringArray{
				address.Name,
			},
		})
		if err != nil {
			return err
		}
		basicHub, err := networkconnectivity.NewHub(ctx, "basic_hub", &networkconnectivity.HubArgs{
			Name: pulumi.String("hub-basic"),
		})
		if err != nil {
			return err
		}
		linkedVpcSpoke, err := networkconnectivity.NewSpoke(ctx, "linked_vpc_spoke", &networkconnectivity.SpokeArgs{
			Name:     pulumi.String("vpc-spoke"),
			Location: pulumi.String("global"),
			Hub:      basicHub.ID(),
			LinkedVpcNetwork: &networkconnectivity.SpokeLinkedVpcNetworkArgs{
				Uri: network.SelfLink,
			},
		})
		if err != nil {
			return err
		}
		_, err = networkconnectivity.NewSpoke(ctx, "primary", &networkconnectivity.SpokeArgs{
			Name:        pulumi.String("producer-spoke"),
			Location:    pulumi.String("global"),
			Description: pulumi.String("A sample spoke with a linked router appliance instance"),
			Labels: pulumi.StringMap{
				"label-one": pulumi.String("value-one"),
			},
			Hub: basicHub.ID(),
			LinkedProducerVpcNetwork: &networkconnectivity.SpokeLinkedProducerVpcNetworkArgs{
				Network: network.Name,
				Peering: peering.Peering,
				ExcludeExportRanges: pulumi.StringArray{
					pulumi.String("198.51.100.0/24"),
					pulumi.String("10.10.0.0/16"),
				},
			},
		}, pulumi.DependsOn([]pulumi.Resource{
			linkedVpcSpoke,
		}))
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.GlobalAddress;
import com.pulumi.gcp.compute.GlobalAddressArgs;
import com.pulumi.gcp.servicenetworking.Connection;
import com.pulumi.gcp.servicenetworking.ConnectionArgs;
import com.pulumi.gcp.networkconnectivity.Hub;
import com.pulumi.gcp.networkconnectivity.HubArgs;
import com.pulumi.gcp.networkconnectivity.Spoke;
import com.pulumi.gcp.networkconnectivity.SpokeArgs;
import com.pulumi.gcp.networkconnectivity.inputs.SpokeLinkedVpcNetworkArgs;
import com.pulumi.gcp.networkconnectivity.inputs.SpokeLinkedProducerVpcNetworkArgs;
import com.pulumi.resources.CustomResourceOptions;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var network = new Network("network", NetworkArgs.builder()
            .name("net-spoke")
            .autoCreateSubnetworks(false)
            .build());

        var address = new GlobalAddress("address", GlobalAddressArgs.builder()
            .name("test-address")
            .purpose("VPC_PEERING")
            .addressType("INTERNAL")
            .prefixLength(16)
            .network(network.id())
            .build());

        var peering = new Connection("peering", ConnectionArgs.builder()
            .network(network.id())
            .service("servicenetworking.googleapis.com")
            .reservedPeeringRanges(address.name())
            .build());

        var basicHub = new Hub("basicHub", HubArgs.builder()
            .name("hub-basic")
            .build());

        var linkedVpcSpoke = new Spoke("linkedVpcSpoke", SpokeArgs.builder()
            .name("vpc-spoke")
            .location("global")
            .hub(basicHub.id())
            .linkedVpcNetwork(SpokeLinkedVpcNetworkArgs.builder()
                .uri(network.selfLink())
                .build())
            .build());

        var primary = new Spoke("primary", SpokeArgs.builder()
            .name("producer-spoke")
            .location("global")
            .description("A sample spoke with a linked router appliance instance")
            .labels(Map.of("label-one", "value-one"))
            .hub(basicHub.id())
            .linkedProducerVpcNetwork(SpokeLinkedProducerVpcNetworkArgs.builder()
                .network(network.name())
                .peering(peering.peering())
                .excludeExportRanges(                
                    "198.51.100.0/24",
                    "10.10.0.0/16")
                .build())
            .build(), CustomResourceOptions.builder()
                .dependsOn(linkedVpcSpoke)
                .build());

    }
}
```
```yaml
resources:
  network:
    type: gcp:compute:Network
    properties:
      name: net-spoke
      autoCreateSubnetworks: false
  address:
    type: gcp:compute:GlobalAddress
    properties:
      name: test-address
      purpose: VPC_PEERING
      addressType: INTERNAL
      prefixLength: 16
      network: ${network.id}
  peering:
    type: gcp:servicenetworking:Connection
    properties:
      network: ${network.id}
      service: servicenetworking.googleapis.com
      reservedPeeringRanges:
        - ${address.name}
  basicHub:
    type: gcp:networkconnectivity:Hub
    name: basic_hub
    properties:
      name: hub-basic
  linkedVpcSpoke:
    type: gcp:networkconnectivity:Spoke
    name: linked_vpc_spoke
    properties:
      name: vpc-spoke
      location: global
      hub: ${basicHub.id}
      linkedVpcNetwork:
        uri: ${network.selfLink}
  primary:
    type: gcp:networkconnectivity:Spoke
    properties:
      name: producer-spoke
      location: global
      description: A sample spoke with a linked router appliance instance
      labels:
        label-one: value-one
      hub: ${basicHub.id}
      linkedProducerVpcNetwork:
        network: ${network.name}
        peering: ${peering.peering}
        excludeExportRanges:
          - 198.51.100.0/24
          - 10.10.0.0/16
    options:
      dependsOn:
        - ${linkedVpcSpoke}
```
<!--End PulumiCodeChooser -->

## Import

Spoke can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/spokes/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

When using the `pulumi import` command, Spoke can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkconnectivity/spoke:Spoke default projects/{{project}}/locations/{{location}}/spokes/{{name}}
```

```sh
$ pulumi import gcp:networkconnectivity/spoke:Spoke default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:networkconnectivity/spoke:Spoke default {{location}}/{{name}}
```

;
descriptionB" &An optional description of the spoke.
I
hub" >Immutable. The URI of the hub that this spoke is attached to.
ñ
labelsB2" ÉOptional labels in key:value format. For more information about labels, see [Requirements for labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
Î
linkedInterconnectAttachments°Bû:õ
ò
networkconnectivity"SpokeLinkedInterconnectAttachments]gcp:networkconnectivity/SpokeLinkedInterconnectAttachments:SpokeLinkedInterconnectAttachments•A collection of VLAN attachment resources. These resources should be redundant attachments that all advertise the same prefixes to Google Cloud. Alternatively, in active/passive configurations, all attachments should be capable of advertising the same prefixes.
Structure is documented below.
à
linkedProducerVpcNetworkíBè:å
â
networkconnectivitySpokeLinkedProducerVpcNetworkSgcp:networkconnectivity/SpokeLinkedProducerVpcNetwork:SpokeLinkedProducerVpcNetworkWProducer VPC network that is associated with the spoke.
Structure is documented below.
ñ
linkedRouterApplianceInstances§B°:û
õ
networkconnectivity#SpokeLinkedRouterApplianceInstances_gcp:networkconnectivity/SpokeLinkedRouterApplianceInstances:SpokeLinkedRouterApplianceInstancesMThe URIs of linked Router appliance resources
Structure is documented below.
€
linkedVpcNetworkwBu:s
q
networkconnectivitySpokeLinkedVpcNetworkCgcp:networkconnectivity/SpokeLinkedVpcNetwork:SpokeLinkedVpcNetworkNVPC network that is associated with the spoke.
Structure is documented below.
‘
linkedVpnTunnelswBu:s
q
networkconnectivitySpokeLinkedVpnTunnelsCgcp:networkconnectivity/SpokeLinkedVpnTunnels:SpokeLinkedVpnTunnelsGThe URIs of linked VPN tunnel resources
Structure is documented below.
6
location" &The location for the resource


- - -
L
nameB" >Immutable. The name of the spoke. Spoke names must be unique.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"?

createTime" -Output only. The time the spoke was created.
";
descriptionB" &An optional description of the spoke.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"I
hub" >Immutable. The URI of the hub that this spoke is attached to.
"ñ
labelsB2" ÉOptional labels in key:value format. For more information about labels, see [Requirements for labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements).
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"Î
linkedInterconnectAttachments°Bû:õ
ò
networkconnectivity"SpokeLinkedInterconnectAttachments]gcp:networkconnectivity/SpokeLinkedInterconnectAttachments:SpokeLinkedInterconnectAttachments•A collection of VLAN attachment resources. These resources should be redundant attachments that all advertise the same prefixes to Google Cloud. Alternatively, in active/passive configurations, all attachments should be capable of advertising the same prefixes.
Structure is documented below.
"à
linkedProducerVpcNetworkíBè:å
â
networkconnectivitySpokeLinkedProducerVpcNetworkSgcp:networkconnectivity/SpokeLinkedProducerVpcNetwork:SpokeLinkedProducerVpcNetworkWProducer VPC network that is associated with the spoke.
Structure is documented below.
"ñ
linkedRouterApplianceInstances§B°:û
õ
networkconnectivity#SpokeLinkedRouterApplianceInstances_gcp:networkconnectivity/SpokeLinkedRouterApplianceInstances:SpokeLinkedRouterApplianceInstancesMThe URIs of linked Router appliance resources
Structure is documented below.
"€
linkedVpcNetworkwBu:s
q
networkconnectivitySpokeLinkedVpcNetworkCgcp:networkconnectivity/SpokeLinkedVpcNetwork:SpokeLinkedVpcNetworkNVPC network that is associated with the spoke.
Structure is documented below.
"‘
linkedVpnTunnelswBu:s
q
networkconnectivitySpokeLinkedVpnTunnelsCgcp:networkconnectivity/SpokeLinkedVpnTunnels:SpokeLinkedVpnTunnelsGThe URIs of linked VPN tunnel resources
Structure is documented below.
"6
location" &The location for the resource


- - -
"J
name" >Immutable. The name of the spoke. Spoke names must be unique.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"E
state" 8Output only. The current lifecycle state of this spoke.
"Í
uniqueId" ŸOutput only. The Google-generated UUID for the spoke. This value is unique across all spoke resources. If a spoke is deleted and another with the same name is created, the new spoke is assigned a different unique_id.
"D

updateTime" 2Output only. The time the spoke was last updated.
*¿⁄
^
networkmanagementConnectivityTest7gcp:networkmanagement/connectivityTest:ConnectivityTestø¨A connectivity test are a static analysis of your resource configurations
that enables you to evaluate connectivity to and from Google Cloud
resources in your Virtual Private Cloud (VPC) network.


To get more information about ConnectivityTest, see:

* [API documentation](https://cloud.google.com/network-intelligence-center/docs/connectivity-tests/reference/networkmanagement/rest/v1/projects.locations.global.connectivityTests)
* How-to Guides
    * [Official Documentation](https://cloud.google.com/network-intelligence-center/docs)

## Example Usage

### Network Management Connectivity Test Instances


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const vpc = new gcp.compute.Network("vpc", {name: "conn-test-net"});
const debian9 = gcp.compute.getImage({
    family: "debian-11",
    project: "debian-cloud",
});
const source = new gcp.compute.Instance("source", {
    networkInterfaces: [{
        accessConfigs: [{}],
        network: vpc.id,
    }],
    name: "source-vm",
    machineType: "e2-medium",
    bootDisk: {
        initializeParams: {
            image: debian9.then(debian9 => debian9.id),
        },
    },
});
const destination = new gcp.compute.Instance("destination", {
    networkInterfaces: [{
        accessConfigs: [{}],
        network: vpc.id,
    }],
    name: "dest-vm",
    machineType: "e2-medium",
    bootDisk: {
        initializeParams: {
            image: debian9.then(debian9 => debian9.id),
        },
    },
});
const instance_test = new gcp.networkmanagement.ConnectivityTest("instance-test", {
    name: "conn-test-instances",
    source: {
        instance: source.id,
    },
    destination: {
        instance: destination.id,
    },
    protocol: "TCP",
    labels: {
        env: "test",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

vpc = gcp.compute.Network("vpc", name="conn-test-net")
debian9 = gcp.compute.get_image(family="debian-11",
    project="debian-cloud")
source = gcp.compute.Instance("source",
    network_interfaces=[{
        "access_configs": [{}],
        "network": vpc.id,
    }],
    name="source-vm",
    machine_type="e2-medium",
    boot_disk={
        "initialize_params": {
            "image": debian9.id,
        },
    })
destination = gcp.compute.Instance("destination",
    network_interfaces=[{
        "access_configs": [{}],
        "network": vpc.id,
    }],
    name="dest-vm",
    machine_type="e2-medium",
    boot_disk={
        "initialize_params": {
            "image": debian9.id,
        },
    })
instance_test = gcp.networkmanagement.ConnectivityTest("instance-test",
    name="conn-test-instances",
    source={
        "instance": source.id,
    },
    destination={
        "instance": destination.id,
    },
    protocol="TCP",
    labels={
        "env": "test",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var vpc = new Gcp.Compute.Network("vpc", new()
    {
        Name = "conn-test-net",
    });

    var debian9 = Gcp.Compute.GetImage.Invoke(new()
    {
        Family = "debian-11",
        Project = "debian-cloud",
    });

    var source = new Gcp.Compute.Instance("source", new()
    {
        NetworkInterfaces = new[]
        {
            new Gcp.Compute.Inputs.InstanceNetworkInterfaceArgs
            {
                AccessConfigs = new[]
                {
                    null,
                },
                Network = vpc.Id,
            },
        },
        Name = "source-vm",
        MachineType = "e2-medium",
        BootDisk = new Gcp.Compute.Inputs.InstanceBootDiskArgs
        {
            InitializeParams = new Gcp.Compute.Inputs.InstanceBootDiskInitializeParamsArgs
            {
                Image = debian9.Apply(getImageResult => getImageResult.Id),
            },
        },
    });

    var destination = new Gcp.Compute.Instance("destination", new()
    {
        NetworkInterfaces = new[]
        {
            new Gcp.Compute.Inputs.InstanceNetworkInterfaceArgs
            {
                AccessConfigs = new[]
                {
                    null,
                },
                Network = vpc.Id,
            },
        },
        Name = "dest-vm",
        MachineType = "e2-medium",
        BootDisk = new Gcp.Compute.Inputs.InstanceBootDiskArgs
        {
            InitializeParams = new Gcp.Compute.Inputs.InstanceBootDiskInitializeParamsArgs
            {
                Image = debian9.Apply(getImageResult => getImageResult.Id),
            },
        },
    });

    var instance_test = new Gcp.NetworkManagement.ConnectivityTest("instance-test", new()
    {
        Name = "conn-test-instances",
        Source = new Gcp.NetworkManagement.Inputs.ConnectivityTestSourceArgs
        {
            Instance = source.Id,
        },
        Destination = new Gcp.NetworkManagement.Inputs.ConnectivityTestDestinationArgs
        {
            Instance = destination.Id,
        },
        Protocol = "TCP",
        Labels = 
        {
            { "env", "test" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkmanagement"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		vpc, err := compute.NewNetwork(ctx, "vpc", &compute.NetworkArgs{
			Name: pulumi.String("conn-test-net"),
		})
		if err != nil {
			return err
		}
		debian9, err := compute.LookupImage(ctx, &compute.LookupImageArgs{
			Family:  pulumi.StringRef("debian-11"),
			Project: pulumi.StringRef("debian-cloud"),
		}, nil)
		if err != nil {
			return err
		}
		source, err := compute.NewInstance(ctx, "source", &compute.InstanceArgs{
			NetworkInterfaces: compute.InstanceNetworkInterfaceArray{
				&compute.InstanceNetworkInterfaceArgs{
					AccessConfigs: compute.InstanceNetworkInterfaceAccessConfigArray{
						&compute.InstanceNetworkInterfaceAccessConfigArgs{},
					},
					Network: vpc.ID(),
				},
			},
			Name:        pulumi.String("source-vm"),
			MachineType: pulumi.String("e2-medium"),
			BootDisk: &compute.InstanceBootDiskArgs{
				InitializeParams: &compute.InstanceBootDiskInitializeParamsArgs{
					Image: pulumi.String(debian9.Id),
				},
			},
		})
		if err != nil {
			return err
		}
		destination, err := compute.NewInstance(ctx, "destination", &compute.InstanceArgs{
			NetworkInterfaces: compute.InstanceNetworkInterfaceArray{
				&compute.InstanceNetworkInterfaceArgs{
					AccessConfigs: compute.InstanceNetworkInterfaceAccessConfigArray{
						&compute.InstanceNetworkInterfaceAccessConfigArgs{},
					},
					Network: vpc.ID(),
				},
			},
			Name:        pulumi.String("dest-vm"),
			MachineType: pulumi.String("e2-medium"),
			BootDisk: &compute.InstanceBootDiskArgs{
				InitializeParams: &compute.InstanceBootDiskInitializeParamsArgs{
					Image: pulumi.String(debian9.Id),
				},
			},
		})
		if err != nil {
			return err
		}
		_, err = networkmanagement.NewConnectivityTest(ctx, "instance-test", &networkmanagement.ConnectivityTestArgs{
			Name: pulumi.String("conn-test-instances"),
			Source: &networkmanagement.ConnectivityTestSourceArgs{
				Instance: source.ID(),
			},
			Destination: &networkmanagement.ConnectivityTestDestinationArgs{
				Instance: destination.ID(),
			},
			Protocol: pulumi.String("TCP"),
			Labels: pulumi.StringMap{
				"env": pulumi.String("test"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.ComputeFunctions;
import com.pulumi.gcp.compute.inputs.GetImageArgs;
import com.pulumi.gcp.compute.Instance;
import com.pulumi.gcp.compute.InstanceArgs;
import com.pulumi.gcp.compute.inputs.InstanceNetworkInterfaceArgs;
import com.pulumi.gcp.compute.inputs.InstanceBootDiskArgs;
import com.pulumi.gcp.compute.inputs.InstanceBootDiskInitializeParamsArgs;
import com.pulumi.gcp.networkmanagement.ConnectivityTest;
import com.pulumi.gcp.networkmanagement.ConnectivityTestArgs;
import com.pulumi.gcp.networkmanagement.inputs.ConnectivityTestSourceArgs;
import com.pulumi.gcp.networkmanagement.inputs.ConnectivityTestDestinationArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var vpc = new Network("vpc", NetworkArgs.builder()
            .name("conn-test-net")
            .build());

        final var debian9 = ComputeFunctions.getImage(GetImageArgs.builder()
            .family("debian-11")
            .project("debian-cloud")
            .build());

        var source = new Instance("source", InstanceArgs.builder()
            .networkInterfaces(InstanceNetworkInterfaceArgs.builder()
                .accessConfigs()
                .network(vpc.id())
                .build())
            .name("source-vm")
            .machineType("e2-medium")
            .bootDisk(InstanceBootDiskArgs.builder()
                .initializeParams(InstanceBootDiskInitializeParamsArgs.builder()
                    .image(debian9.applyValue(getImageResult -> getImageResult.id()))
                    .build())
                .build())
            .build());

        var destination = new Instance("destination", InstanceArgs.builder()
            .networkInterfaces(InstanceNetworkInterfaceArgs.builder()
                .accessConfigs()
                .network(vpc.id())
                .build())
            .name("dest-vm")
            .machineType("e2-medium")
            .bootDisk(InstanceBootDiskArgs.builder()
                .initializeParams(InstanceBootDiskInitializeParamsArgs.builder()
                    .image(debian9.applyValue(getImageResult -> getImageResult.id()))
                    .build())
                .build())
            .build());

        var instance_test = new ConnectivityTest("instance-test", ConnectivityTestArgs.builder()
            .name("conn-test-instances")
            .source(ConnectivityTestSourceArgs.builder()
                .instance(source.id())
                .build())
            .destination(ConnectivityTestDestinationArgs.builder()
                .instance(destination.id())
                .build())
            .protocol("TCP")
            .labels(Map.of("env", "test"))
            .build());

    }
}
```
```yaml
resources:
  instance-test:
    type: gcp:networkmanagement:ConnectivityTest
    properties:
      name: conn-test-instances
      source:
        instance: ${source.id}
      destination:
        instance: ${destination.id}
      protocol: TCP
      labels:
        env: test
  source:
    type: gcp:compute:Instance
    properties:
      networkInterfaces:
        - accessConfigs:
            - {}
          network: ${vpc.id}
      name: source-vm
      machineType: e2-medium
      bootDisk:
        initializeParams:
          image: ${debian9.id}
  destination:
    type: gcp:compute:Instance
    properties:
      networkInterfaces:
        - accessConfigs:
            - {}
          network: ${vpc.id}
      name: dest-vm
      machineType: e2-medium
      bootDisk:
        initializeParams:
          image: ${debian9.id}
  vpc:
    type: gcp:compute:Network
    properties:
      name: conn-test-net
variables:
  debian9:
    fn::invoke:
      function: gcp:compute:getImage
      arguments:
        family: debian-11
        project: debian-cloud
```
<!--End PulumiCodeChooser -->
### Network Management Connectivity Test Addresses


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const vpc = new gcp.compute.Network("vpc", {name: "connectivity-vpc"});
const subnet = new gcp.compute.Subnetwork("subnet", {
    name: "connectivity-vpc-subnet",
    ipCidrRange: "10.0.0.0/16",
    region: "us-central1",
    network: vpc.id,
});
const source_addr = new gcp.compute.Address("source-addr", {
    name: "src-addr",
    subnetwork: subnet.id,
    addressType: "INTERNAL",
    address: "10.0.42.42",
    region: "us-central1",
});
const dest_addr = new gcp.compute.Address("dest-addr", {
    name: "dest-addr",
    subnetwork: subnet.id,
    addressType: "INTERNAL",
    address: "10.0.43.43",
    region: "us-central1",
});
const address_test = new gcp.networkmanagement.ConnectivityTest("address-test", {
    name: "conn-test-addr",
    source: {
        ipAddress: source_addr.address,
        projectId: source_addr.project,
        network: vpc.id,
        networkType: "GCP_NETWORK",
    },
    destination: {
        ipAddress: dest_addr.address,
        projectId: dest_addr.project,
        network: vpc.id,
    },
    protocol: "UDP",
});
```
```python
import pulumi
import pulumi_gcp as gcp

vpc = gcp.compute.Network("vpc", name="connectivity-vpc")
subnet = gcp.compute.Subnetwork("subnet",
    name="connectivity-vpc-subnet",
    ip_cidr_range="10.0.0.0/16",
    region="us-central1",
    network=vpc.id)
source_addr = gcp.compute.Address("source-addr",
    name="src-addr",
    subnetwork=subnet.id,
    address_type="INTERNAL",
    address="10.0.42.42",
    region="us-central1")
dest_addr = gcp.compute.Address("dest-addr",
    name="dest-addr",
    subnetwork=subnet.id,
    address_type="INTERNAL",
    address="10.0.43.43",
    region="us-central1")
address_test = gcp.networkmanagement.ConnectivityTest("address-test",
    name="conn-test-addr",
    source={
        "ip_address": source_addr.address,
        "project_id": source_addr.project,
        "network": vpc.id,
        "network_type": "GCP_NETWORK",
    },
    destination={
        "ip_address": dest_addr.address,
        "project_id": dest_addr.project,
        "network": vpc.id,
    },
    protocol="UDP")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var vpc = new Gcp.Compute.Network("vpc", new()
    {
        Name = "connectivity-vpc",
    });

    var subnet = new Gcp.Compute.Subnetwork("subnet", new()
    {
        Name = "connectivity-vpc-subnet",
        IpCidrRange = "10.0.0.0/16",
        Region = "us-central1",
        Network = vpc.Id,
    });

    var source_addr = new Gcp.Compute.Address("source-addr", new()
    {
        Name = "src-addr",
        Subnetwork = subnet.Id,
        AddressType = "INTERNAL",
        IPAddress = "10.0.42.42",
        Region = "us-central1",
    });

    var dest_addr = new Gcp.Compute.Address("dest-addr", new()
    {
        Name = "dest-addr",
        Subnetwork = subnet.Id,
        AddressType = "INTERNAL",
        IPAddress = "10.0.43.43",
        Region = "us-central1",
    });

    var address_test = new Gcp.NetworkManagement.ConnectivityTest("address-test", new()
    {
        Name = "conn-test-addr",
        Source = new Gcp.NetworkManagement.Inputs.ConnectivityTestSourceArgs
        {
            IpAddress = source_addr.IPAddress,
            ProjectId = source_addr.Project,
            Network = vpc.Id,
            NetworkType = "GCP_NETWORK",
        },
        Destination = new Gcp.NetworkManagement.Inputs.ConnectivityTestDestinationArgs
        {
            IpAddress = dest_addr.IPAddress,
            ProjectId = dest_addr.Project,
            Network = vpc.Id,
        },
        Protocol = "UDP",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkmanagement"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		vpc, err := compute.NewNetwork(ctx, "vpc", &compute.NetworkArgs{
			Name: pulumi.String("connectivity-vpc"),
		})
		if err != nil {
			return err
		}
		subnet, err := compute.NewSubnetwork(ctx, "subnet", &compute.SubnetworkArgs{
			Name:        pulumi.String("connectivity-vpc-subnet"),
			IpCidrRange: pulumi.String("10.0.0.0/16"),
			Region:      pulumi.String("us-central1"),
			Network:     vpc.ID(),
		})
		if err != nil {
			return err
		}
		_, err = compute.NewAddress(ctx, "source-addr", &compute.AddressArgs{
			Name:        pulumi.String("src-addr"),
			Subnetwork:  subnet.ID(),
			AddressType: pulumi.String("INTERNAL"),
			Address:     pulumi.String("10.0.42.42"),
			Region:      pulumi.String("us-central1"),
		})
		if err != nil {
			return err
		}
		_, err = compute.NewAddress(ctx, "dest-addr", &compute.AddressArgs{
			Name:        pulumi.String("dest-addr"),
			Subnetwork:  subnet.ID(),
			AddressType: pulumi.String("INTERNAL"),
			Address:     pulumi.String("10.0.43.43"),
			Region:      pulumi.String("us-central1"),
		})
		if err != nil {
			return err
		}
		_, err = networkmanagement.NewConnectivityTest(ctx, "address-test", &networkmanagement.ConnectivityTestArgs{
			Name: pulumi.String("conn-test-addr"),
			Source: &networkmanagement.ConnectivityTestSourceArgs{
				IpAddress:   source_addr.Address,
				ProjectId:   source_addr.Project,
				Network:     vpc.ID(),
				NetworkType: pulumi.String("GCP_NETWORK"),
			},
			Destination: &networkmanagement.ConnectivityTestDestinationArgs{
				IpAddress: dest_addr.Address,
				ProjectId: dest_addr.Project,
				Network:   vpc.ID(),
			},
			Protocol: pulumi.String("UDP"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.Subnetwork;
import com.pulumi.gcp.compute.SubnetworkArgs;
import com.pulumi.gcp.compute.Address;
import com.pulumi.gcp.compute.AddressArgs;
import com.pulumi.gcp.networkmanagement.ConnectivityTest;
import com.pulumi.gcp.networkmanagement.ConnectivityTestArgs;
import com.pulumi.gcp.networkmanagement.inputs.ConnectivityTestSourceArgs;
import com.pulumi.gcp.networkmanagement.inputs.ConnectivityTestDestinationArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var vpc = new Network("vpc", NetworkArgs.builder()
            .name("connectivity-vpc")
            .build());

        var subnet = new Subnetwork("subnet", SubnetworkArgs.builder()
            .name("connectivity-vpc-subnet")
            .ipCidrRange("10.0.0.0/16")
            .region("us-central1")
            .network(vpc.id())
            .build());

        var source_addr = new Address("source-addr", AddressArgs.builder()
            .name("src-addr")
            .subnetwork(subnet.id())
            .addressType("INTERNAL")
            .address("10.0.42.42")
            .region("us-central1")
            .build());

        var dest_addr = new Address("dest-addr", AddressArgs.builder()
            .name("dest-addr")
            .subnetwork(subnet.id())
            .addressType("INTERNAL")
            .address("10.0.43.43")
            .region("us-central1")
            .build());

        var address_test = new ConnectivityTest("address-test", ConnectivityTestArgs.builder()
            .name("conn-test-addr")
            .source(ConnectivityTestSourceArgs.builder()
                .ipAddress(source_addr.address())
                .projectId(source_addr.project())
                .network(vpc.id())
                .networkType("GCP_NETWORK")
                .build())
            .destination(ConnectivityTestDestinationArgs.builder()
                .ipAddress(dest_addr.address())
                .projectId(dest_addr.project())
                .network(vpc.id())
                .build())
            .protocol("UDP")
            .build());

    }
}
```
```yaml
resources:
  address-test:
    type: gcp:networkmanagement:ConnectivityTest
    properties:
      name: conn-test-addr
      source:
        ipAddress: ${["source-addr"].address}
        projectId: ${["source-addr"].project}
        network: ${vpc.id}
        networkType: GCP_NETWORK
      destination:
        ipAddress: ${["dest-addr"].address}
        projectId: ${["dest-addr"].project}
        network: ${vpc.id}
      protocol: UDP
  vpc:
    type: gcp:compute:Network
    properties:
      name: connectivity-vpc
  subnet:
    type: gcp:compute:Subnetwork
    properties:
      name: connectivity-vpc-subnet
      ipCidrRange: 10.0.0.0/16
      region: us-central1
      network: ${vpc.id}
  source-addr:
    type: gcp:compute:Address
    properties:
      name: src-addr
      subnetwork: ${subnet.id}
      addressType: INTERNAL
      address: 10.0.42.42
      region: us-central1
  dest-addr:
    type: gcp:compute:Address
    properties:
      name: dest-addr
      subnetwork: ${subnet.id}
      addressType: INTERNAL
      address: 10.0.43.43
      region: us-central1
```
<!--End PulumiCodeChooser -->

## Import

ConnectivityTest can be imported using any of these accepted formats:

* `projects/{{project}}/locations/global/connectivityTests/{{name}}`

* `{{project}}/{{name}}`

* `{{name}}`

When using the `pulumi import` command, ConnectivityTest can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkmanagement/connectivityTest:ConnectivityTest default projects/{{project}}/locations/global/connectivityTests/{{name}}
```

```sh
$ pulumi import gcp:networkmanagement/connectivityTest:ConnectivityTest default {{project}}/{{name}}
```

```sh
$ pulumi import gcp:networkmanagement/connectivityTest:ConnectivityTest default {{name}}
```

h
descriptionB" SThe user-supplied description of the Connectivity Test. Maximum of 512 characters.
î
destinationÑ:Å

networkmanagementConnectivityTestDestinationMgcp:networkmanagement/ConnectivityTestDestination:ConnectivityTestDestination˝Required. Destination specification of the Connectivity Test.
You can use a combination of destination IP address, Compute
Engine VM instance, or VPC network to uniquely identify the
destination location.
Even if the destination IP address is not unique, the source IP
location is unique. Usually, the analysis can infer the destination
endpoint from route information.
If the destination you specify is a VM instance and the instance has
multiple network interfaces, then you must also specify either a
destination IP address or VPC network to identify the destination
interface.
A reachability analysis proceeds even if the destination location
is ambiguous. However, the result can include endpoints that you
don't intend to test.
Structure is documented below.
é
labelsB2" ˚Resource labels to represent user-provided metadata. **Note**: This field is non-authoritative, and will only manage the
labels present in your configuration. Please refer to the field 'effective_labels' for all of the labels present on the
resource.
5
nameB" 'Unique name for the connectivity test.

projectB" P
protocolB" >IP Protocol of the test. When not provided, "TCP" is assumed.
¶
relatedProjectsB*" äOther projects that may be relevant for reachability analysis. This is applicable to scenarios where a test can cross
project boundaries.
·
sourcet:r
p
networkmanagementConnectivityTestSourceCgcp:networkmanagement/ConnectivityTestSource:ConnectivityTestSource‡Required. Source specification of the Connectivity Test.
You can use a combination of source IP address, virtual machine
(VM) instance, or Compute Engine network to uniquely identify the
source location.
Examples: If the source IP address is an internal IP address within
a Google Cloud Virtual Private Cloud (VPC) network, then you must
also specify the VPC network. Otherwise, specify the VM instance,
which already contains its internal IP address and VPC network
information.
If the source of the test is within an on-premises network, then
you must provide the destination VPC network.
If the source endpoint is a Compute Engine VM instance with multiple
network interfaces, the instance itself is not sufficient to
identify the endpoint. So, you must also specify the source IP
address or VPC network.
A reachability analysis proceeds even if the source location is
ambiguous. However, the test result may include endpoints that
you don't intend to test.
Structure is documented below.
"h
descriptionB" SThe user-supplied description of the Connectivity Test. Maximum of 512 characters.
"î
destinationÑ:Å

networkmanagementConnectivityTestDestinationMgcp:networkmanagement/ConnectivityTestDestination:ConnectivityTestDestination˝Required. Destination specification of the Connectivity Test.
You can use a combination of destination IP address, Compute
Engine VM instance, or VPC network to uniquely identify the
destination location.
Even if the destination IP address is not unique, the source IP
location is unique. Usually, the analysis can infer the destination
endpoint from route information.
If the destination you specify is a VM instance and the instance has
multiple network interfaces, then you must also specify either a
destination IP address or VPC network to identify the destination
interface.
A reachability analysis proceeds even if the destination location
is ambiguous. However, the result can include endpoints that you
don't intend to test.
Structure is documented below.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"é
labelsB2" ˚Resource labels to represent user-provided metadata. **Note**: This field is non-authoritative, and will only manage the
labels present in your configuration. Please refer to the field 'effective_labels' for all of the labels present on the
resource.
"3
name" 'Unique name for the connectivity test.
"
project" "P
protocolB" >IP Protocol of the test. When not provided, "TCP" is assumed.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"¶
relatedProjectsB*" äOther projects that may be relevant for reachability analysis. This is applicable to scenarios where a test can cross
project boundaries.
"·
sourcet:r
p
networkmanagementConnectivityTestSourceCgcp:networkmanagement/ConnectivityTestSource:ConnectivityTestSource‡Required. Source specification of the Connectivity Test.
You can use a combination of source IP address, virtual machine
(VM) instance, or Compute Engine network to uniquely identify the
source location.
Examples: If the source IP address is an internal IP address within
a Google Cloud Virtual Private Cloud (VPC) network, then you must
also specify the VPC network. Otherwise, specify the VM instance,
which already contains its internal IP address and VPC network
information.
If the source of the test is within an on-premises network, then
you must provide the destination VPC network.
If the source endpoint is a Compute Engine VM instance with multiple
network interfaces, the instance itself is not sufficient to
identify the endpoint. So, you must also specify the source IP
address or VPC network.
A reachability analysis proceeds even if the source location is
ambiguous. However, the test result may include endpoints that
you don't intend to test.
Structure is documented below.
*á≠
a
networkmanagementVpcFlowLogsConfig9gcp:networkmanagement/vpcFlowLogsConfig:VpcFlowLogsConfig∂Å## Example Usage

### Network Management Vpc Flow Logs Config Interconnect Full


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const project = gcp.organizations.getProject({});
const network = new gcp.compute.Network("network", {name: "full-interconnect-test-network"});
const router = new gcp.compute.Router("router", {
    name: "full-interconnect-test-router",
    network: network.name,
    bgp: {
        asn: 16550,
    },
});
const attachment = new gcp.compute.InterconnectAttachment("attachment", {
    name: "full-interconnect-test-id",
    edgeAvailabilityDomain: "AVAILABILITY_DOMAIN_1",
    type: "PARTNER",
    router: router.id,
    mtu: "1500",
});
const interconnect_test = new gcp.networkmanagement.VpcFlowLogsConfig("interconnect-test", {
    vpcFlowLogsConfigId: "full-interconnect-test-id",
    location: "global",
    interconnectAttachment: pulumi.all([project, attachment.name]).apply(([project, name]) => `projects/${project.number}/regions/us-east4/interconnectAttachments/${name}`),
    state: "ENABLED",
    aggregationInterval: "INTERVAL_5_SEC",
    description: "VPC Flow Logs over a VPN Gateway.",
    flowSampling: 0.5,
    metadata: "INCLUDE_ALL_METADATA",
});
```
```python
import pulumi
import pulumi_gcp as gcp

project = gcp.organizations.get_project()
network = gcp.compute.Network("network", name="full-interconnect-test-network")
router = gcp.compute.Router("router",
    name="full-interconnect-test-router",
    network=network.name,
    bgp={
        "asn": 16550,
    })
attachment = gcp.compute.InterconnectAttachment("attachment",
    name="full-interconnect-test-id",
    edge_availability_domain="AVAILABILITY_DOMAIN_1",
    type="PARTNER",
    router=router.id,
    mtu="1500")
interconnect_test = gcp.networkmanagement.VpcFlowLogsConfig("interconnect-test",
    vpc_flow_logs_config_id="full-interconnect-test-id",
    location="global",
    interconnect_attachment=attachment.name.apply(lambda name: f"projects/{project.number}/regions/us-east4/interconnectAttachments/{name}"),
    state="ENABLED",
    aggregation_interval="INTERVAL_5_SEC",
    description="VPC Flow Logs over a VPN Gateway.",
    flow_sampling=0.5,
    metadata="INCLUDE_ALL_METADATA")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var project = Gcp.Organizations.GetProject.Invoke();

    var network = new Gcp.Compute.Network("network", new()
    {
        Name = "full-interconnect-test-network",
    });

    var router = new Gcp.Compute.Router("router", new()
    {
        Name = "full-interconnect-test-router",
        Network = network.Name,
        Bgp = new Gcp.Compute.Inputs.RouterBgpArgs
        {
            Asn = 16550,
        },
    });

    var attachment = new Gcp.Compute.InterconnectAttachment("attachment", new()
    {
        Name = "full-interconnect-test-id",
        EdgeAvailabilityDomain = "AVAILABILITY_DOMAIN_1",
        Type = "PARTNER",
        Router = router.Id,
        Mtu = "1500",
    });

    var interconnect_test = new Gcp.NetworkManagement.VpcFlowLogsConfig("interconnect-test", new()
    {
        VpcFlowLogsConfigId = "full-interconnect-test-id",
        Location = "global",
        InterconnectAttachment = Output.Tuple(project, attachment.Name).Apply(values =>
        {
            var project = values.Item1;
            var name = values.Item2;
            return $"projects/{project.Apply(getProjectResult => getProjectResult.Number)}/regions/us-east4/interconnectAttachments/{name}";
        }),
        State = "ENABLED",
        AggregationInterval = "INTERVAL_5_SEC",
        Description = "VPC Flow Logs over a VPN Gateway.",
        FlowSampling = 0.5,
        Metadata = "INCLUDE_ALL_METADATA",
    });

});
```
```go
package main

import (
	"fmt"

	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkmanagement"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		project, err := organizations.LookupProject(ctx, &organizations.LookupProjectArgs{}, nil)
		if err != nil {
			return err
		}
		network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
			Name: pulumi.String("full-interconnect-test-network"),
		})
		if err != nil {
			return err
		}
		router, err := compute.NewRouter(ctx, "router", &compute.RouterArgs{
			Name:    pulumi.String("full-interconnect-test-router"),
			Network: network.Name,
			Bgp: &compute.RouterBgpArgs{
				Asn: pulumi.Int(16550),
			},
		})
		if err != nil {
			return err
		}
		attachment, err := compute.NewInterconnectAttachment(ctx, "attachment", &compute.InterconnectAttachmentArgs{
			Name:                   pulumi.String("full-interconnect-test-id"),
			EdgeAvailabilityDomain: pulumi.String("AVAILABILITY_DOMAIN_1"),
			Type:                   pulumi.String("PARTNER"),
			Router:                 router.ID(),
			Mtu:                    pulumi.String("1500"),
		})
		if err != nil {
			return err
		}
		_, err = networkmanagement.NewVpcFlowLogsConfig(ctx, "interconnect-test", &networkmanagement.VpcFlowLogsConfigArgs{
			VpcFlowLogsConfigId: pulumi.String("full-interconnect-test-id"),
			Location:            pulumi.String("global"),
			InterconnectAttachment: attachment.Name.ApplyT(func(name string) (string, error) {
				return fmt.Sprintf("projects/%v/regions/us-east4/interconnectAttachments/%v", project.Number, name), nil
			}).(pulumi.StringOutput),
			State:               pulumi.String("ENABLED"),
			AggregationInterval: pulumi.String("INTERVAL_5_SEC"),
			Description:         pulumi.String("VPC Flow Logs over a VPN Gateway."),
			FlowSampling:        pulumi.Float64(0.5),
			Metadata:            pulumi.String("INCLUDE_ALL_METADATA"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.organizations.OrganizationsFunctions;
import com.pulumi.gcp.organizations.inputs.GetProjectArgs;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.Router;
import com.pulumi.gcp.compute.RouterArgs;
import com.pulumi.gcp.compute.inputs.RouterBgpArgs;
import com.pulumi.gcp.compute.InterconnectAttachment;
import com.pulumi.gcp.compute.InterconnectAttachmentArgs;
import com.pulumi.gcp.networkmanagement.VpcFlowLogsConfig;
import com.pulumi.gcp.networkmanagement.VpcFlowLogsConfigArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var project = OrganizationsFunctions.getProject();

        var network = new Network("network", NetworkArgs.builder()
            .name("full-interconnect-test-network")
            .build());

        var router = new Router("router", RouterArgs.builder()
            .name("full-interconnect-test-router")
            .network(network.name())
            .bgp(RouterBgpArgs.builder()
                .asn(16550)
                .build())
            .build());

        var attachment = new InterconnectAttachment("attachment", InterconnectAttachmentArgs.builder()
            .name("full-interconnect-test-id")
            .edgeAvailabilityDomain("AVAILABILITY_DOMAIN_1")
            .type("PARTNER")
            .router(router.id())
            .mtu(1500)
            .build());

        var interconnect_test = new VpcFlowLogsConfig("interconnect-test", VpcFlowLogsConfigArgs.builder()
            .vpcFlowLogsConfigId("full-interconnect-test-id")
            .location("global")
            .interconnectAttachment(attachment.name().applyValue(name -> String.format("projects/%s/regions/us-east4/interconnectAttachments/%s", project.applyValue(getProjectResult -> getProjectResult.number()),name)))
            .state("ENABLED")
            .aggregationInterval("INTERVAL_5_SEC")
            .description("VPC Flow Logs over a VPN Gateway.")
            .flowSampling(0.5)
            .metadata("INCLUDE_ALL_METADATA")
            .build());

    }
}
```
```yaml
resources:
  interconnect-test:
    type: gcp:networkmanagement:VpcFlowLogsConfig
    properties:
      vpcFlowLogsConfigId: full-interconnect-test-id
      location: global
      interconnectAttachment: projects/${project.number}/regions/us-east4/interconnectAttachments/${attachment.name}
      state: ENABLED
      aggregationInterval: INTERVAL_5_SEC
      description: VPC Flow Logs over a VPN Gateway.
      flowSampling: 0.5
      metadata: INCLUDE_ALL_METADATA
  network:
    type: gcp:compute:Network
    properties:
      name: full-interconnect-test-network
  router:
    type: gcp:compute:Router
    properties:
      name: full-interconnect-test-router
      network: ${network.name}
      bgp:
        asn: 16550
  attachment:
    type: gcp:compute:InterconnectAttachment
    properties:
      name: full-interconnect-test-id
      edgeAvailabilityDomain: AVAILABILITY_DOMAIN_1
      type: PARTNER
      router: ${router.id}
      mtu: 1500
variables:
  project:
    fn::invoke:
      function: gcp:organizations:getProject
      arguments: {}
```
<!--End PulumiCodeChooser -->
### Network Management Vpc Flow Logs Config Interconnect Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const project = gcp.organizations.getProject({});
const network = new gcp.compute.Network("network", {name: "basic-interconnect-test-network"});
const router = new gcp.compute.Router("router", {
    name: "basic-interconnect-test-router",
    network: network.name,
    bgp: {
        asn: 16550,
    },
});
const attachment = new gcp.compute.InterconnectAttachment("attachment", {
    name: "basic-interconnect-test-id",
    edgeAvailabilityDomain: "AVAILABILITY_DOMAIN_1",
    type: "PARTNER",
    router: router.id,
    mtu: "1500",
});
const interconnect_test = new gcp.networkmanagement.VpcFlowLogsConfig("interconnect-test", {
    vpcFlowLogsConfigId: "basic-interconnect-test-id",
    location: "global",
    interconnectAttachment: pulumi.all([project, attachment.name]).apply(([project, name]) => `projects/${project.number}/regions/us-east4/interconnectAttachments/${name}`),
});
```
```python
import pulumi
import pulumi_gcp as gcp

project = gcp.organizations.get_project()
network = gcp.compute.Network("network", name="basic-interconnect-test-network")
router = gcp.compute.Router("router",
    name="basic-interconnect-test-router",
    network=network.name,
    bgp={
        "asn": 16550,
    })
attachment = gcp.compute.InterconnectAttachment("attachment",
    name="basic-interconnect-test-id",
    edge_availability_domain="AVAILABILITY_DOMAIN_1",
    type="PARTNER",
    router=router.id,
    mtu="1500")
interconnect_test = gcp.networkmanagement.VpcFlowLogsConfig("interconnect-test",
    vpc_flow_logs_config_id="basic-interconnect-test-id",
    location="global",
    interconnect_attachment=attachment.name.apply(lambda name: f"projects/{project.number}/regions/us-east4/interconnectAttachments/{name}"))
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var project = Gcp.Organizations.GetProject.Invoke();

    var network = new Gcp.Compute.Network("network", new()
    {
        Name = "basic-interconnect-test-network",
    });

    var router = new Gcp.Compute.Router("router", new()
    {
        Name = "basic-interconnect-test-router",
        Network = network.Name,
        Bgp = new Gcp.Compute.Inputs.RouterBgpArgs
        {
            Asn = 16550,
        },
    });

    var attachment = new Gcp.Compute.InterconnectAttachment("attachment", new()
    {
        Name = "basic-interconnect-test-id",
        EdgeAvailabilityDomain = "AVAILABILITY_DOMAIN_1",
        Type = "PARTNER",
        Router = router.Id,
        Mtu = "1500",
    });

    var interconnect_test = new Gcp.NetworkManagement.VpcFlowLogsConfig("interconnect-test", new()
    {
        VpcFlowLogsConfigId = "basic-interconnect-test-id",
        Location = "global",
        InterconnectAttachment = Output.Tuple(project, attachment.Name).Apply(values =>
        {
            var project = values.Item1;
            var name = values.Item2;
            return $"projects/{project.Apply(getProjectResult => getProjectResult.Number)}/regions/us-east4/interconnectAttachments/{name}";
        }),
    });

});
```
```go
package main

import (
	"fmt"

	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkmanagement"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		project, err := organizations.LookupProject(ctx, &organizations.LookupProjectArgs{}, nil)
		if err != nil {
			return err
		}
		network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
			Name: pulumi.String("basic-interconnect-test-network"),
		})
		if err != nil {
			return err
		}
		router, err := compute.NewRouter(ctx, "router", &compute.RouterArgs{
			Name:    pulumi.String("basic-interconnect-test-router"),
			Network: network.Name,
			Bgp: &compute.RouterBgpArgs{
				Asn: pulumi.Int(16550),
			},
		})
		if err != nil {
			return err
		}
		attachment, err := compute.NewInterconnectAttachment(ctx, "attachment", &compute.InterconnectAttachmentArgs{
			Name:                   pulumi.String("basic-interconnect-test-id"),
			EdgeAvailabilityDomain: pulumi.String("AVAILABILITY_DOMAIN_1"),
			Type:                   pulumi.String("PARTNER"),
			Router:                 router.ID(),
			Mtu:                    pulumi.String("1500"),
		})
		if err != nil {
			return err
		}
		_, err = networkmanagement.NewVpcFlowLogsConfig(ctx, "interconnect-test", &networkmanagement.VpcFlowLogsConfigArgs{
			VpcFlowLogsConfigId: pulumi.String("basic-interconnect-test-id"),
			Location:            pulumi.String("global"),
			InterconnectAttachment: attachment.Name.ApplyT(func(name string) (string, error) {
				return fmt.Sprintf("projects/%v/regions/us-east4/interconnectAttachments/%v", project.Number, name), nil
			}).(pulumi.StringOutput),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.organizations.OrganizationsFunctions;
import com.pulumi.gcp.organizations.inputs.GetProjectArgs;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.Router;
import com.pulumi.gcp.compute.RouterArgs;
import com.pulumi.gcp.compute.inputs.RouterBgpArgs;
import com.pulumi.gcp.compute.InterconnectAttachment;
import com.pulumi.gcp.compute.InterconnectAttachmentArgs;
import com.pulumi.gcp.networkmanagement.VpcFlowLogsConfig;
import com.pulumi.gcp.networkmanagement.VpcFlowLogsConfigArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var project = OrganizationsFunctions.getProject();

        var network = new Network("network", NetworkArgs.builder()
            .name("basic-interconnect-test-network")
            .build());

        var router = new Router("router", RouterArgs.builder()
            .name("basic-interconnect-test-router")
            .network(network.name())
            .bgp(RouterBgpArgs.builder()
                .asn(16550)
                .build())
            .build());

        var attachment = new InterconnectAttachment("attachment", InterconnectAttachmentArgs.builder()
            .name("basic-interconnect-test-id")
            .edgeAvailabilityDomain("AVAILABILITY_DOMAIN_1")
            .type("PARTNER")
            .router(router.id())
            .mtu(1500)
            .build());

        var interconnect_test = new VpcFlowLogsConfig("interconnect-test", VpcFlowLogsConfigArgs.builder()
            .vpcFlowLogsConfigId("basic-interconnect-test-id")
            .location("global")
            .interconnectAttachment(attachment.name().applyValue(name -> String.format("projects/%s/regions/us-east4/interconnectAttachments/%s", project.applyValue(getProjectResult -> getProjectResult.number()),name)))
            .build());

    }
}
```
```yaml
resources:
  interconnect-test:
    type: gcp:networkmanagement:VpcFlowLogsConfig
    properties:
      vpcFlowLogsConfigId: basic-interconnect-test-id
      location: global
      interconnectAttachment: projects/${project.number}/regions/us-east4/interconnectAttachments/${attachment.name}
  network:
    type: gcp:compute:Network
    properties:
      name: basic-interconnect-test-network
  router:
    type: gcp:compute:Router
    properties:
      name: basic-interconnect-test-router
      network: ${network.name}
      bgp:
        asn: 16550
  attachment:
    type: gcp:compute:InterconnectAttachment
    properties:
      name: basic-interconnect-test-id
      edgeAvailabilityDomain: AVAILABILITY_DOMAIN_1
      type: PARTNER
      router: ${router.id}
      mtu: 1500
variables:
  project:
    fn::invoke:
      function: gcp:organizations:getProject
      arguments: {}
```
<!--End PulumiCodeChooser -->
### Network Management Vpc Flow Logs Config Vpn Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const project = gcp.organizations.getProject({});
const network = new gcp.compute.Network("network", {name: "basic-test-network"});
const targetGateway = new gcp.compute.VPNGateway("target_gateway", {
    name: "basic-test-gateway",
    network: network.id,
});
const vpnStaticIp = new gcp.compute.Address("vpn_static_ip", {name: "basic-test-address"});
const frEsp = new gcp.compute.ForwardingRule("fr_esp", {
    name: "basic-test-fresp",
    ipProtocol: "ESP",
    ipAddress: vpnStaticIp.address,
    target: targetGateway.id,
});
const frUdp500 = new gcp.compute.ForwardingRule("fr_udp500", {
    name: "basic-test-fr500",
    ipProtocol: "UDP",
    portRange: "500",
    ipAddress: vpnStaticIp.address,
    target: targetGateway.id,
});
const frUdp4500 = new gcp.compute.ForwardingRule("fr_udp4500", {
    name: "basic-test-fr4500",
    ipProtocol: "UDP",
    portRange: "4500",
    ipAddress: vpnStaticIp.address,
    target: targetGateway.id,
});
const tunnel = new gcp.compute.VPNTunnel("tunnel", {
    name: "basic-test-tunnel",
    peerIp: "15.0.0.120",
    sharedSecret: "a secret message",
    targetVpnGateway: targetGateway.id,
}, {
    dependsOn: [
        frEsp,
        frUdp500,
        frUdp4500,
    ],
});
const vpn_test = new gcp.networkmanagement.VpcFlowLogsConfig("vpn-test", {
    vpcFlowLogsConfigId: "basic-test-id",
    location: "global",
    vpnTunnel: pulumi.all([project, tunnel.name]).apply(([project, name]) => `projects/${project.number}/regions/us-central1/vpnTunnels/${name}`),
});
const route = new gcp.compute.Route("route", {
    name: "basic-test-route",
    network: network.name,
    destRange: "15.0.0.0/24",
    priority: 1000,
    nextHopVpnTunnel: tunnel.id,
});
```
```python
import pulumi
import pulumi_gcp as gcp

project = gcp.organizations.get_project()
network = gcp.compute.Network("network", name="basic-test-network")
target_gateway = gcp.compute.VPNGateway("target_gateway",
    name="basic-test-gateway",
    network=network.id)
vpn_static_ip = gcp.compute.Address("vpn_static_ip", name="basic-test-address")
fr_esp = gcp.compute.ForwardingRule("fr_esp",
    name="basic-test-fresp",
    ip_protocol="ESP",
    ip_address=vpn_static_ip.address,
    target=target_gateway.id)
fr_udp500 = gcp.compute.ForwardingRule("fr_udp500",
    name="basic-test-fr500",
    ip_protocol="UDP",
    port_range="500",
    ip_address=vpn_static_ip.address,
    target=target_gateway.id)
fr_udp4500 = gcp.compute.ForwardingRule("fr_udp4500",
    name="basic-test-fr4500",
    ip_protocol="UDP",
    port_range="4500",
    ip_address=vpn_static_ip.address,
    target=target_gateway.id)
tunnel = gcp.compute.VPNTunnel("tunnel",
    name="basic-test-tunnel",
    peer_ip="15.0.0.120",
    shared_secret="a secret message",
    target_vpn_gateway=target_gateway.id,
    opts = pulumi.ResourceOptions(depends_on=[
            fr_esp,
            fr_udp500,
            fr_udp4500,
        ]))
vpn_test = gcp.networkmanagement.VpcFlowLogsConfig("vpn-test",
    vpc_flow_logs_config_id="basic-test-id",
    location="global",
    vpn_tunnel=tunnel.name.apply(lambda name: f"projects/{project.number}/regions/us-central1/vpnTunnels/{name}"))
route = gcp.compute.Route("route",
    name="basic-test-route",
    network=network.name,
    dest_range="15.0.0.0/24",
    priority=1000,
    next_hop_vpn_tunnel=tunnel.id)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var project = Gcp.Organizations.GetProject.Invoke();

    var network = new Gcp.Compute.Network("network", new()
    {
        Name = "basic-test-network",
    });

    var targetGateway = new Gcp.Compute.VPNGateway("target_gateway", new()
    {
        Name = "basic-test-gateway",
        Network = network.Id,
    });

    var vpnStaticIp = new Gcp.Compute.Address("vpn_static_ip", new()
    {
        Name = "basic-test-address",
    });

    var frEsp = new Gcp.Compute.ForwardingRule("fr_esp", new()
    {
        Name = "basic-test-fresp",
        IpProtocol = "ESP",
        IpAddress = vpnStaticIp.IPAddress,
        Target = targetGateway.Id,
    });

    var frUdp500 = new Gcp.Compute.ForwardingRule("fr_udp500", new()
    {
        Name = "basic-test-fr500",
        IpProtocol = "UDP",
        PortRange = "500",
        IpAddress = vpnStaticIp.IPAddress,
        Target = targetGateway.Id,
    });

    var frUdp4500 = new Gcp.Compute.ForwardingRule("fr_udp4500", new()
    {
        Name = "basic-test-fr4500",
        IpProtocol = "UDP",
        PortRange = "4500",
        IpAddress = vpnStaticIp.IPAddress,
        Target = targetGateway.Id,
    });

    var tunnel = new Gcp.Compute.VPNTunnel("tunnel", new()
    {
        Name = "basic-test-tunnel",
        PeerIp = "15.0.0.120",
        SharedSecret = "a secret message",
        TargetVpnGateway = targetGateway.Id,
    }, new CustomResourceOptions
    {
        DependsOn =
        {
            frEsp,
            frUdp500,
            frUdp4500,
        },
    });

    var vpn_test = new Gcp.NetworkManagement.VpcFlowLogsConfig("vpn-test", new()
    {
        VpcFlowLogsConfigId = "basic-test-id",
        Location = "global",
        VpnTunnel = Output.Tuple(project, tunnel.Name).Apply(values =>
        {
            var project = values.Item1;
            var name = values.Item2;
            return $"projects/{project.Apply(getProjectResult => getProjectResult.Number)}/regions/us-central1/vpnTunnels/{name}";
        }),
    });

    var route = new Gcp.Compute.Route("route", new()
    {
        Name = "basic-test-route",
        Network = network.Name,
        DestRange = "15.0.0.0/24",
        Priority = 1000,
        NextHopVpnTunnel = tunnel.Id,
    });

});
```
```go
package main

import (
	"fmt"

	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkmanagement"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		project, err := organizations.LookupProject(ctx, &organizations.LookupProjectArgs{}, nil)
		if err != nil {
			return err
		}
		network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
			Name: pulumi.String("basic-test-network"),
		})
		if err != nil {
			return err
		}
		targetGateway, err := compute.NewVPNGateway(ctx, "target_gateway", &compute.VPNGatewayArgs{
			Name:    pulumi.String("basic-test-gateway"),
			Network: network.ID(),
		})
		if err != nil {
			return err
		}
		vpnStaticIp, err := compute.NewAddress(ctx, "vpn_static_ip", &compute.AddressArgs{
			Name: pulumi.String("basic-test-address"),
		})
		if err != nil {
			return err
		}
		frEsp, err := compute.NewForwardingRule(ctx, "fr_esp", &compute.ForwardingRuleArgs{
			Name:       pulumi.String("basic-test-fresp"),
			IpProtocol: pulumi.String("ESP"),
			IpAddress:  vpnStaticIp.Address,
			Target:     targetGateway.ID(),
		})
		if err != nil {
			return err
		}
		frUdp500, err := compute.NewForwardingRule(ctx, "fr_udp500", &compute.ForwardingRuleArgs{
			Name:       pulumi.String("basic-test-fr500"),
			IpProtocol: pulumi.String("UDP"),
			PortRange:  pulumi.String("500"),
			IpAddress:  vpnStaticIp.Address,
			Target:     targetGateway.ID(),
		})
		if err != nil {
			return err
		}
		frUdp4500, err := compute.NewForwardingRule(ctx, "fr_udp4500", &compute.ForwardingRuleArgs{
			Name:       pulumi.String("basic-test-fr4500"),
			IpProtocol: pulumi.String("UDP"),
			PortRange:  pulumi.String("4500"),
			IpAddress:  vpnStaticIp.Address,
			Target:     targetGateway.ID(),
		})
		if err != nil {
			return err
		}
		tunnel, err := compute.NewVPNTunnel(ctx, "tunnel", &compute.VPNTunnelArgs{
			Name:             pulumi.String("basic-test-tunnel"),
			PeerIp:           pulumi.String("15.0.0.120"),
			SharedSecret:     pulumi.String("a secret message"),
			TargetVpnGateway: targetGateway.ID(),
		}, pulumi.DependsOn([]pulumi.Resource{
			frEsp,
			frUdp500,
			frUdp4500,
		}))
		if err != nil {
			return err
		}
		_, err = networkmanagement.NewVpcFlowLogsConfig(ctx, "vpn-test", &networkmanagement.VpcFlowLogsConfigArgs{
			VpcFlowLogsConfigId: pulumi.String("basic-test-id"),
			Location:            pulumi.String("global"),
			VpnTunnel: tunnel.Name.ApplyT(func(name string) (string, error) {
				return fmt.Sprintf("projects/%v/regions/us-central1/vpnTunnels/%v", project.Number, name), nil
			}).(pulumi.StringOutput),
		})
		if err != nil {
			return err
		}
		_, err = compute.NewRoute(ctx, "route", &compute.RouteArgs{
			Name:             pulumi.String("basic-test-route"),
			Network:          network.Name,
			DestRange:        pulumi.String("15.0.0.0/24"),
			Priority:         pulumi.Int(1000),
			NextHopVpnTunnel: tunnel.ID(),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.organizations.OrganizationsFunctions;
import com.pulumi.gcp.organizations.inputs.GetProjectArgs;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.VPNGateway;
import com.pulumi.gcp.compute.VPNGatewayArgs;
import com.pulumi.gcp.compute.Address;
import com.pulumi.gcp.compute.AddressArgs;
import com.pulumi.gcp.compute.ForwardingRule;
import com.pulumi.gcp.compute.ForwardingRuleArgs;
import com.pulumi.gcp.compute.VPNTunnel;
import com.pulumi.gcp.compute.VPNTunnelArgs;
import com.pulumi.gcp.networkmanagement.VpcFlowLogsConfig;
import com.pulumi.gcp.networkmanagement.VpcFlowLogsConfigArgs;
import com.pulumi.gcp.compute.Route;
import com.pulumi.gcp.compute.RouteArgs;
import com.pulumi.resources.CustomResourceOptions;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var project = OrganizationsFunctions.getProject();

        var network = new Network("network", NetworkArgs.builder()
            .name("basic-test-network")
            .build());

        var targetGateway = new VPNGateway("targetGateway", VPNGatewayArgs.builder()
            .name("basic-test-gateway")
            .network(network.id())
            .build());

        var vpnStaticIp = new Address("vpnStaticIp", AddressArgs.builder()
            .name("basic-test-address")
            .build());

        var frEsp = new ForwardingRule("frEsp", ForwardingRuleArgs.builder()
            .name("basic-test-fresp")
            .ipProtocol("ESP")
            .ipAddress(vpnStaticIp.address())
            .target(targetGateway.id())
            .build());

        var frUdp500 = new ForwardingRule("frUdp500", ForwardingRuleArgs.builder()
            .name("basic-test-fr500")
            .ipProtocol("UDP")
            .portRange("500")
            .ipAddress(vpnStaticIp.address())
            .target(targetGateway.id())
            .build());

        var frUdp4500 = new ForwardingRule("frUdp4500", ForwardingRuleArgs.builder()
            .name("basic-test-fr4500")
            .ipProtocol("UDP")
            .portRange("4500")
            .ipAddress(vpnStaticIp.address())
            .target(targetGateway.id())
            .build());

        var tunnel = new VPNTunnel("tunnel", VPNTunnelArgs.builder()
            .name("basic-test-tunnel")
            .peerIp("15.0.0.120")
            .sharedSecret("a secret message")
            .targetVpnGateway(targetGateway.id())
            .build(), CustomResourceOptions.builder()
                .dependsOn(                
                    frEsp,
                    frUdp500,
                    frUdp4500)
                .build());

        var vpn_test = new VpcFlowLogsConfig("vpn-test", VpcFlowLogsConfigArgs.builder()
            .vpcFlowLogsConfigId("basic-test-id")
            .location("global")
            .vpnTunnel(tunnel.name().applyValue(name -> String.format("projects/%s/regions/us-central1/vpnTunnels/%s", project.applyValue(getProjectResult -> getProjectResult.number()),name)))
            .build());

        var route = new Route("route", RouteArgs.builder()
            .name("basic-test-route")
            .network(network.name())
            .destRange("15.0.0.0/24")
            .priority(1000)
            .nextHopVpnTunnel(tunnel.id())
            .build());

    }
}
```
```yaml
resources:
  vpn-test:
    type: gcp:networkmanagement:VpcFlowLogsConfig
    properties:
      vpcFlowLogsConfigId: basic-test-id
      location: global
      vpnTunnel: projects/${project.number}/regions/us-central1/vpnTunnels/${tunnel.name}
  tunnel:
    type: gcp:compute:VPNTunnel
    properties:
      name: basic-test-tunnel
      peerIp: 15.0.0.120
      sharedSecret: a secret message
      targetVpnGateway: ${targetGateway.id}
    options:
      dependsOn:
        - ${frEsp}
        - ${frUdp500}
        - ${frUdp4500}
  targetGateway:
    type: gcp:compute:VPNGateway
    name: target_gateway
    properties:
      name: basic-test-gateway
      network: ${network.id}
  network:
    type: gcp:compute:Network
    properties:
      name: basic-test-network
  vpnStaticIp:
    type: gcp:compute:Address
    name: vpn_static_ip
    properties:
      name: basic-test-address
  frEsp:
    type: gcp:compute:ForwardingRule
    name: fr_esp
    properties:
      name: basic-test-fresp
      ipProtocol: ESP
      ipAddress: ${vpnStaticIp.address}
      target: ${targetGateway.id}
  frUdp500:
    type: gcp:compute:ForwardingRule
    name: fr_udp500
    properties:
      name: basic-test-fr500
      ipProtocol: UDP
      portRange: '500'
      ipAddress: ${vpnStaticIp.address}
      target: ${targetGateway.id}
  frUdp4500:
    type: gcp:compute:ForwardingRule
    name: fr_udp4500
    properties:
      name: basic-test-fr4500
      ipProtocol: UDP
      portRange: '4500'
      ipAddress: ${vpnStaticIp.address}
      target: ${targetGateway.id}
  route:
    type: gcp:compute:Route
    properties:
      name: basic-test-route
      network: ${network.name}
      destRange: 15.0.0.0/24
      priority: 1000
      nextHopVpnTunnel: ${tunnel.id}
variables:
  project:
    fn::invoke:
      function: gcp:organizations:getProject
      arguments: {}
```
<!--End PulumiCodeChooser -->
### Network Management Vpc Flow Logs Config Vpn Full


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const project = gcp.organizations.getProject({});
const network = new gcp.compute.Network("network", {name: "full-test-network"});
const targetGateway = new gcp.compute.VPNGateway("target_gateway", {
    name: "full-test-gateway",
    network: network.id,
});
const vpnStaticIp = new gcp.compute.Address("vpn_static_ip", {name: "full-test-address"});
const frEsp = new gcp.compute.ForwardingRule("fr_esp", {
    name: "full-test-fresp",
    ipProtocol: "ESP",
    ipAddress: vpnStaticIp.address,
    target: targetGateway.id,
});
const frUdp500 = new gcp.compute.ForwardingRule("fr_udp500", {
    name: "full-test-fr500",
    ipProtocol: "UDP",
    portRange: "500",
    ipAddress: vpnStaticIp.address,
    target: targetGateway.id,
});
const frUdp4500 = new gcp.compute.ForwardingRule("fr_udp4500", {
    name: "full-test-fr4500",
    ipProtocol: "UDP",
    portRange: "4500",
    ipAddress: vpnStaticIp.address,
    target: targetGateway.id,
});
const tunnel = new gcp.compute.VPNTunnel("tunnel", {
    name: "full-test-tunnel",
    peerIp: "15.0.0.120",
    sharedSecret: "a secret message",
    targetVpnGateway: targetGateway.id,
}, {
    dependsOn: [
        frEsp,
        frUdp500,
        frUdp4500,
    ],
});
const vpn_test = new gcp.networkmanagement.VpcFlowLogsConfig("vpn-test", {
    vpcFlowLogsConfigId: "full-test-id",
    location: "global",
    vpnTunnel: pulumi.all([project, tunnel.name]).apply(([project, name]) => `projects/${project.number}/regions/us-central1/vpnTunnels/${name}`),
    state: "ENABLED",
    aggregationInterval: "INTERVAL_5_SEC",
    description: "VPC Flow Logs over a VPN Gateway.",
    flowSampling: 0.5,
    metadata: "INCLUDE_ALL_METADATA",
});
const route = new gcp.compute.Route("route", {
    name: "full-test-route",
    network: network.name,
    destRange: "15.0.0.0/24",
    priority: 1000,
    nextHopVpnTunnel: tunnel.id,
});
```
```python
import pulumi
import pulumi_gcp as gcp

project = gcp.organizations.get_project()
network = gcp.compute.Network("network", name="full-test-network")
target_gateway = gcp.compute.VPNGateway("target_gateway",
    name="full-test-gateway",
    network=network.id)
vpn_static_ip = gcp.compute.Address("vpn_static_ip", name="full-test-address")
fr_esp = gcp.compute.ForwardingRule("fr_esp",
    name="full-test-fresp",
    ip_protocol="ESP",
    ip_address=vpn_static_ip.address,
    target=target_gateway.id)
fr_udp500 = gcp.compute.ForwardingRule("fr_udp500",
    name="full-test-fr500",
    ip_protocol="UDP",
    port_range="500",
    ip_address=vpn_static_ip.address,
    target=target_gateway.id)
fr_udp4500 = gcp.compute.ForwardingRule("fr_udp4500",
    name="full-test-fr4500",
    ip_protocol="UDP",
    port_range="4500",
    ip_address=vpn_static_ip.address,
    target=target_gateway.id)
tunnel = gcp.compute.VPNTunnel("tunnel",
    name="full-test-tunnel",
    peer_ip="15.0.0.120",
    shared_secret="a secret message",
    target_vpn_gateway=target_gateway.id,
    opts = pulumi.ResourceOptions(depends_on=[
            fr_esp,
            fr_udp500,
            fr_udp4500,
        ]))
vpn_test = gcp.networkmanagement.VpcFlowLogsConfig("vpn-test",
    vpc_flow_logs_config_id="full-test-id",
    location="global",
    vpn_tunnel=tunnel.name.apply(lambda name: f"projects/{project.number}/regions/us-central1/vpnTunnels/{name}"),
    state="ENABLED",
    aggregation_interval="INTERVAL_5_SEC",
    description="VPC Flow Logs over a VPN Gateway.",
    flow_sampling=0.5,
    metadata="INCLUDE_ALL_METADATA")
route = gcp.compute.Route("route",
    name="full-test-route",
    network=network.name,
    dest_range="15.0.0.0/24",
    priority=1000,
    next_hop_vpn_tunnel=tunnel.id)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var project = Gcp.Organizations.GetProject.Invoke();

    var network = new Gcp.Compute.Network("network", new()
    {
        Name = "full-test-network",
    });

    var targetGateway = new Gcp.Compute.VPNGateway("target_gateway", new()
    {
        Name = "full-test-gateway",
        Network = network.Id,
    });

    var vpnStaticIp = new Gcp.Compute.Address("vpn_static_ip", new()
    {
        Name = "full-test-address",
    });

    var frEsp = new Gcp.Compute.ForwardingRule("fr_esp", new()
    {
        Name = "full-test-fresp",
        IpProtocol = "ESP",
        IpAddress = vpnStaticIp.IPAddress,
        Target = targetGateway.Id,
    });

    var frUdp500 = new Gcp.Compute.ForwardingRule("fr_udp500", new()
    {
        Name = "full-test-fr500",
        IpProtocol = "UDP",
        PortRange = "500",
        IpAddress = vpnStaticIp.IPAddress,
        Target = targetGateway.Id,
    });

    var frUdp4500 = new Gcp.Compute.ForwardingRule("fr_udp4500", new()
    {
        Name = "full-test-fr4500",
        IpProtocol = "UDP",
        PortRange = "4500",
        IpAddress = vpnStaticIp.IPAddress,
        Target = targetGateway.Id,
    });

    var tunnel = new Gcp.Compute.VPNTunnel("tunnel", new()
    {
        Name = "full-test-tunnel",
        PeerIp = "15.0.0.120",
        SharedSecret = "a secret message",
        TargetVpnGateway = targetGateway.Id,
    }, new CustomResourceOptions
    {
        DependsOn =
        {
            frEsp,
            frUdp500,
            frUdp4500,
        },
    });

    var vpn_test = new Gcp.NetworkManagement.VpcFlowLogsConfig("vpn-test", new()
    {
        VpcFlowLogsConfigId = "full-test-id",
        Location = "global",
        VpnTunnel = Output.Tuple(project, tunnel.Name).Apply(values =>
        {
            var project = values.Item1;
            var name = values.Item2;
            return $"projects/{project.Apply(getProjectResult => getProjectResult.Number)}/regions/us-central1/vpnTunnels/{name}";
        }),
        State = "ENABLED",
        AggregationInterval = "INTERVAL_5_SEC",
        Description = "VPC Flow Logs over a VPN Gateway.",
        FlowSampling = 0.5,
        Metadata = "INCLUDE_ALL_METADATA",
    });

    var route = new Gcp.Compute.Route("route", new()
    {
        Name = "full-test-route",
        Network = network.Name,
        DestRange = "15.0.0.0/24",
        Priority = 1000,
        NextHopVpnTunnel = tunnel.Id,
    });

});
```
```go
package main

import (
	"fmt"

	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkmanagement"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		project, err := organizations.LookupProject(ctx, &organizations.LookupProjectArgs{}, nil)
		if err != nil {
			return err
		}
		network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
			Name: pulumi.String("full-test-network"),
		})
		if err != nil {
			return err
		}
		targetGateway, err := compute.NewVPNGateway(ctx, "target_gateway", &compute.VPNGatewayArgs{
			Name:    pulumi.String("full-test-gateway"),
			Network: network.ID(),
		})
		if err != nil {
			return err
		}
		vpnStaticIp, err := compute.NewAddress(ctx, "vpn_static_ip", &compute.AddressArgs{
			Name: pulumi.String("full-test-address"),
		})
		if err != nil {
			return err
		}
		frEsp, err := compute.NewForwardingRule(ctx, "fr_esp", &compute.ForwardingRuleArgs{
			Name:       pulumi.String("full-test-fresp"),
			IpProtocol: pulumi.String("ESP"),
			IpAddress:  vpnStaticIp.Address,
			Target:     targetGateway.ID(),
		})
		if err != nil {
			return err
		}
		frUdp500, err := compute.NewForwardingRule(ctx, "fr_udp500", &compute.ForwardingRuleArgs{
			Name:       pulumi.String("full-test-fr500"),
			IpProtocol: pulumi.String("UDP"),
			PortRange:  pulumi.String("500"),
			IpAddress:  vpnStaticIp.Address,
			Target:     targetGateway.ID(),
		})
		if err != nil {
			return err
		}
		frUdp4500, err := compute.NewForwardingRule(ctx, "fr_udp4500", &compute.ForwardingRuleArgs{
			Name:       pulumi.String("full-test-fr4500"),
			IpProtocol: pulumi.String("UDP"),
			PortRange:  pulumi.String("4500"),
			IpAddress:  vpnStaticIp.Address,
			Target:     targetGateway.ID(),
		})
		if err != nil {
			return err
		}
		tunnel, err := compute.NewVPNTunnel(ctx, "tunnel", &compute.VPNTunnelArgs{
			Name:             pulumi.String("full-test-tunnel"),
			PeerIp:           pulumi.String("15.0.0.120"),
			SharedSecret:     pulumi.String("a secret message"),
			TargetVpnGateway: targetGateway.ID(),
		}, pulumi.DependsOn([]pulumi.Resource{
			frEsp,
			frUdp500,
			frUdp4500,
		}))
		if err != nil {
			return err
		}
		_, err = networkmanagement.NewVpcFlowLogsConfig(ctx, "vpn-test", &networkmanagement.VpcFlowLogsConfigArgs{
			VpcFlowLogsConfigId: pulumi.String("full-test-id"),
			Location:            pulumi.String("global"),
			VpnTunnel: tunnel.Name.ApplyT(func(name string) (string, error) {
				return fmt.Sprintf("projects/%v/regions/us-central1/vpnTunnels/%v", project.Number, name), nil
			}).(pulumi.StringOutput),
			State:               pulumi.String("ENABLED"),
			AggregationInterval: pulumi.String("INTERVAL_5_SEC"),
			Description:         pulumi.String("VPC Flow Logs over a VPN Gateway."),
			FlowSampling:        pulumi.Float64(0.5),
			Metadata:            pulumi.String("INCLUDE_ALL_METADATA"),
		})
		if err != nil {
			return err
		}
		_, err = compute.NewRoute(ctx, "route", &compute.RouteArgs{
			Name:             pulumi.String("full-test-route"),
			Network:          network.Name,
			DestRange:        pulumi.String("15.0.0.0/24"),
			Priority:         pulumi.Int(1000),
			NextHopVpnTunnel: tunnel.ID(),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.organizations.OrganizationsFunctions;
import com.pulumi.gcp.organizations.inputs.GetProjectArgs;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.VPNGateway;
import com.pulumi.gcp.compute.VPNGatewayArgs;
import com.pulumi.gcp.compute.Address;
import com.pulumi.gcp.compute.AddressArgs;
import com.pulumi.gcp.compute.ForwardingRule;
import com.pulumi.gcp.compute.ForwardingRuleArgs;
import com.pulumi.gcp.compute.VPNTunnel;
import com.pulumi.gcp.compute.VPNTunnelArgs;
import com.pulumi.gcp.networkmanagement.VpcFlowLogsConfig;
import com.pulumi.gcp.networkmanagement.VpcFlowLogsConfigArgs;
import com.pulumi.gcp.compute.Route;
import com.pulumi.gcp.compute.RouteArgs;
import com.pulumi.resources.CustomResourceOptions;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var project = OrganizationsFunctions.getProject();

        var network = new Network("network", NetworkArgs.builder()
            .name("full-test-network")
            .build());

        var targetGateway = new VPNGateway("targetGateway", VPNGatewayArgs.builder()
            .name("full-test-gateway")
            .network(network.id())
            .build());

        var vpnStaticIp = new Address("vpnStaticIp", AddressArgs.builder()
            .name("full-test-address")
            .build());

        var frEsp = new ForwardingRule("frEsp", ForwardingRuleArgs.builder()
            .name("full-test-fresp")
            .ipProtocol("ESP")
            .ipAddress(vpnStaticIp.address())
            .target(targetGateway.id())
            .build());

        var frUdp500 = new ForwardingRule("frUdp500", ForwardingRuleArgs.builder()
            .name("full-test-fr500")
            .ipProtocol("UDP")
            .portRange("500")
            .ipAddress(vpnStaticIp.address())
            .target(targetGateway.id())
            .build());

        var frUdp4500 = new ForwardingRule("frUdp4500", ForwardingRuleArgs.builder()
            .name("full-test-fr4500")
            .ipProtocol("UDP")
            .portRange("4500")
            .ipAddress(vpnStaticIp.address())
            .target(targetGateway.id())
            .build());

        var tunnel = new VPNTunnel("tunnel", VPNTunnelArgs.builder()
            .name("full-test-tunnel")
            .peerIp("15.0.0.120")
            .sharedSecret("a secret message")
            .targetVpnGateway(targetGateway.id())
            .build(), CustomResourceOptions.builder()
                .dependsOn(                
                    frEsp,
                    frUdp500,
                    frUdp4500)
                .build());

        var vpn_test = new VpcFlowLogsConfig("vpn-test", VpcFlowLogsConfigArgs.builder()
            .vpcFlowLogsConfigId("full-test-id")
            .location("global")
            .vpnTunnel(tunnel.name().applyValue(name -> String.format("projects/%s/regions/us-central1/vpnTunnels/%s", project.applyValue(getProjectResult -> getProjectResult.number()),name)))
            .state("ENABLED")
            .aggregationInterval("INTERVAL_5_SEC")
            .description("VPC Flow Logs over a VPN Gateway.")
            .flowSampling(0.5)
            .metadata("INCLUDE_ALL_METADATA")
            .build());

        var route = new Route("route", RouteArgs.builder()
            .name("full-test-route")
            .network(network.name())
            .destRange("15.0.0.0/24")
            .priority(1000)
            .nextHopVpnTunnel(tunnel.id())
            .build());

    }
}
```
```yaml
resources:
  vpn-test:
    type: gcp:networkmanagement:VpcFlowLogsConfig
    properties:
      vpcFlowLogsConfigId: full-test-id
      location: global
      vpnTunnel: projects/${project.number}/regions/us-central1/vpnTunnels/${tunnel.name}
      state: ENABLED
      aggregationInterval: INTERVAL_5_SEC
      description: VPC Flow Logs over a VPN Gateway.
      flowSampling: 0.5
      metadata: INCLUDE_ALL_METADATA
  tunnel:
    type: gcp:compute:VPNTunnel
    properties:
      name: full-test-tunnel
      peerIp: 15.0.0.120
      sharedSecret: a secret message
      targetVpnGateway: ${targetGateway.id}
    options:
      dependsOn:
        - ${frEsp}
        - ${frUdp500}
        - ${frUdp4500}
  targetGateway:
    type: gcp:compute:VPNGateway
    name: target_gateway
    properties:
      name: full-test-gateway
      network: ${network.id}
  network:
    type: gcp:compute:Network
    properties:
      name: full-test-network
  vpnStaticIp:
    type: gcp:compute:Address
    name: vpn_static_ip
    properties:
      name: full-test-address
  frEsp:
    type: gcp:compute:ForwardingRule
    name: fr_esp
    properties:
      name: full-test-fresp
      ipProtocol: ESP
      ipAddress: ${vpnStaticIp.address}
      target: ${targetGateway.id}
  frUdp500:
    type: gcp:compute:ForwardingRule
    name: fr_udp500
    properties:
      name: full-test-fr500
      ipProtocol: UDP
      portRange: '500'
      ipAddress: ${vpnStaticIp.address}
      target: ${targetGateway.id}
  frUdp4500:
    type: gcp:compute:ForwardingRule
    name: fr_udp4500
    properties:
      name: full-test-fr4500
      ipProtocol: UDP
      portRange: '4500'
      ipAddress: ${vpnStaticIp.address}
      target: ${targetGateway.id}
  route:
    type: gcp:compute:Route
    properties:
      name: full-test-route
      network: ${network.name}
      destRange: 15.0.0.0/24
      priority: 1000
      nextHopVpnTunnel: ${tunnel.id}
variables:
  project:
    fn::invoke:
      function: gcp:organizations:getProject
      arguments: {}
```
<!--End PulumiCodeChooser -->

## Import

VpcFlowLogsConfig can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/vpcFlowLogsConfigs/{{vpc_flow_logs_config_id}}`

* `{{project}}/{{location}}/{{vpc_flow_logs_config_id}}`

* `{{location}}/{{vpc_flow_logs_config_id}}`

When using the `pulumi import` command, VpcFlowLogsConfig can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkmanagement/vpcFlowLogsConfig:VpcFlowLogsConfig default projects/{{project}}/locations/{{location}}/vpcFlowLogsConfigs/{{vpc_flow_logs_config_id}}
```

```sh
$ pulumi import gcp:networkmanagement/vpcFlowLogsConfig:VpcFlowLogsConfig default {{project}}/{{location}}/{{vpc_flow_logs_config_id}}
```

```sh
$ pulumi import gcp:networkmanagement/vpcFlowLogsConfig:VpcFlowLogsConfig default {{location}}/{{vpc_flow_logs_config_id}}
```

É
aggregationIntervalB" ÂOptional. The aggregation interval for the logs. Default value is
INTERVAL_5_SEC.   Possible values:  AGGREGATION_INTERVAL_UNSPECIFIED INTERVAL_5_SEC INTERVAL_30_SEC INTERVAL_1_MIN INTERVAL_5_MIN INTERVAL_10_MIN INTERVAL_15_MIN"
|
descriptionB" gOptional. The user-supplied description of the VPC Flow Logs configuration. Maximum
of 512 characters.
a

filterExprB" MOptional. Export filter used to define which VPC Flow Logs should be logged.
©
flowSamplingB íOptional. The value of the field must be in (0, 1]. The sampling rate
of VPC Flow Logs where 1.0 means all collected logs are reported. Setting the
sampling rate to 0.0 is not allowed. If you want to disable VPC Flow Logs, use
the state field instead. Default value is 1.0.
®
interconnectAttachmentB" áTraffic will be logged from the Interconnect Attachment. Format: projects/{project_id}/regions/{region}/interconnectAttachments/{name}
ô
labelsB2" ÜOptional. Resource labels to represent user-provided metadata.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
˛
location" ÌResource ID segment making up resource `name`. It identifies the resource
within its parent collection as described in https://google.aip.dev/122. See documentation
for resource type `networkmanagement.googleapis.com/VpcFlowLogsConfig`.
ê
metadataB" ˝Optional. Configures whether all, none or a subset of metadata fields
should be added to the reported VPC flow logs. Default value is INCLUDE_ALL_METADATA.
Possible values:  METADATA_UNSPECIFIED INCLUDE_ALL_METADATA EXCLUDE_ALL_METADATA CUSTOM_METADATA
®
metadataFieldsB*" çOptional. Custom metadata fields to include in the reported VPC flow
logs. Can only be specified if \"metadata\" was set to CUSTOM_METADATA.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
£
stateB" ìOptional. The state of the VPC Flow Log configuration. Default value
is ENABLED. When creating a new configuration, it must be enabled.   Possible
L
vpcFlowLogsConfigId" 1Required. ID of the `VpcFlowLogsConfig`.


- - -
Ä
	vpnTunnelB" mTraffic will be logged from the VPN Tunnel. Format: projects/{project_id}/regions/{region}/vpnTunnels/{name}
"Å
aggregationInterval" ÂOptional. The aggregation interval for the logs. Default value is
INTERVAL_5_SEC.   Possible values:  AGGREGATION_INTERVAL_UNSPECIFIED INTERVAL_5_SEC INTERVAL_30_SEC INTERVAL_1_MIN INTERVAL_5_MIN INTERVAL_10_MIN INTERVAL_15_MIN"
"@

createTime" .Output only. The time the config was created.
"|
descriptionB" gOptional. The user-supplied description of the VPC Flow Logs configuration. Maximum
of 512 characters.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"a

filterExprB" MOptional. Export filter used to define which VPC Flow Logs should be logged.
"ß
flowSampling íOptional. The value of the field must be in (0, 1]. The sampling rate
of VPC Flow Logs where 1.0 means all collected logs are reported. Setting the
sampling rate to 0.0 is not allowed. If you want to disable VPC Flow Logs, use
the state field instead. Default value is 1.0.
"®
interconnectAttachmentB" áTraffic will be logged from the Interconnect Attachment. Format: projects/{project_id}/regions/{region}/interconnectAttachments/{name}
"ô
labelsB2" ÜOptional. Resource labels to represent user-provided metadata.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"˛
location" ÌResource ID segment making up resource `name`. It identifies the resource
within its parent collection as described in https://google.aip.dev/122. See documentation
for resource type `networkmanagement.googleapis.com/VpcFlowLogsConfig`.
"é
metadata" ˝Optional. Configures whether all, none or a subset of metadata fields
should be added to the reported VPC flow logs. Default value is INCLUDE_ALL_METADATA.
Possible values:  METADATA_UNSPECIFIED INCLUDE_ALL_METADATA EXCLUDE_ALL_METADATA CUSTOM_METADATA
"®
metadataFieldsB*" çOptional. Custom metadata fields to include in the reported VPC flow
logs. Can only be specified if \"metadata\" was set to CUSTOM_METADATA.
"§
name" óIdentifier. Unique name of the configuration using the form:     `projects/{project_id}/locations/global/vpcFlowLogsConfigs/{vpc_flow_logs_config_id}`
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"°
state" ìOptional. The state of the VPC Flow Log configuration. Default value
is ENABLED. When creating a new configuration, it must be enabled.   Possible
"@

updateTime" .Output only. The time the config was updated.
"L
vpcFlowLogsConfigId" 1Required. ID of the `VpcFlowLogsConfig`.


- - -
"Ä
	vpnTunnelB" mTraffic will be logged from the VPN Tunnel. Format: projects/{project_id}/regions/{region}/vpnTunnels/{name}
*Ù~
N
networksecurityAddressGroup-gcp:networksecurity/addressGroup:AddressGroupØgAddressGroup is a resource that specifies how a collection of IP/DNS used in Firewall Policy.


To get more information about AddressGroup, see:

* [API documentation](https://cloud.google.com/traffic-director/docs/reference/network-security/rest/v1beta1/organizations.locations.addressGroups)
* How-to Guides
    * [Use AddressGroups](https://cloud.google.com/vpc/docs/use-address-groups-firewall-policies)

## Example Usage

### Network Security Address Groups Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networksecurity.AddressGroup("default", {
    name: "my-address-groups",
    parent: "projects/my-project-name",
    location: "us-central1",
    type: "IPV4",
    capacity: 100,
    items: ["208.80.154.224/32"],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networksecurity.AddressGroup("default",
    name="my-address-groups",
    parent="projects/my-project-name",
    location="us-central1",
    type="IPV4",
    capacity=100,
    items=["208.80.154.224/32"])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkSecurity.AddressGroup("default", new()
    {
        Name = "my-address-groups",
        Parent = "projects/my-project-name",
        Location = "us-central1",
        Type = "IPV4",
        Capacity = 100,
        Items = new[]
        {
            "208.80.154.224/32",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networksecurity.NewAddressGroup(ctx, "default", &networksecurity.AddressGroupArgs{
			Name:     pulumi.String("my-address-groups"),
			Parent:   pulumi.String("projects/my-project-name"),
			Location: pulumi.String("us-central1"),
			Type:     pulumi.String("IPV4"),
			Capacity: pulumi.Int(100),
			Items: pulumi.StringArray{
				pulumi.String("208.80.154.224/32"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networksecurity.AddressGroup;
import com.pulumi.gcp.networksecurity.AddressGroupArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new AddressGroup("default", AddressGroupArgs.builder()
            .name("my-address-groups")
            .parent("projects/my-project-name")
            .location("us-central1")
            .type("IPV4")
            .capacity("100")
            .items("208.80.154.224/32")
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networksecurity:AddressGroup
    properties:
      name: my-address-groups
      parent: projects/my-project-name
      location: us-central1
      type: IPV4
      capacity: '100'
      items:
        - 208.80.154.224/32
```
<!--End PulumiCodeChooser -->
### Network Security Address Groups Organization Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networksecurity.AddressGroup("default", {
    name: "my-address-groups",
    parent: "organizations/123456789",
    location: "us-central1",
    type: "IPV4",
    capacity: 100,
    items: ["208.80.154.224/32"],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networksecurity.AddressGroup("default",
    name="my-address-groups",
    parent="organizations/123456789",
    location="us-central1",
    type="IPV4",
    capacity=100,
    items=["208.80.154.224/32"])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkSecurity.AddressGroup("default", new()
    {
        Name = "my-address-groups",
        Parent = "organizations/123456789",
        Location = "us-central1",
        Type = "IPV4",
        Capacity = 100,
        Items = new[]
        {
            "208.80.154.224/32",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networksecurity.NewAddressGroup(ctx, "default", &networksecurity.AddressGroupArgs{
			Name:     pulumi.String("my-address-groups"),
			Parent:   pulumi.String("organizations/123456789"),
			Location: pulumi.String("us-central1"),
			Type:     pulumi.String("IPV4"),
			Capacity: pulumi.Int(100),
			Items: pulumi.StringArray{
				pulumi.String("208.80.154.224/32"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networksecurity.AddressGroup;
import com.pulumi.gcp.networksecurity.AddressGroupArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new AddressGroup("default", AddressGroupArgs.builder()
            .name("my-address-groups")
            .parent("organizations/123456789")
            .location("us-central1")
            .type("IPV4")
            .capacity("100")
            .items("208.80.154.224/32")
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networksecurity:AddressGroup
    properties:
      name: my-address-groups
      parent: organizations/123456789
      location: us-central1
      type: IPV4
      capacity: '100'
      items:
        - 208.80.154.224/32
```
<!--End PulumiCodeChooser -->
### Network Security Address Groups Advanced


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networksecurity.AddressGroup("default", {
    name: "my-address-groups",
    parent: "projects/my-project-name",
    location: "us-central1",
    description: "my description",
    type: "IPV4",
    capacity: 100,
    items: ["208.80.154.224/32"],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networksecurity.AddressGroup("default",
    name="my-address-groups",
    parent="projects/my-project-name",
    location="us-central1",
    description="my description",
    type="IPV4",
    capacity=100,
    items=["208.80.154.224/32"])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkSecurity.AddressGroup("default", new()
    {
        Name = "my-address-groups",
        Parent = "projects/my-project-name",
        Location = "us-central1",
        Description = "my description",
        Type = "IPV4",
        Capacity = 100,
        Items = new[]
        {
            "208.80.154.224/32",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networksecurity.NewAddressGroup(ctx, "default", &networksecurity.AddressGroupArgs{
			Name:        pulumi.String("my-address-groups"),
			Parent:      pulumi.String("projects/my-project-name"),
			Location:    pulumi.String("us-central1"),
			Description: pulumi.String("my description"),
			Type:        pulumi.String("IPV4"),
			Capacity:    pulumi.Int(100),
			Items: pulumi.StringArray{
				pulumi.String("208.80.154.224/32"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networksecurity.AddressGroup;
import com.pulumi.gcp.networksecurity.AddressGroupArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new AddressGroup("default", AddressGroupArgs.builder()
            .name("my-address-groups")
            .parent("projects/my-project-name")
            .location("us-central1")
            .description("my description")
            .type("IPV4")
            .capacity("100")
            .items("208.80.154.224/32")
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networksecurity:AddressGroup
    properties:
      name: my-address-groups
      parent: projects/my-project-name
      location: us-central1
      description: my description
      type: IPV4
      capacity: '100'
      items:
        - 208.80.154.224/32
```
<!--End PulumiCodeChooser -->
### Network Security Address Groups Cloud Armor


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networksecurity.AddressGroup("default", {
    name: "my-address-groups",
    parent: "projects/my-project-name",
    location: "global",
    type: "IPV4",
    capacity: 100,
    purposes: ["CLOUD_ARMOR"],
    items: ["208.80.154.224/32"],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networksecurity.AddressGroup("default",
    name="my-address-groups",
    parent="projects/my-project-name",
    location="global",
    type="IPV4",
    capacity=100,
    purposes=["CLOUD_ARMOR"],
    items=["208.80.154.224/32"])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkSecurity.AddressGroup("default", new()
    {
        Name = "my-address-groups",
        Parent = "projects/my-project-name",
        Location = "global",
        Type = "IPV4",
        Capacity = 100,
        Purposes = new[]
        {
            "CLOUD_ARMOR",
        },
        Items = new[]
        {
            "208.80.154.224/32",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networksecurity.NewAddressGroup(ctx, "default", &networksecurity.AddressGroupArgs{
			Name:     pulumi.String("my-address-groups"),
			Parent:   pulumi.String("projects/my-project-name"),
			Location: pulumi.String("global"),
			Type:     pulumi.String("IPV4"),
			Capacity: pulumi.Int(100),
			Purposes: pulumi.StringArray{
				pulumi.String("CLOUD_ARMOR"),
			},
			Items: pulumi.StringArray{
				pulumi.String("208.80.154.224/32"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networksecurity.AddressGroup;
import com.pulumi.gcp.networksecurity.AddressGroupArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new AddressGroup("default", AddressGroupArgs.builder()
            .name("my-address-groups")
            .parent("projects/my-project-name")
            .location("global")
            .type("IPV4")
            .capacity("100")
            .purposes("CLOUD_ARMOR")
            .items("208.80.154.224/32")
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networksecurity:AddressGroup
    properties:
      name: my-address-groups
      parent: projects/my-project-name
      location: global
      type: IPV4
      capacity: '100'
      purposes:
        - CLOUD_ARMOR
      items:
        - 208.80.154.224/32
```
<!--End PulumiCodeChooser -->

## Import

AddressGroup can be imported using any of these accepted formats:

* `{{parent}}/locations/{{location}}/addressGroups/{{name}}`

When using the `pulumi import` command, AddressGroup can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networksecurity/addressGroup:AddressGroup default {{parent}}/locations/{{location}}/addressGroups/{{name}}
```

/
capacity Capacity of the Address Group.
<
descriptionB" 'Free-text description of the resource.
 
itemsB*" List of items.
à
labelsB2" ıSet of label tags associated with the AddressGroup resource.
An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
d
location" TThe location of the gateway security policy.
The default value is `global`.


- - -
1
nameB" #Name of the AddressGroup resource.
à
parentB" xThe name of the parent this address group belongs to. Format: organizations/{organization_id} or projects/{project_id}.
y
purposesB*" eList of supported purposes of the Address Group.
Each value may be one of: `DEFAULT`, `CLOUD_ARMOR`.
v
type" jThe type of the Address Group. Possible values are "IPV4" or "IPV6".
Possible values are: `IPV4`, `IPV6`.
"/
capacity Capacity of the Address Group.
"Ì

createTime" ⁄The timestamp when the resource was created.
A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z"
"<
descriptionB" 'Free-text description of the resource.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
" 
itemsB*" List of items.
"à
labelsB2" ıSet of label tags associated with the AddressGroup resource.
An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"d
location" TThe location of the gateway security policy.
The default value is `global`.


- - -
"/
name" #Name of the AddressGroup resource.
"à
parentB" xThe name of the parent this address group belongs to. Format: organizations/{organization_id} or projects/{project_id}.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"w
purposes*" eList of supported purposes of the Address Group.
Each value may be one of: `DEFAULT`, `CLOUD_ARMOR`.
"v
type" jThe type of the Address Group. Possible values are "IPV4" or "IPV6".
Possible values are: `IPV4`, `IPV6`.
"Ó

updateTime" €The timestamp when the resource was updated.
A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
*’<
l
networksecurityAddressGroupIamBindingAgcp:networksecurity/addressGroupIamBinding:AddressGroupIamBindingâThree different resources help you manage your IAM policy for Network security ProjectAddressGroup. Each of these resources serves a different use case:

* `gcp.networksecurity.AddressGroupIamPolicy`: Authoritative. Sets the IAM policy for the projectaddressgroup and replaces any existing policy already attached.
* `gcp.networksecurity.AddressGroupIamBinding`: Authoritative for a given role. Updates the IAM policy to grant a role to a list of members. Other roles within the IAM policy for the projectaddressgroup are preserved.
* `gcp.networksecurity.AddressGroupIamMember`: Non-authoritative. Updates the IAM policy to grant a role to a new member. Other members for the role for the projectaddressgroup are preserved.

A data source can be used to retrieve policy data in advent you do not need creation

* `gcp.networksecurity.AddressGroupIamPolicy`: Retrieves the IAM policy for the projectaddressgroup

> **Note:** `gcp.networksecurity.AddressGroupIamPolicy` **cannot** be used in conjunction with `gcp.networksecurity.AddressGroupIamBinding` and `gcp.networksecurity.AddressGroupIamMember` or they will fight over what your policy should be.

> **Note:** `gcp.networksecurity.AddressGroupIamBinding` resources **can be** used in conjunction with `gcp.networksecurity.AddressGroupIamMember` resources **only if** they do not grant privilege to the same role.



## Import

For all import syntaxes, the "resource in question" can take any of the following forms:

* projects/{{project}}/locations/{{location}}/addressGroups/{{name}}

* {{project}}/{{location}}/{{name}}

* {{location}}/{{name}}

* {{name}}

Any variables not passed in the import command will be taken from the provider configuration.

Network security projectaddressgroup IAM resources can be imported using the resource identifiers, role, and member.

IAM member imports use space-delimited identifiers: the resource in question, the role, and the member identity, e.g.

```sh
$ pulumi import gcp:networksecurity/addressGroupIamBinding:AddressGroupIamBinding editor "projects/{{project}}/locations/{{location}}/addressGroups/{{project_address_group}} roles/compute.networkAdmin user:jane@example.com"
```

IAM binding imports use space-delimited identifiers: the resource in question and the role, e.g.

```sh
$ pulumi import gcp:networksecurity/addressGroupIamBinding:AddressGroupIamBinding editor "projects/{{project}}/locations/{{location}}/addressGroups/{{project_address_group}} roles/compute.networkAdmin"
```

IAM policy imports use the identifier of the resource in question, e.g.

```sh
$ pulumi import gcp:networksecurity/addressGroupIamBinding:AddressGroupIamBinding editor projects/{{project}}/locations/{{location}}/addressGroups/{{project_address_group}}
```

-> **Custom Roles** If you're importing a IAM resource with a custom role, make sure to use the

 full name of the custom role, e.g. `[projects/my-project|organizations/my-org]/roles/my-custom-role`.

û
	conditionêBç:ä
á
networksecurityAddressGroupIamBindingConditionSgcp:networksecurity/AddressGroupIamBindingCondition:AddressGroupIamBindingCondition“
locationB" øThe location of the gateway security policy.
Used to find the parent resource to bind the IAM policy to. If not specified,
the value will be parsed from the identifier of the parent resource. If no location is provided in the parent identifier and no
location is specified, it is taken from the provider configuration.
÷	
members*" ƒ	Identities that will be granted the privilege in `role`.
Each entry can have one of the following values:
* **allUsers**: A special identifier that represents anyone who is on the internet; with or without a Google account.
* **allAuthenticatedUsers**: A special identifier that represents anyone who is authenticated with a Google account or a service account.
* **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com or joe@example.com.
* **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
* **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
* **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
* **projectOwner:projectid**: Owners of the given project. For example, "projectOwner:my-example-project"
* **projectEditor:projectid**: Editors of the given project. For example, "projectEditor:my-example-project"
* **projectViewer:projectid**: Viewers of the given project. For example, "projectViewer:my-example-project"
I
nameB" ;Used to find the parent resource to bind the IAM policy to
ì
projectB" ÅThe ID of the project in which the resource belongs.
If it is not provided, the project will be parsed from the identifier of the parent resource. If no project is provided in the parent identifier and no project is specified, the provider project is used.
„
role" ÷The role that should be applied. Only one
`gcp.networksecurity.AddressGroupIamBinding` can be used per role. Note that custom roles must be of the format
`[projects|organizations]/{parent-name}/roles/{role-name}`.
"û
	conditionêBç:ä
á
networksecurityAddressGroupIamBindingConditionSgcp:networksecurity/AddressGroupIamBindingCondition:AddressGroupIamBindingCondition"3
etag" '(Computed) The etag of the IAM policy.
"–
location" øThe location of the gateway security policy.
Used to find the parent resource to bind the IAM policy to. If not specified,
the value will be parsed from the identifier of the parent resource. If no location is provided in the parent identifier and no
location is specified, it is taken from the provider configuration.
"÷	
members*" ƒ	Identities that will be granted the privilege in `role`.
Each entry can have one of the following values:
* **allUsers**: A special identifier that represents anyone who is on the internet; with or without a Google account.
* **allAuthenticatedUsers**: A special identifier that represents anyone who is authenticated with a Google account or a service account.
* **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com or joe@example.com.
* **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
* **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
* **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
* **projectOwner:projectid**: Owners of the given project. For example, "projectOwner:my-example-project"
* **projectEditor:projectid**: Editors of the given project. For example, "projectEditor:my-example-project"
* **projectViewer:projectid**: Viewers of the given project. For example, "projectViewer:my-example-project"
"G
name" ;Used to find the parent resource to bind the IAM policy to
"ë
project" ÅThe ID of the project in which the resource belongs.
If it is not provided, the project will be parsed from the identifier of the parent resource. If no project is provided in the parent identifier and no project is specified, the provider project is used.
"„
role" ÷The role that should be applied. Only one
`gcp.networksecurity.AddressGroupIamBinding` can be used per role. Note that custom roles must be of the format
`[projects|organizations]/{parent-name}/roles/{role-name}`.
*¿<
i
networksecurityAddressGroupIamMember?gcp:networksecurity/addressGroupIamMember:AddressGroupIamMemberÉThree different resources help you manage your IAM policy for Network security ProjectAddressGroup. Each of these resources serves a different use case:

* `gcp.networksecurity.AddressGroupIamPolicy`: Authoritative. Sets the IAM policy for the projectaddressgroup and replaces any existing policy already attached.
* `gcp.networksecurity.AddressGroupIamBinding`: Authoritative for a given role. Updates the IAM policy to grant a role to a list of members. Other roles within the IAM policy for the projectaddressgroup are preserved.
* `gcp.networksecurity.AddressGroupIamMember`: Non-authoritative. Updates the IAM policy to grant a role to a new member. Other members for the role for the projectaddressgroup are preserved.

A data source can be used to retrieve policy data in advent you do not need creation

* `gcp.networksecurity.AddressGroupIamPolicy`: Retrieves the IAM policy for the projectaddressgroup

> **Note:** `gcp.networksecurity.AddressGroupIamPolicy` **cannot** be used in conjunction with `gcp.networksecurity.AddressGroupIamBinding` and `gcp.networksecurity.AddressGroupIamMember` or they will fight over what your policy should be.

> **Note:** `gcp.networksecurity.AddressGroupIamBinding` resources **can be** used in conjunction with `gcp.networksecurity.AddressGroupIamMember` resources **only if** they do not grant privilege to the same role.



## Import

For all import syntaxes, the "resource in question" can take any of the following forms:

* projects/{{project}}/locations/{{location}}/addressGroups/{{name}}

* {{project}}/{{location}}/{{name}}

* {{location}}/{{name}}

* {{name}}

Any variables not passed in the import command will be taken from the provider configuration.

Network security projectaddressgroup IAM resources can be imported using the resource identifiers, role, and member.

IAM member imports use space-delimited identifiers: the resource in question, the role, and the member identity, e.g.

```sh
$ pulumi import gcp:networksecurity/addressGroupIamMember:AddressGroupIamMember editor "projects/{{project}}/locations/{{location}}/addressGroups/{{project_address_group}} roles/compute.networkAdmin user:jane@example.com"
```

IAM binding imports use space-delimited identifiers: the resource in question and the role, e.g.

```sh
$ pulumi import gcp:networksecurity/addressGroupIamMember:AddressGroupIamMember editor "projects/{{project}}/locations/{{location}}/addressGroups/{{project_address_group}} roles/compute.networkAdmin"
```

IAM policy imports use the identifier of the resource in question, e.g.

```sh
$ pulumi import gcp:networksecurity/addressGroupIamMember:AddressGroupIamMember editor projects/{{project}}/locations/{{location}}/addressGroups/{{project_address_group}}
```

-> **Custom Roles** If you're importing a IAM resource with a custom role, make sure to use the

 full name of the custom role, e.g. `[projects/my-project|organizations/my-org]/roles/my-custom-role`.

õ
	conditionçBä:á
Ñ
networksecurityAddressGroupIamMemberConditionQgcp:networksecurity/AddressGroupIamMemberCondition:AddressGroupIamMemberCondition“
locationB" øThe location of the gateway security policy.
Used to find the parent resource to bind the IAM policy to. If not specified,
the value will be parsed from the identifier of the parent resource. If no location is provided in the parent identifier and no
location is specified, it is taken from the provider configuration.
”	
member" ƒ	Identities that will be granted the privilege in `role`.
Each entry can have one of the following values:
* **allUsers**: A special identifier that represents anyone who is on the internet; with or without a Google account.
* **allAuthenticatedUsers**: A special identifier that represents anyone who is authenticated with a Google account or a service account.
* **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com or joe@example.com.
* **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
* **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
* **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
* **projectOwner:projectid**: Owners of the given project. For example, "projectOwner:my-example-project"
* **projectEditor:projectid**: Editors of the given project. For example, "projectEditor:my-example-project"
* **projectViewer:projectid**: Viewers of the given project. For example, "projectViewer:my-example-project"
I
nameB" ;Used to find the parent resource to bind the IAM policy to
ì
projectB" ÅThe ID of the project in which the resource belongs.
If it is not provided, the project will be parsed from the identifier of the parent resource. If no project is provided in the parent identifier and no project is specified, the provider project is used.
„
role" ÷The role that should be applied. Only one
`gcp.networksecurity.AddressGroupIamBinding` can be used per role. Note that custom roles must be of the format
`[projects|organizations]/{parent-name}/roles/{role-name}`.
"õ
	conditionçBä:á
Ñ
networksecurityAddressGroupIamMemberConditionQgcp:networksecurity/AddressGroupIamMemberCondition:AddressGroupIamMemberCondition"3
etag" '(Computed) The etag of the IAM policy.
"–
location" øThe location of the gateway security policy.
Used to find the parent resource to bind the IAM policy to. If not specified,
the value will be parsed from the identifier of the parent resource. If no location is provided in the parent identifier and no
location is specified, it is taken from the provider configuration.
"”	
member" ƒ	Identities that will be granted the privilege in `role`.
Each entry can have one of the following values:
* **allUsers**: A special identifier that represents anyone who is on the internet; with or without a Google account.
* **allAuthenticatedUsers**: A special identifier that represents anyone who is authenticated with a Google account or a service account.
* **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com or joe@example.com.
* **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
* **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
* **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
* **projectOwner:projectid**: Owners of the given project. For example, "projectOwner:my-example-project"
* **projectEditor:projectid**: Editors of the given project. For example, "projectEditor:my-example-project"
* **projectViewer:projectid**: Viewers of the given project. For example, "projectViewer:my-example-project"
"G
name" ;Used to find the parent resource to bind the IAM policy to
"ë
project" ÅThe ID of the project in which the resource belongs.
If it is not provided, the project will be parsed from the identifier of the parent resource. If no project is provided in the parent identifier and no project is specified, the provider project is used.
"„
role" ÷The role that should be applied. Only one
`gcp.networksecurity.AddressGroupIamBinding` can be used per role. Note that custom roles must be of the format
`[projects|organizations]/{parent-name}/roles/{role-name}`.
*Œ$
i
networksecurityAddressGroupIamPolicy?gcp:networksecurity/addressGroupIamPolicy:AddressGroupIamPolicyÉThree different resources help you manage your IAM policy for Network security ProjectAddressGroup. Each of these resources serves a different use case:

* `gcp.networksecurity.AddressGroupIamPolicy`: Authoritative. Sets the IAM policy for the projectaddressgroup and replaces any existing policy already attached.
* `gcp.networksecurity.AddressGroupIamBinding`: Authoritative for a given role. Updates the IAM policy to grant a role to a list of members. Other roles within the IAM policy for the projectaddressgroup are preserved.
* `gcp.networksecurity.AddressGroupIamMember`: Non-authoritative. Updates the IAM policy to grant a role to a new member. Other members for the role for the projectaddressgroup are preserved.

A data source can be used to retrieve policy data in advent you do not need creation

* `gcp.networksecurity.AddressGroupIamPolicy`: Retrieves the IAM policy for the projectaddressgroup

> **Note:** `gcp.networksecurity.AddressGroupIamPolicy` **cannot** be used in conjunction with `gcp.networksecurity.AddressGroupIamBinding` and `gcp.networksecurity.AddressGroupIamMember` or they will fight over what your policy should be.

> **Note:** `gcp.networksecurity.AddressGroupIamBinding` resources **can be** used in conjunction with `gcp.networksecurity.AddressGroupIamMember` resources **only if** they do not grant privilege to the same role.



## Import

For all import syntaxes, the "resource in question" can take any of the following forms:

* projects/{{project}}/locations/{{location}}/addressGroups/{{name}}

* {{project}}/{{location}}/{{name}}

* {{location}}/{{name}}

* {{name}}

Any variables not passed in the import command will be taken from the provider configuration.

Network security projectaddressgroup IAM resources can be imported using the resource identifiers, role, and member.

IAM member imports use space-delimited identifiers: the resource in question, the role, and the member identity, e.g.

```sh
$ pulumi import gcp:networksecurity/addressGroupIamPolicy:AddressGroupIamPolicy editor "projects/{{project}}/locations/{{location}}/addressGroups/{{project_address_group}} roles/compute.networkAdmin user:jane@example.com"
```

IAM binding imports use space-delimited identifiers: the resource in question and the role, e.g.

```sh
$ pulumi import gcp:networksecurity/addressGroupIamPolicy:AddressGroupIamPolicy editor "projects/{{project}}/locations/{{location}}/addressGroups/{{project_address_group}} roles/compute.networkAdmin"
```

IAM policy imports use the identifier of the resource in question, e.g.

```sh
$ pulumi import gcp:networksecurity/addressGroupIamPolicy:AddressGroupIamPolicy editor projects/{{project}}/locations/{{location}}/addressGroups/{{project_address_group}}
```

-> **Custom Roles** If you're importing a IAM resource with a custom role, make sure to use the

 full name of the custom role, e.g. `[projects/my-project|organizations/my-org]/roles/my-custom-role`.

“
locationB" øThe location of the gateway security policy.
Used to find the parent resource to bind the IAM policy to. If not specified,
the value will be parsed from the identifier of the parent resource. If no location is provided in the parent identifier and no
location is specified, it is taken from the provider configuration.
I
nameB" ;Used to find the parent resource to bind the IAM policy to
_

policyData" MThe policy data generated by
a `gcp.organizations.getIAMPolicy` data source.
ì
projectB" ÅThe ID of the project in which the resource belongs.
If it is not provided, the project will be parsed from the identifier of the parent resource. If no project is provided in the parent identifier and no project is specified, the provider project is used.
"3
etag" '(Computed) The etag of the IAM policy.
"–
location" øThe location of the gateway security policy.
Used to find the parent resource to bind the IAM policy to. If not specified,
the value will be parsed from the identifier of the parent resource. If no location is provided in the parent identifier and no
location is specified, it is taken from the provider configuration.
"G
name" ;Used to find the parent resource to bind the IAM policy to
"_

policyData" MThe policy data generated by
a `gcp.organizations.getIAMPolicy` data source.
"ë
project" ÅThe ID of the project in which the resource belongs.
If it is not provided, the project will be parsed from the identifier of the parent resource. If no project is provided in the parent identifier and no project is specified, the provider project is used.
*Èy
c
networksecurityAuthorizationPolicy;gcp:networksecurity/authorizationPolicy:AuthorizationPolicyÍa## Example Usage

### Network Security Authorization Policy Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networksecurity.AuthorizationPolicy("default", {
    name: "my-authorization-policy",
    labels: {
        foo: "bar",
    },
    description: "my description",
    action: "ALLOW",
    rules: [{
        sources: [{
            principals: ["namespace/*"],
            ipBlocks: ["1.2.3.0/24"],
        }],
    }],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networksecurity.AuthorizationPolicy("default",
    name="my-authorization-policy",
    labels={
        "foo": "bar",
    },
    description="my description",
    action="ALLOW",
    rules=[{
        "sources": [{
            "principals": ["namespace/*"],
            "ip_blocks": ["1.2.3.0/24"],
        }],
    }])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkSecurity.AuthorizationPolicy("default", new()
    {
        Name = "my-authorization-policy",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        Action = "ALLOW",
        Rules = new[]
        {
            new Gcp.NetworkSecurity.Inputs.AuthorizationPolicyRuleArgs
            {
                Sources = new[]
                {
                    new Gcp.NetworkSecurity.Inputs.AuthorizationPolicyRuleSourceArgs
                    {
                        Principals = new[]
                        {
                            "namespace/*",
                        },
                        IpBlocks = new[]
                        {
                            "1.2.3.0/24",
                        },
                    },
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networksecurity.NewAuthorizationPolicy(ctx, "default", &networksecurity.AuthorizationPolicyArgs{
			Name: pulumi.String("my-authorization-policy"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			Action:      pulumi.String("ALLOW"),
			Rules: networksecurity.AuthorizationPolicyRuleArray{
				&networksecurity.AuthorizationPolicyRuleArgs{
					Sources: networksecurity.AuthorizationPolicyRuleSourceArray{
						&networksecurity.AuthorizationPolicyRuleSourceArgs{
							Principals: pulumi.StringArray{
								pulumi.String("namespace/*"),
							},
							IpBlocks: pulumi.StringArray{
								pulumi.String("1.2.3.0/24"),
							},
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networksecurity.AuthorizationPolicy;
import com.pulumi.gcp.networksecurity.AuthorizationPolicyArgs;
import com.pulumi.gcp.networksecurity.inputs.AuthorizationPolicyRuleArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new AuthorizationPolicy("default", AuthorizationPolicyArgs.builder()
            .name("my-authorization-policy")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .action("ALLOW")
            .rules(AuthorizationPolicyRuleArgs.builder()
                .sources(AuthorizationPolicyRuleSourceArgs.builder()
                    .principals("namespace/*")
                    .ipBlocks("1.2.3.0/24")
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networksecurity:AuthorizationPolicy
    properties:
      name: my-authorization-policy
      labels:
        foo: bar
      description: my description
      action: ALLOW
      rules:
        - sources:
            - principals:
                - namespace/*
              ipBlocks:
                - 1.2.3.0/24
```
<!--End PulumiCodeChooser -->
### Network Security Authorization Policy Destinations


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networksecurity.AuthorizationPolicy("default", {
    name: "my-authorization-policy",
    labels: {
        foo: "bar",
    },
    description: "my description",
    action: "ALLOW",
    rules: [{
        sources: [{
            principals: ["namespace/*"],
            ipBlocks: ["1.2.3.0/24"],
        }],
        destinations: [{
            hosts: ["mydomain.*"],
            ports: [8080],
            methods: ["GET"],
            httpHeaderMatch: {
                headerName: ":method",
                regexMatch: "GET",
            },
        }],
    }],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networksecurity.AuthorizationPolicy("default",
    name="my-authorization-policy",
    labels={
        "foo": "bar",
    },
    description="my description",
    action="ALLOW",
    rules=[{
        "sources": [{
            "principals": ["namespace/*"],
            "ip_blocks": ["1.2.3.0/24"],
        }],
        "destinations": [{
            "hosts": ["mydomain.*"],
            "ports": [8080],
            "methods": ["GET"],
            "http_header_match": {
                "header_name": ":method",
                "regex_match": "GET",
            },
        }],
    }])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkSecurity.AuthorizationPolicy("default", new()
    {
        Name = "my-authorization-policy",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        Action = "ALLOW",
        Rules = new[]
        {
            new Gcp.NetworkSecurity.Inputs.AuthorizationPolicyRuleArgs
            {
                Sources = new[]
                {
                    new Gcp.NetworkSecurity.Inputs.AuthorizationPolicyRuleSourceArgs
                    {
                        Principals = new[]
                        {
                            "namespace/*",
                        },
                        IpBlocks = new[]
                        {
                            "1.2.3.0/24",
                        },
                    },
                },
                Destinations = new[]
                {
                    new Gcp.NetworkSecurity.Inputs.AuthorizationPolicyRuleDestinationArgs
                    {
                        Hosts = new[]
                        {
                            "mydomain.*",
                        },
                        Ports = new[]
                        {
                            8080,
                        },
                        Methods = new[]
                        {
                            "GET",
                        },
                        HttpHeaderMatch = new Gcp.NetworkSecurity.Inputs.AuthorizationPolicyRuleDestinationHttpHeaderMatchArgs
                        {
                            HeaderName = ":method",
                            RegexMatch = "GET",
                        },
                    },
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networksecurity.NewAuthorizationPolicy(ctx, "default", &networksecurity.AuthorizationPolicyArgs{
			Name: pulumi.String("my-authorization-policy"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			Action:      pulumi.String("ALLOW"),
			Rules: networksecurity.AuthorizationPolicyRuleArray{
				&networksecurity.AuthorizationPolicyRuleArgs{
					Sources: networksecurity.AuthorizationPolicyRuleSourceArray{
						&networksecurity.AuthorizationPolicyRuleSourceArgs{
							Principals: pulumi.StringArray{
								pulumi.String("namespace/*"),
							},
							IpBlocks: pulumi.StringArray{
								pulumi.String("1.2.3.0/24"),
							},
						},
					},
					Destinations: networksecurity.AuthorizationPolicyRuleDestinationArray{
						&networksecurity.AuthorizationPolicyRuleDestinationArgs{
							Hosts: pulumi.StringArray{
								pulumi.String("mydomain.*"),
							},
							Ports: pulumi.IntArray{
								pulumi.Int(8080),
							},
							Methods: pulumi.StringArray{
								pulumi.String("GET"),
							},
							HttpHeaderMatch: &networksecurity.AuthorizationPolicyRuleDestinationHttpHeaderMatchArgs{
								HeaderName: pulumi.String(":method"),
								RegexMatch: pulumi.String("GET"),
							},
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networksecurity.AuthorizationPolicy;
import com.pulumi.gcp.networksecurity.AuthorizationPolicyArgs;
import com.pulumi.gcp.networksecurity.inputs.AuthorizationPolicyRuleArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new AuthorizationPolicy("default", AuthorizationPolicyArgs.builder()
            .name("my-authorization-policy")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .action("ALLOW")
            .rules(AuthorizationPolicyRuleArgs.builder()
                .sources(AuthorizationPolicyRuleSourceArgs.builder()
                    .principals("namespace/*")
                    .ipBlocks("1.2.3.0/24")
                    .build())
                .destinations(AuthorizationPolicyRuleDestinationArgs.builder()
                    .hosts("mydomain.*")
                    .ports(8080)
                    .methods("GET")
                    .httpHeaderMatch(AuthorizationPolicyRuleDestinationHttpHeaderMatchArgs.builder()
                        .headerName(":method")
                        .regexMatch("GET")
                        .build())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networksecurity:AuthorizationPolicy
    properties:
      name: my-authorization-policy
      labels:
        foo: bar
      description: my description
      action: ALLOW
      rules:
        - sources:
            - principals:
                - namespace/*
              ipBlocks:
                - 1.2.3.0/24
          destinations:
            - hosts:
                - mydomain.*
              ports:
                - 8080
              methods:
                - GET
              httpHeaderMatch:
                headerName: :method
                regexMatch: GET
```
<!--End PulumiCodeChooser -->

## Import

AuthorizationPolicy can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/authorizationPolicies/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

When using the `pulumi import` command, AuthorizationPolicy can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networksecurity/authorizationPolicy:AuthorizationPolicy default projects/{{project}}/locations/{{location}}/authorizationPolicies/{{name}}
```

```sh
$ pulumi import gcp:networksecurity/authorizationPolicy:AuthorizationPolicy default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:networksecurity/authorizationPolicy:AuthorizationPolicy default {{location}}/{{name}}
```

ä
action" |The action to take when a rule match is found. Possible values are "ALLOW" or "DENY".
Possible values are: `ALLOW`, `DENY`.
Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
ù
labelsB2" äSet of label tags associated with the AuthorizationPolicy resource.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
[
locationB" IThe location of the authorization policy.
The default value is `global`.
@
nameB" 2Name of the AuthorizationPolicy resource.


- - -
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
…
ruleswBu*s:q
o
networksecurityAuthorizationPolicyRuleCgcp:networksecurity/AuthorizationPolicyRule:AuthorizationPolicyRule∆List of rules to match. Note that at least one of the rules must match in order for the action specified in the 'action' field to be taken.
A rule is a match if there is a matching source and destination. If left blank, the action specified in the action field will be applied on every request.
Structure is documented below.
"ä
action" |The action to take when a rule match is found. Possible values are "ALLOW" or "DENY".
Possible values are: `ALLOW`, `DENY`.
"C

createTime" 1Time the AuthorizationPolicy was created in UTC.
"Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"ù
labelsB2" äSet of label tags associated with the AuthorizationPolicy resource.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"[
locationB" IThe location of the authorization policy.
The default value is `global`.
">
name" 2Name of the AuthorizationPolicy resource.


- - -
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"…
ruleswBu*s:q
o
networksecurityAuthorizationPolicyRuleCgcp:networksecurity/AuthorizationPolicyRule:AuthorizationPolicyRule∆List of rules to match. Note that at least one of the rules must match in order for the action specified in the 'action' field to be taken.
A rule is a match if there is a matching source and destination. If left blank, the action specified in the action field will be applied on every request.
Structure is documented below.
"C

updateTime" 1Time the AuthorizationPolicy was updated in UTC.
*§á
K
networksecurityAuthzPolicy+gcp:networksecurity/authzPolicy:AuthzPolicyÿﬂAuthzPolicy is a resource that allows to forward traffic to a callout backend designed to scan the traffic for security purposes.


To get more information about AuthzPolicy, see:

* [API documentation](https://cloud.google.com/load-balancing/docs/reference/network-security/rest/v1beta1/projects.locations.authzPolicies)

## Example Usage

### Network Services Authz Policy Advanced


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.compute.Network("default", {
    name: "lb-network",
    project: "my-project-name",
    autoCreateSubnetworks: false,
});
const defaultSubnetwork = new gcp.compute.Subnetwork("default", {
    name: "backend-subnet",
    project: "my-project-name",
    region: "us-west1",
    ipCidrRange: "10.1.2.0/24",
    network: _default.id,
});
const proxyOnly = new gcp.compute.Subnetwork("proxy_only", {
    name: "proxy-only-subnet",
    project: "my-project-name",
    region: "us-west1",
    ipCidrRange: "10.129.0.0/23",
    purpose: "REGIONAL_MANAGED_PROXY",
    role: "ACTIVE",
    network: _default.id,
});
const defaultAddress = new gcp.compute.Address("default", {
    name: "l7-ilb-ip-address",
    project: "my-project-name",
    region: "us-west1",
    subnetwork: defaultSubnetwork.id,
    addressType: "INTERNAL",
    purpose: "GCE_ENDPOINT",
});
const defaultRegionHealthCheck = new gcp.compute.RegionHealthCheck("default", {
    name: "l7-ilb-basic-check",
    project: "my-project-name",
    region: "us-west1",
    httpHealthCheck: {
        portSpecification: "USE_SERVING_PORT",
    },
});
const urlMap = new gcp.compute.RegionBackendService("url_map", {
    name: "l7-ilb-backend-service",
    project: "my-project-name",
    region: "us-west1",
    loadBalancingScheme: "INTERNAL_MANAGED",
    healthChecks: defaultRegionHealthCheck.id,
});
const defaultRegionUrlMap = new gcp.compute.RegionUrlMap("default", {
    name: "l7-ilb-map",
    project: "my-project-name",
    region: "us-west1",
    defaultService: urlMap.id,
});
const defaultRegionTargetHttpProxy = new gcp.compute.RegionTargetHttpProxy("default", {
    name: "l7-ilb-proxy",
    project: "my-project-name",
    region: "us-west1",
    urlMap: defaultRegionUrlMap.id,
});
const defaultForwardingRule = new gcp.compute.ForwardingRule("default", {
    name: "l7-ilb-forwarding-rule",
    project: "my-project-name",
    region: "us-west1",
    loadBalancingScheme: "INTERNAL_MANAGED",
    network: _default.id,
    subnetwork: defaultSubnetwork.id,
    ipProtocol: "TCP",
    portRange: "80",
    target: defaultRegionTargetHttpProxy.id,
    ipAddress: defaultAddress.id,
}, {
    dependsOn: [proxyOnly],
});
const authzExtension = new gcp.compute.RegionBackendService("authz_extension", {
    name: "authz-service",
    project: "my-project-name",
    region: "us-west1",
    protocol: "HTTP2",
    loadBalancingScheme: "INTERNAL_MANAGED",
    portName: "grpc",
});
const defaultAuthzExtension = new gcp.networkservices.AuthzExtension("default", {
    name: "my-authz-ext",
    project: "my-project-name",
    location: "us-west1",
    description: "my description",
    loadBalancingScheme: "INTERNAL_MANAGED",
    authority: "ext11.com",
    service: authzExtension.selfLink,
    timeout: "0.1s",
    failOpen: false,
    forwardHeaders: ["Authorization"],
});
const defaultAuthzPolicy = new gcp.networksecurity.AuthzPolicy("default", {
    name: "my-authz-policy",
    project: "my-project-name",
    location: "us-west1",
    description: "my description",
    target: {
        loadBalancingScheme: "INTERNAL_MANAGED",
        resources: [defaultForwardingRule.selfLink],
    },
    action: "CUSTOM",
    customProvider: {
        authzExtension: {
            resources: [defaultAuthzExtension.id],
        },
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.compute.Network("default",
    name="lb-network",
    project="my-project-name",
    auto_create_subnetworks=False)
default_subnetwork = gcp.compute.Subnetwork("default",
    name="backend-subnet",
    project="my-project-name",
    region="us-west1",
    ip_cidr_range="10.1.2.0/24",
    network=default.id)
proxy_only = gcp.compute.Subnetwork("proxy_only",
    name="proxy-only-subnet",
    project="my-project-name",
    region="us-west1",
    ip_cidr_range="10.129.0.0/23",
    purpose="REGIONAL_MANAGED_PROXY",
    role="ACTIVE",
    network=default.id)
default_address = gcp.compute.Address("default",
    name="l7-ilb-ip-address",
    project="my-project-name",
    region="us-west1",
    subnetwork=default_subnetwork.id,
    address_type="INTERNAL",
    purpose="GCE_ENDPOINT")
default_region_health_check = gcp.compute.RegionHealthCheck("default",
    name="l7-ilb-basic-check",
    project="my-project-name",
    region="us-west1",
    http_health_check={
        "port_specification": "USE_SERVING_PORT",
    })
url_map = gcp.compute.RegionBackendService("url_map",
    name="l7-ilb-backend-service",
    project="my-project-name",
    region="us-west1",
    load_balancing_scheme="INTERNAL_MANAGED",
    health_checks=default_region_health_check.id)
default_region_url_map = gcp.compute.RegionUrlMap("default",
    name="l7-ilb-map",
    project="my-project-name",
    region="us-west1",
    default_service=url_map.id)
default_region_target_http_proxy = gcp.compute.RegionTargetHttpProxy("default",
    name="l7-ilb-proxy",
    project="my-project-name",
    region="us-west1",
    url_map=default_region_url_map.id)
default_forwarding_rule = gcp.compute.ForwardingRule("default",
    name="l7-ilb-forwarding-rule",
    project="my-project-name",
    region="us-west1",
    load_balancing_scheme="INTERNAL_MANAGED",
    network=default.id,
    subnetwork=default_subnetwork.id,
    ip_protocol="TCP",
    port_range="80",
    target=default_region_target_http_proxy.id,
    ip_address=default_address.id,
    opts = pulumi.ResourceOptions(depends_on=[proxy_only]))
authz_extension = gcp.compute.RegionBackendService("authz_extension",
    name="authz-service",
    project="my-project-name",
    region="us-west1",
    protocol="HTTP2",
    load_balancing_scheme="INTERNAL_MANAGED",
    port_name="grpc")
default_authz_extension = gcp.networkservices.AuthzExtension("default",
    name="my-authz-ext",
    project="my-project-name",
    location="us-west1",
    description="my description",
    load_balancing_scheme="INTERNAL_MANAGED",
    authority="ext11.com",
    service=authz_extension.self_link,
    timeout="0.1s",
    fail_open=False,
    forward_headers=["Authorization"])
default_authz_policy = gcp.networksecurity.AuthzPolicy("default",
    name="my-authz-policy",
    project="my-project-name",
    location="us-west1",
    description="my description",
    target={
        "load_balancing_scheme": "INTERNAL_MANAGED",
        "resources": [default_forwarding_rule.self_link],
    },
    action="CUSTOM",
    custom_provider={
        "authz_extension": {
            "resources": [default_authz_extension.id],
        },
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.Compute.Network("default", new()
    {
        Name = "lb-network",
        Project = "my-project-name",
        AutoCreateSubnetworks = false,
    });

    var defaultSubnetwork = new Gcp.Compute.Subnetwork("default", new()
    {
        Name = "backend-subnet",
        Project = "my-project-name",
        Region = "us-west1",
        IpCidrRange = "10.1.2.0/24",
        Network = @default.Id,
    });

    var proxyOnly = new Gcp.Compute.Subnetwork("proxy_only", new()
    {
        Name = "proxy-only-subnet",
        Project = "my-project-name",
        Region = "us-west1",
        IpCidrRange = "10.129.0.0/23",
        Purpose = "REGIONAL_MANAGED_PROXY",
        Role = "ACTIVE",
        Network = @default.Id,
    });

    var defaultAddress = new Gcp.Compute.Address("default", new()
    {
        Name = "l7-ilb-ip-address",
        Project = "my-project-name",
        Region = "us-west1",
        Subnetwork = defaultSubnetwork.Id,
        AddressType = "INTERNAL",
        Purpose = "GCE_ENDPOINT",
    });

    var defaultRegionHealthCheck = new Gcp.Compute.RegionHealthCheck("default", new()
    {
        Name = "l7-ilb-basic-check",
        Project = "my-project-name",
        Region = "us-west1",
        HttpHealthCheck = new Gcp.Compute.Inputs.RegionHealthCheckHttpHealthCheckArgs
        {
            PortSpecification = "USE_SERVING_PORT",
        },
    });

    var urlMap = new Gcp.Compute.RegionBackendService("url_map", new()
    {
        Name = "l7-ilb-backend-service",
        Project = "my-project-name",
        Region = "us-west1",
        LoadBalancingScheme = "INTERNAL_MANAGED",
        HealthChecks = defaultRegionHealthCheck.Id,
    });

    var defaultRegionUrlMap = new Gcp.Compute.RegionUrlMap("default", new()
    {
        Name = "l7-ilb-map",
        Project = "my-project-name",
        Region = "us-west1",
        DefaultService = urlMap.Id,
    });

    var defaultRegionTargetHttpProxy = new Gcp.Compute.RegionTargetHttpProxy("default", new()
    {
        Name = "l7-ilb-proxy",
        Project = "my-project-name",
        Region = "us-west1",
        UrlMap = defaultRegionUrlMap.Id,
    });

    var defaultForwardingRule = new Gcp.Compute.ForwardingRule("default", new()
    {
        Name = "l7-ilb-forwarding-rule",
        Project = "my-project-name",
        Region = "us-west1",
        LoadBalancingScheme = "INTERNAL_MANAGED",
        Network = @default.Id,
        Subnetwork = defaultSubnetwork.Id,
        IpProtocol = "TCP",
        PortRange = "80",
        Target = defaultRegionTargetHttpProxy.Id,
        IpAddress = defaultAddress.Id,
    }, new CustomResourceOptions
    {
        DependsOn =
        {
            proxyOnly,
        },
    });

    var authzExtension = new Gcp.Compute.RegionBackendService("authz_extension", new()
    {
        Name = "authz-service",
        Project = "my-project-name",
        Region = "us-west1",
        Protocol = "HTTP2",
        LoadBalancingScheme = "INTERNAL_MANAGED",
        PortName = "grpc",
    });

    var defaultAuthzExtension = new Gcp.NetworkServices.AuthzExtension("default", new()
    {
        Name = "my-authz-ext",
        Project = "my-project-name",
        Location = "us-west1",
        Description = "my description",
        LoadBalancingScheme = "INTERNAL_MANAGED",
        Authority = "ext11.com",
        Service = authzExtension.SelfLink,
        Timeout = "0.1s",
        FailOpen = false,
        ForwardHeaders = new[]
        {
            "Authorization",
        },
    });

    var defaultAuthzPolicy = new Gcp.NetworkSecurity.AuthzPolicy("default", new()
    {
        Name = "my-authz-policy",
        Project = "my-project-name",
        Location = "us-west1",
        Description = "my description",
        Target = new Gcp.NetworkSecurity.Inputs.AuthzPolicyTargetArgs
        {
            LoadBalancingScheme = "INTERNAL_MANAGED",
            Resources = new[]
            {
                defaultForwardingRule.SelfLink,
            },
        },
        Action = "CUSTOM",
        CustomProvider = new Gcp.NetworkSecurity.Inputs.AuthzPolicyCustomProviderArgs
        {
            AuthzExtension = new Gcp.NetworkSecurity.Inputs.AuthzPolicyCustomProviderAuthzExtensionArgs
            {
                Resources = new[]
                {
                    defaultAuthzExtension.Id,
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := compute.NewNetwork(ctx, "default", &compute.NetworkArgs{
			Name:                  pulumi.String("lb-network"),
			Project:               pulumi.String("my-project-name"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		defaultSubnetwork, err := compute.NewSubnetwork(ctx, "default", &compute.SubnetworkArgs{
			Name:        pulumi.String("backend-subnet"),
			Project:     pulumi.String("my-project-name"),
			Region:      pulumi.String("us-west1"),
			IpCidrRange: pulumi.String("10.1.2.0/24"),
			Network:     _default.ID(),
		})
		if err != nil {
			return err
		}
		proxyOnly, err := compute.NewSubnetwork(ctx, "proxy_only", &compute.SubnetworkArgs{
			Name:        pulumi.String("proxy-only-subnet"),
			Project:     pulumi.String("my-project-name"),
			Region:      pulumi.String("us-west1"),
			IpCidrRange: pulumi.String("10.129.0.0/23"),
			Purpose:     pulumi.String("REGIONAL_MANAGED_PROXY"),
			Role:        pulumi.String("ACTIVE"),
			Network:     _default.ID(),
		})
		if err != nil {
			return err
		}
		defaultAddress, err := compute.NewAddress(ctx, "default", &compute.AddressArgs{
			Name:        pulumi.String("l7-ilb-ip-address"),
			Project:     pulumi.String("my-project-name"),
			Region:      pulumi.String("us-west1"),
			Subnetwork:  defaultSubnetwork.ID(),
			AddressType: pulumi.String("INTERNAL"),
			Purpose:     pulumi.String("GCE_ENDPOINT"),
		})
		if err != nil {
			return err
		}
		defaultRegionHealthCheck, err := compute.NewRegionHealthCheck(ctx, "default", &compute.RegionHealthCheckArgs{
			Name:    pulumi.String("l7-ilb-basic-check"),
			Project: pulumi.String("my-project-name"),
			Region:  pulumi.String("us-west1"),
			HttpHealthCheck: &compute.RegionHealthCheckHttpHealthCheckArgs{
				PortSpecification: pulumi.String("USE_SERVING_PORT"),
			},
		})
		if err != nil {
			return err
		}
		urlMap, err := compute.NewRegionBackendService(ctx, "url_map", &compute.RegionBackendServiceArgs{
			Name:                pulumi.String("l7-ilb-backend-service"),
			Project:             pulumi.String("my-project-name"),
			Region:              pulumi.String("us-west1"),
			LoadBalancingScheme: pulumi.String("INTERNAL_MANAGED"),
			HealthChecks:        defaultRegionHealthCheck.ID(),
		})
		if err != nil {
			return err
		}
		defaultRegionUrlMap, err := compute.NewRegionUrlMap(ctx, "default", &compute.RegionUrlMapArgs{
			Name:           pulumi.String("l7-ilb-map"),
			Project:        pulumi.String("my-project-name"),
			Region:         pulumi.String("us-west1"),
			DefaultService: urlMap.ID(),
		})
		if err != nil {
			return err
		}
		defaultRegionTargetHttpProxy, err := compute.NewRegionTargetHttpProxy(ctx, "default", &compute.RegionTargetHttpProxyArgs{
			Name:    pulumi.String("l7-ilb-proxy"),
			Project: pulumi.String("my-project-name"),
			Region:  pulumi.String("us-west1"),
			UrlMap:  defaultRegionUrlMap.ID(),
		})
		if err != nil {
			return err
		}
		defaultForwardingRule, err := compute.NewForwardingRule(ctx, "default", &compute.ForwardingRuleArgs{
			Name:                pulumi.String("l7-ilb-forwarding-rule"),
			Project:             pulumi.String("my-project-name"),
			Region:              pulumi.String("us-west1"),
			LoadBalancingScheme: pulumi.String("INTERNAL_MANAGED"),
			Network:             _default.ID(),
			Subnetwork:          defaultSubnetwork.ID(),
			IpProtocol:          pulumi.String("TCP"),
			PortRange:           pulumi.String("80"),
			Target:              defaultRegionTargetHttpProxy.ID(),
			IpAddress:           defaultAddress.ID(),
		}, pulumi.DependsOn([]pulumi.Resource{
			proxyOnly,
		}))
		if err != nil {
			return err
		}
		authzExtension, err := compute.NewRegionBackendService(ctx, "authz_extension", &compute.RegionBackendServiceArgs{
			Name:                pulumi.String("authz-service"),
			Project:             pulumi.String("my-project-name"),
			Region:              pulumi.String("us-west1"),
			Protocol:            pulumi.String("HTTP2"),
			LoadBalancingScheme: pulumi.String("INTERNAL_MANAGED"),
			PortName:            pulumi.String("grpc"),
		})
		if err != nil {
			return err
		}
		defaultAuthzExtension, err := networkservices.NewAuthzExtension(ctx, "default", &networkservices.AuthzExtensionArgs{
			Name:                pulumi.String("my-authz-ext"),
			Project:             pulumi.String("my-project-name"),
			Location:            pulumi.String("us-west1"),
			Description:         pulumi.String("my description"),
			LoadBalancingScheme: pulumi.String("INTERNAL_MANAGED"),
			Authority:           pulumi.String("ext11.com"),
			Service:             authzExtension.SelfLink,
			Timeout:             pulumi.String("0.1s"),
			FailOpen:            pulumi.Bool(false),
			ForwardHeaders: pulumi.StringArray{
				pulumi.String("Authorization"),
			},
		})
		if err != nil {
			return err
		}
		_, err = networksecurity.NewAuthzPolicy(ctx, "default", &networksecurity.AuthzPolicyArgs{
			Name:        pulumi.String("my-authz-policy"),
			Project:     pulumi.String("my-project-name"),
			Location:    pulumi.String("us-west1"),
			Description: pulumi.String("my description"),
			Target: &networksecurity.AuthzPolicyTargetArgs{
				LoadBalancingScheme: pulumi.String("INTERNAL_MANAGED"),
				Resources: pulumi.StringArray{
					defaultForwardingRule.SelfLink,
				},
			},
			Action: pulumi.String("CUSTOM"),
			CustomProvider: &networksecurity.AuthzPolicyCustomProviderArgs{
				AuthzExtension: &networksecurity.AuthzPolicyCustomProviderAuthzExtensionArgs{
					Resources: pulumi.StringArray{
						defaultAuthzExtension.ID(),
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.Subnetwork;
import com.pulumi.gcp.compute.SubnetworkArgs;
import com.pulumi.gcp.compute.Address;
import com.pulumi.gcp.compute.AddressArgs;
import com.pulumi.gcp.compute.RegionHealthCheck;
import com.pulumi.gcp.compute.RegionHealthCheckArgs;
import com.pulumi.gcp.compute.inputs.RegionHealthCheckHttpHealthCheckArgs;
import com.pulumi.gcp.compute.RegionBackendService;
import com.pulumi.gcp.compute.RegionBackendServiceArgs;
import com.pulumi.gcp.compute.RegionUrlMap;
import com.pulumi.gcp.compute.RegionUrlMapArgs;
import com.pulumi.gcp.compute.RegionTargetHttpProxy;
import com.pulumi.gcp.compute.RegionTargetHttpProxyArgs;
import com.pulumi.gcp.compute.ForwardingRule;
import com.pulumi.gcp.compute.ForwardingRuleArgs;
import com.pulumi.gcp.networkservices.AuthzExtension;
import com.pulumi.gcp.networkservices.AuthzExtensionArgs;
import com.pulumi.gcp.networksecurity.AuthzPolicy;
import com.pulumi.gcp.networksecurity.AuthzPolicyArgs;
import com.pulumi.gcp.networksecurity.inputs.AuthzPolicyTargetArgs;
import com.pulumi.gcp.networksecurity.inputs.AuthzPolicyCustomProviderArgs;
import com.pulumi.gcp.networksecurity.inputs.AuthzPolicyCustomProviderAuthzExtensionArgs;
import com.pulumi.resources.CustomResourceOptions;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new Network("default", NetworkArgs.builder()
            .name("lb-network")
            .project("my-project-name")
            .autoCreateSubnetworks(false)
            .build());

        var defaultSubnetwork = new Subnetwork("defaultSubnetwork", SubnetworkArgs.builder()
            .name("backend-subnet")
            .project("my-project-name")
            .region("us-west1")
            .ipCidrRange("10.1.2.0/24")
            .network(default_.id())
            .build());

        var proxyOnly = new Subnetwork("proxyOnly", SubnetworkArgs.builder()
            .name("proxy-only-subnet")
            .project("my-project-name")
            .region("us-west1")
            .ipCidrRange("10.129.0.0/23")
            .purpose("REGIONAL_MANAGED_PROXY")
            .role("ACTIVE")
            .network(default_.id())
            .build());

        var defaultAddress = new Address("defaultAddress", AddressArgs.builder()
            .name("l7-ilb-ip-address")
            .project("my-project-name")
            .region("us-west1")
            .subnetwork(defaultSubnetwork.id())
            .addressType("INTERNAL")
            .purpose("GCE_ENDPOINT")
            .build());

        var defaultRegionHealthCheck = new RegionHealthCheck("defaultRegionHealthCheck", RegionHealthCheckArgs.builder()
            .name("l7-ilb-basic-check")
            .project("my-project-name")
            .region("us-west1")
            .httpHealthCheck(RegionHealthCheckHttpHealthCheckArgs.builder()
                .portSpecification("USE_SERVING_PORT")
                .build())
            .build());

        var urlMap = new RegionBackendService("urlMap", RegionBackendServiceArgs.builder()
            .name("l7-ilb-backend-service")
            .project("my-project-name")
            .region("us-west1")
            .loadBalancingScheme("INTERNAL_MANAGED")
            .healthChecks(defaultRegionHealthCheck.id())
            .build());

        var defaultRegionUrlMap = new RegionUrlMap("defaultRegionUrlMap", RegionUrlMapArgs.builder()
            .name("l7-ilb-map")
            .project("my-project-name")
            .region("us-west1")
            .defaultService(urlMap.id())
            .build());

        var defaultRegionTargetHttpProxy = new RegionTargetHttpProxy("defaultRegionTargetHttpProxy", RegionTargetHttpProxyArgs.builder()
            .name("l7-ilb-proxy")
            .project("my-project-name")
            .region("us-west1")
            .urlMap(defaultRegionUrlMap.id())
            .build());

        var defaultForwardingRule = new ForwardingRule("defaultForwardingRule", ForwardingRuleArgs.builder()
            .name("l7-ilb-forwarding-rule")
            .project("my-project-name")
            .region("us-west1")
            .loadBalancingScheme("INTERNAL_MANAGED")
            .network(default_.id())
            .subnetwork(defaultSubnetwork.id())
            .ipProtocol("TCP")
            .portRange("80")
            .target(defaultRegionTargetHttpProxy.id())
            .ipAddress(defaultAddress.id())
            .build(), CustomResourceOptions.builder()
                .dependsOn(proxyOnly)
                .build());

        var authzExtension = new RegionBackendService("authzExtension", RegionBackendServiceArgs.builder()
            .name("authz-service")
            .project("my-project-name")
            .region("us-west1")
            .protocol("HTTP2")
            .loadBalancingScheme("INTERNAL_MANAGED")
            .portName("grpc")
            .build());

        var defaultAuthzExtension = new AuthzExtension("defaultAuthzExtension", AuthzExtensionArgs.builder()
            .name("my-authz-ext")
            .project("my-project-name")
            .location("us-west1")
            .description("my description")
            .loadBalancingScheme("INTERNAL_MANAGED")
            .authority("ext11.com")
            .service(authzExtension.selfLink())
            .timeout("0.1s")
            .failOpen(false)
            .forwardHeaders("Authorization")
            .build());

        var defaultAuthzPolicy = new AuthzPolicy("defaultAuthzPolicy", AuthzPolicyArgs.builder()
            .name("my-authz-policy")
            .project("my-project-name")
            .location("us-west1")
            .description("my description")
            .target(AuthzPolicyTargetArgs.builder()
                .loadBalancingScheme("INTERNAL_MANAGED")
                .resources(defaultForwardingRule.selfLink())
                .build())
            .action("CUSTOM")
            .customProvider(AuthzPolicyCustomProviderArgs.builder()
                .authzExtension(AuthzPolicyCustomProviderAuthzExtensionArgs.builder()
                    .resources(defaultAuthzExtension.id())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:compute:Network
    properties:
      name: lb-network
      project: my-project-name
      autoCreateSubnetworks: false
  defaultSubnetwork:
    type: gcp:compute:Subnetwork
    name: default
    properties:
      name: backend-subnet
      project: my-project-name
      region: us-west1
      ipCidrRange: 10.1.2.0/24
      network: ${default.id}
  proxyOnly:
    type: gcp:compute:Subnetwork
    name: proxy_only
    properties:
      name: proxy-only-subnet
      project: my-project-name
      region: us-west1
      ipCidrRange: 10.129.0.0/23
      purpose: REGIONAL_MANAGED_PROXY
      role: ACTIVE
      network: ${default.id}
  defaultAddress:
    type: gcp:compute:Address
    name: default
    properties:
      name: l7-ilb-ip-address
      project: my-project-name
      region: us-west1
      subnetwork: ${defaultSubnetwork.id}
      addressType: INTERNAL
      purpose: GCE_ENDPOINT
  defaultRegionHealthCheck:
    type: gcp:compute:RegionHealthCheck
    name: default
    properties:
      name: l7-ilb-basic-check
      project: my-project-name
      region: us-west1
      httpHealthCheck:
        portSpecification: USE_SERVING_PORT
  urlMap:
    type: gcp:compute:RegionBackendService
    name: url_map
    properties:
      name: l7-ilb-backend-service
      project: my-project-name
      region: us-west1
      loadBalancingScheme: INTERNAL_MANAGED
      healthChecks: ${defaultRegionHealthCheck.id}
  defaultRegionUrlMap:
    type: gcp:compute:RegionUrlMap
    name: default
    properties:
      name: l7-ilb-map
      project: my-project-name
      region: us-west1
      defaultService: ${urlMap.id}
  defaultRegionTargetHttpProxy:
    type: gcp:compute:RegionTargetHttpProxy
    name: default
    properties:
      name: l7-ilb-proxy
      project: my-project-name
      region: us-west1
      urlMap: ${defaultRegionUrlMap.id}
  defaultForwardingRule:
    type: gcp:compute:ForwardingRule
    name: default
    properties:
      name: l7-ilb-forwarding-rule
      project: my-project-name
      region: us-west1
      loadBalancingScheme: INTERNAL_MANAGED
      network: ${default.id}
      subnetwork: ${defaultSubnetwork.id}
      ipProtocol: TCP
      portRange: '80'
      target: ${defaultRegionTargetHttpProxy.id}
      ipAddress: ${defaultAddress.id}
    options:
      dependsOn:
        - ${proxyOnly}
  authzExtension:
    type: gcp:compute:RegionBackendService
    name: authz_extension
    properties:
      name: authz-service
      project: my-project-name
      region: us-west1
      protocol: HTTP2
      loadBalancingScheme: INTERNAL_MANAGED
      portName: grpc
  defaultAuthzExtension:
    type: gcp:networkservices:AuthzExtension
    name: default
    properties:
      name: my-authz-ext
      project: my-project-name
      location: us-west1
      description: my description
      loadBalancingScheme: INTERNAL_MANAGED
      authority: ext11.com
      service: ${authzExtension.selfLink}
      timeout: 0.1s
      failOpen: false
      forwardHeaders:
        - Authorization
  defaultAuthzPolicy:
    type: gcp:networksecurity:AuthzPolicy
    name: default
    properties:
      name: my-authz-policy
      project: my-project-name
      location: us-west1
      description: my description
      target:
        loadBalancingScheme: INTERNAL_MANAGED
        resources:
          - ${defaultForwardingRule.selfLink}
      action: CUSTOM
      customProvider:
        authzExtension:
          resources:
            - ${defaultAuthzExtension.id}
```
<!--End PulumiCodeChooser -->

## Import

AuthzPolicy can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/authzPolicies/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

* `{{name}}`

When using the `pulumi import` command, AuthzPolicy can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networksecurity/authzPolicy:AuthzPolicy default projects/{{project}}/locations/{{location}}/authzPolicies/{{name}}
```

```sh
$ pulumi import gcp:networksecurity/authzPolicy:AuthzPolicy default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:networksecurity/authzPolicy:AuthzPolicy default {{location}}/{{name}}
```

```sh
$ pulumi import gcp:networksecurity/authzPolicy:AuthzPolicy default {{name}}
```

‰
action" ’When the action is CUSTOM, customProvider must be specified.
When the action is ALLOW, only requests matching the policy will be allowed.
When the action is DENY, only requests matching the policy will be denied.
When a request arrives, the policies are evaluated in the following order:
1. If there is a CUSTOM policy that matches the request, the CUSTOM policy is evaluated using the custom authorization providers and the request is denied if the provider rejects the request.
2. If there are any DENY policies that match the request, the request is denied.
3. If there are no ALLOW policies for the resource or if any of the ALLOW policies match the request, the request is allowed.
4. Else the request is denied by default if none of the configured AuthzPolicies with ALLOW action match the request.
Possible values are: `ALLOW`, `DENY`, `CUSTOM`.
∏
customProvider{By:w
u
networksecurityAuthzPolicyCustomProviderGgcp:networksecurity/AuthzPolicyCustomProvider:AuthzPolicyCustomProvider®Required if the action is CUSTOM. Allows delegating authorization decisions to Cloud IAP or to Service Extensions. One
of cloudIap or authzExtension must be specified.
C
descriptionB" .A human-readable description of the resource.
é
	httpRuleskBi*g:e
c
networksecurityAuthzPolicyHttpRule;gcp:networksecurity/AuthzPolicyHttpRule:AuthzPolicyHttpRuleìA list of authorization HTTP rules to match against the incoming request.A policy match occurs when at least one HTTP
rule matches the request or when no HTTP rules are specified in the policy. At least one HTTP Rule is required for Allow
or Deny Action. Limited to 5 rules.
î
labelsB2" ÅSet of labels associated with the AuthzExtension resource. **Note**: This field is non-authoritative, and will only
manage the labels present in your configuration. Please refer to the field 'effective_labels' for all of the labels
present on the resource.
.
location" The location of the resource.
<
nameB" .Identifier. Name of the AuthzPolicy resource.

projectB" ÷
targeta:_
]
networksecurityAuthzPolicyTarget7gcp:networksecurity/AuthzPolicyTarget:AuthzPolicyTargetiSpecifies the set of resources to which this policy should be applied to.
Structure is documented below.
"‰
action" ’When the action is CUSTOM, customProvider must be specified.
When the action is ALLOW, only requests matching the policy will be allowed.
When the action is DENY, only requests matching the policy will be denied.
When a request arrives, the policies are evaluated in the following order:
1. If there is a CUSTOM policy that matches the request, the CUSTOM policy is evaluated using the custom authorization providers and the request is denied if the provider rejects the request.
2. If there are any DENY policies that match the request, the request is denied.
3. If there are no ALLOW policies for the resource or if any of the ALLOW policies match the request, the request is allowed.
4. Else the request is denied by default if none of the configured AuthzPolicies with ALLOW action match the request.
Possible values are: `ALLOW`, `DENY`, `CUSTOM`.
"?

createTime" -The timestamp when the resource was created.
"∏
customProvider{By:w
u
networksecurityAuthzPolicyCustomProviderGgcp:networksecurity/AuthzPolicyCustomProvider:AuthzPolicyCustomProvider®Required if the action is CUSTOM. Allows delegating authorization decisions to Cloud IAP or to Service Extensions. One
of cloudIap or authzExtension must be specified.
"C
descriptionB" .A human-readable description of the resource.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"é
	httpRuleskBi*g:e
c
networksecurityAuthzPolicyHttpRule;gcp:networksecurity/AuthzPolicyHttpRule:AuthzPolicyHttpRuleìA list of authorization HTTP rules to match against the incoming request.A policy match occurs when at least one HTTP
rule matches the request or when no HTTP rules are specified in the policy. At least one HTTP Rule is required for Allow
or Deny Action. Limited to 5 rules.
"î
labelsB2" ÅSet of labels associated with the AuthzExtension resource. **Note**: This field is non-authoritative, and will only
manage the labels present in your configuration. Please refer to the field 'effective_labels' for all of the labels
present on the resource.
".
location" The location of the resource.
":
name" .Identifier. Name of the AuthzPolicy resource.
"
project" "É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"÷
targeta:_
]
networksecurityAuthzPolicyTarget7gcp:networksecurity/AuthzPolicyTarget:AuthzPolicyTargetiSpecifies the set of resources to which this policy should be applied to.
Structure is documented below.
"?

updateTime" -The timestamp when the resource was updated.
*Ωe
W
networksecurityClientTlsPolicy3gcp:networksecurity/clientTlsPolicy:ClientTlsPolicy˙IClientTlsPolicy is a resource that specifies how a client should authenticate connections to backends of a service. This resource itself does not affect configuration unless it is attached to a backend service resource.


To get more information about ClientTlsPolicy, see:

* [API documentation](https://cloud.google.com/traffic-director/docs/reference/network-security/rest/v1beta1/projects.locations.clientTlsPolicies)
* How-to Guides
    * [Service Security](https://cloud.google.com/traffic-director/docs/security-use-cases)

## Example Usage

### Network Security Client Tls Policy Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networksecurity.ClientTlsPolicy("default", {
    name: "my-client-tls-policy",
    labels: {
        foo: "bar",
    },
    description: "my description",
    sni: "secure.example.com",
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networksecurity.ClientTlsPolicy("default",
    name="my-client-tls-policy",
    labels={
        "foo": "bar",
    },
    description="my description",
    sni="secure.example.com")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkSecurity.ClientTlsPolicy("default", new()
    {
        Name = "my-client-tls-policy",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        Sni = "secure.example.com",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networksecurity.NewClientTlsPolicy(ctx, "default", &networksecurity.ClientTlsPolicyArgs{
			Name: pulumi.String("my-client-tls-policy"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			Sni:         pulumi.String("secure.example.com"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networksecurity.ClientTlsPolicy;
import com.pulumi.gcp.networksecurity.ClientTlsPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new ClientTlsPolicy("default", ClientTlsPolicyArgs.builder()
            .name("my-client-tls-policy")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .sni("secure.example.com")
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networksecurity:ClientTlsPolicy
    properties:
      name: my-client-tls-policy
      labels:
        foo: bar
      description: my description
      sni: secure.example.com
```
<!--End PulumiCodeChooser -->
### Network Security Client Tls Policy Advanced


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networksecurity.ClientTlsPolicy("default", {
    name: "my-client-tls-policy",
    labels: {
        foo: "bar",
    },
    description: "my description",
    clientCertificate: {
        certificateProviderInstance: {
            pluginInstance: "google_cloud_private_spiffe",
        },
    },
    serverValidationCas: [{
        grpcEndpoint: {
            targetUri: "unix:mypath",
        },
    }],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networksecurity.ClientTlsPolicy("default",
    name="my-client-tls-policy",
    labels={
        "foo": "bar",
    },
    description="my description",
    client_certificate={
        "certificate_provider_instance": {
            "plugin_instance": "google_cloud_private_spiffe",
        },
    },
    server_validation_cas=[{
        "grpc_endpoint": {
            "target_uri": "unix:mypath",
        },
    }])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkSecurity.ClientTlsPolicy("default", new()
    {
        Name = "my-client-tls-policy",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        ClientCertificate = new Gcp.NetworkSecurity.Inputs.ClientTlsPolicyClientCertificateArgs
        {
            CertificateProviderInstance = new Gcp.NetworkSecurity.Inputs.ClientTlsPolicyClientCertificateCertificateProviderInstanceArgs
            {
                PluginInstance = "google_cloud_private_spiffe",
            },
        },
        ServerValidationCas = new[]
        {
            new Gcp.NetworkSecurity.Inputs.ClientTlsPolicyServerValidationCaArgs
            {
                GrpcEndpoint = new Gcp.NetworkSecurity.Inputs.ClientTlsPolicyServerValidationCaGrpcEndpointArgs
                {
                    TargetUri = "unix:mypath",
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networksecurity.NewClientTlsPolicy(ctx, "default", &networksecurity.ClientTlsPolicyArgs{
			Name: pulumi.String("my-client-tls-policy"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			ClientCertificate: &networksecurity.ClientTlsPolicyClientCertificateArgs{
				CertificateProviderInstance: &networksecurity.ClientTlsPolicyClientCertificateCertificateProviderInstanceArgs{
					PluginInstance: pulumi.String("google_cloud_private_spiffe"),
				},
			},
			ServerValidationCas: networksecurity.ClientTlsPolicyServerValidationCaArray{
				&networksecurity.ClientTlsPolicyServerValidationCaArgs{
					GrpcEndpoint: &networksecurity.ClientTlsPolicyServerValidationCaGrpcEndpointArgs{
						TargetUri: pulumi.String("unix:mypath"),
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networksecurity.ClientTlsPolicy;
import com.pulumi.gcp.networksecurity.ClientTlsPolicyArgs;
import com.pulumi.gcp.networksecurity.inputs.ClientTlsPolicyClientCertificateArgs;
import com.pulumi.gcp.networksecurity.inputs.ClientTlsPolicyClientCertificateCertificateProviderInstanceArgs;
import com.pulumi.gcp.networksecurity.inputs.ClientTlsPolicyServerValidationCaArgs;
import com.pulumi.gcp.networksecurity.inputs.ClientTlsPolicyServerValidationCaGrpcEndpointArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new ClientTlsPolicy("default", ClientTlsPolicyArgs.builder()
            .name("my-client-tls-policy")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .clientCertificate(ClientTlsPolicyClientCertificateArgs.builder()
                .certificateProviderInstance(ClientTlsPolicyClientCertificateCertificateProviderInstanceArgs.builder()
                    .pluginInstance("google_cloud_private_spiffe")
                    .build())
                .build())
            .serverValidationCas(ClientTlsPolicyServerValidationCaArgs.builder()
                .grpcEndpoint(ClientTlsPolicyServerValidationCaGrpcEndpointArgs.builder()
                    .targetUri("unix:mypath")
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networksecurity:ClientTlsPolicy
    properties:
      name: my-client-tls-policy
      labels:
        foo: bar
      description: my description
      clientCertificate:
        certificateProviderInstance:
          pluginInstance: google_cloud_private_spiffe
      serverValidationCas:
        - grpcEndpoint:
            targetUri: unix:mypath
```
<!--End PulumiCodeChooser -->

## Import

ClientTlsPolicy can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/clientTlsPolicies/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

When using the `pulumi import` command, ClientTlsPolicy can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networksecurity/clientTlsPolicy:ClientTlsPolicy default projects/{{project}}/locations/{{location}}/clientTlsPolicies/{{name}}
```

```sh
$ pulumi import gcp:networksecurity/clientTlsPolicy:ClientTlsPolicy default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:networksecurity/clientTlsPolicy:ClientTlsPolicy default {{location}}/{{name}}
```

€
clientCertificateìBê:ç
ä
networksecurity ClientTlsPolicyClientCertificateUgcp:networksecurity/ClientTlsPolicyClientCertificate:ClientTlsPolicyClientCertificateØDefines a mechanism to provision client identity (public and private keys) for peer to peer authentication. The presence of this dictates mTLS.
Structure is documented below.
Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
ô
labelsB2" ÜSet of label tags associated with the ClientTlsPolicy resource.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
X
locationB" FThe location of the client tls policy.
The default value is `global`.
<
nameB" .Name of the ClientTlsPolicy resource.


- - -
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
¯
serverValidationCasôBñ*ì:ê
ç
networksecurity!ClientTlsPolicyServerValidationCaWgcp:networksecurity/ClientTlsPolicyServerValidationCa:ClientTlsPolicyServerValidationCaƒDefines the mechanism to obtain the Certificate Authority certificate to validate the server certificate. If empty, client does not validate the server certificate.
Structure is documented below.
u
sniB" hServer Name Indication string to present to the server during TLS handshake. E.g: "secure.example.com".
"€
clientCertificateìBê:ç
ä
networksecurity ClientTlsPolicyClientCertificateUgcp:networksecurity/ClientTlsPolicyClientCertificate:ClientTlsPolicyClientCertificateØDefines a mechanism to provision client identity (public and private keys) for peer to peer authentication. The presence of this dictates mTLS.
Structure is documented below.
"?

createTime" -Time the ClientTlsPolicy was created in UTC.
"Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"ô
labelsB2" ÜSet of label tags associated with the ClientTlsPolicy resource.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"X
locationB" FThe location of the client tls policy.
The default value is `global`.
":
name" .Name of the ClientTlsPolicy resource.


- - -
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"¯
serverValidationCasôBñ*ì:ê
ç
networksecurity!ClientTlsPolicyServerValidationCaWgcp:networksecurity/ClientTlsPolicyServerValidationCa:ClientTlsPolicyServerValidationCaƒDefines the mechanism to obtain the Certificate Authority certificate to validate the server certificate. If empty, client does not validate the server certificate.
Structure is documented below.
"u
sniB" hServer Name Indication string to present to the server during TLS handshake. E.g: "secure.example.com".
"?

updateTime" -Time the ClientTlsPolicy was updated in UTC.
*ñ4
Z
networksecurityFirewallEndpoint5gcp:networksecurity/firewallEndpoint:FirewallEndpointÕ"A Firewall endpoint is a Cloud Firewall resource that enables
layer 7 advanced protection capabilities, such as intrusion prevention,
in your network.


To get more information about FirewallEndpoint, see:

* [API documentation](https://cloud.google.com/firewall/docs/reference/network-security/rest/v1/organizations.locations.firewallEndpoints)
* How-to Guides
    * [Create and associate firewall endpoints](https://cloud.google.com/firewall/docs/configure-firewall-endpoints)
    * [Firewall endpoint overview](https://cloud.google.com/firewall/docs/about-firewall-endpoints)

> **Warning:** If you are using User ADCs (Application Default Credentials) with this resource,
you must specify a `billing_project_id` and set `user_project_override` to true
in the provider configuration. Otherwise the ACM API will return a 403 error.
Your account must have the `serviceusage.services.use` permission on the
`billing_project_id` you defined.

## Example Usage

### Network Security Firewall Endpoint Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networksecurity.FirewallEndpoint("default", {
    name: "my-firewall-endpoint",
    parent: "organizations/123456789",
    location: "us-central1-a",
    billingProjectId: "my-project-name",
    labels: {
        foo: "bar",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networksecurity.FirewallEndpoint("default",
    name="my-firewall-endpoint",
    parent="organizations/123456789",
    location="us-central1-a",
    billing_project_id="my-project-name",
    labels={
        "foo": "bar",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkSecurity.FirewallEndpoint("default", new()
    {
        Name = "my-firewall-endpoint",
        Parent = "organizations/123456789",
        Location = "us-central1-a",
        BillingProjectId = "my-project-name",
        Labels = 
        {
            { "foo", "bar" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networksecurity.NewFirewallEndpoint(ctx, "default", &networksecurity.FirewallEndpointArgs{
			Name:             pulumi.String("my-firewall-endpoint"),
			Parent:           pulumi.String("organizations/123456789"),
			Location:         pulumi.String("us-central1-a"),
			BillingProjectId: pulumi.String("my-project-name"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networksecurity.FirewallEndpoint;
import com.pulumi.gcp.networksecurity.FirewallEndpointArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new FirewallEndpoint("default", FirewallEndpointArgs.builder()
            .name("my-firewall-endpoint")
            .parent("organizations/123456789")
            .location("us-central1-a")
            .billingProjectId("my-project-name")
            .labels(Map.of("foo", "bar"))
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networksecurity:FirewallEndpoint
    properties:
      name: my-firewall-endpoint
      parent: organizations/123456789
      location: us-central1-a
      billingProjectId: my-project-name
      labels:
        foo: bar
```
<!--End PulumiCodeChooser -->

## Import

FirewallEndpoint can be imported using any of these accepted formats:

* `{{parent}}/locations/{{location}}/firewallEndpoints/{{name}}`

When using the `pulumi import` command, FirewallEndpoint can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networksecurity/firewallEndpoint:FirewallEndpoint default {{parent}}/locations/{{location}}/firewallEndpoints/{{name}}
```

B
billingProjectId" *Project to bill on endpoint uptime usage.
î
labelsB2" ÅA map of key/value label pairs to assign to the resource.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
>
location" .The location (zone) of the firewall endpoint.
:
nameB" ,The name of the firewall endpoint resource.
y
parent" kThe name of the parent this firewall endpoint belongs to.
Format: organizations/{organization_id}.


- - -
"¬
associatedNetworks*" •List of networks that are associated with this endpoint in the local zone.
This is a projection of the FirewallEndpointAssociations pointing at this
endpoint. A network will only appear in this list after traffic routing is
fully configured. Format: projects/{project}/global/networks/{name}.
"B
billingProjectId" *Project to bill on endpoint uptime usage.
"A

createTime" /Time the firewall endpoint was created in UTC.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"î
labelsB2" ÅA map of key/value label pairs to assign to the resource.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
">
location" .The location (zone) of the firewall endpoint.
"8
name" ,The name of the firewall endpoint resource.
"y
parent" kThe name of the parent this firewall endpoint belongs to.
Format: organizations/{organization_id}.


- - -
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"c
reconciling
 PWhether reconciling is in progress, recommended per https://google.aip.dev/128.
"5
selfLink" %Server-defined URL of this resource.
"0
state" #The current state of the endpoint.
"A

updateTime" /Time the firewall endpoint was updated in UTC.
*ó#
{
networksecurityFirewallEndpointAssociationKgcp:networksecurity/firewallEndpointAssociation:FirewallEndpointAssociation¬Firewall endpoint association links a firewall endpoint to a VPC network in
the same zone. After you define this association, Cloud Firewall forwards the
zonal workload traffic in your VPC network that requires layer 7 inspection to
the attached firewall endpoint.


To get more information about FirewallEndpointAssociation, see:

* [API documentation](https://cloud.google.com/firewall/docs/reference/network-security/rest/v1/projects.locations.firewallEndpointAssociations#FirewallEndpointAssociation)
* How-to Guides
    * [Create and associate firewall endpoints](https://cloud.google.com/firewall/docs/configure-firewall-endpoints)
    * [Firewall endpoint overview](https://cloud.google.com/firewall/docs/about-firewall-endpoints)

> **Warning:** If you are using User ADCs (Application Default Credentials) with this resource,
you must specify a `billing_project_id` and set `user_project_override` to true
in the provider configuration. Otherwise the ACM API will return a 403 error.
Your account must have the `serviceusage.services.use` permission on the
`billing_project_id` you defined.

## Example Usage

## Import

FirewallEndpointAssociation can be imported using any of these accepted formats:

* `{{parent}}/locations/{{location}}/firewallEndpointAssociations/{{name}}`

When using the `pulumi import` command, FirewallEndpointAssociation can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networksecurity/firewallEndpointAssociation:FirewallEndpointAssociation default {{parent}}/locations/{{location}}/firewallEndpointAssociations/{{name}}
```

ä
disabledB
 ˜Whether the association is disabled. True indicates that traffic will not be intercepted.
> **Note:** The API will reject the request if this value is set to true when creating the resource,
otherwise on an update the association can be disabled.
S
firewallEndpoint" ;The URL of the firewall endpoint that is being associated.
î
labelsB2" ÅA map of key/value label pairs to assign to the resource.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
R
location" BThe location (zone) of the firewall endpoint association.


- - -
F
nameB" 8The name of the firewall endpoint association resource.
@
network" 1The URL of the network that is being associated.
u
parentB" eThe name of the parent this firewall endpoint association belongs to.
Format: projects/{project_id}.
Z
tlsInspectionPolicyB" =The URL of the TlsInspectionPolicy that is being associated.
"A

createTime" /Time the firewall endpoint was created in UTC.
"ä
disabledB
 ˜Whether the association is disabled. True indicates that traffic will not be intercepted.
> **Note:** The API will reject the request if this value is set to true when creating the resource,
otherwise on an update the association can be disabled.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"S
firewallEndpoint" ;The URL of the firewall endpoint that is being associated.
"î
labelsB2" ÅA map of key/value label pairs to assign to the resource.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"R
location" BThe location (zone) of the firewall endpoint association.


- - -
"D
name" 8The name of the firewall endpoint association resource.
"@
network" 1The URL of the network that is being associated.
"u
parentB" eThe name of the parent this firewall endpoint association belongs to.
Format: projects/{project_id}.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"c
reconciling
 PWhether reconciling is in progress, recommended per https://google.aip.dev/128.
"5
selfLink" %Server-defined URL of this resource.
"0
state" #The current state of the endpoint.
"Z
tlsInspectionPolicyB" =The URL of the TlsInspectionPolicy that is being associated.
"A

updateTime" /Time the firewall endpoint was updated in UTC.
*‚Ê
i
networksecurityGatewaySecurityPolicy?gcp:networksecurity/gatewaySecurityPolicy:GatewaySecurityPolicyØ’The GatewaySecurityPolicy resource contains a collection of GatewaySecurityPolicyRules and associated metadata.


To get more information about GatewaySecurityPolicy, see:

* [API documentation](https://cloud.google.com/secure-web-proxy/docs/reference/network-security/rest/v1/projects.locations.gatewaySecurityPolicies)

## Example Usage

### Network Security Gateway Security Policy Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networksecurity.GatewaySecurityPolicy("default", {
    name: "my-gateway-security-policy",
    location: "us-central1",
    description: "my description",
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networksecurity.GatewaySecurityPolicy("default",
    name="my-gateway-security-policy",
    location="us-central1",
    description="my description")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkSecurity.GatewaySecurityPolicy("default", new()
    {
        Name = "my-gateway-security-policy",
        Location = "us-central1",
        Description = "my description",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networksecurity.NewGatewaySecurityPolicy(ctx, "default", &networksecurity.GatewaySecurityPolicyArgs{
			Name:        pulumi.String("my-gateway-security-policy"),
			Location:    pulumi.String("us-central1"),
			Description: pulumi.String("my description"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networksecurity.GatewaySecurityPolicy;
import com.pulumi.gcp.networksecurity.GatewaySecurityPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new GatewaySecurityPolicy("default", GatewaySecurityPolicyArgs.builder()
            .name("my-gateway-security-policy")
            .location("us-central1")
            .description("my description")
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networksecurity:GatewaySecurityPolicy
    properties:
      name: my-gateway-security-policy
      location: us-central1
      description: my description
```
<!--End PulumiCodeChooser -->
### Network Security Gateway Security Policy Tls Inspection Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.certificateauthority.CaPool("default", {
    name: "my-basic-ca-pool",
    location: "us-central1",
    tier: "DEVOPS",
    publishingOptions: {
        publishCaCert: false,
        publishCrl: false,
    },
    issuancePolicy: {
        maximumLifetime: "1209600s",
        baselineValues: {
            caOptions: {
                isCa: false,
            },
            keyUsage: {
                baseKeyUsage: {},
                extendedKeyUsage: {
                    serverAuth: true,
                },
            },
        },
    },
});
const defaultAuthority = new gcp.certificateauthority.Authority("default", {
    pool: _default.name,
    certificateAuthorityId: "my-basic-certificate-authority",
    location: "us-central1",
    lifetime: "86400s",
    type: "SELF_SIGNED",
    deletionProtection: false,
    skipGracePeriod: true,
    ignoreActiveCertificatesOnDeletion: true,
    config: {
        subjectConfig: {
            subject: {
                organization: "Test LLC",
                commonName: "my-ca",
            },
        },
        x509Config: {
            caOptions: {
                isCa: true,
            },
            keyUsage: {
                baseKeyUsage: {
                    certSign: true,
                    crlSign: true,
                },
                extendedKeyUsage: {
                    serverAuth: false,
                },
            },
        },
    },
    keySpec: {
        algorithm: "RSA_PKCS1_4096_SHA256",
    },
});
const project = gcp.organizations.getProject({});
const tlsInspectionPermission = new gcp.certificateauthority.CaPoolIamMember("tls_inspection_permission", {
    caPool: _default.id,
    role: "roles/privateca.certificateManager",
    member: project.then(project => `serviceAccount:service-${project.number}@gcp-sa-networksecurity.iam.gserviceaccount.com`),
});
const defaultTlsInspectionPolicy = new gcp.networksecurity.TlsInspectionPolicy("default", {
    name: "my-tls-inspection-policy",
    location: "us-central1",
    caPool: _default.id,
}, {
    dependsOn: [
        _default,
        defaultAuthority,
        tlsInspectionPermission,
    ],
});
const defaultGatewaySecurityPolicy = new gcp.networksecurity.GatewaySecurityPolicy("default", {
    name: "my-gateway-security-policy",
    location: "us-central1",
    description: "my description",
    tlsInspectionPolicy: defaultTlsInspectionPolicy.id,
}, {
    dependsOn: [defaultTlsInspectionPolicy],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.certificateauthority.CaPool("default",
    name="my-basic-ca-pool",
    location="us-central1",
    tier="DEVOPS",
    publishing_options={
        "publish_ca_cert": False,
        "publish_crl": False,
    },
    issuance_policy={
        "maximum_lifetime": "1209600s",
        "baseline_values": {
            "ca_options": {
                "is_ca": False,
            },
            "key_usage": {
                "base_key_usage": {},
                "extended_key_usage": {
                    "server_auth": True,
                },
            },
        },
    })
default_authority = gcp.certificateauthority.Authority("default",
    pool=default.name,
    certificate_authority_id="my-basic-certificate-authority",
    location="us-central1",
    lifetime="86400s",
    type="SELF_SIGNED",
    deletion_protection=False,
    skip_grace_period=True,
    ignore_active_certificates_on_deletion=True,
    config={
        "subject_config": {
            "subject": {
                "organization": "Test LLC",
                "common_name": "my-ca",
            },
        },
        "x509_config": {
            "ca_options": {
                "is_ca": True,
            },
            "key_usage": {
                "base_key_usage": {
                    "cert_sign": True,
                    "crl_sign": True,
                },
                "extended_key_usage": {
                    "server_auth": False,
                },
            },
        },
    },
    key_spec={
        "algorithm": "RSA_PKCS1_4096_SHA256",
    })
project = gcp.organizations.get_project()
tls_inspection_permission = gcp.certificateauthority.CaPoolIamMember("tls_inspection_permission",
    ca_pool=default.id,
    role="roles/privateca.certificateManager",
    member=f"serviceAccount:service-{project.number}@gcp-sa-networksecurity.iam.gserviceaccount.com")
default_tls_inspection_policy = gcp.networksecurity.TlsInspectionPolicy("default",
    name="my-tls-inspection-policy",
    location="us-central1",
    ca_pool=default.id,
    opts = pulumi.ResourceOptions(depends_on=[
            default,
            default_authority,
            tls_inspection_permission,
        ]))
default_gateway_security_policy = gcp.networksecurity.GatewaySecurityPolicy("default",
    name="my-gateway-security-policy",
    location="us-central1",
    description="my description",
    tls_inspection_policy=default_tls_inspection_policy.id,
    opts = pulumi.ResourceOptions(depends_on=[default_tls_inspection_policy]))
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.CertificateAuthority.CaPool("default", new()
    {
        Name = "my-basic-ca-pool",
        Location = "us-central1",
        Tier = "DEVOPS",
        PublishingOptions = new Gcp.CertificateAuthority.Inputs.CaPoolPublishingOptionsArgs
        {
            PublishCaCert = false,
            PublishCrl = false,
        },
        IssuancePolicy = new Gcp.CertificateAuthority.Inputs.CaPoolIssuancePolicyArgs
        {
            MaximumLifetime = "1209600s",
            BaselineValues = new Gcp.CertificateAuthority.Inputs.CaPoolIssuancePolicyBaselineValuesArgs
            {
                CaOptions = new Gcp.CertificateAuthority.Inputs.CaPoolIssuancePolicyBaselineValuesCaOptionsArgs
                {
                    IsCa = false,
                },
                KeyUsage = new Gcp.CertificateAuthority.Inputs.CaPoolIssuancePolicyBaselineValuesKeyUsageArgs
                {
                    BaseKeyUsage = null,
                    ExtendedKeyUsage = new Gcp.CertificateAuthority.Inputs.CaPoolIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsageArgs
                    {
                        ServerAuth = true,
                    },
                },
            },
        },
    });

    var defaultAuthority = new Gcp.CertificateAuthority.Authority("default", new()
    {
        Pool = @default.Name,
        CertificateAuthorityId = "my-basic-certificate-authority",
        Location = "us-central1",
        Lifetime = "86400s",
        Type = "SELF_SIGNED",
        DeletionProtection = false,
        SkipGracePeriod = true,
        IgnoreActiveCertificatesOnDeletion = true,
        Config = new Gcp.CertificateAuthority.Inputs.AuthorityConfigArgs
        {
            SubjectConfig = new Gcp.CertificateAuthority.Inputs.AuthorityConfigSubjectConfigArgs
            {
                Subject = new Gcp.CertificateAuthority.Inputs.AuthorityConfigSubjectConfigSubjectArgs
                {
                    Organization = "Test LLC",
                    CommonName = "my-ca",
                },
            },
            X509Config = new Gcp.CertificateAuthority.Inputs.AuthorityConfigX509ConfigArgs
            {
                CaOptions = new Gcp.CertificateAuthority.Inputs.AuthorityConfigX509ConfigCaOptionsArgs
                {
                    IsCa = true,
                },
                KeyUsage = new Gcp.CertificateAuthority.Inputs.AuthorityConfigX509ConfigKeyUsageArgs
                {
                    BaseKeyUsage = new Gcp.CertificateAuthority.Inputs.AuthorityConfigX509ConfigKeyUsageBaseKeyUsageArgs
                    {
                        CertSign = true,
                        CrlSign = true,
                    },
                    ExtendedKeyUsage = new Gcp.CertificateAuthority.Inputs.AuthorityConfigX509ConfigKeyUsageExtendedKeyUsageArgs
                    {
                        ServerAuth = false,
                    },
                },
            },
        },
        KeySpec = new Gcp.CertificateAuthority.Inputs.AuthorityKeySpecArgs
        {
            Algorithm = "RSA_PKCS1_4096_SHA256",
        },
    });

    var project = Gcp.Organizations.GetProject.Invoke();

    var tlsInspectionPermission = new Gcp.CertificateAuthority.CaPoolIamMember("tls_inspection_permission", new()
    {
        CaPool = @default.Id,
        Role = "roles/privateca.certificateManager",
        Member = $"serviceAccount:service-{project.Apply(getProjectResult => getProjectResult.Number)}@gcp-sa-networksecurity.iam.gserviceaccount.com",
    });

    var defaultTlsInspectionPolicy = new Gcp.NetworkSecurity.TlsInspectionPolicy("default", new()
    {
        Name = "my-tls-inspection-policy",
        Location = "us-central1",
        CaPool = @default.Id,
    }, new CustomResourceOptions
    {
        DependsOn =
        {
            @default,
            defaultAuthority,
            tlsInspectionPermission,
        },
    });

    var defaultGatewaySecurityPolicy = new Gcp.NetworkSecurity.GatewaySecurityPolicy("default", new()
    {
        Name = "my-gateway-security-policy",
        Location = "us-central1",
        Description = "my description",
        TlsInspectionPolicy = defaultTlsInspectionPolicy.Id,
    }, new CustomResourceOptions
    {
        DependsOn =
        {
            defaultTlsInspectionPolicy,
        },
    });

});
```
```go
package main

import (
	"fmt"

	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/certificateauthority"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := certificateauthority.NewCaPool(ctx, "default", &certificateauthority.CaPoolArgs{
			Name:     pulumi.String("my-basic-ca-pool"),
			Location: pulumi.String("us-central1"),
			Tier:     pulumi.String("DEVOPS"),
			PublishingOptions: &certificateauthority.CaPoolPublishingOptionsArgs{
				PublishCaCert: pulumi.Bool(false),
				PublishCrl:    pulumi.Bool(false),
			},
			IssuancePolicy: &certificateauthority.CaPoolIssuancePolicyArgs{
				MaximumLifetime: pulumi.String("1209600s"),
				BaselineValues: &certificateauthority.CaPoolIssuancePolicyBaselineValuesArgs{
					CaOptions: &certificateauthority.CaPoolIssuancePolicyBaselineValuesCaOptionsArgs{
						IsCa: pulumi.Bool(false),
					},
					KeyUsage: &certificateauthority.CaPoolIssuancePolicyBaselineValuesKeyUsageArgs{
						BaseKeyUsage: &certificateauthority.CaPoolIssuancePolicyBaselineValuesKeyUsageBaseKeyUsageArgs{},
						ExtendedKeyUsage: &certificateauthority.CaPoolIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsageArgs{
							ServerAuth: pulumi.Bool(true),
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		defaultAuthority, err := certificateauthority.NewAuthority(ctx, "default", &certificateauthority.AuthorityArgs{
			Pool:                               _default.Name,
			CertificateAuthorityId:             pulumi.String("my-basic-certificate-authority"),
			Location:                           pulumi.String("us-central1"),
			Lifetime:                           pulumi.String("86400s"),
			Type:                               pulumi.String("SELF_SIGNED"),
			DeletionProtection:                 pulumi.Bool(false),
			SkipGracePeriod:                    pulumi.Bool(true),
			IgnoreActiveCertificatesOnDeletion: pulumi.Bool(true),
			Config: &certificateauthority.AuthorityConfigArgs{
				SubjectConfig: &certificateauthority.AuthorityConfigSubjectConfigArgs{
					Subject: &certificateauthority.AuthorityConfigSubjectConfigSubjectArgs{
						Organization: pulumi.String("Test LLC"),
						CommonName:   pulumi.String("my-ca"),
					},
				},
				X509Config: &certificateauthority.AuthorityConfigX509ConfigArgs{
					CaOptions: &certificateauthority.AuthorityConfigX509ConfigCaOptionsArgs{
						IsCa: pulumi.Bool(true),
					},
					KeyUsage: &certificateauthority.AuthorityConfigX509ConfigKeyUsageArgs{
						BaseKeyUsage: &certificateauthority.AuthorityConfigX509ConfigKeyUsageBaseKeyUsageArgs{
							CertSign: pulumi.Bool(true),
							CrlSign:  pulumi.Bool(true),
						},
						ExtendedKeyUsage: &certificateauthority.AuthorityConfigX509ConfigKeyUsageExtendedKeyUsageArgs{
							ServerAuth: pulumi.Bool(false),
						},
					},
				},
			},
			KeySpec: &certificateauthority.AuthorityKeySpecArgs{
				Algorithm: pulumi.String("RSA_PKCS1_4096_SHA256"),
			},
		})
		if err != nil {
			return err
		}
		project, err := organizations.LookupProject(ctx, &organizations.LookupProjectArgs{}, nil)
		if err != nil {
			return err
		}
		tlsInspectionPermission, err := certificateauthority.NewCaPoolIamMember(ctx, "tls_inspection_permission", &certificateauthority.CaPoolIamMemberArgs{
			CaPool: _default.ID(),
			Role:   pulumi.String("roles/privateca.certificateManager"),
			Member: pulumi.Sprintf("serviceAccount:service-%v@gcp-sa-networksecurity.iam.gserviceaccount.com", project.Number),
		})
		if err != nil {
			return err
		}
		defaultTlsInspectionPolicy, err := networksecurity.NewTlsInspectionPolicy(ctx, "default", &networksecurity.TlsInspectionPolicyArgs{
			Name:     pulumi.String("my-tls-inspection-policy"),
			Location: pulumi.String("us-central1"),
			CaPool:   _default.ID(),
		}, pulumi.DependsOn([]pulumi.Resource{
			_default,
			defaultAuthority,
			tlsInspectionPermission,
		}))
		if err != nil {
			return err
		}
		_, err = networksecurity.NewGatewaySecurityPolicy(ctx, "default", &networksecurity.GatewaySecurityPolicyArgs{
			Name:                pulumi.String("my-gateway-security-policy"),
			Location:            pulumi.String("us-central1"),
			Description:         pulumi.String("my description"),
			TlsInspectionPolicy: defaultTlsInspectionPolicy.ID(),
		}, pulumi.DependsOn([]pulumi.Resource{
			defaultTlsInspectionPolicy,
		}))
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.certificateauthority.CaPool;
import com.pulumi.gcp.certificateauthority.CaPoolArgs;
import com.pulumi.gcp.certificateauthority.inputs.CaPoolPublishingOptionsArgs;
import com.pulumi.gcp.certificateauthority.inputs.CaPoolIssuancePolicyArgs;
import com.pulumi.gcp.certificateauthority.inputs.CaPoolIssuancePolicyBaselineValuesArgs;
import com.pulumi.gcp.certificateauthority.inputs.CaPoolIssuancePolicyBaselineValuesCaOptionsArgs;
import com.pulumi.gcp.certificateauthority.inputs.CaPoolIssuancePolicyBaselineValuesKeyUsageArgs;
import com.pulumi.gcp.certificateauthority.inputs.CaPoolIssuancePolicyBaselineValuesKeyUsageBaseKeyUsageArgs;
import com.pulumi.gcp.certificateauthority.inputs.CaPoolIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsageArgs;
import com.pulumi.gcp.certificateauthority.Authority;
import com.pulumi.gcp.certificateauthority.AuthorityArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigSubjectConfigArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigSubjectConfigSubjectArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigX509ConfigArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigX509ConfigCaOptionsArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigX509ConfigKeyUsageArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigX509ConfigKeyUsageBaseKeyUsageArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigX509ConfigKeyUsageExtendedKeyUsageArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityKeySpecArgs;
import com.pulumi.gcp.organizations.OrganizationsFunctions;
import com.pulumi.gcp.organizations.inputs.GetProjectArgs;
import com.pulumi.gcp.certificateauthority.CaPoolIamMember;
import com.pulumi.gcp.certificateauthority.CaPoolIamMemberArgs;
import com.pulumi.gcp.networksecurity.TlsInspectionPolicy;
import com.pulumi.gcp.networksecurity.TlsInspectionPolicyArgs;
import com.pulumi.gcp.networksecurity.GatewaySecurityPolicy;
import com.pulumi.gcp.networksecurity.GatewaySecurityPolicyArgs;
import com.pulumi.resources.CustomResourceOptions;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new CaPool("default", CaPoolArgs.builder()
            .name("my-basic-ca-pool")
            .location("us-central1")
            .tier("DEVOPS")
            .publishingOptions(CaPoolPublishingOptionsArgs.builder()
                .publishCaCert(false)
                .publishCrl(false)
                .build())
            .issuancePolicy(CaPoolIssuancePolicyArgs.builder()
                .maximumLifetime("1209600s")
                .baselineValues(CaPoolIssuancePolicyBaselineValuesArgs.builder()
                    .caOptions(CaPoolIssuancePolicyBaselineValuesCaOptionsArgs.builder()
                        .isCa(false)
                        .build())
                    .keyUsage(CaPoolIssuancePolicyBaselineValuesKeyUsageArgs.builder()
                        .baseKeyUsage()
                        .extendedKeyUsage(CaPoolIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsageArgs.builder()
                            .serverAuth(true)
                            .build())
                        .build())
                    .build())
                .build())
            .build());

        var defaultAuthority = new Authority("defaultAuthority", AuthorityArgs.builder()
            .pool(default_.name())
            .certificateAuthorityId("my-basic-certificate-authority")
            .location("us-central1")
            .lifetime("86400s")
            .type("SELF_SIGNED")
            .deletionProtection(false)
            .skipGracePeriod(true)
            .ignoreActiveCertificatesOnDeletion(true)
            .config(AuthorityConfigArgs.builder()
                .subjectConfig(AuthorityConfigSubjectConfigArgs.builder()
                    .subject(AuthorityConfigSubjectConfigSubjectArgs.builder()
                        .organization("Test LLC")
                        .commonName("my-ca")
                        .build())
                    .build())
                .x509Config(AuthorityConfigX509ConfigArgs.builder()
                    .caOptions(AuthorityConfigX509ConfigCaOptionsArgs.builder()
                        .isCa(true)
                        .build())
                    .keyUsage(AuthorityConfigX509ConfigKeyUsageArgs.builder()
                        .baseKeyUsage(AuthorityConfigX509ConfigKeyUsageBaseKeyUsageArgs.builder()
                            .certSign(true)
                            .crlSign(true)
                            .build())
                        .extendedKeyUsage(AuthorityConfigX509ConfigKeyUsageExtendedKeyUsageArgs.builder()
                            .serverAuth(false)
                            .build())
                        .build())
                    .build())
                .build())
            .keySpec(AuthorityKeySpecArgs.builder()
                .algorithm("RSA_PKCS1_4096_SHA256")
                .build())
            .build());

        final var project = OrganizationsFunctions.getProject();

        var tlsInspectionPermission = new CaPoolIamMember("tlsInspectionPermission", CaPoolIamMemberArgs.builder()
            .caPool(default_.id())
            .role("roles/privateca.certificateManager")
            .member(String.format("serviceAccount:service-%s@gcp-sa-networksecurity.iam.gserviceaccount.com", project.applyValue(getProjectResult -> getProjectResult.number())))
            .build());

        var defaultTlsInspectionPolicy = new TlsInspectionPolicy("defaultTlsInspectionPolicy", TlsInspectionPolicyArgs.builder()
            .name("my-tls-inspection-policy")
            .location("us-central1")
            .caPool(default_.id())
            .build(), CustomResourceOptions.builder()
                .dependsOn(                
                    default_,
                    defaultAuthority,
                    tlsInspectionPermission)
                .build());

        var defaultGatewaySecurityPolicy = new GatewaySecurityPolicy("defaultGatewaySecurityPolicy", GatewaySecurityPolicyArgs.builder()
            .name("my-gateway-security-policy")
            .location("us-central1")
            .description("my description")
            .tlsInspectionPolicy(defaultTlsInspectionPolicy.id())
            .build(), CustomResourceOptions.builder()
                .dependsOn(defaultTlsInspectionPolicy)
                .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:certificateauthority:CaPool
    properties:
      name: my-basic-ca-pool
      location: us-central1
      tier: DEVOPS
      publishingOptions:
        publishCaCert: false
        publishCrl: false
      issuancePolicy:
        maximumLifetime: 1209600s
        baselineValues:
          caOptions:
            isCa: false
          keyUsage:
            baseKeyUsage: {}
            extendedKeyUsage:
              serverAuth: true
  defaultAuthority:
    type: gcp:certificateauthority:Authority
    name: default
    properties:
      pool: ${default.name}
      certificateAuthorityId: my-basic-certificate-authority
      location: us-central1
      lifetime: 86400s
      type: SELF_SIGNED
      deletionProtection: false
      skipGracePeriod: true
      ignoreActiveCertificatesOnDeletion: true
      config:
        subjectConfig:
          subject:
            organization: Test LLC
            commonName: my-ca
        x509Config:
          caOptions:
            isCa: true
          keyUsage:
            baseKeyUsage:
              certSign: true
              crlSign: true
            extendedKeyUsage:
              serverAuth: false
      keySpec:
        algorithm: RSA_PKCS1_4096_SHA256
  tlsInspectionPermission:
    type: gcp:certificateauthority:CaPoolIamMember
    name: tls_inspection_permission
    properties:
      caPool: ${default.id}
      role: roles/privateca.certificateManager
      member: serviceAccount:service-${project.number}@gcp-sa-networksecurity.iam.gserviceaccount.com
  defaultTlsInspectionPolicy:
    type: gcp:networksecurity:TlsInspectionPolicy
    name: default
    properties:
      name: my-tls-inspection-policy
      location: us-central1
      caPool: ${default.id}
    options:
      dependsOn:
        - ${default}
        - ${defaultAuthority}
        - ${tlsInspectionPermission}
  defaultGatewaySecurityPolicy:
    type: gcp:networksecurity:GatewaySecurityPolicy
    name: default
    properties:
      name: my-gateway-security-policy
      location: us-central1
      description: my description
      tlsInspectionPolicy: ${defaultTlsInspectionPolicy.id}
    options:
      dependsOn:
        - ${defaultTlsInspectionPolicy}
variables:
  project:
    fn::invoke:
      function: gcp:organizations:getProject
      arguments: {}
```
<!--End PulumiCodeChooser -->

## Import

GatewaySecurityPolicy can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/gatewaySecurityPolicies/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

When using the `pulumi import` command, GatewaySecurityPolicy can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networksecurity/gatewaySecurityPolicy:GatewaySecurityPolicy default projects/{{project}}/locations/{{location}}/gatewaySecurityPolicies/{{name}}
```

```sh
$ pulumi import gcp:networksecurity/gatewaySecurityPolicy:GatewaySecurityPolicy default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:networksecurity/gatewaySecurityPolicy:GatewaySecurityPolicy default {{location}}/{{name}}
```

Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
^
locationB" LThe location of the gateway security policy.
The default value is `global`.
“
nameB" √Name of the resource. Name is of the form projects/{project}/locations/{location}/gatewaySecurityPolicies/{gatewaySecurityPolicy}
gatewaySecurityPolicy should match the pattern:(^a-z?$).


- - -
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
á
tlsInspectionPolicyB" ÈName of a TlsInspectionPolicy resource that defines how TLS inspection is performed for any rule that enables it.
Note: gcp.networksecurity.TlsInspectionPolicy resource is still in Beta therefore it will need to import the provider.
"Ì

createTime" ⁄The timestamp when the resource was created.
A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z"
"Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
"^
locationB" LThe location of the gateway security policy.
The default value is `global`.
"–
name" √Name of the resource. Name is of the form projects/{project}/locations/{location}/gatewaySecurityPolicies/{gatewaySecurityPolicy}
gatewaySecurityPolicy should match the pattern:(^a-z?$).


- - -
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"5
selfLink" %Server-defined URL of this resource.
"á
tlsInspectionPolicyB" ÈName of a TlsInspectionPolicy resource that defines how TLS inspection is performed for any rule that enables it.
Note: gcp.networksecurity.TlsInspectionPolicy resource is still in Beta therefore it will need to import the provider.
"Ó

updateTime" €The timestamp when the resource was updated.
A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
*Ã
u
networksecurityGatewaySecurityPolicyRuleGgcp:networksecurity/gatewaySecurityPolicyRule:GatewaySecurityPolicyRule®gThe GatewaySecurityPolicyRule resource is in a nested collection within a GatewaySecurityPolicy and represents
a traffic matching condition and associated action to perform.


To get more information about GatewaySecurityPolicyRule, see:

* [API documentation](https://cloud.google.com/secure-web-proxy/docs/reference/network-security/rest/v1/projects.locations.gatewaySecurityPolicies.rules)

## Example Usage

### Network Security Gateway Security Policy Rules Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networksecurity.GatewaySecurityPolicy("default", {
    name: "my-gateway-security-policy",
    location: "us-central1",
    description: "gateway security policy created to be used as reference by the rule.",
});
const defaultGatewaySecurityPolicyRule = new gcp.networksecurity.GatewaySecurityPolicyRule("default", {
    name: "my-gateway-security-policy-rule",
    location: "us-central1",
    gatewaySecurityPolicy: _default.name,
    enabled: true,
    description: "my description",
    priority: 0,
    sessionMatcher: "host() == 'example.com'",
    basicProfile: "ALLOW",
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networksecurity.GatewaySecurityPolicy("default",
    name="my-gateway-security-policy",
    location="us-central1",
    description="gateway security policy created to be used as reference by the rule.")
default_gateway_security_policy_rule = gcp.networksecurity.GatewaySecurityPolicyRule("default",
    name="my-gateway-security-policy-rule",
    location="us-central1",
    gateway_security_policy=default.name,
    enabled=True,
    description="my description",
    priority=0,
    session_matcher="host() == 'example.com'",
    basic_profile="ALLOW")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkSecurity.GatewaySecurityPolicy("default", new()
    {
        Name = "my-gateway-security-policy",
        Location = "us-central1",
        Description = "gateway security policy created to be used as reference by the rule.",
    });

    var defaultGatewaySecurityPolicyRule = new Gcp.NetworkSecurity.GatewaySecurityPolicyRule("default", new()
    {
        Name = "my-gateway-security-policy-rule",
        Location = "us-central1",
        GatewaySecurityPolicy = @default.Name,
        Enabled = true,
        Description = "my description",
        Priority = 0,
        SessionMatcher = "host() == 'example.com'",
        BasicProfile = "ALLOW",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networksecurity.NewGatewaySecurityPolicy(ctx, "default", &networksecurity.GatewaySecurityPolicyArgs{
			Name:        pulumi.String("my-gateway-security-policy"),
			Location:    pulumi.String("us-central1"),
			Description: pulumi.String("gateway security policy created to be used as reference by the rule."),
		})
		if err != nil {
			return err
		}
		_, err = networksecurity.NewGatewaySecurityPolicyRule(ctx, "default", &networksecurity.GatewaySecurityPolicyRuleArgs{
			Name:                  pulumi.String("my-gateway-security-policy-rule"),
			Location:              pulumi.String("us-central1"),
			GatewaySecurityPolicy: _default.Name,
			Enabled:               pulumi.Bool(true),
			Description:           pulumi.String("my description"),
			Priority:              pulumi.Int(0),
			SessionMatcher:        pulumi.String("host() == 'example.com'"),
			BasicProfile:          pulumi.String("ALLOW"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networksecurity.GatewaySecurityPolicy;
import com.pulumi.gcp.networksecurity.GatewaySecurityPolicyArgs;
import com.pulumi.gcp.networksecurity.GatewaySecurityPolicyRule;
import com.pulumi.gcp.networksecurity.GatewaySecurityPolicyRuleArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new GatewaySecurityPolicy("default", GatewaySecurityPolicyArgs.builder()
            .name("my-gateway-security-policy")
            .location("us-central1")
            .description("gateway security policy created to be used as reference by the rule.")
            .build());

        var defaultGatewaySecurityPolicyRule = new GatewaySecurityPolicyRule("defaultGatewaySecurityPolicyRule", GatewaySecurityPolicyRuleArgs.builder()
            .name("my-gateway-security-policy-rule")
            .location("us-central1")
            .gatewaySecurityPolicy(default_.name())
            .enabled(true)
            .description("my description")
            .priority(0)
            .sessionMatcher("host() == 'example.com'")
            .basicProfile("ALLOW")
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networksecurity:GatewaySecurityPolicy
    properties:
      name: my-gateway-security-policy
      location: us-central1
      description: gateway security policy created to be used as reference by the rule.
  defaultGatewaySecurityPolicyRule:
    type: gcp:networksecurity:GatewaySecurityPolicyRule
    name: default
    properties:
      name: my-gateway-security-policy-rule
      location: us-central1
      gatewaySecurityPolicy: ${default.name}
      enabled: true
      description: my description
      priority: 0
      sessionMatcher: host() == 'example.com'
      basicProfile: ALLOW
```
<!--End PulumiCodeChooser -->
### Network Security Gateway Security Policy Rules Advanced


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networksecurity.GatewaySecurityPolicy("default", {
    name: "my-gateway-security-policy",
    location: "us-central1",
    description: "gateway security policy created to be used as reference by the rule.",
});
const defaultGatewaySecurityPolicyRule = new gcp.networksecurity.GatewaySecurityPolicyRule("default", {
    name: "my-gateway-security-policy-rule",
    location: "us-central1",
    gatewaySecurityPolicy: _default.name,
    enabled: true,
    description: "my description",
    priority: 0,
    sessionMatcher: "host() == 'example.com'",
    applicationMatcher: "request.method == 'POST'",
    tlsInspectionEnabled: false,
    basicProfile: "ALLOW",
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networksecurity.GatewaySecurityPolicy("default",
    name="my-gateway-security-policy",
    location="us-central1",
    description="gateway security policy created to be used as reference by the rule.")
default_gateway_security_policy_rule = gcp.networksecurity.GatewaySecurityPolicyRule("default",
    name="my-gateway-security-policy-rule",
    location="us-central1",
    gateway_security_policy=default.name,
    enabled=True,
    description="my description",
    priority=0,
    session_matcher="host() == 'example.com'",
    application_matcher="request.method == 'POST'",
    tls_inspection_enabled=False,
    basic_profile="ALLOW")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkSecurity.GatewaySecurityPolicy("default", new()
    {
        Name = "my-gateway-security-policy",
        Location = "us-central1",
        Description = "gateway security policy created to be used as reference by the rule.",
    });

    var defaultGatewaySecurityPolicyRule = new Gcp.NetworkSecurity.GatewaySecurityPolicyRule("default", new()
    {
        Name = "my-gateway-security-policy-rule",
        Location = "us-central1",
        GatewaySecurityPolicy = @default.Name,
        Enabled = true,
        Description = "my description",
        Priority = 0,
        SessionMatcher = "host() == 'example.com'",
        ApplicationMatcher = "request.method == 'POST'",
        TlsInspectionEnabled = false,
        BasicProfile = "ALLOW",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networksecurity.NewGatewaySecurityPolicy(ctx, "default", &networksecurity.GatewaySecurityPolicyArgs{
			Name:        pulumi.String("my-gateway-security-policy"),
			Location:    pulumi.String("us-central1"),
			Description: pulumi.String("gateway security policy created to be used as reference by the rule."),
		})
		if err != nil {
			return err
		}
		_, err = networksecurity.NewGatewaySecurityPolicyRule(ctx, "default", &networksecurity.GatewaySecurityPolicyRuleArgs{
			Name:                  pulumi.String("my-gateway-security-policy-rule"),
			Location:              pulumi.String("us-central1"),
			GatewaySecurityPolicy: _default.Name,
			Enabled:               pulumi.Bool(true),
			Description:           pulumi.String("my description"),
			Priority:              pulumi.Int(0),
			SessionMatcher:        pulumi.String("host() == 'example.com'"),
			ApplicationMatcher:    pulumi.String("request.method == 'POST'"),
			TlsInspectionEnabled:  pulumi.Bool(false),
			BasicProfile:          pulumi.String("ALLOW"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networksecurity.GatewaySecurityPolicy;
import com.pulumi.gcp.networksecurity.GatewaySecurityPolicyArgs;
import com.pulumi.gcp.networksecurity.GatewaySecurityPolicyRule;
import com.pulumi.gcp.networksecurity.GatewaySecurityPolicyRuleArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new GatewaySecurityPolicy("default", GatewaySecurityPolicyArgs.builder()
            .name("my-gateway-security-policy")
            .location("us-central1")
            .description("gateway security policy created to be used as reference by the rule.")
            .build());

        var defaultGatewaySecurityPolicyRule = new GatewaySecurityPolicyRule("defaultGatewaySecurityPolicyRule", GatewaySecurityPolicyRuleArgs.builder()
            .name("my-gateway-security-policy-rule")
            .location("us-central1")
            .gatewaySecurityPolicy(default_.name())
            .enabled(true)
            .description("my description")
            .priority(0)
            .sessionMatcher("host() == 'example.com'")
            .applicationMatcher("request.method == 'POST'")
            .tlsInspectionEnabled(false)
            .basicProfile("ALLOW")
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networksecurity:GatewaySecurityPolicy
    properties:
      name: my-gateway-security-policy
      location: us-central1
      description: gateway security policy created to be used as reference by the rule.
  defaultGatewaySecurityPolicyRule:
    type: gcp:networksecurity:GatewaySecurityPolicyRule
    name: default
    properties:
      name: my-gateway-security-policy-rule
      location: us-central1
      gatewaySecurityPolicy: ${default.name}
      enabled: true
      description: my description
      priority: 0
      sessionMatcher: host() == 'example.com'
      applicationMatcher: request.method == 'POST'
      tlsInspectionEnabled: false
      basicProfile: ALLOW
```
<!--End PulumiCodeChooser -->

## Import

GatewaySecurityPolicyRule can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/gatewaySecurityPolicies/{{gateway_security_policy}}/rules/{{name}}`

* `{{project}}/{{location}}/{{gateway_security_policy}}/{{name}}`

* `{{location}}/{{gateway_security_policy}}/{{name}}`

When using the `pulumi import` command, GatewaySecurityPolicyRule can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networksecurity/gatewaySecurityPolicyRule:GatewaySecurityPolicyRule default projects/{{project}}/locations/{{location}}/gatewaySecurityPolicies/{{gateway_security_policy}}/rules/{{name}}
```

```sh
$ pulumi import gcp:networksecurity/gatewaySecurityPolicyRule:GatewaySecurityPolicyRule default {{project}}/{{location}}/{{gateway_security_policy}}/{{name}}
```

```sh
$ pulumi import gcp:networksecurity/gatewaySecurityPolicyRule:GatewaySecurityPolicyRule default {{location}}/{{gateway_security_policy}}/{{name}}
```

Z
applicationMatcherB" >CEL expression for matching on L7/application level criteria.
∂
basicProfile" °Profile which tells what the primitive action should be. Possible values are: * ALLOW * DENY.
Possible values are: `BASIC_PROFILE_UNSPECIFIED`, `ALLOW`, `DENY`.
<
descriptionB" 'Free-text description of the resource.
-
enabled
 Whether the rule is enforced.
c
gatewaySecurityPolicy" FThe name of the gatewat security policy this rule belongs to.


- - -
=
location" -The location of the gateway security policy.
÷
nameB" «Name of the resource. ame is the full resource name so projects/{project}/locations/{location}/gatewaySecurityPolicies/{gateway_security_policy}/rules/{rule}
rule should match the pattern: (^a-z?$).
U
priority EPriority of the rule. Lower number corresponds to higher precedence.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
G
sessionMatcher" 1CEL expression for matching on session criteria.
¨
tlsInspectionEnabledB
 çFlag to enable TLS inspection of traffic matching on. Can only be true if the
parent GatewaySecurityPolicy references a TLSInspectionConfig.
"Z
applicationMatcherB" >CEL expression for matching on L7/application level criteria.
"∂
basicProfile" °Profile which tells what the primitive action should be. Possible values are: * ALLOW * DENY.
Possible values are: `BASIC_PROFILE_UNSPECIFIED`, `ALLOW`, `DENY`.
"Ì

createTime" ⁄The timestamp when the resource was created.
A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z"
"<
descriptionB" 'Free-text description of the resource.
"-
enabled
 Whether the rule is enforced.
"c
gatewaySecurityPolicy" FThe name of the gatewat security policy this rule belongs to.


- - -
"=
location" -The location of the gateway security policy.
"‘
name" «Name of the resource. ame is the full resource name so projects/{project}/locations/{location}/gatewaySecurityPolicies/{gateway_security_policy}/rules/{rule}
rule should match the pattern: (^a-z?$).
"U
priority EPriority of the rule. Lower number corresponds to higher precedence.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"5
selfLink" %Server-defined URL of this resource.
"G
sessionMatcher" 1CEL expression for matching on session criteria.
"¨
tlsInspectionEnabledB
 çFlag to enable TLS inspection of traffic matching on. Can only be true if the
parent GatewaySecurityPolicy references a TLSInspectionConfig.
"Ó

updateTime" €The timestamp when the resource was updated.
A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
*⁄Ö
c
networksecurityInterceptDeployment;gcp:networksecurity/interceptDeployment:InterceptDeployment§l## Example Usage

### Network Security Intercept Deployment Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const network = new gcp.compute.Network("network", {
    name: "example-network",
    autoCreateSubnetworks: false,
});
const subnetwork = new gcp.compute.Subnetwork("subnetwork", {
    name: "example-subnet",
    region: "us-central1",
    ipCidrRange: "10.1.0.0/16",
    network: network.name,
});
const healthCheck = new gcp.compute.RegionHealthCheck("health_check", {
    name: "example-hc",
    region: "us-central1",
    httpHealthCheck: {
        port: 80,
    },
});
const backendService = new gcp.compute.RegionBackendService("backend_service", {
    name: "example-bs",
    region: "us-central1",
    healthChecks: healthCheck.id,
    protocol: "UDP",
    loadBalancingScheme: "INTERNAL",
});
const forwardingRule = new gcp.compute.ForwardingRule("forwarding_rule", {
    name: "example-fwr",
    region: "us-central1",
    network: network.name,
    subnetwork: subnetwork.name,
    backendService: backendService.id,
    loadBalancingScheme: "INTERNAL",
    ports: ["6081"],
    ipProtocol: "UDP",
});
const deploymentGroup = new gcp.networksecurity.InterceptDeploymentGroup("deployment_group", {
    interceptDeploymentGroupId: "example-dg",
    location: "global",
    network: network.id,
});
const _default = new gcp.networksecurity.InterceptDeployment("default", {
    interceptDeploymentId: "example-deployment",
    location: "us-central1-a",
    forwardingRule: forwardingRule.id,
    interceptDeploymentGroup: deploymentGroup.id,
    labels: {
        foo: "bar",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

network = gcp.compute.Network("network",
    name="example-network",
    auto_create_subnetworks=False)
subnetwork = gcp.compute.Subnetwork("subnetwork",
    name="example-subnet",
    region="us-central1",
    ip_cidr_range="10.1.0.0/16",
    network=network.name)
health_check = gcp.compute.RegionHealthCheck("health_check",
    name="example-hc",
    region="us-central1",
    http_health_check={
        "port": 80,
    })
backend_service = gcp.compute.RegionBackendService("backend_service",
    name="example-bs",
    region="us-central1",
    health_checks=health_check.id,
    protocol="UDP",
    load_balancing_scheme="INTERNAL")
forwarding_rule = gcp.compute.ForwardingRule("forwarding_rule",
    name="example-fwr",
    region="us-central1",
    network=network.name,
    subnetwork=subnetwork.name,
    backend_service=backend_service.id,
    load_balancing_scheme="INTERNAL",
    ports=["6081"],
    ip_protocol="UDP")
deployment_group = gcp.networksecurity.InterceptDeploymentGroup("deployment_group",
    intercept_deployment_group_id="example-dg",
    location="global",
    network=network.id)
default = gcp.networksecurity.InterceptDeployment("default",
    intercept_deployment_id="example-deployment",
    location="us-central1-a",
    forwarding_rule=forwarding_rule.id,
    intercept_deployment_group=deployment_group.id,
    labels={
        "foo": "bar",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var network = new Gcp.Compute.Network("network", new()
    {
        Name = "example-network",
        AutoCreateSubnetworks = false,
    });

    var subnetwork = new Gcp.Compute.Subnetwork("subnetwork", new()
    {
        Name = "example-subnet",
        Region = "us-central1",
        IpCidrRange = "10.1.0.0/16",
        Network = network.Name,
    });

    var healthCheck = new Gcp.Compute.RegionHealthCheck("health_check", new()
    {
        Name = "example-hc",
        Region = "us-central1",
        HttpHealthCheck = new Gcp.Compute.Inputs.RegionHealthCheckHttpHealthCheckArgs
        {
            Port = 80,
        },
    });

    var backendService = new Gcp.Compute.RegionBackendService("backend_service", new()
    {
        Name = "example-bs",
        Region = "us-central1",
        HealthChecks = healthCheck.Id,
        Protocol = "UDP",
        LoadBalancingScheme = "INTERNAL",
    });

    var forwardingRule = new Gcp.Compute.ForwardingRule("forwarding_rule", new()
    {
        Name = "example-fwr",
        Region = "us-central1",
        Network = network.Name,
        Subnetwork = subnetwork.Name,
        BackendService = backendService.Id,
        LoadBalancingScheme = "INTERNAL",
        Ports = new[]
        {
            "6081",
        },
        IpProtocol = "UDP",
    });

    var deploymentGroup = new Gcp.NetworkSecurity.InterceptDeploymentGroup("deployment_group", new()
    {
        InterceptDeploymentGroupId = "example-dg",
        Location = "global",
        Network = network.Id,
    });

    var @default = new Gcp.NetworkSecurity.InterceptDeployment("default", new()
    {
        InterceptDeploymentId = "example-deployment",
        Location = "us-central1-a",
        ForwardingRule = forwardingRule.Id,
        InterceptDeploymentGroup = deploymentGroup.Id,
        Labels = 
        {
            { "foo", "bar" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
			Name:                  pulumi.String("example-network"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		subnetwork, err := compute.NewSubnetwork(ctx, "subnetwork", &compute.SubnetworkArgs{
			Name:        pulumi.String("example-subnet"),
			Region:      pulumi.String("us-central1"),
			IpCidrRange: pulumi.String("10.1.0.0/16"),
			Network:     network.Name,
		})
		if err != nil {
			return err
		}
		healthCheck, err := compute.NewRegionHealthCheck(ctx, "health_check", &compute.RegionHealthCheckArgs{
			Name:   pulumi.String("example-hc"),
			Region: pulumi.String("us-central1"),
			HttpHealthCheck: &compute.RegionHealthCheckHttpHealthCheckArgs{
				Port: pulumi.Int(80),
			},
		})
		if err != nil {
			return err
		}
		backendService, err := compute.NewRegionBackendService(ctx, "backend_service", &compute.RegionBackendServiceArgs{
			Name:                pulumi.String("example-bs"),
			Region:              pulumi.String("us-central1"),
			HealthChecks:        healthCheck.ID(),
			Protocol:            pulumi.String("UDP"),
			LoadBalancingScheme: pulumi.String("INTERNAL"),
		})
		if err != nil {
			return err
		}
		forwardingRule, err := compute.NewForwardingRule(ctx, "forwarding_rule", &compute.ForwardingRuleArgs{
			Name:                pulumi.String("example-fwr"),
			Region:              pulumi.String("us-central1"),
			Network:             network.Name,
			Subnetwork:          subnetwork.Name,
			BackendService:      backendService.ID(),
			LoadBalancingScheme: pulumi.String("INTERNAL"),
			Ports: pulumi.StringArray{
				pulumi.String("6081"),
			},
			IpProtocol: pulumi.String("UDP"),
		})
		if err != nil {
			return err
		}
		deploymentGroup, err := networksecurity.NewInterceptDeploymentGroup(ctx, "deployment_group", &networksecurity.InterceptDeploymentGroupArgs{
			InterceptDeploymentGroupId: pulumi.String("example-dg"),
			Location:                   pulumi.String("global"),
			Network:                    network.ID(),
		})
		if err != nil {
			return err
		}
		_, err = networksecurity.NewInterceptDeployment(ctx, "default", &networksecurity.InterceptDeploymentArgs{
			InterceptDeploymentId:    pulumi.String("example-deployment"),
			Location:                 pulumi.String("us-central1-a"),
			ForwardingRule:           forwardingRule.ID(),
			InterceptDeploymentGroup: deploymentGroup.ID(),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.Subnetwork;
import com.pulumi.gcp.compute.SubnetworkArgs;
import com.pulumi.gcp.compute.RegionHealthCheck;
import com.pulumi.gcp.compute.RegionHealthCheckArgs;
import com.pulumi.gcp.compute.inputs.RegionHealthCheckHttpHealthCheckArgs;
import com.pulumi.gcp.compute.RegionBackendService;
import com.pulumi.gcp.compute.RegionBackendServiceArgs;
import com.pulumi.gcp.compute.ForwardingRule;
import com.pulumi.gcp.compute.ForwardingRuleArgs;
import com.pulumi.gcp.networksecurity.InterceptDeploymentGroup;
import com.pulumi.gcp.networksecurity.InterceptDeploymentGroupArgs;
import com.pulumi.gcp.networksecurity.InterceptDeployment;
import com.pulumi.gcp.networksecurity.InterceptDeploymentArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var network = new Network("network", NetworkArgs.builder()
            .name("example-network")
            .autoCreateSubnetworks(false)
            .build());

        var subnetwork = new Subnetwork("subnetwork", SubnetworkArgs.builder()
            .name("example-subnet")
            .region("us-central1")
            .ipCidrRange("10.1.0.0/16")
            .network(network.name())
            .build());

        var healthCheck = new RegionHealthCheck("healthCheck", RegionHealthCheckArgs.builder()
            .name("example-hc")
            .region("us-central1")
            .httpHealthCheck(RegionHealthCheckHttpHealthCheckArgs.builder()
                .port(80)
                .build())
            .build());

        var backendService = new RegionBackendService("backendService", RegionBackendServiceArgs.builder()
            .name("example-bs")
            .region("us-central1")
            .healthChecks(healthCheck.id())
            .protocol("UDP")
            .loadBalancingScheme("INTERNAL")
            .build());

        var forwardingRule = new ForwardingRule("forwardingRule", ForwardingRuleArgs.builder()
            .name("example-fwr")
            .region("us-central1")
            .network(network.name())
            .subnetwork(subnetwork.name())
            .backendService(backendService.id())
            .loadBalancingScheme("INTERNAL")
            .ports(6081)
            .ipProtocol("UDP")
            .build());

        var deploymentGroup = new InterceptDeploymentGroup("deploymentGroup", InterceptDeploymentGroupArgs.builder()
            .interceptDeploymentGroupId("example-dg")
            .location("global")
            .network(network.id())
            .build());

        var default_ = new InterceptDeployment("default", InterceptDeploymentArgs.builder()
            .interceptDeploymentId("example-deployment")
            .location("us-central1-a")
            .forwardingRule(forwardingRule.id())
            .interceptDeploymentGroup(deploymentGroup.id())
            .labels(Map.of("foo", "bar"))
            .build());

    }
}
```
```yaml
resources:
  network:
    type: gcp:compute:Network
    properties:
      name: example-network
      autoCreateSubnetworks: false
  subnetwork:
    type: gcp:compute:Subnetwork
    properties:
      name: example-subnet
      region: us-central1
      ipCidrRange: 10.1.0.0/16
      network: ${network.name}
  healthCheck:
    type: gcp:compute:RegionHealthCheck
    name: health_check
    properties:
      name: example-hc
      region: us-central1
      httpHealthCheck:
        port: 80
  backendService:
    type: gcp:compute:RegionBackendService
    name: backend_service
    properties:
      name: example-bs
      region: us-central1
      healthChecks: ${healthCheck.id}
      protocol: UDP
      loadBalancingScheme: INTERNAL
  forwardingRule:
    type: gcp:compute:ForwardingRule
    name: forwarding_rule
    properties:
      name: example-fwr
      region: us-central1
      network: ${network.name}
      subnetwork: ${subnetwork.name}
      backendService: ${backendService.id}
      loadBalancingScheme: INTERNAL
      ports:
        - 6081
      ipProtocol: UDP
  deploymentGroup:
    type: gcp:networksecurity:InterceptDeploymentGroup
    name: deployment_group
    properties:
      interceptDeploymentGroupId: example-dg
      location: global
      network: ${network.id}
  default:
    type: gcp:networksecurity:InterceptDeployment
    properties:
      interceptDeploymentId: example-deployment
      location: us-central1-a
      forwardingRule: ${forwardingRule.id}
      interceptDeploymentGroup: ${deploymentGroup.id}
      labels:
        foo: bar
```
<!--End PulumiCodeChooser -->

## Import

InterceptDeployment can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/interceptDeployments/{{intercept_deployment_id}}`

* `{{project}}/{{location}}/{{intercept_deployment_id}}`

* `{{location}}/{{intercept_deployment_id}}`

When using the `pulumi import` command, InterceptDeployment can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networksecurity/interceptDeployment:InterceptDeployment default projects/{{project}}/locations/{{location}}/interceptDeployments/{{intercept_deployment_id}}
```

```sh
$ pulumi import gcp:networksecurity/interceptDeployment:InterceptDeployment default {{project}}/{{location}}/{{intercept_deployment_id}}
```

```sh
$ pulumi import gcp:networksecurity/interceptDeployment:InterceptDeployment default {{location}}/{{intercept_deployment_id}}
```

√
forwardingRule" ¨Immutable. The regional load balancer which the intercepted traffic should be forwarded
to. Format is:
projects/{project}/regions/{region}/forwardingRules/{forwardingRule}
–
interceptDeploymentGroup" ØImmutable. The Intercept Deployment Group that this resource is part of. Format is:
`projects/{project}/locations/global/interceptDeploymentGroups/{interceptDeploymentGroup}`
ª
interceptDeploymentId" ùId of the requesting object
If auto-generating Id server-side, remove this field and
intercept_deployment_id from the method_signature of Create RPC


- - -
˝
labelsB2" ÍOptional. Labels as key value pairs
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
˛
location" ÌResource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122. See documentation for resource type `networksecurity.googleapis.com/InterceptDeployment`.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"$

createTime" Create time stamp
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"√
forwardingRule" ¨Immutable. The regional load balancer which the intercepted traffic should be forwarded
to. Format is:
projects/{project}/regions/{region}/forwardingRules/{forwardingRule}
"–
interceptDeploymentGroup" ØImmutable. The Intercept Deployment Group that this resource is part of. Format is:
`projects/{project}/locations/global/interceptDeploymentGroups/{interceptDeploymentGroup}`
"ª
interceptDeploymentId" ùId of the requesting object
If auto-generating Id server-side, remove this field and
intercept_deployment_id from the method_signature of Create RPC


- - -
"˝
labelsB2" ÍOptional. Labels as key value pairs
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"˛
location" ÌResource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122. See documentation for resource type `networksecurity.googleapis.com/InterceptDeployment`.
"=
name" 1Identifier. The name of the InterceptDeployment.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"c
reconciling
 PWhether reconciling is in progress, recommended per
https://google.aip.dev/128.
"Ñ
state" wCurrent state of the deployment.
Possible values:
STATE_UNSPECIFIED
ACTIVE
CREATING
DELETING
OUT_OF_SYNC
DELETE_FAILED
"$

updateTime" Update time stamp
*ﬂ>
r
networksecurityInterceptDeploymentGroupEgcp:networksecurity/interceptDeploymentGroup:InterceptDeploymentGroup’%## Example Usage

### Network Security Intercept Deployment Group Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const network = new gcp.compute.Network("network", {
    name: "example-network",
    autoCreateSubnetworks: false,
});
const _default = new gcp.networksecurity.InterceptDeploymentGroup("default", {
    interceptDeploymentGroupId: "example-dg",
    location: "global",
    network: network.id,
    labels: {
        foo: "bar",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

network = gcp.compute.Network("network",
    name="example-network",
    auto_create_subnetworks=False)
default = gcp.networksecurity.InterceptDeploymentGroup("default",
    intercept_deployment_group_id="example-dg",
    location="global",
    network=network.id,
    labels={
        "foo": "bar",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var network = new Gcp.Compute.Network("network", new()
    {
        Name = "example-network",
        AutoCreateSubnetworks = false,
    });

    var @default = new Gcp.NetworkSecurity.InterceptDeploymentGroup("default", new()
    {
        InterceptDeploymentGroupId = "example-dg",
        Location = "global",
        Network = network.Id,
        Labels = 
        {
            { "foo", "bar" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
			Name:                  pulumi.String("example-network"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		_, err = networksecurity.NewInterceptDeploymentGroup(ctx, "default", &networksecurity.InterceptDeploymentGroupArgs{
			InterceptDeploymentGroupId: pulumi.String("example-dg"),
			Location:                   pulumi.String("global"),
			Network:                    network.ID(),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.networksecurity.InterceptDeploymentGroup;
import com.pulumi.gcp.networksecurity.InterceptDeploymentGroupArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var network = new Network("network", NetworkArgs.builder()
            .name("example-network")
            .autoCreateSubnetworks(false)
            .build());

        var default_ = new InterceptDeploymentGroup("default", InterceptDeploymentGroupArgs.builder()
            .interceptDeploymentGroupId("example-dg")
            .location("global")
            .network(network.id())
            .labels(Map.of("foo", "bar"))
            .build());

    }
}
```
```yaml
resources:
  network:
    type: gcp:compute:Network
    properties:
      name: example-network
      autoCreateSubnetworks: false
  default:
    type: gcp:networksecurity:InterceptDeploymentGroup
    properties:
      interceptDeploymentGroupId: example-dg
      location: global
      network: ${network.id}
      labels:
        foo: bar
```
<!--End PulumiCodeChooser -->

## Import

InterceptDeploymentGroup can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/interceptDeploymentGroups/{{intercept_deployment_group_id}}`

* `{{project}}/{{location}}/{{intercept_deployment_group_id}}`

* `{{location}}/{{intercept_deployment_group_id}}`

When using the `pulumi import` command, InterceptDeploymentGroup can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networksecurity/interceptDeploymentGroup:InterceptDeploymentGroup default projects/{{project}}/locations/{{location}}/interceptDeploymentGroups/{{intercept_deployment_group_id}}
```

```sh
$ pulumi import gcp:networksecurity/interceptDeploymentGroup:InterceptDeploymentGroup default {{project}}/{{location}}/{{intercept_deployment_group_id}}
```

```sh
$ pulumi import gcp:networksecurity/interceptDeploymentGroup:InterceptDeploymentGroup default {{location}}/{{intercept_deployment_group_id}}
```

–
interceptDeploymentGroupId" ≠Required. Id of the requesting object
If auto-generating Id server-side, remove this field and
intercept_deployment_group_id from the method_signature of Create RPC


- - -
˝
labelsB2" ÍOptional. Labels as key value pairs
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
É
location" ÚResource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122. See documentation for resource type `networksecurity.googleapis.com/InterceptDeploymentGroup`.
ë
network" ÅRequired. Immutable. The network that is being used for the deployment. Format is:
projects/{project}/global/networks/{network}.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"“
connectedEndpointGroupsΩ*∫:∑
¥
networksecurity.InterceptDeploymentGroupConnectedEndpointGroupqgcp:networksecurity/InterceptDeploymentGroupConnectedEndpointGroup:InterceptDeploymentGroupConnectedEndpointGroupwOutput only. The list of Intercept Endpoint Groups that are connected to this resource.
Structure is documented below.
"?

createTime" -Output only. [Output only] Create time stamp
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"–
interceptDeploymentGroupId" ≠Required. Id of the requesting object
If auto-generating Id server-side, remove this field and
intercept_deployment_group_id from the method_signature of Create RPC


- - -
"˝
labelsB2" ÍOptional. Labels as key value pairs
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"É
location" ÚResource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122. See documentation for resource type `networksecurity.googleapis.com/InterceptDeploymentGroup`.
"H
name" <(Output)
Output only. A connected intercept endpoint group.
"ë
network" ÅRequired. Immutable. The network that is being used for the deployment. Format is:
projects/{project}/global/networks/{network}.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"p
reconciling
 ]Output only. Whether reconciling is in progress, recommended per
https://google.aip.dev/128.
"}
state" pOutput only. Current state of the deployment group.
Possible values:
STATE_UNSPECIFIED
ACTIVE
CREATING
DELETING
"?

updateTime" -Output only. [Output only] Update time stamp
*—à
c
networksecurityMirroringDeployment;gcp:networksecurity/mirroringDeployment:MirroringDeploymentân## Example Usage

### Network Security Mirroring Deployment Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const network = new gcp.compute.Network("network", {
    name: "example-network",
    autoCreateSubnetworks: false,
});
const subnetwork = new gcp.compute.Subnetwork("subnetwork", {
    name: "example-subnet",
    region: "us-central1",
    ipCidrRange: "10.1.0.0/16",
    network: network.name,
});
const healthCheck = new gcp.compute.RegionHealthCheck("health_check", {
    name: "example-hc",
    region: "us-central1",
    httpHealthCheck: {
        port: 80,
    },
});
const backendService = new gcp.compute.RegionBackendService("backend_service", {
    name: "example-bs",
    region: "us-central1",
    healthChecks: healthCheck.id,
    protocol: "UDP",
    loadBalancingScheme: "INTERNAL",
});
const forwardingRule = new gcp.compute.ForwardingRule("forwarding_rule", {
    name: "example-fwr",
    region: "us-central1",
    network: network.name,
    subnetwork: subnetwork.name,
    backendService: backendService.id,
    loadBalancingScheme: "INTERNAL",
    ports: ["6081"],
    ipProtocol: "UDP",
    isMirroringCollector: true,
});
const deploymentGroup = new gcp.networksecurity.MirroringDeploymentGroup("deployment_group", {
    mirroringDeploymentGroupId: "example-dg",
    location: "global",
    network: network.id,
});
const _default = new gcp.networksecurity.MirroringDeployment("default", {
    mirroringDeploymentId: "example-deployment",
    location: "us-central1-a",
    forwardingRule: forwardingRule.id,
    mirroringDeploymentGroup: deploymentGroup.id,
    labels: {
        foo: "bar",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

network = gcp.compute.Network("network",
    name="example-network",
    auto_create_subnetworks=False)
subnetwork = gcp.compute.Subnetwork("subnetwork",
    name="example-subnet",
    region="us-central1",
    ip_cidr_range="10.1.0.0/16",
    network=network.name)
health_check = gcp.compute.RegionHealthCheck("health_check",
    name="example-hc",
    region="us-central1",
    http_health_check={
        "port": 80,
    })
backend_service = gcp.compute.RegionBackendService("backend_service",
    name="example-bs",
    region="us-central1",
    health_checks=health_check.id,
    protocol="UDP",
    load_balancing_scheme="INTERNAL")
forwarding_rule = gcp.compute.ForwardingRule("forwarding_rule",
    name="example-fwr",
    region="us-central1",
    network=network.name,
    subnetwork=subnetwork.name,
    backend_service=backend_service.id,
    load_balancing_scheme="INTERNAL",
    ports=["6081"],
    ip_protocol="UDP",
    is_mirroring_collector=True)
deployment_group = gcp.networksecurity.MirroringDeploymentGroup("deployment_group",
    mirroring_deployment_group_id="example-dg",
    location="global",
    network=network.id)
default = gcp.networksecurity.MirroringDeployment("default",
    mirroring_deployment_id="example-deployment",
    location="us-central1-a",
    forwarding_rule=forwarding_rule.id,
    mirroring_deployment_group=deployment_group.id,
    labels={
        "foo": "bar",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var network = new Gcp.Compute.Network("network", new()
    {
        Name = "example-network",
        AutoCreateSubnetworks = false,
    });

    var subnetwork = new Gcp.Compute.Subnetwork("subnetwork", new()
    {
        Name = "example-subnet",
        Region = "us-central1",
        IpCidrRange = "10.1.0.0/16",
        Network = network.Name,
    });

    var healthCheck = new Gcp.Compute.RegionHealthCheck("health_check", new()
    {
        Name = "example-hc",
        Region = "us-central1",
        HttpHealthCheck = new Gcp.Compute.Inputs.RegionHealthCheckHttpHealthCheckArgs
        {
            Port = 80,
        },
    });

    var backendService = new Gcp.Compute.RegionBackendService("backend_service", new()
    {
        Name = "example-bs",
        Region = "us-central1",
        HealthChecks = healthCheck.Id,
        Protocol = "UDP",
        LoadBalancingScheme = "INTERNAL",
    });

    var forwardingRule = new Gcp.Compute.ForwardingRule("forwarding_rule", new()
    {
        Name = "example-fwr",
        Region = "us-central1",
        Network = network.Name,
        Subnetwork = subnetwork.Name,
        BackendService = backendService.Id,
        LoadBalancingScheme = "INTERNAL",
        Ports = new[]
        {
            "6081",
        },
        IpProtocol = "UDP",
        IsMirroringCollector = true,
    });

    var deploymentGroup = new Gcp.NetworkSecurity.MirroringDeploymentGroup("deployment_group", new()
    {
        MirroringDeploymentGroupId = "example-dg",
        Location = "global",
        Network = network.Id,
    });

    var @default = new Gcp.NetworkSecurity.MirroringDeployment("default", new()
    {
        MirroringDeploymentId = "example-deployment",
        Location = "us-central1-a",
        ForwardingRule = forwardingRule.Id,
        MirroringDeploymentGroup = deploymentGroup.Id,
        Labels = 
        {
            { "foo", "bar" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
			Name:                  pulumi.String("example-network"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		subnetwork, err := compute.NewSubnetwork(ctx, "subnetwork", &compute.SubnetworkArgs{
			Name:        pulumi.String("example-subnet"),
			Region:      pulumi.String("us-central1"),
			IpCidrRange: pulumi.String("10.1.0.0/16"),
			Network:     network.Name,
		})
		if err != nil {
			return err
		}
		healthCheck, err := compute.NewRegionHealthCheck(ctx, "health_check", &compute.RegionHealthCheckArgs{
			Name:   pulumi.String("example-hc"),
			Region: pulumi.String("us-central1"),
			HttpHealthCheck: &compute.RegionHealthCheckHttpHealthCheckArgs{
				Port: pulumi.Int(80),
			},
		})
		if err != nil {
			return err
		}
		backendService, err := compute.NewRegionBackendService(ctx, "backend_service", &compute.RegionBackendServiceArgs{
			Name:                pulumi.String("example-bs"),
			Region:              pulumi.String("us-central1"),
			HealthChecks:        healthCheck.ID(),
			Protocol:            pulumi.String("UDP"),
			LoadBalancingScheme: pulumi.String("INTERNAL"),
		})
		if err != nil {
			return err
		}
		forwardingRule, err := compute.NewForwardingRule(ctx, "forwarding_rule", &compute.ForwardingRuleArgs{
			Name:                pulumi.String("example-fwr"),
			Region:              pulumi.String("us-central1"),
			Network:             network.Name,
			Subnetwork:          subnetwork.Name,
			BackendService:      backendService.ID(),
			LoadBalancingScheme: pulumi.String("INTERNAL"),
			Ports: pulumi.StringArray{
				pulumi.String("6081"),
			},
			IpProtocol:           pulumi.String("UDP"),
			IsMirroringCollector: pulumi.Bool(true),
		})
		if err != nil {
			return err
		}
		deploymentGroup, err := networksecurity.NewMirroringDeploymentGroup(ctx, "deployment_group", &networksecurity.MirroringDeploymentGroupArgs{
			MirroringDeploymentGroupId: pulumi.String("example-dg"),
			Location:                   pulumi.String("global"),
			Network:                    network.ID(),
		})
		if err != nil {
			return err
		}
		_, err = networksecurity.NewMirroringDeployment(ctx, "default", &networksecurity.MirroringDeploymentArgs{
			MirroringDeploymentId:    pulumi.String("example-deployment"),
			Location:                 pulumi.String("us-central1-a"),
			ForwardingRule:           forwardingRule.ID(),
			MirroringDeploymentGroup: deploymentGroup.ID(),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.Subnetwork;
import com.pulumi.gcp.compute.SubnetworkArgs;
import com.pulumi.gcp.compute.RegionHealthCheck;
import com.pulumi.gcp.compute.RegionHealthCheckArgs;
import com.pulumi.gcp.compute.inputs.RegionHealthCheckHttpHealthCheckArgs;
import com.pulumi.gcp.compute.RegionBackendService;
import com.pulumi.gcp.compute.RegionBackendServiceArgs;
import com.pulumi.gcp.compute.ForwardingRule;
import com.pulumi.gcp.compute.ForwardingRuleArgs;
import com.pulumi.gcp.networksecurity.MirroringDeploymentGroup;
import com.pulumi.gcp.networksecurity.MirroringDeploymentGroupArgs;
import com.pulumi.gcp.networksecurity.MirroringDeployment;
import com.pulumi.gcp.networksecurity.MirroringDeploymentArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var network = new Network("network", NetworkArgs.builder()
            .name("example-network")
            .autoCreateSubnetworks(false)
            .build());

        var subnetwork = new Subnetwork("subnetwork", SubnetworkArgs.builder()
            .name("example-subnet")
            .region("us-central1")
            .ipCidrRange("10.1.0.0/16")
            .network(network.name())
            .build());

        var healthCheck = new RegionHealthCheck("healthCheck", RegionHealthCheckArgs.builder()
            .name("example-hc")
            .region("us-central1")
            .httpHealthCheck(RegionHealthCheckHttpHealthCheckArgs.builder()
                .port(80)
                .build())
            .build());

        var backendService = new RegionBackendService("backendService", RegionBackendServiceArgs.builder()
            .name("example-bs")
            .region("us-central1")
            .healthChecks(healthCheck.id())
            .protocol("UDP")
            .loadBalancingScheme("INTERNAL")
            .build());

        var forwardingRule = new ForwardingRule("forwardingRule", ForwardingRuleArgs.builder()
            .name("example-fwr")
            .region("us-central1")
            .network(network.name())
            .subnetwork(subnetwork.name())
            .backendService(backendService.id())
            .loadBalancingScheme("INTERNAL")
            .ports(6081)
            .ipProtocol("UDP")
            .isMirroringCollector(true)
            .build());

        var deploymentGroup = new MirroringDeploymentGroup("deploymentGroup", MirroringDeploymentGroupArgs.builder()
            .mirroringDeploymentGroupId("example-dg")
            .location("global")
            .network(network.id())
            .build());

        var default_ = new MirroringDeployment("default", MirroringDeploymentArgs.builder()
            .mirroringDeploymentId("example-deployment")
            .location("us-central1-a")
            .forwardingRule(forwardingRule.id())
            .mirroringDeploymentGroup(deploymentGroup.id())
            .labels(Map.of("foo", "bar"))
            .build());

    }
}
```
```yaml
resources:
  network:
    type: gcp:compute:Network
    properties:
      name: example-network
      autoCreateSubnetworks: false
  subnetwork:
    type: gcp:compute:Subnetwork
    properties:
      name: example-subnet
      region: us-central1
      ipCidrRange: 10.1.0.0/16
      network: ${network.name}
  healthCheck:
    type: gcp:compute:RegionHealthCheck
    name: health_check
    properties:
      name: example-hc
      region: us-central1
      httpHealthCheck:
        port: 80
  backendService:
    type: gcp:compute:RegionBackendService
    name: backend_service
    properties:
      name: example-bs
      region: us-central1
      healthChecks: ${healthCheck.id}
      protocol: UDP
      loadBalancingScheme: INTERNAL
  forwardingRule:
    type: gcp:compute:ForwardingRule
    name: forwarding_rule
    properties:
      name: example-fwr
      region: us-central1
      network: ${network.name}
      subnetwork: ${subnetwork.name}
      backendService: ${backendService.id}
      loadBalancingScheme: INTERNAL
      ports:
        - 6081
      ipProtocol: UDP
      isMirroringCollector: true
  deploymentGroup:
    type: gcp:networksecurity:MirroringDeploymentGroup
    name: deployment_group
    properties:
      mirroringDeploymentGroupId: example-dg
      location: global
      network: ${network.id}
  default:
    type: gcp:networksecurity:MirroringDeployment
    properties:
      mirroringDeploymentId: example-deployment
      location: us-central1-a
      forwardingRule: ${forwardingRule.id}
      mirroringDeploymentGroup: ${deploymentGroup.id}
      labels:
        foo: bar
```
<!--End PulumiCodeChooser -->

## Import

MirroringDeployment can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/mirroringDeployments/{{mirroring_deployment_id}}`

* `{{project}}/{{location}}/{{mirroring_deployment_id}}`

* `{{location}}/{{mirroring_deployment_id}}`

When using the `pulumi import` command, MirroringDeployment can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networksecurity/mirroringDeployment:MirroringDeployment default projects/{{project}}/locations/{{location}}/mirroringDeployments/{{mirroring_deployment_id}}
```

```sh
$ pulumi import gcp:networksecurity/mirroringDeployment:MirroringDeployment default {{project}}/{{location}}/{{mirroring_deployment_id}}
```

```sh
$ pulumi import gcp:networksecurity/mirroringDeployment:MirroringDeployment default {{location}}/{{mirroring_deployment_id}}
```

 
forwardingRule" ≥Required. Immutable. The regional load balancer which the mirrored traffic should be forwarded
to. Format is:
projects/{project}/regions/{region}/forwardingRules/{forwardingRule}
˝
labelsB2" ÍOptional. Labels as key value pairs
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
˛
location" ÌResource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122. See documentation for resource type `networksecurity.googleapis.com/MirroringDeployment`.
⁄
mirroringDeploymentGroup" πRequired. Immutable. The Mirroring Deployment Group that this resource is part of. Format is:
`projects/{project}/locations/global/mirroringDeploymentGroups/{mirroringDeploymentGroup}`
≈
mirroringDeploymentId" ßRequired. Id of the requesting object
If auto-generating Id server-side, remove this field and
mirroring_deployment_id from the method_signature of Create RPC


- - -
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"?

createTime" -Output only. [Output only] Create time stamp
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
" 
forwardingRule" ≥Required. Immutable. The regional load balancer which the mirrored traffic should be forwarded
to. Format is:
projects/{project}/regions/{region}/forwardingRules/{forwardingRule}
"˝
labelsB2" ÍOptional. Labels as key value pairs
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"˛
location" ÌResource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122. See documentation for resource type `networksecurity.googleapis.com/MirroringDeployment`.
"⁄
mirroringDeploymentGroup" πRequired. Immutable. The Mirroring Deployment Group that this resource is part of. Format is:
`projects/{project}/locations/global/mirroringDeploymentGroups/{mirroringDeploymentGroup}`
"≈
mirroringDeploymentId" ßRequired. Id of the requesting object
If auto-generating Id server-side, remove this field and
mirroring_deployment_id from the method_signature of Create RPC


- - -
"H
name" <Immutable. Identifier. The name of the MirroringDeployment.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"p
reconciling
 ]Output only. Whether reconciling is in progress, recommended per
https://google.aip.dev/128.
"í
state" ÑOutput only. Current state of the deployment.
Possible values:
STATE_UNSPECIFIED
ACTIVE
CREATING
DELETING
OUT_OF_SYNC
DELETE_FAILED
"?

updateTime" -Output only. [Output only] Update time stamp
*ﬂ>
r
networksecurityMirroringDeploymentGroupEgcp:networksecurity/mirroringDeploymentGroup:MirroringDeploymentGroup’%## Example Usage

### Network Security Mirroring Deployment Group Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const network = new gcp.compute.Network("network", {
    name: "example-network",
    autoCreateSubnetworks: false,
});
const _default = new gcp.networksecurity.MirroringDeploymentGroup("default", {
    mirroringDeploymentGroupId: "example-dg",
    location: "global",
    network: network.id,
    labels: {
        foo: "bar",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

network = gcp.compute.Network("network",
    name="example-network",
    auto_create_subnetworks=False)
default = gcp.networksecurity.MirroringDeploymentGroup("default",
    mirroring_deployment_group_id="example-dg",
    location="global",
    network=network.id,
    labels={
        "foo": "bar",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var network = new Gcp.Compute.Network("network", new()
    {
        Name = "example-network",
        AutoCreateSubnetworks = false,
    });

    var @default = new Gcp.NetworkSecurity.MirroringDeploymentGroup("default", new()
    {
        MirroringDeploymentGroupId = "example-dg",
        Location = "global",
        Network = network.Id,
        Labels = 
        {
            { "foo", "bar" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
			Name:                  pulumi.String("example-network"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		_, err = networksecurity.NewMirroringDeploymentGroup(ctx, "default", &networksecurity.MirroringDeploymentGroupArgs{
			MirroringDeploymentGroupId: pulumi.String("example-dg"),
			Location:                   pulumi.String("global"),
			Network:                    network.ID(),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.networksecurity.MirroringDeploymentGroup;
import com.pulumi.gcp.networksecurity.MirroringDeploymentGroupArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var network = new Network("network", NetworkArgs.builder()
            .name("example-network")
            .autoCreateSubnetworks(false)
            .build());

        var default_ = new MirroringDeploymentGroup("default", MirroringDeploymentGroupArgs.builder()
            .mirroringDeploymentGroupId("example-dg")
            .location("global")
            .network(network.id())
            .labels(Map.of("foo", "bar"))
            .build());

    }
}
```
```yaml
resources:
  network:
    type: gcp:compute:Network
    properties:
      name: example-network
      autoCreateSubnetworks: false
  default:
    type: gcp:networksecurity:MirroringDeploymentGroup
    properties:
      mirroringDeploymentGroupId: example-dg
      location: global
      network: ${network.id}
      labels:
        foo: bar
```
<!--End PulumiCodeChooser -->

## Import

MirroringDeploymentGroup can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/mirroringDeploymentGroups/{{mirroring_deployment_group_id}}`

* `{{project}}/{{location}}/{{mirroring_deployment_group_id}}`

* `{{location}}/{{mirroring_deployment_group_id}}`

When using the `pulumi import` command, MirroringDeploymentGroup can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networksecurity/mirroringDeploymentGroup:MirroringDeploymentGroup default projects/{{project}}/locations/{{location}}/mirroringDeploymentGroups/{{mirroring_deployment_group_id}}
```

```sh
$ pulumi import gcp:networksecurity/mirroringDeploymentGroup:MirroringDeploymentGroup default {{project}}/{{location}}/{{mirroring_deployment_group_id}}
```

```sh
$ pulumi import gcp:networksecurity/mirroringDeploymentGroup:MirroringDeploymentGroup default {{location}}/{{mirroring_deployment_group_id}}
```

˝
labelsB2" ÍOptional. Labels as key value pairs
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
É
location" ÚResource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122. See documentation for resource type `networksecurity.googleapis.com/MirroringDeploymentGroup`.
–
mirroringDeploymentGroupId" ≠Required. Id of the requesting object
If auto-generating Id server-side, remove this field and
mirroring_deployment_group_id from the method_signature of Create RPC


- - -
ë
network" ÅRequired. Immutable. The network that is being used for the deployment. Format is:
projects/{project}/global/networks/{network}.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"“
connectedEndpointGroupsΩ*∫:∑
¥
networksecurity.MirroringDeploymentGroupConnectedEndpointGroupqgcp:networksecurity/MirroringDeploymentGroupConnectedEndpointGroup:MirroringDeploymentGroupConnectedEndpointGroupwOutput only. The list of Mirroring Endpoint Groups that are connected to this resource.
Structure is documented below.
"?

createTime" -Output only. [Output only] Create time stamp
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"˝
labelsB2" ÍOptional. Labels as key value pairs
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"É
location" ÚResource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122. See documentation for resource type `networksecurity.googleapis.com/MirroringDeploymentGroup`.
"–
mirroringDeploymentGroupId" ≠Required. Id of the requesting object
If auto-generating Id server-side, remove this field and
mirroring_deployment_group_id from the method_signature of Create RPC


- - -
"H
name" <(Output)
Output only. A connected mirroring endpoint group.
"ë
network" ÅRequired. Immutable. The network that is being used for the deployment. Format is:
projects/{project}/global/networks/{network}.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"p
reconciling
 ]Output only. Whether reconciling is in progress, recommended per
https://google.aip.dev/128.
"}
state" pOutput only. Current state of the deployment group.
Possible values:
STATE_UNSPECIFIED
ACTIVE
CREATING
DELETING
"?

updateTime" -Output only. [Output only] Update time stamp
*˚I
l
networksecurityMirroringEndpointGroupAgcp:networksecurity/mirroringEndpointGroup:MirroringEndpointGroup¶2## Example Usage

### Network Security Mirroring Endpoint Group Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const network = new gcp.compute.Network("network", {
    name: "example-network",
    autoCreateSubnetworks: false,
});
const deploymentGroup = new gcp.networksecurity.MirroringDeploymentGroup("deployment_group", {
    mirroringDeploymentGroupId: "example-dg",
    location: "global",
    network: network.id,
});
const _default = new gcp.networksecurity.MirroringEndpointGroup("default", {
    mirroringEndpointGroupId: "example-eg",
    location: "global",
    mirroringDeploymentGroup: deploymentGroup.id,
    labels: {
        foo: "bar",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

network = gcp.compute.Network("network",
    name="example-network",
    auto_create_subnetworks=False)
deployment_group = gcp.networksecurity.MirroringDeploymentGroup("deployment_group",
    mirroring_deployment_group_id="example-dg",
    location="global",
    network=network.id)
default = gcp.networksecurity.MirroringEndpointGroup("default",
    mirroring_endpoint_group_id="example-eg",
    location="global",
    mirroring_deployment_group=deployment_group.id,
    labels={
        "foo": "bar",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var network = new Gcp.Compute.Network("network", new()
    {
        Name = "example-network",
        AutoCreateSubnetworks = false,
    });

    var deploymentGroup = new Gcp.NetworkSecurity.MirroringDeploymentGroup("deployment_group", new()
    {
        MirroringDeploymentGroupId = "example-dg",
        Location = "global",
        Network = network.Id,
    });

    var @default = new Gcp.NetworkSecurity.MirroringEndpointGroup("default", new()
    {
        MirroringEndpointGroupId = "example-eg",
        Location = "global",
        MirroringDeploymentGroup = deploymentGroup.Id,
        Labels = 
        {
            { "foo", "bar" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		network, err := compute.NewNetwork(ctx, "network", &compute.NetworkArgs{
			Name:                  pulumi.String("example-network"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		deploymentGroup, err := networksecurity.NewMirroringDeploymentGroup(ctx, "deployment_group", &networksecurity.MirroringDeploymentGroupArgs{
			MirroringDeploymentGroupId: pulumi.String("example-dg"),
			Location:                   pulumi.String("global"),
			Network:                    network.ID(),
		})
		if err != nil {
			return err
		}
		_, err = networksecurity.NewMirroringEndpointGroup(ctx, "default", &networksecurity.MirroringEndpointGroupArgs{
			MirroringEndpointGroupId: pulumi.String("example-eg"),
			Location:                 pulumi.String("global"),
			MirroringDeploymentGroup: deploymentGroup.ID(),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.networksecurity.MirroringDeploymentGroup;
import com.pulumi.gcp.networksecurity.MirroringDeploymentGroupArgs;
import com.pulumi.gcp.networksecurity.MirroringEndpointGroup;
import com.pulumi.gcp.networksecurity.MirroringEndpointGroupArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var network = new Network("network", NetworkArgs.builder()
            .name("example-network")
            .autoCreateSubnetworks(false)
            .build());

        var deploymentGroup = new MirroringDeploymentGroup("deploymentGroup", MirroringDeploymentGroupArgs.builder()
            .mirroringDeploymentGroupId("example-dg")
            .location("global")
            .network(network.id())
            .build());

        var default_ = new MirroringEndpointGroup("default", MirroringEndpointGroupArgs.builder()
            .mirroringEndpointGroupId("example-eg")
            .location("global")
            .mirroringDeploymentGroup(deploymentGroup.id())
            .labels(Map.of("foo", "bar"))
            .build());

    }
}
```
```yaml
resources:
  network:
    type: gcp:compute:Network
    properties:
      name: example-network
      autoCreateSubnetworks: false
  deploymentGroup:
    type: gcp:networksecurity:MirroringDeploymentGroup
    name: deployment_group
    properties:
      mirroringDeploymentGroupId: example-dg
      location: global
      network: ${network.id}
  default:
    type: gcp:networksecurity:MirroringEndpointGroup
    properties:
      mirroringEndpointGroupId: example-eg
      location: global
      mirroringDeploymentGroup: ${deploymentGroup.id}
      labels:
        foo: bar
```
<!--End PulumiCodeChooser -->

## Import

MirroringEndpointGroup can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/mirroringEndpointGroups/{{mirroring_endpoint_group_id}}`

* `{{project}}/{{location}}/{{mirroring_endpoint_group_id}}`

* `{{location}}/{{mirroring_endpoint_group_id}}`

When using the `pulumi import` command, MirroringEndpointGroup can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networksecurity/mirroringEndpointGroup:MirroringEndpointGroup default projects/{{project}}/locations/{{location}}/mirroringEndpointGroups/{{mirroring_endpoint_group_id}}
```

```sh
$ pulumi import gcp:networksecurity/mirroringEndpointGroup:MirroringEndpointGroup default {{project}}/{{location}}/{{mirroring_endpoint_group_id}}
```

```sh
$ pulumi import gcp:networksecurity/mirroringEndpointGroup:MirroringEndpointGroup default {{location}}/{{mirroring_endpoint_group_id}}
```

˝
labelsB2" ÍOptional. Labels as key value pairs
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
Å
location" Resource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122. See documentation for resource type `networksecurity.googleapis.com/MirroringEndpointGroup`.
ﬂ
mirroringDeploymentGroup" æRequired. Immutable. The Mirroring Deployment Group that this resource is connected to. Format
is:
`projects/{project}/locations/global/mirroringDeploymentGroups/{mirroringDeploymentGroup}`
Ã
mirroringEndpointGroupId" ´Required. Id of the requesting object
If auto-generating Id server-side, remove this field and
mirroring_endpoint_group_id from the method_signature of Create RPC


- - -
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"?

createTime" -Output only. [Output only] Create time stamp
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"˝
labelsB2" ÍOptional. Labels as key value pairs
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"Å
location" Resource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122. See documentation for resource type `networksecurity.googleapis.com/MirroringEndpointGroup`.
"ﬂ
mirroringDeploymentGroup" æRequired. Immutable. The Mirroring Deployment Group that this resource is connected to. Format
is:
`projects/{project}/locations/global/mirroringDeploymentGroups/{mirroringDeploymentGroup}`
"Ã
mirroringEndpointGroupId" ´Required. Id of the requesting object
If auto-generating Id server-side, remove this field and
mirroring_endpoint_group_id from the method_signature of Create RPC


- - -
"K
name" ?Immutable. Identifier. The name of the MirroringEndpointGroup.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"p
reconciling
 ]Output only. Whether reconciling is in progress, recommended per
https://google.aip.dev/128.
"è
state" ÅOutput only. Current state of the endpoint group.
Possible values:
STATE_UNSPECIFIED
ACTIVE
CLOSED
CREATING
DELETING
OUT_OF_SYNC
"?

updateTime" -Output only. [Output only] Update time stamp
*®j
ç
networksecurity!MirroringEndpointGroupAssociationWgcp:networksecurity/mirroringEndpointGroupAssociation:MirroringEndpointGroupAssociation¿M## Example Usage

### Network Security Mirroring Endpoint Group Association Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const producerNetwork = new gcp.compute.Network("producer_network", {
    name: "example-prod-network",
    autoCreateSubnetworks: false,
});
const consumerNetwork = new gcp.compute.Network("consumer_network", {
    name: "example-cons-network",
    autoCreateSubnetworks: false,
});
const deploymentGroup = new gcp.networksecurity.MirroringDeploymentGroup("deployment_group", {
    mirroringDeploymentGroupId: "example-dg",
    location: "global",
    network: producerNetwork.id,
});
const endpointGroup = new gcp.networksecurity.MirroringEndpointGroup("endpoint_group", {
    mirroringEndpointGroupId: "example-eg",
    location: "global",
    mirroringDeploymentGroup: deploymentGroup.id,
});
const _default = new gcp.networksecurity.MirroringEndpointGroupAssociation("default", {
    mirroringEndpointGroupAssociationId: "example-ega",
    location: "global",
    network: consumerNetwork.id,
    mirroringEndpointGroup: endpointGroup.id,
    labels: {
        foo: "bar",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

producer_network = gcp.compute.Network("producer_network",
    name="example-prod-network",
    auto_create_subnetworks=False)
consumer_network = gcp.compute.Network("consumer_network",
    name="example-cons-network",
    auto_create_subnetworks=False)
deployment_group = gcp.networksecurity.MirroringDeploymentGroup("deployment_group",
    mirroring_deployment_group_id="example-dg",
    location="global",
    network=producer_network.id)
endpoint_group = gcp.networksecurity.MirroringEndpointGroup("endpoint_group",
    mirroring_endpoint_group_id="example-eg",
    location="global",
    mirroring_deployment_group=deployment_group.id)
default = gcp.networksecurity.MirroringEndpointGroupAssociation("default",
    mirroring_endpoint_group_association_id="example-ega",
    location="global",
    network=consumer_network.id,
    mirroring_endpoint_group=endpoint_group.id,
    labels={
        "foo": "bar",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var producerNetwork = new Gcp.Compute.Network("producer_network", new()
    {
        Name = "example-prod-network",
        AutoCreateSubnetworks = false,
    });

    var consumerNetwork = new Gcp.Compute.Network("consumer_network", new()
    {
        Name = "example-cons-network",
        AutoCreateSubnetworks = false,
    });

    var deploymentGroup = new Gcp.NetworkSecurity.MirroringDeploymentGroup("deployment_group", new()
    {
        MirroringDeploymentGroupId = "example-dg",
        Location = "global",
        Network = producerNetwork.Id,
    });

    var endpointGroup = new Gcp.NetworkSecurity.MirroringEndpointGroup("endpoint_group", new()
    {
        MirroringEndpointGroupId = "example-eg",
        Location = "global",
        MirroringDeploymentGroup = deploymentGroup.Id,
    });

    var @default = new Gcp.NetworkSecurity.MirroringEndpointGroupAssociation("default", new()
    {
        MirroringEndpointGroupAssociationId = "example-ega",
        Location = "global",
        Network = consumerNetwork.Id,
        MirroringEndpointGroup = endpointGroup.Id,
        Labels = 
        {
            { "foo", "bar" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		producerNetwork, err := compute.NewNetwork(ctx, "producer_network", &compute.NetworkArgs{
			Name:                  pulumi.String("example-prod-network"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		consumerNetwork, err := compute.NewNetwork(ctx, "consumer_network", &compute.NetworkArgs{
			Name:                  pulumi.String("example-cons-network"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		deploymentGroup, err := networksecurity.NewMirroringDeploymentGroup(ctx, "deployment_group", &networksecurity.MirroringDeploymentGroupArgs{
			MirroringDeploymentGroupId: pulumi.String("example-dg"),
			Location:                   pulumi.String("global"),
			Network:                    producerNetwork.ID(),
		})
		if err != nil {
			return err
		}
		endpointGroup, err := networksecurity.NewMirroringEndpointGroup(ctx, "endpoint_group", &networksecurity.MirroringEndpointGroupArgs{
			MirroringEndpointGroupId: pulumi.String("example-eg"),
			Location:                 pulumi.String("global"),
			MirroringDeploymentGroup: deploymentGroup.ID(),
		})
		if err != nil {
			return err
		}
		_, err = networksecurity.NewMirroringEndpointGroupAssociation(ctx, "default", &networksecurity.MirroringEndpointGroupAssociationArgs{
			MirroringEndpointGroupAssociationId: pulumi.String("example-ega"),
			Location:                            pulumi.String("global"),
			Network:                             consumerNetwork.ID(),
			MirroringEndpointGroup:              endpointGroup.ID(),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.networksecurity.MirroringDeploymentGroup;
import com.pulumi.gcp.networksecurity.MirroringDeploymentGroupArgs;
import com.pulumi.gcp.networksecurity.MirroringEndpointGroup;
import com.pulumi.gcp.networksecurity.MirroringEndpointGroupArgs;
import com.pulumi.gcp.networksecurity.MirroringEndpointGroupAssociation;
import com.pulumi.gcp.networksecurity.MirroringEndpointGroupAssociationArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var producerNetwork = new Network("producerNetwork", NetworkArgs.builder()
            .name("example-prod-network")
            .autoCreateSubnetworks(false)
            .build());

        var consumerNetwork = new Network("consumerNetwork", NetworkArgs.builder()
            .name("example-cons-network")
            .autoCreateSubnetworks(false)
            .build());

        var deploymentGroup = new MirroringDeploymentGroup("deploymentGroup", MirroringDeploymentGroupArgs.builder()
            .mirroringDeploymentGroupId("example-dg")
            .location("global")
            .network(producerNetwork.id())
            .build());

        var endpointGroup = new MirroringEndpointGroup("endpointGroup", MirroringEndpointGroupArgs.builder()
            .mirroringEndpointGroupId("example-eg")
            .location("global")
            .mirroringDeploymentGroup(deploymentGroup.id())
            .build());

        var default_ = new MirroringEndpointGroupAssociation("default", MirroringEndpointGroupAssociationArgs.builder()
            .mirroringEndpointGroupAssociationId("example-ega")
            .location("global")
            .network(consumerNetwork.id())
            .mirroringEndpointGroup(endpointGroup.id())
            .labels(Map.of("foo", "bar"))
            .build());

    }
}
```
```yaml
resources:
  producerNetwork:
    type: gcp:compute:Network
    name: producer_network
    properties:
      name: example-prod-network
      autoCreateSubnetworks: false
  consumerNetwork:
    type: gcp:compute:Network
    name: consumer_network
    properties:
      name: example-cons-network
      autoCreateSubnetworks: false
  deploymentGroup:
    type: gcp:networksecurity:MirroringDeploymentGroup
    name: deployment_group
    properties:
      mirroringDeploymentGroupId: example-dg
      location: global
      network: ${producerNetwork.id}
  endpointGroup:
    type: gcp:networksecurity:MirroringEndpointGroup
    name: endpoint_group
    properties:
      mirroringEndpointGroupId: example-eg
      location: global
      mirroringDeploymentGroup: ${deploymentGroup.id}
  default:
    type: gcp:networksecurity:MirroringEndpointGroupAssociation
    properties:
      mirroringEndpointGroupAssociationId: example-ega
      location: global
      network: ${consumerNetwork.id}
      mirroringEndpointGroup: ${endpointGroup.id}
      labels:
        foo: bar
```
<!--End PulumiCodeChooser -->

## Import

MirroringEndpointGroupAssociation can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/mirroringEndpointGroupAssociations/{{mirroring_endpoint_group_association_id}}`

* `{{project}}/{{location}}/{{mirroring_endpoint_group_association_id}}`

* `{{location}}/{{mirroring_endpoint_group_association_id}}`

When using the `pulumi import` command, MirroringEndpointGroupAssociation can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networksecurity/mirroringEndpointGroupAssociation:MirroringEndpointGroupAssociation default projects/{{project}}/locations/{{location}}/mirroringEndpointGroupAssociations/{{mirroring_endpoint_group_association_id}}
```

```sh
$ pulumi import gcp:networksecurity/mirroringEndpointGroupAssociation:MirroringEndpointGroupAssociation default {{project}}/{{location}}/{{mirroring_endpoint_group_association_id}}
```

```sh
$ pulumi import gcp:networksecurity/mirroringEndpointGroupAssociation:MirroringEndpointGroupAssociation default {{location}}/{{mirroring_endpoint_group_association_id}}
```

˝
labelsB2" ÍOptional. Labels as key value pairs
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
î
location" ÉResource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122. See documentation for resource type `networksecurity.googleapis.com/MirroringEndpointGroupAssociation`.


- - -
◊
mirroringEndpointGroup" ∏Required. Immutable. The Mirroring Endpoint Group that this resource is connected to. Format
is:
`projects/{project}/locations/global/mirroringEndpointGroups/{mirroringEndpointGroup}`
›
#mirroringEndpointGroupAssociationIdB" ØOptional. Id of the requesting object
If auto-generating Id server-side, remove this field and
mirroring_endpoint_group_association_id from the method_signature of Create
RPC
v
network" gRequired. Immutable. The VPC network associated. Format:
projects/{project}/global/networks/{network}.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"?

createTime" -Output only. [Output only] Create time stamp
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"˝
labelsB2" ÍOptional. Labels as key value pairs
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"î
location" ÉResource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122. See documentation for resource type `networksecurity.googleapis.com/MirroringEndpointGroupAssociation`.


- - -
"…
locationsDetails√*¿:Ω
∫
networksecurity0MirroringEndpointGroupAssociationLocationsDetailugcp:networksecurity/MirroringEndpointGroupAssociationLocationsDetail:MirroringEndpointGroupAssociationLocationsDetailoOutput only. The list of locations that this association is in and its details.
Structure is documented below.
"◊
mirroringEndpointGroup" ∏Required. Immutable. The Mirroring Endpoint Group that this resource is connected to. Format
is:
`projects/{project}/locations/global/mirroringEndpointGroups/{mirroringEndpointGroup}`
"›
#mirroringEndpointGroupAssociationIdB" ØOptional. Id of the requesting object
If auto-generating Id server-side, remove this field and
mirroring_endpoint_group_association_id from the method_signature of Create
RPC
"V
name" JImmutable. Identifier. The name of the MirroringEndpointGroupAssociation.
"v
network" gRequired. Immutable. The VPC network associated. Format:
projects/{project}/global/networks/{network}.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"p
reconciling
 ]Output only. Whether reconciling is in progress, recommended per
https://google.aip.dev/128.
"Å
state" t(Output)
Output only. The association state in this location.
Possible values:
STATE_UNSPECIFIED
ACTIVE
OUT_OF_SYNC
"?

updateTime" -Output only. [Output only] Update time stamp
*⁄e
W
networksecuritySecurityProfile3gcp:networksecurity/securityProfile:SecurityProfile∏OA security profile defines the behavior associated to a profile type.


To get more information about SecurityProfile, see:

* [API documentation](https://cloud.google.com/firewall/docs/reference/network-security/rest/v1/organizations.locations.securityProfiles)
* How-to Guides
    * [Create and manage security profiles](https://cloud.google.com/firewall/docs/configure-security-profiles)

## Example Usage

### Network Security Security Profile Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networksecurity.SecurityProfile("default", {
    name: "my-security-profile",
    parent: "organizations/123456789",
    description: "my description",
    type: "THREAT_PREVENTION",
    labels: {
        foo: "bar",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networksecurity.SecurityProfile("default",
    name="my-security-profile",
    parent="organizations/123456789",
    description="my description",
    type="THREAT_PREVENTION",
    labels={
        "foo": "bar",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkSecurity.SecurityProfile("default", new()
    {
        Name = "my-security-profile",
        Parent = "organizations/123456789",
        Description = "my description",
        Type = "THREAT_PREVENTION",
        Labels = 
        {
            { "foo", "bar" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networksecurity.NewSecurityProfile(ctx, "default", &networksecurity.SecurityProfileArgs{
			Name:        pulumi.String("my-security-profile"),
			Parent:      pulumi.String("organizations/123456789"),
			Description: pulumi.String("my description"),
			Type:        pulumi.String("THREAT_PREVENTION"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networksecurity.SecurityProfile;
import com.pulumi.gcp.networksecurity.SecurityProfileArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new SecurityProfile("default", SecurityProfileArgs.builder()
            .name("my-security-profile")
            .parent("organizations/123456789")
            .description("my description")
            .type("THREAT_PREVENTION")
            .labels(Map.of("foo", "bar"))
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networksecurity:SecurityProfile
    properties:
      name: my-security-profile
      parent: organizations/123456789
      description: my description
      type: THREAT_PREVENTION
      labels:
        foo: bar
```
<!--End PulumiCodeChooser -->
### Network Security Security Profile Overrides


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networksecurity.SecurityProfile("default", {
    name: "my-security-profile",
    parent: "organizations/123456789",
    description: "my description",
    type: "THREAT_PREVENTION",
    threatPreventionProfile: {
        severityOverrides: [
            {
                action: "ALLOW",
                severity: "INFORMATIONAL",
            },
            {
                action: "DENY",
                severity: "HIGH",
            },
        ],
        threatOverrides: [{
            action: "ALLOW",
            threatId: "280647",
        }],
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networksecurity.SecurityProfile("default",
    name="my-security-profile",
    parent="organizations/123456789",
    description="my description",
    type="THREAT_PREVENTION",
    threat_prevention_profile={
        "severity_overrides": [
            {
                "action": "ALLOW",
                "severity": "INFORMATIONAL",
            },
            {
                "action": "DENY",
                "severity": "HIGH",
            },
        ],
        "threat_overrides": [{
            "action": "ALLOW",
            "threat_id": "280647",
        }],
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkSecurity.SecurityProfile("default", new()
    {
        Name = "my-security-profile",
        Parent = "organizations/123456789",
        Description = "my description",
        Type = "THREAT_PREVENTION",
        ThreatPreventionProfile = new Gcp.NetworkSecurity.Inputs.SecurityProfileThreatPreventionProfileArgs
        {
            SeverityOverrides = new[]
            {
                new Gcp.NetworkSecurity.Inputs.SecurityProfileThreatPreventionProfileSeverityOverrideArgs
                {
                    Action = "ALLOW",
                    Severity = "INFORMATIONAL",
                },
                new Gcp.NetworkSecurity.Inputs.SecurityProfileThreatPreventionProfileSeverityOverrideArgs
                {
                    Action = "DENY",
                    Severity = "HIGH",
                },
            },
            ThreatOverrides = new[]
            {
                new Gcp.NetworkSecurity.Inputs.SecurityProfileThreatPreventionProfileThreatOverrideArgs
                {
                    Action = "ALLOW",
                    ThreatId = "280647",
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networksecurity.NewSecurityProfile(ctx, "default", &networksecurity.SecurityProfileArgs{
			Name:        pulumi.String("my-security-profile"),
			Parent:      pulumi.String("organizations/123456789"),
			Description: pulumi.String("my description"),
			Type:        pulumi.String("THREAT_PREVENTION"),
			ThreatPreventionProfile: &networksecurity.SecurityProfileThreatPreventionProfileArgs{
				SeverityOverrides: networksecurity.SecurityProfileThreatPreventionProfileSeverityOverrideArray{
					&networksecurity.SecurityProfileThreatPreventionProfileSeverityOverrideArgs{
						Action:   pulumi.String("ALLOW"),
						Severity: pulumi.String("INFORMATIONAL"),
					},
					&networksecurity.SecurityProfileThreatPreventionProfileSeverityOverrideArgs{
						Action:   pulumi.String("DENY"),
						Severity: pulumi.String("HIGH"),
					},
				},
				ThreatOverrides: networksecurity.SecurityProfileThreatPreventionProfileThreatOverrideArray{
					&networksecurity.SecurityProfileThreatPreventionProfileThreatOverrideArgs{
						Action:   pulumi.String("ALLOW"),
						ThreatId: pulumi.String("280647"),
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networksecurity.SecurityProfile;
import com.pulumi.gcp.networksecurity.SecurityProfileArgs;
import com.pulumi.gcp.networksecurity.inputs.SecurityProfileThreatPreventionProfileArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new SecurityProfile("default", SecurityProfileArgs.builder()
            .name("my-security-profile")
            .parent("organizations/123456789")
            .description("my description")
            .type("THREAT_PREVENTION")
            .threatPreventionProfile(SecurityProfileThreatPreventionProfileArgs.builder()
                .severityOverrides(                
                    SecurityProfileThreatPreventionProfileSeverityOverrideArgs.builder()
                        .action("ALLOW")
                        .severity("INFORMATIONAL")
                        .build(),
                    SecurityProfileThreatPreventionProfileSeverityOverrideArgs.builder()
                        .action("DENY")
                        .severity("HIGH")
                        .build())
                .threatOverrides(SecurityProfileThreatPreventionProfileThreatOverrideArgs.builder()
                    .action("ALLOW")
                    .threatId("280647")
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networksecurity:SecurityProfile
    properties:
      name: my-security-profile
      parent: organizations/123456789
      description: my description
      type: THREAT_PREVENTION
      threatPreventionProfile:
        severityOverrides:
          - action: ALLOW
            severity: INFORMATIONAL
          - action: DENY
            severity: HIGH
        threatOverrides:
          - action: ALLOW
            threatId: '280647'
```
<!--End PulumiCodeChooser -->

## Import

SecurityProfile can be imported using any of these accepted formats:

* `{{parent}}/locations/{{location}}/securityProfiles/{{name}}`

When using the `pulumi import` command, SecurityProfile can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networksecurity/securityProfile:SecurityProfile default {{parent}}/locations/{{location}}/securityProfiles/{{name}}
```

h
descriptionB" SAn optional description of the security profile. The Max length is 512 characters.
î
labelsB2" ÅA map of key/value label pairs to assign to the resource.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
W
locationB" EThe location of the security profile.
The default value is `global`.
A
nameB" 3The name of the security profile resource.


- - -
r
parentB" bThe name of the parent this security profile belongs to.
Format: organizations/{organization_id}.
†
threatPreventionProfile•B¢:ü
ú
networksecurity&SecurityProfileThreatPreventionProfileagcp:networksecurity/SecurityProfileThreatPreventionProfile:SecurityProfileThreatPreventionProfile]The threat prevention configuration for the security profile.
Structure is documented below.
T
type" HThe type of security profile.
Possible values are: `THREAT_PREVENTION`.
"@

createTime" .Time the security profile was created in UTC.
"h
descriptionB" SAn optional description of the security profile. The Max length is 512 characters.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"«
etag" ∫This checksum is computed by the server based on the value of other fields,
and may be sent on update and delete requests to ensure the client has an up-to-date
value before proceeding.
"î
labelsB2" ÅA map of key/value label pairs to assign to the resource.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"W
locationB" EThe location of the security profile.
The default value is `global`.
"?
name" 3The name of the security profile resource.


- - -
"r
parentB" bThe name of the parent this security profile belongs to.
Format: organizations/{organization_id}.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"5
selfLink" %Server-defined URL of this resource.
"†
threatPreventionProfile•B¢:ü
ú
networksecurity&SecurityProfileThreatPreventionProfileagcp:networksecurity/SecurityProfileThreatPreventionProfile:SecurityProfileThreatPreventionProfile]The threat prevention configuration for the security profile.
Structure is documented below.
"T
type" HThe type of security profile.
Possible values are: `THREAT_PREVENTION`.
"@

updateTime" .Time the security profile was updated in UTC.
*±?
f
networksecuritySecurityProfileGroup=gcp:networksecurity/securityProfileGroup:SecurityProfileGroup˜,A security profile group defines a container for security profiles.


To get more information about SecurityProfileGroup, see:

* [API documentation](https://cloud.google.com/firewall/docs/reference/network-security/rest/v1/organizations.locations.securityProfileGroups)
* How-to Guides
    * [Create and manage security profile groups](https://cloud.google.com/firewall/docs/configure-security-profile-groups)
    * [Security profile groups overview](https://cloud.google.com/firewall/docs/about-security-profile-groups)

## Example Usage

### Network Security Security Profile Group Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const securityProfile = new gcp.networksecurity.SecurityProfile("security_profile", {
    name: "sec-profile",
    type: "THREAT_PREVENTION",
    parent: "organizations/123456789",
    location: "global",
});
const _default = new gcp.networksecurity.SecurityProfileGroup("default", {
    name: "sec-profile-group",
    parent: "organizations/123456789",
    description: "my description",
    threatPreventionProfile: securityProfile.id,
    labels: {
        foo: "bar",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

security_profile = gcp.networksecurity.SecurityProfile("security_profile",
    name="sec-profile",
    type="THREAT_PREVENTION",
    parent="organizations/123456789",
    location="global")
default = gcp.networksecurity.SecurityProfileGroup("default",
    name="sec-profile-group",
    parent="organizations/123456789",
    description="my description",
    threat_prevention_profile=security_profile.id,
    labels={
        "foo": "bar",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var securityProfile = new Gcp.NetworkSecurity.SecurityProfile("security_profile", new()
    {
        Name = "sec-profile",
        Type = "THREAT_PREVENTION",
        Parent = "organizations/123456789",
        Location = "global",
    });

    var @default = new Gcp.NetworkSecurity.SecurityProfileGroup("default", new()
    {
        Name = "sec-profile-group",
        Parent = "organizations/123456789",
        Description = "my description",
        ThreatPreventionProfile = securityProfile.Id,
        Labels = 
        {
            { "foo", "bar" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		securityProfile, err := networksecurity.NewSecurityProfile(ctx, "security_profile", &networksecurity.SecurityProfileArgs{
			Name:     pulumi.String("sec-profile"),
			Type:     pulumi.String("THREAT_PREVENTION"),
			Parent:   pulumi.String("organizations/123456789"),
			Location: pulumi.String("global"),
		})
		if err != nil {
			return err
		}
		_, err = networksecurity.NewSecurityProfileGroup(ctx, "default", &networksecurity.SecurityProfileGroupArgs{
			Name:                    pulumi.String("sec-profile-group"),
			Parent:                  pulumi.String("organizations/123456789"),
			Description:             pulumi.String("my description"),
			ThreatPreventionProfile: securityProfile.ID(),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networksecurity.SecurityProfile;
import com.pulumi.gcp.networksecurity.SecurityProfileArgs;
import com.pulumi.gcp.networksecurity.SecurityProfileGroup;
import com.pulumi.gcp.networksecurity.SecurityProfileGroupArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var securityProfile = new SecurityProfile("securityProfile", SecurityProfileArgs.builder()
            .name("sec-profile")
            .type("THREAT_PREVENTION")
            .parent("organizations/123456789")
            .location("global")
            .build());

        var default_ = new SecurityProfileGroup("default", SecurityProfileGroupArgs.builder()
            .name("sec-profile-group")
            .parent("organizations/123456789")
            .description("my description")
            .threatPreventionProfile(securityProfile.id())
            .labels(Map.of("foo", "bar"))
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networksecurity:SecurityProfileGroup
    properties:
      name: sec-profile-group
      parent: organizations/123456789
      description: my description
      threatPreventionProfile: ${securityProfile.id}
      labels:
        foo: bar
  securityProfile:
    type: gcp:networksecurity:SecurityProfile
    name: security_profile
    properties:
      name: sec-profile
      type: THREAT_PREVENTION
      parent: organizations/123456789
      location: global
```
<!--End PulumiCodeChooser -->

## Import

SecurityProfileGroup can be imported using any of these accepted formats:

* `{{parent}}/locations/{{location}}/securityProfileGroups/{{name}}`

When using the `pulumi import` command, SecurityProfileGroup can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networksecurity/securityProfileGroup:SecurityProfileGroup default {{parent}}/locations/{{location}}/securityProfileGroups/{{name}}
```

_
descriptionB" JAn optional description of the profile. The Max length is 512 characters.
î
labelsB2" ÅA map of key/value label pairs to assign to the resource.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
]
locationB" KThe location of the security profile group.
The default value is `global`.
G
nameB" 9The name of the security profile group resource.


- - -
x
parentB" hThe name of the parent this security profile group belongs to.
Format: organizations/{organization_id}.
á
threatPreventionProfileB" fReference to a SecurityProfile with the threat prevention configuration for the SecurityProfileGroup.
"F

createTime" 4Time the security profile group was created in UTC.
"_
descriptionB" JAn optional description of the profile. The Max length is 512 characters.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"«
etag" ∫This checksum is computed by the server based on the value of other fields,
and may be sent on update and delete requests to ensure the client has an up-to-date
value before proceeding.
"î
labelsB2" ÅA map of key/value label pairs to assign to the resource.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"]
locationB" KThe location of the security profile group.
The default value is `global`.
"E
name" 9The name of the security profile group resource.


- - -
"x
parentB" hThe name of the parent this security profile group belongs to.
Format: organizations/{organization_id}.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"á
threatPreventionProfileB" fReference to a SecurityProfile with the threat prevention configuration for the SecurityProfileGroup.
"F

updateTime" 4Time the security profile group was updated in UTC.
*›Û
W
networksecurityServerTlsPolicy3gcp:networksecurity/serverTlsPolicy:ServerTlsPolicy£ÃServerTlsPolicy is a resource that specifies how a server should authenticate incoming requests. This resource itself does not affect configuration unless it is attached to a target HTTPS proxy or endpoint config selector resource.


To get more information about ServerTlsPolicy, see:

* [API documentation](https://cloud.google.com/traffic-director/docs/reference/network-security/rest/v1beta1/projects.locations.serverTlsPolicies)

## Example Usage

### Network Security Server Tls Policy Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networksecurity.ServerTlsPolicy("default", {
    name: "my-server-tls-policy",
    labels: {
        foo: "bar",
    },
    description: "my description",
    allowOpen: false,
    serverCertificate: {
        certificateProviderInstance: {
            pluginInstance: "google_cloud_private_spiffe",
        },
    },
    mtlsPolicy: {
        clientValidationCas: [{
            grpcEndpoint: {
                targetUri: "unix:mypath",
            },
        }],
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networksecurity.ServerTlsPolicy("default",
    name="my-server-tls-policy",
    labels={
        "foo": "bar",
    },
    description="my description",
    allow_open=False,
    server_certificate={
        "certificate_provider_instance": {
            "plugin_instance": "google_cloud_private_spiffe",
        },
    },
    mtls_policy={
        "client_validation_cas": [{
            "grpc_endpoint": {
                "target_uri": "unix:mypath",
            },
        }],
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkSecurity.ServerTlsPolicy("default", new()
    {
        Name = "my-server-tls-policy",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        AllowOpen = false,
        ServerCertificate = new Gcp.NetworkSecurity.Inputs.ServerTlsPolicyServerCertificateArgs
        {
            CertificateProviderInstance = new Gcp.NetworkSecurity.Inputs.ServerTlsPolicyServerCertificateCertificateProviderInstanceArgs
            {
                PluginInstance = "google_cloud_private_spiffe",
            },
        },
        MtlsPolicy = new Gcp.NetworkSecurity.Inputs.ServerTlsPolicyMtlsPolicyArgs
        {
            ClientValidationCas = new[]
            {
                new Gcp.NetworkSecurity.Inputs.ServerTlsPolicyMtlsPolicyClientValidationCaArgs
                {
                    GrpcEndpoint = new Gcp.NetworkSecurity.Inputs.ServerTlsPolicyMtlsPolicyClientValidationCaGrpcEndpointArgs
                    {
                        TargetUri = "unix:mypath",
                    },
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networksecurity.NewServerTlsPolicy(ctx, "default", &networksecurity.ServerTlsPolicyArgs{
			Name: pulumi.String("my-server-tls-policy"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			AllowOpen:   pulumi.Bool(false),
			ServerCertificate: &networksecurity.ServerTlsPolicyServerCertificateArgs{
				CertificateProviderInstance: &networksecurity.ServerTlsPolicyServerCertificateCertificateProviderInstanceArgs{
					PluginInstance: pulumi.String("google_cloud_private_spiffe"),
				},
			},
			MtlsPolicy: &networksecurity.ServerTlsPolicyMtlsPolicyArgs{
				ClientValidationCas: networksecurity.ServerTlsPolicyMtlsPolicyClientValidationCaArray{
					&networksecurity.ServerTlsPolicyMtlsPolicyClientValidationCaArgs{
						GrpcEndpoint: &networksecurity.ServerTlsPolicyMtlsPolicyClientValidationCaGrpcEndpointArgs{
							TargetUri: pulumi.String("unix:mypath"),
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networksecurity.ServerTlsPolicy;
import com.pulumi.gcp.networksecurity.ServerTlsPolicyArgs;
import com.pulumi.gcp.networksecurity.inputs.ServerTlsPolicyServerCertificateArgs;
import com.pulumi.gcp.networksecurity.inputs.ServerTlsPolicyServerCertificateCertificateProviderInstanceArgs;
import com.pulumi.gcp.networksecurity.inputs.ServerTlsPolicyMtlsPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new ServerTlsPolicy("default", ServerTlsPolicyArgs.builder()
            .name("my-server-tls-policy")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .allowOpen("false")
            .serverCertificate(ServerTlsPolicyServerCertificateArgs.builder()
                .certificateProviderInstance(ServerTlsPolicyServerCertificateCertificateProviderInstanceArgs.builder()
                    .pluginInstance("google_cloud_private_spiffe")
                    .build())
                .build())
            .mtlsPolicy(ServerTlsPolicyMtlsPolicyArgs.builder()
                .clientValidationCas(ServerTlsPolicyMtlsPolicyClientValidationCaArgs.builder()
                    .grpcEndpoint(ServerTlsPolicyMtlsPolicyClientValidationCaGrpcEndpointArgs.builder()
                        .targetUri("unix:mypath")
                        .build())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networksecurity:ServerTlsPolicy
    properties:
      name: my-server-tls-policy
      labels:
        foo: bar
      description: my description
      allowOpen: 'false'
      serverCertificate:
        certificateProviderInstance:
          pluginInstance: google_cloud_private_spiffe
      mtlsPolicy:
        clientValidationCas:
          - grpcEndpoint:
              targetUri: unix:mypath
```
<!--End PulumiCodeChooser -->
### Network Security Server Tls Policy Advanced


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networksecurity.ServerTlsPolicy("default", {
    name: "my-server-tls-policy",
    labels: {
        foo: "bar",
    },
    description: "my description",
    location: "global",
    allowOpen: false,
    mtlsPolicy: {
        clientValidationMode: "ALLOW_INVALID_OR_MISSING_CLIENT_CERT",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networksecurity.ServerTlsPolicy("default",
    name="my-server-tls-policy",
    labels={
        "foo": "bar",
    },
    description="my description",
    location="global",
    allow_open=False,
    mtls_policy={
        "client_validation_mode": "ALLOW_INVALID_OR_MISSING_CLIENT_CERT",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkSecurity.ServerTlsPolicy("default", new()
    {
        Name = "my-server-tls-policy",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        Location = "global",
        AllowOpen = false,
        MtlsPolicy = new Gcp.NetworkSecurity.Inputs.ServerTlsPolicyMtlsPolicyArgs
        {
            ClientValidationMode = "ALLOW_INVALID_OR_MISSING_CLIENT_CERT",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networksecurity.NewServerTlsPolicy(ctx, "default", &networksecurity.ServerTlsPolicyArgs{
			Name: pulumi.String("my-server-tls-policy"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			Location:    pulumi.String("global"),
			AllowOpen:   pulumi.Bool(false),
			MtlsPolicy: &networksecurity.ServerTlsPolicyMtlsPolicyArgs{
				ClientValidationMode: pulumi.String("ALLOW_INVALID_OR_MISSING_CLIENT_CERT"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networksecurity.ServerTlsPolicy;
import com.pulumi.gcp.networksecurity.ServerTlsPolicyArgs;
import com.pulumi.gcp.networksecurity.inputs.ServerTlsPolicyMtlsPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new ServerTlsPolicy("default", ServerTlsPolicyArgs.builder()
            .name("my-server-tls-policy")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .location("global")
            .allowOpen("false")
            .mtlsPolicy(ServerTlsPolicyMtlsPolicyArgs.builder()
                .clientValidationMode("ALLOW_INVALID_OR_MISSING_CLIENT_CERT")
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networksecurity:ServerTlsPolicy
    properties:
      name: my-server-tls-policy
      labels:
        foo: bar
      description: my description
      location: global
      allowOpen: 'false'
      mtlsPolicy:
        clientValidationMode: ALLOW_INVALID_OR_MISSING_CLIENT_CERT
```
<!--End PulumiCodeChooser -->
### Network Security Server Tls Policy Server Cert


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networksecurity.ServerTlsPolicy("default", {
    name: "my-server-tls-policy",
    labels: {
        foo: "bar",
    },
    description: "my description",
    location: "global",
    allowOpen: false,
    serverCertificate: {
        grpcEndpoint: {
            targetUri: "unix:mypath",
        },
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networksecurity.ServerTlsPolicy("default",
    name="my-server-tls-policy",
    labels={
        "foo": "bar",
    },
    description="my description",
    location="global",
    allow_open=False,
    server_certificate={
        "grpc_endpoint": {
            "target_uri": "unix:mypath",
        },
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkSecurity.ServerTlsPolicy("default", new()
    {
        Name = "my-server-tls-policy",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        Location = "global",
        AllowOpen = false,
        ServerCertificate = new Gcp.NetworkSecurity.Inputs.ServerTlsPolicyServerCertificateArgs
        {
            GrpcEndpoint = new Gcp.NetworkSecurity.Inputs.ServerTlsPolicyServerCertificateGrpcEndpointArgs
            {
                TargetUri = "unix:mypath",
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networksecurity.NewServerTlsPolicy(ctx, "default", &networksecurity.ServerTlsPolicyArgs{
			Name: pulumi.String("my-server-tls-policy"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			Location:    pulumi.String("global"),
			AllowOpen:   pulumi.Bool(false),
			ServerCertificate: &networksecurity.ServerTlsPolicyServerCertificateArgs{
				GrpcEndpoint: &networksecurity.ServerTlsPolicyServerCertificateGrpcEndpointArgs{
					TargetUri: pulumi.String("unix:mypath"),
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networksecurity.ServerTlsPolicy;
import com.pulumi.gcp.networksecurity.ServerTlsPolicyArgs;
import com.pulumi.gcp.networksecurity.inputs.ServerTlsPolicyServerCertificateArgs;
import com.pulumi.gcp.networksecurity.inputs.ServerTlsPolicyServerCertificateGrpcEndpointArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new ServerTlsPolicy("default", ServerTlsPolicyArgs.builder()
            .name("my-server-tls-policy")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .location("global")
            .allowOpen("false")
            .serverCertificate(ServerTlsPolicyServerCertificateArgs.builder()
                .grpcEndpoint(ServerTlsPolicyServerCertificateGrpcEndpointArgs.builder()
                    .targetUri("unix:mypath")
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networksecurity:ServerTlsPolicy
    properties:
      name: my-server-tls-policy
      labels:
        foo: bar
      description: my description
      location: global
      allowOpen: 'false'
      serverCertificate:
        grpcEndpoint:
          targetUri: unix:mypath
```
<!--End PulumiCodeChooser -->
### Network Security Server Tls Policy Mtls


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";
import * as std from "@pulumi/std";

const project = gcp.organizations.getProject({});
const defaultTrustConfig = new gcp.certificatemanager.TrustConfig("default", {
    name: "my-trust-config",
    description: "sample trust config description",
    location: "global",
    trustStores: [{
        trustAnchors: [{
            pemCertificate: std.file({
                input: "test-fixtures/ca_cert.pem",
            }).then(invoke => invoke.result),
        }],
        intermediateCas: [{
            pemCertificate: std.file({
                input: "test-fixtures/ca_cert.pem",
            }).then(invoke => invoke.result),
        }],
    }],
    labels: {
        foo: "bar",
    },
});
const _default = new gcp.networksecurity.ServerTlsPolicy("default", {
    name: "my-server-tls-policy",
    description: "my description",
    location: "global",
    allowOpen: false,
    mtlsPolicy: {
        clientValidationMode: "REJECT_INVALID",
        clientValidationTrustConfig: pulumi.all([project, defaultTrustConfig.name]).apply(([project, name]) => `projects/${project.number}/locations/global/trustConfigs/${name}`),
    },
    labels: {
        foo: "bar",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp
import pulumi_std as std

project = gcp.organizations.get_project()
default_trust_config = gcp.certificatemanager.TrustConfig("default",
    name="my-trust-config",
    description="sample trust config description",
    location="global",
    trust_stores=[{
        "trust_anchors": [{
            "pem_certificate": std.file(input="test-fixtures/ca_cert.pem").result,
        }],
        "intermediate_cas": [{
            "pem_certificate": std.file(input="test-fixtures/ca_cert.pem").result,
        }],
    }],
    labels={
        "foo": "bar",
    })
default = gcp.networksecurity.ServerTlsPolicy("default",
    name="my-server-tls-policy",
    description="my description",
    location="global",
    allow_open=False,
    mtls_policy={
        "client_validation_mode": "REJECT_INVALID",
        "client_validation_trust_config": default_trust_config.name.apply(lambda name: f"projects/{project.number}/locations/global/trustConfigs/{name}"),
    },
    labels={
        "foo": "bar",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;
using Std = Pulumi.Std;

return await Deployment.RunAsync(() => 
{
    var project = Gcp.Organizations.GetProject.Invoke();

    var defaultTrustConfig = new Gcp.CertificateManager.TrustConfig("default", new()
    {
        Name = "my-trust-config",
        Description = "sample trust config description",
        Location = "global",
        TrustStores = new[]
        {
            new Gcp.CertificateManager.Inputs.TrustConfigTrustStoreArgs
            {
                TrustAnchors = new[]
                {
                    new Gcp.CertificateManager.Inputs.TrustConfigTrustStoreTrustAnchorArgs
                    {
                        PemCertificate = Std.File.Invoke(new()
                        {
                            Input = "test-fixtures/ca_cert.pem",
                        }).Apply(invoke => invoke.Result),
                    },
                },
                IntermediateCas = new[]
                {
                    new Gcp.CertificateManager.Inputs.TrustConfigTrustStoreIntermediateCaArgs
                    {
                        PemCertificate = Std.File.Invoke(new()
                        {
                            Input = "test-fixtures/ca_cert.pem",
                        }).Apply(invoke => invoke.Result),
                    },
                },
            },
        },
        Labels = 
        {
            { "foo", "bar" },
        },
    });

    var @default = new Gcp.NetworkSecurity.ServerTlsPolicy("default", new()
    {
        Name = "my-server-tls-policy",
        Description = "my description",
        Location = "global",
        AllowOpen = false,
        MtlsPolicy = new Gcp.NetworkSecurity.Inputs.ServerTlsPolicyMtlsPolicyArgs
        {
            ClientValidationMode = "REJECT_INVALID",
            ClientValidationTrustConfig = Output.Tuple(project, defaultTrustConfig.Name).Apply(values =>
            {
                var project = values.Item1;
                var name = values.Item2;
                return $"projects/{project.Apply(getProjectResult => getProjectResult.Number)}/locations/global/trustConfigs/{name}";
            }),
        },
        Labels = 
        {
            { "foo", "bar" },
        },
    });

});
```
```go
package main

import (
	"fmt"

	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/certificatemanager"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi-std/sdk/go/std"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		project, err := organizations.LookupProject(ctx, &organizations.LookupProjectArgs{}, nil)
		if err != nil {
			return err
		}
		invokeFile, err := std.File(ctx, &std.FileArgs{
			Input: "test-fixtures/ca_cert.pem",
		}, nil)
		if err != nil {
			return err
		}
		invokeFile1, err := std.File(ctx, &std.FileArgs{
			Input: "test-fixtures/ca_cert.pem",
		}, nil)
		if err != nil {
			return err
		}
		defaultTrustConfig, err := certificatemanager.NewTrustConfig(ctx, "default", &certificatemanager.TrustConfigArgs{
			Name:        pulumi.String("my-trust-config"),
			Description: pulumi.String("sample trust config description"),
			Location:    pulumi.String("global"),
			TrustStores: certificatemanager.TrustConfigTrustStoreArray{
				&certificatemanager.TrustConfigTrustStoreArgs{
					TrustAnchors: certificatemanager.TrustConfigTrustStoreTrustAnchorArray{
						&certificatemanager.TrustConfigTrustStoreTrustAnchorArgs{
							PemCertificate: pulumi.String(invokeFile.Result),
						},
					},
					IntermediateCas: certificatemanager.TrustConfigTrustStoreIntermediateCaArray{
						&certificatemanager.TrustConfigTrustStoreIntermediateCaArgs{
							PemCertificate: pulumi.String(invokeFile1.Result),
						},
					},
				},
			},
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
		})
		if err != nil {
			return err
		}
		_, err = networksecurity.NewServerTlsPolicy(ctx, "default", &networksecurity.ServerTlsPolicyArgs{
			Name:        pulumi.String("my-server-tls-policy"),
			Description: pulumi.String("my description"),
			Location:    pulumi.String("global"),
			AllowOpen:   pulumi.Bool(false),
			MtlsPolicy: &networksecurity.ServerTlsPolicyMtlsPolicyArgs{
				ClientValidationMode: pulumi.String("REJECT_INVALID"),
				ClientValidationTrustConfig: defaultTrustConfig.Name.ApplyT(func(name string) (string, error) {
					return fmt.Sprintf("projects/%v/locations/global/trustConfigs/%v", project.Number, name), nil
				}).(pulumi.StringOutput),
			},
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.organizations.OrganizationsFunctions;
import com.pulumi.gcp.organizations.inputs.GetProjectArgs;
import com.pulumi.gcp.certificatemanager.TrustConfig;
import com.pulumi.gcp.certificatemanager.TrustConfigArgs;
import com.pulumi.gcp.certificatemanager.inputs.TrustConfigTrustStoreArgs;
import com.pulumi.gcp.networksecurity.ServerTlsPolicy;
import com.pulumi.gcp.networksecurity.ServerTlsPolicyArgs;
import com.pulumi.gcp.networksecurity.inputs.ServerTlsPolicyMtlsPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var project = OrganizationsFunctions.getProject();

        var defaultTrustConfig = new TrustConfig("defaultTrustConfig", TrustConfigArgs.builder()
            .name("my-trust-config")
            .description("sample trust config description")
            .location("global")
            .trustStores(TrustConfigTrustStoreArgs.builder()
                .trustAnchors(TrustConfigTrustStoreTrustAnchorArgs.builder()
                    .pemCertificate(StdFunctions.file(FileArgs.builder()
                        .input("test-fixtures/ca_cert.pem")
                        .build()).result())
                    .build())
                .intermediateCas(TrustConfigTrustStoreIntermediateCaArgs.builder()
                    .pemCertificate(StdFunctions.file(FileArgs.builder()
                        .input("test-fixtures/ca_cert.pem")
                        .build()).result())
                    .build())
                .build())
            .labels(Map.of("foo", "bar"))
            .build());

        var default_ = new ServerTlsPolicy("default", ServerTlsPolicyArgs.builder()
            .name("my-server-tls-policy")
            .description("my description")
            .location("global")
            .allowOpen("false")
            .mtlsPolicy(ServerTlsPolicyMtlsPolicyArgs.builder()
                .clientValidationMode("REJECT_INVALID")
                .clientValidationTrustConfig(defaultTrustConfig.name().applyValue(name -> String.format("projects/%s/locations/global/trustConfigs/%s", project.applyValue(getProjectResult -> getProjectResult.number()),name)))
                .build())
            .labels(Map.of("foo", "bar"))
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networksecurity:ServerTlsPolicy
    properties:
      name: my-server-tls-policy
      description: my description
      location: global
      allowOpen: 'false'
      mtlsPolicy:
        clientValidationMode: REJECT_INVALID
        clientValidationTrustConfig: projects/${project.number}/locations/global/trustConfigs/${defaultTrustConfig.name}
      labels:
        foo: bar
  defaultTrustConfig:
    type: gcp:certificatemanager:TrustConfig
    name: default
    properties:
      name: my-trust-config
      description: sample trust config description
      location: global
      trustStores:
        - trustAnchors:
            - pemCertificate:
                fn::invoke:
                  function: std:file
                  arguments:
                    input: test-fixtures/ca_cert.pem
                  return: result
          intermediateCas:
            - pemCertificate:
                fn::invoke:
                  function: std:file
                  arguments:
                    input: test-fixtures/ca_cert.pem
                  return: result
      labels:
        foo: bar
variables:
  project:
    fn::invoke:
      function: gcp:organizations:getProject
      arguments: {}
```
<!--End PulumiCodeChooser -->

## Import

ServerTlsPolicy can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/serverTlsPolicies/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

When using the `pulumi import` command, ServerTlsPolicy can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networksecurity/serverTlsPolicy:ServerTlsPolicy default projects/{{project}}/locations/{{location}}/serverTlsPolicies/{{name}}
```

```sh
$ pulumi import gcp:networksecurity/serverTlsPolicy:ServerTlsPolicy default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:networksecurity/serverTlsPolicy:ServerTlsPolicy default {{location}}/{{name}}
```

Ü
	allowOpenB
 ÚThis field applies only for Traffic Director policies. It is must be set to false for external HTTPS load balancer policies.
Determines if server allows plaintext connections. If set to true, server allows plain text connections. By default, it is set to false. This setting is not exclusive of other encryption modes. For example, if allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections. See documentation of other encryption modes to confirm compatibility.
Consider using it if you wish to upgrade in place your deployment to TLS while having mixed TLS and non-TLS traffic reaching port :80.
Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
ô
labelsB2" ÜSet of label tags associated with the ServerTlsPolicy resource.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
X
locationB" FThe location of the server tls policy.
The default value is `global`.
·

mtlsPolicy{By:w
u
networksecurityServerTlsPolicyMtlsPolicyGgcp:networksecurity/ServerTlsPolicyMtlsPolicy:ServerTlsPolicyMtlsPolicy’This field is required if the policy is used with external HTTPS load balancers. This field can be empty for Traffic Director.
Defines a mechanism to provision peer validation certificates for peer to peer authentication (Mutual TLS - mTLS). If not specified, client certificate will not be requested. The connection is treated as TLS and not mTLS. If allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections.
Structure is documented below.
<
nameB" .Name of the ServerTlsPolicy resource.


- - -
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
€
serverCertificateìBê:ç
ä
networksecurity ServerTlsPolicyServerCertificateUgcp:networksecurity/ServerTlsPolicyServerCertificate:ServerTlsPolicyServerCertificateØDefines a mechanism to provision client identity (public and private keys) for peer to peer authentication. The presence of this dictates mTLS.
Structure is documented below.
"Ü
	allowOpenB
 ÚThis field applies only for Traffic Director policies. It is must be set to false for external HTTPS load balancer policies.
Determines if server allows plaintext connections. If set to true, server allows plain text connections. By default, it is set to false. This setting is not exclusive of other encryption modes. For example, if allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections. See documentation of other encryption modes to confirm compatibility.
Consider using it if you wish to upgrade in place your deployment to TLS while having mixed TLS and non-TLS traffic reaching port :80.
"?

createTime" -Time the ServerTlsPolicy was created in UTC.
"Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"ô
labelsB2" ÜSet of label tags associated with the ServerTlsPolicy resource.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"X
locationB" FThe location of the server tls policy.
The default value is `global`.
"·

mtlsPolicy{By:w
u
networksecurityServerTlsPolicyMtlsPolicyGgcp:networksecurity/ServerTlsPolicyMtlsPolicy:ServerTlsPolicyMtlsPolicy’This field is required if the policy is used with external HTTPS load balancers. This field can be empty for Traffic Director.
Defines a mechanism to provision peer validation certificates for peer to peer authentication (Mutual TLS - mTLS). If not specified, client certificate will not be requested. The connection is treated as TLS and not mTLS. If allowOpen and mtlsPolicy are set, server allows both plain text and mTLS connections.
Structure is documented below.
":
name" .Name of the ServerTlsPolicy resource.


- - -
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"€
serverCertificateìBê:ç
ä
networksecurity ServerTlsPolicyServerCertificateUgcp:networksecurity/ServerTlsPolicyServerCertificate:ServerTlsPolicyServerCertificateØDefines a mechanism to provision client identity (public and private keys) for peer to peer authentication. The presence of this dictates mTLS.
Structure is documented below.
"?

updateTime" -Time the ServerTlsPolicy was updated in UTC.
*¨‘
c
networksecurityTlsInspectionPolicy;gcp:networksecurity/tlsInspectionPolicy:TlsInspectionPolicy—©The TlsInspectionPolicy resource contains references to CA pools in Certificate Authority Service and associated metadata.


To get more information about TlsInspectionPolicy, see:

* [API documentation](https://cloud.google.com/secure-web-proxy/docs/reference/network-security/rest/v1/projects.locations.tlsInspectionPolicies)
* How-to Guides
    * [Use TlsInspectionPolicy](https://cloud.google.com/secure-web-proxy/docs/tls-inspection-overview)

## Example Usage

### Network Security Tls Inspection Policy Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.certificateauthority.CaPool("default", {
    name: "my-basic-ca-pool",
    location: "us-central1",
    tier: "DEVOPS",
    publishingOptions: {
        publishCaCert: false,
        publishCrl: false,
    },
    issuancePolicy: {
        maximumLifetime: "1209600s",
        baselineValues: {
            caOptions: {
                isCa: false,
            },
            keyUsage: {
                baseKeyUsage: {},
                extendedKeyUsage: {
                    serverAuth: true,
                },
            },
        },
    },
});
const defaultAuthority = new gcp.certificateauthority.Authority("default", {
    pool: _default.name,
    certificateAuthorityId: "my-basic-certificate-authority",
    location: "us-central1",
    lifetime: "86400s",
    type: "SELF_SIGNED",
    deletionProtection: false,
    skipGracePeriod: true,
    ignoreActiveCertificatesOnDeletion: true,
    config: {
        subjectConfig: {
            subject: {
                organization: "Test LLC",
                commonName: "my-ca",
            },
        },
        x509Config: {
            caOptions: {
                isCa: true,
            },
            keyUsage: {
                baseKeyUsage: {
                    certSign: true,
                    crlSign: true,
                },
                extendedKeyUsage: {
                    serverAuth: false,
                },
            },
        },
    },
    keySpec: {
        algorithm: "RSA_PKCS1_4096_SHA256",
    },
});
const project = gcp.organizations.getProject({});
const tlsInspectionPermission = new gcp.certificateauthority.CaPoolIamMember("tls_inspection_permission", {
    caPool: _default.id,
    role: "roles/privateca.certificateManager",
    member: project.then(project => `serviceAccount:service-${project.number}@gcp-sa-networksecurity.iam.gserviceaccount.com`),
});
const defaultTlsInspectionPolicy = new gcp.networksecurity.TlsInspectionPolicy("default", {
    name: "my-tls-inspection-policy",
    location: "us-central1",
    caPool: _default.id,
    excludePublicCaSet: false,
}, {
    dependsOn: [
        _default,
        defaultAuthority,
        tlsInspectionPermission,
    ],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.certificateauthority.CaPool("default",
    name="my-basic-ca-pool",
    location="us-central1",
    tier="DEVOPS",
    publishing_options={
        "publish_ca_cert": False,
        "publish_crl": False,
    },
    issuance_policy={
        "maximum_lifetime": "1209600s",
        "baseline_values": {
            "ca_options": {
                "is_ca": False,
            },
            "key_usage": {
                "base_key_usage": {},
                "extended_key_usage": {
                    "server_auth": True,
                },
            },
        },
    })
default_authority = gcp.certificateauthority.Authority("default",
    pool=default.name,
    certificate_authority_id="my-basic-certificate-authority",
    location="us-central1",
    lifetime="86400s",
    type="SELF_SIGNED",
    deletion_protection=False,
    skip_grace_period=True,
    ignore_active_certificates_on_deletion=True,
    config={
        "subject_config": {
            "subject": {
                "organization": "Test LLC",
                "common_name": "my-ca",
            },
        },
        "x509_config": {
            "ca_options": {
                "is_ca": True,
            },
            "key_usage": {
                "base_key_usage": {
                    "cert_sign": True,
                    "crl_sign": True,
                },
                "extended_key_usage": {
                    "server_auth": False,
                },
            },
        },
    },
    key_spec={
        "algorithm": "RSA_PKCS1_4096_SHA256",
    })
project = gcp.organizations.get_project()
tls_inspection_permission = gcp.certificateauthority.CaPoolIamMember("tls_inspection_permission",
    ca_pool=default.id,
    role="roles/privateca.certificateManager",
    member=f"serviceAccount:service-{project.number}@gcp-sa-networksecurity.iam.gserviceaccount.com")
default_tls_inspection_policy = gcp.networksecurity.TlsInspectionPolicy("default",
    name="my-tls-inspection-policy",
    location="us-central1",
    ca_pool=default.id,
    exclude_public_ca_set=False,
    opts = pulumi.ResourceOptions(depends_on=[
            default,
            default_authority,
            tls_inspection_permission,
        ]))
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.CertificateAuthority.CaPool("default", new()
    {
        Name = "my-basic-ca-pool",
        Location = "us-central1",
        Tier = "DEVOPS",
        PublishingOptions = new Gcp.CertificateAuthority.Inputs.CaPoolPublishingOptionsArgs
        {
            PublishCaCert = false,
            PublishCrl = false,
        },
        IssuancePolicy = new Gcp.CertificateAuthority.Inputs.CaPoolIssuancePolicyArgs
        {
            MaximumLifetime = "1209600s",
            BaselineValues = new Gcp.CertificateAuthority.Inputs.CaPoolIssuancePolicyBaselineValuesArgs
            {
                CaOptions = new Gcp.CertificateAuthority.Inputs.CaPoolIssuancePolicyBaselineValuesCaOptionsArgs
                {
                    IsCa = false,
                },
                KeyUsage = new Gcp.CertificateAuthority.Inputs.CaPoolIssuancePolicyBaselineValuesKeyUsageArgs
                {
                    BaseKeyUsage = null,
                    ExtendedKeyUsage = new Gcp.CertificateAuthority.Inputs.CaPoolIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsageArgs
                    {
                        ServerAuth = true,
                    },
                },
            },
        },
    });

    var defaultAuthority = new Gcp.CertificateAuthority.Authority("default", new()
    {
        Pool = @default.Name,
        CertificateAuthorityId = "my-basic-certificate-authority",
        Location = "us-central1",
        Lifetime = "86400s",
        Type = "SELF_SIGNED",
        DeletionProtection = false,
        SkipGracePeriod = true,
        IgnoreActiveCertificatesOnDeletion = true,
        Config = new Gcp.CertificateAuthority.Inputs.AuthorityConfigArgs
        {
            SubjectConfig = new Gcp.CertificateAuthority.Inputs.AuthorityConfigSubjectConfigArgs
            {
                Subject = new Gcp.CertificateAuthority.Inputs.AuthorityConfigSubjectConfigSubjectArgs
                {
                    Organization = "Test LLC",
                    CommonName = "my-ca",
                },
            },
            X509Config = new Gcp.CertificateAuthority.Inputs.AuthorityConfigX509ConfigArgs
            {
                CaOptions = new Gcp.CertificateAuthority.Inputs.AuthorityConfigX509ConfigCaOptionsArgs
                {
                    IsCa = true,
                },
                KeyUsage = new Gcp.CertificateAuthority.Inputs.AuthorityConfigX509ConfigKeyUsageArgs
                {
                    BaseKeyUsage = new Gcp.CertificateAuthority.Inputs.AuthorityConfigX509ConfigKeyUsageBaseKeyUsageArgs
                    {
                        CertSign = true,
                        CrlSign = true,
                    },
                    ExtendedKeyUsage = new Gcp.CertificateAuthority.Inputs.AuthorityConfigX509ConfigKeyUsageExtendedKeyUsageArgs
                    {
                        ServerAuth = false,
                    },
                },
            },
        },
        KeySpec = new Gcp.CertificateAuthority.Inputs.AuthorityKeySpecArgs
        {
            Algorithm = "RSA_PKCS1_4096_SHA256",
        },
    });

    var project = Gcp.Organizations.GetProject.Invoke();

    var tlsInspectionPermission = new Gcp.CertificateAuthority.CaPoolIamMember("tls_inspection_permission", new()
    {
        CaPool = @default.Id,
        Role = "roles/privateca.certificateManager",
        Member = $"serviceAccount:service-{project.Apply(getProjectResult => getProjectResult.Number)}@gcp-sa-networksecurity.iam.gserviceaccount.com",
    });

    var defaultTlsInspectionPolicy = new Gcp.NetworkSecurity.TlsInspectionPolicy("default", new()
    {
        Name = "my-tls-inspection-policy",
        Location = "us-central1",
        CaPool = @default.Id,
        ExcludePublicCaSet = false,
    }, new CustomResourceOptions
    {
        DependsOn =
        {
            @default,
            defaultAuthority,
            tlsInspectionPermission,
        },
    });

});
```
```go
package main

import (
	"fmt"

	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/certificateauthority"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := certificateauthority.NewCaPool(ctx, "default", &certificateauthority.CaPoolArgs{
			Name:     pulumi.String("my-basic-ca-pool"),
			Location: pulumi.String("us-central1"),
			Tier:     pulumi.String("DEVOPS"),
			PublishingOptions: &certificateauthority.CaPoolPublishingOptionsArgs{
				PublishCaCert: pulumi.Bool(false),
				PublishCrl:    pulumi.Bool(false),
			},
			IssuancePolicy: &certificateauthority.CaPoolIssuancePolicyArgs{
				MaximumLifetime: pulumi.String("1209600s"),
				BaselineValues: &certificateauthority.CaPoolIssuancePolicyBaselineValuesArgs{
					CaOptions: &certificateauthority.CaPoolIssuancePolicyBaselineValuesCaOptionsArgs{
						IsCa: pulumi.Bool(false),
					},
					KeyUsage: &certificateauthority.CaPoolIssuancePolicyBaselineValuesKeyUsageArgs{
						BaseKeyUsage: &certificateauthority.CaPoolIssuancePolicyBaselineValuesKeyUsageBaseKeyUsageArgs{},
						ExtendedKeyUsage: &certificateauthority.CaPoolIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsageArgs{
							ServerAuth: pulumi.Bool(true),
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		defaultAuthority, err := certificateauthority.NewAuthority(ctx, "default", &certificateauthority.AuthorityArgs{
			Pool:                               _default.Name,
			CertificateAuthorityId:             pulumi.String("my-basic-certificate-authority"),
			Location:                           pulumi.String("us-central1"),
			Lifetime:                           pulumi.String("86400s"),
			Type:                               pulumi.String("SELF_SIGNED"),
			DeletionProtection:                 pulumi.Bool(false),
			SkipGracePeriod:                    pulumi.Bool(true),
			IgnoreActiveCertificatesOnDeletion: pulumi.Bool(true),
			Config: &certificateauthority.AuthorityConfigArgs{
				SubjectConfig: &certificateauthority.AuthorityConfigSubjectConfigArgs{
					Subject: &certificateauthority.AuthorityConfigSubjectConfigSubjectArgs{
						Organization: pulumi.String("Test LLC"),
						CommonName:   pulumi.String("my-ca"),
					},
				},
				X509Config: &certificateauthority.AuthorityConfigX509ConfigArgs{
					CaOptions: &certificateauthority.AuthorityConfigX509ConfigCaOptionsArgs{
						IsCa: pulumi.Bool(true),
					},
					KeyUsage: &certificateauthority.AuthorityConfigX509ConfigKeyUsageArgs{
						BaseKeyUsage: &certificateauthority.AuthorityConfigX509ConfigKeyUsageBaseKeyUsageArgs{
							CertSign: pulumi.Bool(true),
							CrlSign:  pulumi.Bool(true),
						},
						ExtendedKeyUsage: &certificateauthority.AuthorityConfigX509ConfigKeyUsageExtendedKeyUsageArgs{
							ServerAuth: pulumi.Bool(false),
						},
					},
				},
			},
			KeySpec: &certificateauthority.AuthorityKeySpecArgs{
				Algorithm: pulumi.String("RSA_PKCS1_4096_SHA256"),
			},
		})
		if err != nil {
			return err
		}
		project, err := organizations.LookupProject(ctx, &organizations.LookupProjectArgs{}, nil)
		if err != nil {
			return err
		}
		tlsInspectionPermission, err := certificateauthority.NewCaPoolIamMember(ctx, "tls_inspection_permission", &certificateauthority.CaPoolIamMemberArgs{
			CaPool: _default.ID(),
			Role:   pulumi.String("roles/privateca.certificateManager"),
			Member: pulumi.Sprintf("serviceAccount:service-%v@gcp-sa-networksecurity.iam.gserviceaccount.com", project.Number),
		})
		if err != nil {
			return err
		}
		_, err = networksecurity.NewTlsInspectionPolicy(ctx, "default", &networksecurity.TlsInspectionPolicyArgs{
			Name:               pulumi.String("my-tls-inspection-policy"),
			Location:           pulumi.String("us-central1"),
			CaPool:             _default.ID(),
			ExcludePublicCaSet: pulumi.Bool(false),
		}, pulumi.DependsOn([]pulumi.Resource{
			_default,
			defaultAuthority,
			tlsInspectionPermission,
		}))
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.certificateauthority.CaPool;
import com.pulumi.gcp.certificateauthority.CaPoolArgs;
import com.pulumi.gcp.certificateauthority.inputs.CaPoolPublishingOptionsArgs;
import com.pulumi.gcp.certificateauthority.inputs.CaPoolIssuancePolicyArgs;
import com.pulumi.gcp.certificateauthority.inputs.CaPoolIssuancePolicyBaselineValuesArgs;
import com.pulumi.gcp.certificateauthority.inputs.CaPoolIssuancePolicyBaselineValuesCaOptionsArgs;
import com.pulumi.gcp.certificateauthority.inputs.CaPoolIssuancePolicyBaselineValuesKeyUsageArgs;
import com.pulumi.gcp.certificateauthority.inputs.CaPoolIssuancePolicyBaselineValuesKeyUsageBaseKeyUsageArgs;
import com.pulumi.gcp.certificateauthority.inputs.CaPoolIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsageArgs;
import com.pulumi.gcp.certificateauthority.Authority;
import com.pulumi.gcp.certificateauthority.AuthorityArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigSubjectConfigArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigSubjectConfigSubjectArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigX509ConfigArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigX509ConfigCaOptionsArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigX509ConfigKeyUsageArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigX509ConfigKeyUsageBaseKeyUsageArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigX509ConfigKeyUsageExtendedKeyUsageArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityKeySpecArgs;
import com.pulumi.gcp.organizations.OrganizationsFunctions;
import com.pulumi.gcp.organizations.inputs.GetProjectArgs;
import com.pulumi.gcp.certificateauthority.CaPoolIamMember;
import com.pulumi.gcp.certificateauthority.CaPoolIamMemberArgs;
import com.pulumi.gcp.networksecurity.TlsInspectionPolicy;
import com.pulumi.gcp.networksecurity.TlsInspectionPolicyArgs;
import com.pulumi.resources.CustomResourceOptions;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new CaPool("default", CaPoolArgs.builder()
            .name("my-basic-ca-pool")
            .location("us-central1")
            .tier("DEVOPS")
            .publishingOptions(CaPoolPublishingOptionsArgs.builder()
                .publishCaCert(false)
                .publishCrl(false)
                .build())
            .issuancePolicy(CaPoolIssuancePolicyArgs.builder()
                .maximumLifetime("1209600s")
                .baselineValues(CaPoolIssuancePolicyBaselineValuesArgs.builder()
                    .caOptions(CaPoolIssuancePolicyBaselineValuesCaOptionsArgs.builder()
                        .isCa(false)
                        .build())
                    .keyUsage(CaPoolIssuancePolicyBaselineValuesKeyUsageArgs.builder()
                        .baseKeyUsage()
                        .extendedKeyUsage(CaPoolIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsageArgs.builder()
                            .serverAuth(true)
                            .build())
                        .build())
                    .build())
                .build())
            .build());

        var defaultAuthority = new Authority("defaultAuthority", AuthorityArgs.builder()
            .pool(default_.name())
            .certificateAuthorityId("my-basic-certificate-authority")
            .location("us-central1")
            .lifetime("86400s")
            .type("SELF_SIGNED")
            .deletionProtection(false)
            .skipGracePeriod(true)
            .ignoreActiveCertificatesOnDeletion(true)
            .config(AuthorityConfigArgs.builder()
                .subjectConfig(AuthorityConfigSubjectConfigArgs.builder()
                    .subject(AuthorityConfigSubjectConfigSubjectArgs.builder()
                        .organization("Test LLC")
                        .commonName("my-ca")
                        .build())
                    .build())
                .x509Config(AuthorityConfigX509ConfigArgs.builder()
                    .caOptions(AuthorityConfigX509ConfigCaOptionsArgs.builder()
                        .isCa(true)
                        .build())
                    .keyUsage(AuthorityConfigX509ConfigKeyUsageArgs.builder()
                        .baseKeyUsage(AuthorityConfigX509ConfigKeyUsageBaseKeyUsageArgs.builder()
                            .certSign(true)
                            .crlSign(true)
                            .build())
                        .extendedKeyUsage(AuthorityConfigX509ConfigKeyUsageExtendedKeyUsageArgs.builder()
                            .serverAuth(false)
                            .build())
                        .build())
                    .build())
                .build())
            .keySpec(AuthorityKeySpecArgs.builder()
                .algorithm("RSA_PKCS1_4096_SHA256")
                .build())
            .build());

        final var project = OrganizationsFunctions.getProject();

        var tlsInspectionPermission = new CaPoolIamMember("tlsInspectionPermission", CaPoolIamMemberArgs.builder()
            .caPool(default_.id())
            .role("roles/privateca.certificateManager")
            .member(String.format("serviceAccount:service-%s@gcp-sa-networksecurity.iam.gserviceaccount.com", project.applyValue(getProjectResult -> getProjectResult.number())))
            .build());

        var defaultTlsInspectionPolicy = new TlsInspectionPolicy("defaultTlsInspectionPolicy", TlsInspectionPolicyArgs.builder()
            .name("my-tls-inspection-policy")
            .location("us-central1")
            .caPool(default_.id())
            .excludePublicCaSet(false)
            .build(), CustomResourceOptions.builder()
                .dependsOn(                
                    default_,
                    defaultAuthority,
                    tlsInspectionPermission)
                .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:certificateauthority:CaPool
    properties:
      name: my-basic-ca-pool
      location: us-central1
      tier: DEVOPS
      publishingOptions:
        publishCaCert: false
        publishCrl: false
      issuancePolicy:
        maximumLifetime: 1209600s
        baselineValues:
          caOptions:
            isCa: false
          keyUsage:
            baseKeyUsage: {}
            extendedKeyUsage:
              serverAuth: true
  defaultAuthority:
    type: gcp:certificateauthority:Authority
    name: default
    properties:
      pool: ${default.name}
      certificateAuthorityId: my-basic-certificate-authority
      location: us-central1
      lifetime: 86400s
      type: SELF_SIGNED
      deletionProtection: false
      skipGracePeriod: true
      ignoreActiveCertificatesOnDeletion: true
      config:
        subjectConfig:
          subject:
            organization: Test LLC
            commonName: my-ca
        x509Config:
          caOptions:
            isCa: true
          keyUsage:
            baseKeyUsage:
              certSign: true
              crlSign: true
            extendedKeyUsage:
              serverAuth: false
      keySpec:
        algorithm: RSA_PKCS1_4096_SHA256
  tlsInspectionPermission:
    type: gcp:certificateauthority:CaPoolIamMember
    name: tls_inspection_permission
    properties:
      caPool: ${default.id}
      role: roles/privateca.certificateManager
      member: serviceAccount:service-${project.number}@gcp-sa-networksecurity.iam.gserviceaccount.com
  defaultTlsInspectionPolicy:
    type: gcp:networksecurity:TlsInspectionPolicy
    name: default
    properties:
      name: my-tls-inspection-policy
      location: us-central1
      caPool: ${default.id}
      excludePublicCaSet: false
    options:
      dependsOn:
        - ${default}
        - ${defaultAuthority}
        - ${tlsInspectionPermission}
variables:
  project:
    fn::invoke:
      function: gcp:organizations:getProject
      arguments: {}
```
<!--End PulumiCodeChooser -->
### Network Security Tls Inspection Policy Custom


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";
import * as std from "@pulumi/std";

const _default = new gcp.certificateauthority.CaPool("default", {
    name: "my-basic-ca-pool",
    location: "us-central1",
    tier: "DEVOPS",
    publishingOptions: {
        publishCaCert: false,
        publishCrl: false,
    },
    issuancePolicy: {
        maximumLifetime: "1209600s",
        baselineValues: {
            caOptions: {
                isCa: false,
            },
            keyUsage: {
                baseKeyUsage: {},
                extendedKeyUsage: {
                    serverAuth: true,
                },
            },
        },
    },
});
const defaultAuthority = new gcp.certificateauthority.Authority("default", {
    pool: _default.name,
    certificateAuthorityId: "my-basic-certificate-authority",
    location: "us-central1",
    lifetime: "86400s",
    type: "SELF_SIGNED",
    deletionProtection: false,
    skipGracePeriod: true,
    ignoreActiveCertificatesOnDeletion: true,
    config: {
        subjectConfig: {
            subject: {
                organization: "Test LLC",
                commonName: "my-ca",
            },
        },
        x509Config: {
            caOptions: {
                isCa: true,
            },
            keyUsage: {
                baseKeyUsage: {
                    certSign: true,
                    crlSign: true,
                },
                extendedKeyUsage: {
                    serverAuth: false,
                },
            },
        },
    },
    keySpec: {
        algorithm: "RSA_PKCS1_4096_SHA256",
    },
});
const nsSa = new gcp.projects.ServiceIdentity("ns_sa", {service: "networksecurity.googleapis.com"});
const defaultCaPoolIamMember = new gcp.certificateauthority.CaPoolIamMember("default", {
    caPool: _default.id,
    role: "roles/privateca.certificateManager",
    member: nsSa.member,
});
const defaultTrustConfig = new gcp.certificatemanager.TrustConfig("default", {
    name: "my-trust-config",
    description: "sample trust config description",
    location: "us-central1",
    trustStores: [{
        trustAnchors: [{
            pemCertificate: std.file({
                input: "test-fixtures/ca_cert.pem",
            }).then(invoke => invoke.result),
        }],
        intermediateCas: [{
            pemCertificate: std.file({
                input: "test-fixtures/ca_cert.pem",
            }).then(invoke => invoke.result),
        }],
    }],
});
const defaultTlsInspectionPolicy = new gcp.networksecurity.TlsInspectionPolicy("default", {
    name: "my-tls-inspection-policy",
    location: "us-central1",
    caPool: _default.id,
    excludePublicCaSet: false,
    minTlsVersion: "TLS_1_0",
    trustConfig: defaultTrustConfig.id,
    tlsFeatureProfile: "PROFILE_CUSTOM",
    customTlsFeatures: [
        "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
        "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
        "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
        "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
        "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",
        "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
        "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
        "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
        "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
        "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
        "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
        "TLS_RSA_WITH_AES_128_CBC_SHA",
        "TLS_RSA_WITH_AES_128_GCM_SHA256",
        "TLS_RSA_WITH_AES_256_CBC_SHA",
        "TLS_RSA_WITH_AES_256_GCM_SHA384",
    ],
}, {
    dependsOn: [
        defaultAuthority,
        defaultCaPoolIamMember,
    ],
});
```
```python
import pulumi
import pulumi_gcp as gcp
import pulumi_std as std

default = gcp.certificateauthority.CaPool("default",
    name="my-basic-ca-pool",
    location="us-central1",
    tier="DEVOPS",
    publishing_options={
        "publish_ca_cert": False,
        "publish_crl": False,
    },
    issuance_policy={
        "maximum_lifetime": "1209600s",
        "baseline_values": {
            "ca_options": {
                "is_ca": False,
            },
            "key_usage": {
                "base_key_usage": {},
                "extended_key_usage": {
                    "server_auth": True,
                },
            },
        },
    })
default_authority = gcp.certificateauthority.Authority("default",
    pool=default.name,
    certificate_authority_id="my-basic-certificate-authority",
    location="us-central1",
    lifetime="86400s",
    type="SELF_SIGNED",
    deletion_protection=False,
    skip_grace_period=True,
    ignore_active_certificates_on_deletion=True,
    config={
        "subject_config": {
            "subject": {
                "organization": "Test LLC",
                "common_name": "my-ca",
            },
        },
        "x509_config": {
            "ca_options": {
                "is_ca": True,
            },
            "key_usage": {
                "base_key_usage": {
                    "cert_sign": True,
                    "crl_sign": True,
                },
                "extended_key_usage": {
                    "server_auth": False,
                },
            },
        },
    },
    key_spec={
        "algorithm": "RSA_PKCS1_4096_SHA256",
    })
ns_sa = gcp.projects.ServiceIdentity("ns_sa", service="networksecurity.googleapis.com")
default_ca_pool_iam_member = gcp.certificateauthority.CaPoolIamMember("default",
    ca_pool=default.id,
    role="roles/privateca.certificateManager",
    member=ns_sa.member)
default_trust_config = gcp.certificatemanager.TrustConfig("default",
    name="my-trust-config",
    description="sample trust config description",
    location="us-central1",
    trust_stores=[{
        "trust_anchors": [{
            "pem_certificate": std.file(input="test-fixtures/ca_cert.pem").result,
        }],
        "intermediate_cas": [{
            "pem_certificate": std.file(input="test-fixtures/ca_cert.pem").result,
        }],
    }])
default_tls_inspection_policy = gcp.networksecurity.TlsInspectionPolicy("default",
    name="my-tls-inspection-policy",
    location="us-central1",
    ca_pool=default.id,
    exclude_public_ca_set=False,
    min_tls_version="TLS_1_0",
    trust_config=default_trust_config.id,
    tls_feature_profile="PROFILE_CUSTOM",
    custom_tls_features=[
        "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
        "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
        "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
        "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
        "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",
        "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
        "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
        "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
        "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
        "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
        "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
        "TLS_RSA_WITH_AES_128_CBC_SHA",
        "TLS_RSA_WITH_AES_128_GCM_SHA256",
        "TLS_RSA_WITH_AES_256_CBC_SHA",
        "TLS_RSA_WITH_AES_256_GCM_SHA384",
    ],
    opts = pulumi.ResourceOptions(depends_on=[
            default_authority,
            default_ca_pool_iam_member,
        ]))
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;
using Std = Pulumi.Std;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.CertificateAuthority.CaPool("default", new()
    {
        Name = "my-basic-ca-pool",
        Location = "us-central1",
        Tier = "DEVOPS",
        PublishingOptions = new Gcp.CertificateAuthority.Inputs.CaPoolPublishingOptionsArgs
        {
            PublishCaCert = false,
            PublishCrl = false,
        },
        IssuancePolicy = new Gcp.CertificateAuthority.Inputs.CaPoolIssuancePolicyArgs
        {
            MaximumLifetime = "1209600s",
            BaselineValues = new Gcp.CertificateAuthority.Inputs.CaPoolIssuancePolicyBaselineValuesArgs
            {
                CaOptions = new Gcp.CertificateAuthority.Inputs.CaPoolIssuancePolicyBaselineValuesCaOptionsArgs
                {
                    IsCa = false,
                },
                KeyUsage = new Gcp.CertificateAuthority.Inputs.CaPoolIssuancePolicyBaselineValuesKeyUsageArgs
                {
                    BaseKeyUsage = null,
                    ExtendedKeyUsage = new Gcp.CertificateAuthority.Inputs.CaPoolIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsageArgs
                    {
                        ServerAuth = true,
                    },
                },
            },
        },
    });

    var defaultAuthority = new Gcp.CertificateAuthority.Authority("default", new()
    {
        Pool = @default.Name,
        CertificateAuthorityId = "my-basic-certificate-authority",
        Location = "us-central1",
        Lifetime = "86400s",
        Type = "SELF_SIGNED",
        DeletionProtection = false,
        SkipGracePeriod = true,
        IgnoreActiveCertificatesOnDeletion = true,
        Config = new Gcp.CertificateAuthority.Inputs.AuthorityConfigArgs
        {
            SubjectConfig = new Gcp.CertificateAuthority.Inputs.AuthorityConfigSubjectConfigArgs
            {
                Subject = new Gcp.CertificateAuthority.Inputs.AuthorityConfigSubjectConfigSubjectArgs
                {
                    Organization = "Test LLC",
                    CommonName = "my-ca",
                },
            },
            X509Config = new Gcp.CertificateAuthority.Inputs.AuthorityConfigX509ConfigArgs
            {
                CaOptions = new Gcp.CertificateAuthority.Inputs.AuthorityConfigX509ConfigCaOptionsArgs
                {
                    IsCa = true,
                },
                KeyUsage = new Gcp.CertificateAuthority.Inputs.AuthorityConfigX509ConfigKeyUsageArgs
                {
                    BaseKeyUsage = new Gcp.CertificateAuthority.Inputs.AuthorityConfigX509ConfigKeyUsageBaseKeyUsageArgs
                    {
                        CertSign = true,
                        CrlSign = true,
                    },
                    ExtendedKeyUsage = new Gcp.CertificateAuthority.Inputs.AuthorityConfigX509ConfigKeyUsageExtendedKeyUsageArgs
                    {
                        ServerAuth = false,
                    },
                },
            },
        },
        KeySpec = new Gcp.CertificateAuthority.Inputs.AuthorityKeySpecArgs
        {
            Algorithm = "RSA_PKCS1_4096_SHA256",
        },
    });

    var nsSa = new Gcp.Projects.ServiceIdentity("ns_sa", new()
    {
        Service = "networksecurity.googleapis.com",
    });

    var defaultCaPoolIamMember = new Gcp.CertificateAuthority.CaPoolIamMember("default", new()
    {
        CaPool = @default.Id,
        Role = "roles/privateca.certificateManager",
        Member = nsSa.Member,
    });

    var defaultTrustConfig = new Gcp.CertificateManager.TrustConfig("default", new()
    {
        Name = "my-trust-config",
        Description = "sample trust config description",
        Location = "us-central1",
        TrustStores = new[]
        {
            new Gcp.CertificateManager.Inputs.TrustConfigTrustStoreArgs
            {
                TrustAnchors = new[]
                {
                    new Gcp.CertificateManager.Inputs.TrustConfigTrustStoreTrustAnchorArgs
                    {
                        PemCertificate = Std.File.Invoke(new()
                        {
                            Input = "test-fixtures/ca_cert.pem",
                        }).Apply(invoke => invoke.Result),
                    },
                },
                IntermediateCas = new[]
                {
                    new Gcp.CertificateManager.Inputs.TrustConfigTrustStoreIntermediateCaArgs
                    {
                        PemCertificate = Std.File.Invoke(new()
                        {
                            Input = "test-fixtures/ca_cert.pem",
                        }).Apply(invoke => invoke.Result),
                    },
                },
            },
        },
    });

    var defaultTlsInspectionPolicy = new Gcp.NetworkSecurity.TlsInspectionPolicy("default", new()
    {
        Name = "my-tls-inspection-policy",
        Location = "us-central1",
        CaPool = @default.Id,
        ExcludePublicCaSet = false,
        MinTlsVersion = "TLS_1_0",
        TrustConfig = defaultTrustConfig.Id,
        TlsFeatureProfile = "PROFILE_CUSTOM",
        CustomTlsFeatures = new[]
        {
            "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
            "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
            "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
            "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
            "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",
            "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
            "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
            "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
            "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
            "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
            "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
            "TLS_RSA_WITH_AES_128_CBC_SHA",
            "TLS_RSA_WITH_AES_128_GCM_SHA256",
            "TLS_RSA_WITH_AES_256_CBC_SHA",
            "TLS_RSA_WITH_AES_256_GCM_SHA384",
        },
    }, new CustomResourceOptions
    {
        DependsOn =
        {
            defaultAuthority,
            defaultCaPoolIamMember,
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/certificateauthority"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/certificatemanager"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/projects"
	"github.com/pulumi/pulumi-std/sdk/go/std"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := certificateauthority.NewCaPool(ctx, "default", &certificateauthority.CaPoolArgs{
			Name:     pulumi.String("my-basic-ca-pool"),
			Location: pulumi.String("us-central1"),
			Tier:     pulumi.String("DEVOPS"),
			PublishingOptions: &certificateauthority.CaPoolPublishingOptionsArgs{
				PublishCaCert: pulumi.Bool(false),
				PublishCrl:    pulumi.Bool(false),
			},
			IssuancePolicy: &certificateauthority.CaPoolIssuancePolicyArgs{
				MaximumLifetime: pulumi.String("1209600s"),
				BaselineValues: &certificateauthority.CaPoolIssuancePolicyBaselineValuesArgs{
					CaOptions: &certificateauthority.CaPoolIssuancePolicyBaselineValuesCaOptionsArgs{
						IsCa: pulumi.Bool(false),
					},
					KeyUsage: &certificateauthority.CaPoolIssuancePolicyBaselineValuesKeyUsageArgs{
						BaseKeyUsage: &certificateauthority.CaPoolIssuancePolicyBaselineValuesKeyUsageBaseKeyUsageArgs{},
						ExtendedKeyUsage: &certificateauthority.CaPoolIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsageArgs{
							ServerAuth: pulumi.Bool(true),
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		defaultAuthority, err := certificateauthority.NewAuthority(ctx, "default", &certificateauthority.AuthorityArgs{
			Pool:                               _default.Name,
			CertificateAuthorityId:             pulumi.String("my-basic-certificate-authority"),
			Location:                           pulumi.String("us-central1"),
			Lifetime:                           pulumi.String("86400s"),
			Type:                               pulumi.String("SELF_SIGNED"),
			DeletionProtection:                 pulumi.Bool(false),
			SkipGracePeriod:                    pulumi.Bool(true),
			IgnoreActiveCertificatesOnDeletion: pulumi.Bool(true),
			Config: &certificateauthority.AuthorityConfigArgs{
				SubjectConfig: &certificateauthority.AuthorityConfigSubjectConfigArgs{
					Subject: &certificateauthority.AuthorityConfigSubjectConfigSubjectArgs{
						Organization: pulumi.String("Test LLC"),
						CommonName:   pulumi.String("my-ca"),
					},
				},
				X509Config: &certificateauthority.AuthorityConfigX509ConfigArgs{
					CaOptions: &certificateauthority.AuthorityConfigX509ConfigCaOptionsArgs{
						IsCa: pulumi.Bool(true),
					},
					KeyUsage: &certificateauthority.AuthorityConfigX509ConfigKeyUsageArgs{
						BaseKeyUsage: &certificateauthority.AuthorityConfigX509ConfigKeyUsageBaseKeyUsageArgs{
							CertSign: pulumi.Bool(true),
							CrlSign:  pulumi.Bool(true),
						},
						ExtendedKeyUsage: &certificateauthority.AuthorityConfigX509ConfigKeyUsageExtendedKeyUsageArgs{
							ServerAuth: pulumi.Bool(false),
						},
					},
				},
			},
			KeySpec: &certificateauthority.AuthorityKeySpecArgs{
				Algorithm: pulumi.String("RSA_PKCS1_4096_SHA256"),
			},
		})
		if err != nil {
			return err
		}
		nsSa, err := projects.NewServiceIdentity(ctx, "ns_sa", &projects.ServiceIdentityArgs{
			Service: pulumi.String("networksecurity.googleapis.com"),
		})
		if err != nil {
			return err
		}
		defaultCaPoolIamMember, err := certificateauthority.NewCaPoolIamMember(ctx, "default", &certificateauthority.CaPoolIamMemberArgs{
			CaPool: _default.ID(),
			Role:   pulumi.String("roles/privateca.certificateManager"),
			Member: nsSa.Member,
		})
		if err != nil {
			return err
		}
		invokeFile, err := std.File(ctx, &std.FileArgs{
			Input: "test-fixtures/ca_cert.pem",
		}, nil)
		if err != nil {
			return err
		}
		invokeFile1, err := std.File(ctx, &std.FileArgs{
			Input: "test-fixtures/ca_cert.pem",
		}, nil)
		if err != nil {
			return err
		}
		defaultTrustConfig, err := certificatemanager.NewTrustConfig(ctx, "default", &certificatemanager.TrustConfigArgs{
			Name:        pulumi.String("my-trust-config"),
			Description: pulumi.String("sample trust config description"),
			Location:    pulumi.String("us-central1"),
			TrustStores: certificatemanager.TrustConfigTrustStoreArray{
				&certificatemanager.TrustConfigTrustStoreArgs{
					TrustAnchors: certificatemanager.TrustConfigTrustStoreTrustAnchorArray{
						&certificatemanager.TrustConfigTrustStoreTrustAnchorArgs{
							PemCertificate: pulumi.String(invokeFile.Result),
						},
					},
					IntermediateCas: certificatemanager.TrustConfigTrustStoreIntermediateCaArray{
						&certificatemanager.TrustConfigTrustStoreIntermediateCaArgs{
							PemCertificate: pulumi.String(invokeFile1.Result),
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		_, err = networksecurity.NewTlsInspectionPolicy(ctx, "default", &networksecurity.TlsInspectionPolicyArgs{
			Name:               pulumi.String("my-tls-inspection-policy"),
			Location:           pulumi.String("us-central1"),
			CaPool:             _default.ID(),
			ExcludePublicCaSet: pulumi.Bool(false),
			MinTlsVersion:      pulumi.String("TLS_1_0"),
			TrustConfig:        defaultTrustConfig.ID(),
			TlsFeatureProfile:  pulumi.String("PROFILE_CUSTOM"),
			CustomTlsFeatures: pulumi.StringArray{
				pulumi.String("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"),
				pulumi.String("TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"),
				pulumi.String("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA"),
				pulumi.String("TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"),
				pulumi.String("TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256"),
				pulumi.String("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"),
				pulumi.String("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"),
				pulumi.String("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA"),
				pulumi.String("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"),
				pulumi.String("TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256"),
				pulumi.String("TLS_RSA_WITH_3DES_EDE_CBC_SHA"),
				pulumi.String("TLS_RSA_WITH_AES_128_CBC_SHA"),
				pulumi.String("TLS_RSA_WITH_AES_128_GCM_SHA256"),
				pulumi.String("TLS_RSA_WITH_AES_256_CBC_SHA"),
				pulumi.String("TLS_RSA_WITH_AES_256_GCM_SHA384"),
			},
		}, pulumi.DependsOn([]pulumi.Resource{
			defaultAuthority,
			defaultCaPoolIamMember,
		}))
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.certificateauthority.CaPool;
import com.pulumi.gcp.certificateauthority.CaPoolArgs;
import com.pulumi.gcp.certificateauthority.inputs.CaPoolPublishingOptionsArgs;
import com.pulumi.gcp.certificateauthority.inputs.CaPoolIssuancePolicyArgs;
import com.pulumi.gcp.certificateauthority.inputs.CaPoolIssuancePolicyBaselineValuesArgs;
import com.pulumi.gcp.certificateauthority.inputs.CaPoolIssuancePolicyBaselineValuesCaOptionsArgs;
import com.pulumi.gcp.certificateauthority.inputs.CaPoolIssuancePolicyBaselineValuesKeyUsageArgs;
import com.pulumi.gcp.certificateauthority.inputs.CaPoolIssuancePolicyBaselineValuesKeyUsageBaseKeyUsageArgs;
import com.pulumi.gcp.certificateauthority.inputs.CaPoolIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsageArgs;
import com.pulumi.gcp.certificateauthority.Authority;
import com.pulumi.gcp.certificateauthority.AuthorityArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigSubjectConfigArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigSubjectConfigSubjectArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigX509ConfigArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigX509ConfigCaOptionsArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigX509ConfigKeyUsageArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigX509ConfigKeyUsageBaseKeyUsageArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityConfigX509ConfigKeyUsageExtendedKeyUsageArgs;
import com.pulumi.gcp.certificateauthority.inputs.AuthorityKeySpecArgs;
import com.pulumi.gcp.projects.ServiceIdentity;
import com.pulumi.gcp.projects.ServiceIdentityArgs;
import com.pulumi.gcp.certificateauthority.CaPoolIamMember;
import com.pulumi.gcp.certificateauthority.CaPoolIamMemberArgs;
import com.pulumi.gcp.certificatemanager.TrustConfig;
import com.pulumi.gcp.certificatemanager.TrustConfigArgs;
import com.pulumi.gcp.certificatemanager.inputs.TrustConfigTrustStoreArgs;
import com.pulumi.gcp.networksecurity.TlsInspectionPolicy;
import com.pulumi.gcp.networksecurity.TlsInspectionPolicyArgs;
import com.pulumi.resources.CustomResourceOptions;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new CaPool("default", CaPoolArgs.builder()
            .name("my-basic-ca-pool")
            .location("us-central1")
            .tier("DEVOPS")
            .publishingOptions(CaPoolPublishingOptionsArgs.builder()
                .publishCaCert(false)
                .publishCrl(false)
                .build())
            .issuancePolicy(CaPoolIssuancePolicyArgs.builder()
                .maximumLifetime("1209600s")
                .baselineValues(CaPoolIssuancePolicyBaselineValuesArgs.builder()
                    .caOptions(CaPoolIssuancePolicyBaselineValuesCaOptionsArgs.builder()
                        .isCa(false)
                        .build())
                    .keyUsage(CaPoolIssuancePolicyBaselineValuesKeyUsageArgs.builder()
                        .baseKeyUsage()
                        .extendedKeyUsage(CaPoolIssuancePolicyBaselineValuesKeyUsageExtendedKeyUsageArgs.builder()
                            .serverAuth(true)
                            .build())
                        .build())
                    .build())
                .build())
            .build());

        var defaultAuthority = new Authority("defaultAuthority", AuthorityArgs.builder()
            .pool(default_.name())
            .certificateAuthorityId("my-basic-certificate-authority")
            .location("us-central1")
            .lifetime("86400s")
            .type("SELF_SIGNED")
            .deletionProtection(false)
            .skipGracePeriod(true)
            .ignoreActiveCertificatesOnDeletion(true)
            .config(AuthorityConfigArgs.builder()
                .subjectConfig(AuthorityConfigSubjectConfigArgs.builder()
                    .subject(AuthorityConfigSubjectConfigSubjectArgs.builder()
                        .organization("Test LLC")
                        .commonName("my-ca")
                        .build())
                    .build())
                .x509Config(AuthorityConfigX509ConfigArgs.builder()
                    .caOptions(AuthorityConfigX509ConfigCaOptionsArgs.builder()
                        .isCa(true)
                        .build())
                    .keyUsage(AuthorityConfigX509ConfigKeyUsageArgs.builder()
                        .baseKeyUsage(AuthorityConfigX509ConfigKeyUsageBaseKeyUsageArgs.builder()
                            .certSign(true)
                            .crlSign(true)
                            .build())
                        .extendedKeyUsage(AuthorityConfigX509ConfigKeyUsageExtendedKeyUsageArgs.builder()
                            .serverAuth(false)
                            .build())
                        .build())
                    .build())
                .build())
            .keySpec(AuthorityKeySpecArgs.builder()
                .algorithm("RSA_PKCS1_4096_SHA256")
                .build())
            .build());

        var nsSa = new ServiceIdentity("nsSa", ServiceIdentityArgs.builder()
            .service("networksecurity.googleapis.com")
            .build());

        var defaultCaPoolIamMember = new CaPoolIamMember("defaultCaPoolIamMember", CaPoolIamMemberArgs.builder()
            .caPool(default_.id())
            .role("roles/privateca.certificateManager")
            .member(nsSa.member())
            .build());

        var defaultTrustConfig = new TrustConfig("defaultTrustConfig", TrustConfigArgs.builder()
            .name("my-trust-config")
            .description("sample trust config description")
            .location("us-central1")
            .trustStores(TrustConfigTrustStoreArgs.builder()
                .trustAnchors(TrustConfigTrustStoreTrustAnchorArgs.builder()
                    .pemCertificate(StdFunctions.file(FileArgs.builder()
                        .input("test-fixtures/ca_cert.pem")
                        .build()).result())
                    .build())
                .intermediateCas(TrustConfigTrustStoreIntermediateCaArgs.builder()
                    .pemCertificate(StdFunctions.file(FileArgs.builder()
                        .input("test-fixtures/ca_cert.pem")
                        .build()).result())
                    .build())
                .build())
            .build());

        var defaultTlsInspectionPolicy = new TlsInspectionPolicy("defaultTlsInspectionPolicy", TlsInspectionPolicyArgs.builder()
            .name("my-tls-inspection-policy")
            .location("us-central1")
            .caPool(default_.id())
            .excludePublicCaSet(false)
            .minTlsVersion("TLS_1_0")
            .trustConfig(defaultTrustConfig.id())
            .tlsFeatureProfile("PROFILE_CUSTOM")
            .customTlsFeatures(            
                "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
                "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
                "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
                "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
                "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",
                "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
                "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
                "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
                "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
                "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
                "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
                "TLS_RSA_WITH_AES_128_CBC_SHA",
                "TLS_RSA_WITH_AES_128_GCM_SHA256",
                "TLS_RSA_WITH_AES_256_CBC_SHA",
                "TLS_RSA_WITH_AES_256_GCM_SHA384")
            .build(), CustomResourceOptions.builder()
                .dependsOn(                
                    defaultAuthority,
                    defaultCaPoolIamMember)
                .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:certificateauthority:CaPool
    properties:
      name: my-basic-ca-pool
      location: us-central1
      tier: DEVOPS
      publishingOptions:
        publishCaCert: false
        publishCrl: false
      issuancePolicy:
        maximumLifetime: 1209600s
        baselineValues:
          caOptions:
            isCa: false
          keyUsage:
            baseKeyUsage: {}
            extendedKeyUsage:
              serverAuth: true
  defaultAuthority:
    type: gcp:certificateauthority:Authority
    name: default
    properties:
      pool: ${default.name}
      certificateAuthorityId: my-basic-certificate-authority
      location: us-central1
      lifetime: 86400s
      type: SELF_SIGNED
      deletionProtection: false
      skipGracePeriod: true
      ignoreActiveCertificatesOnDeletion: true
      config:
        subjectConfig:
          subject:
            organization: Test LLC
            commonName: my-ca
        x509Config:
          caOptions:
            isCa: true
          keyUsage:
            baseKeyUsage:
              certSign: true
              crlSign: true
            extendedKeyUsage:
              serverAuth: false
      keySpec:
        algorithm: RSA_PKCS1_4096_SHA256
  nsSa:
    type: gcp:projects:ServiceIdentity
    name: ns_sa
    properties:
      service: networksecurity.googleapis.com
  defaultCaPoolIamMember:
    type: gcp:certificateauthority:CaPoolIamMember
    name: default
    properties:
      caPool: ${default.id}
      role: roles/privateca.certificateManager
      member: ${nsSa.member}
  defaultTrustConfig:
    type: gcp:certificatemanager:TrustConfig
    name: default
    properties:
      name: my-trust-config
      description: sample trust config description
      location: us-central1
      trustStores:
        - trustAnchors:
            - pemCertificate:
                fn::invoke:
                  function: std:file
                  arguments:
                    input: test-fixtures/ca_cert.pem
                  return: result
          intermediateCas:
            - pemCertificate:
                fn::invoke:
                  function: std:file
                  arguments:
                    input: test-fixtures/ca_cert.pem
                  return: result
  defaultTlsInspectionPolicy:
    type: gcp:networksecurity:TlsInspectionPolicy
    name: default
    properties:
      name: my-tls-inspection-policy
      location: us-central1
      caPool: ${default.id}
      excludePublicCaSet: false
      minTlsVersion: TLS_1_0
      trustConfig: ${defaultTrustConfig.id}
      tlsFeatureProfile: PROFILE_CUSTOM
      customTlsFeatures:
        - TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
        - TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
        - TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
        - TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
        - TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
        - TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
        - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
        - TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
        - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
        - TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
        - TLS_RSA_WITH_3DES_EDE_CBC_SHA
        - TLS_RSA_WITH_AES_128_CBC_SHA
        - TLS_RSA_WITH_AES_128_GCM_SHA256
        - TLS_RSA_WITH_AES_256_CBC_SHA
        - TLS_RSA_WITH_AES_256_GCM_SHA384
    options:
      dependsOn:
        - ${defaultAuthority}
        - ${defaultCaPoolIamMember}
```
<!--End PulumiCodeChooser -->

## Import

TlsInspectionPolicy can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/tlsInspectionPolicies/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

When using the `pulumi import` command, TlsInspectionPolicy can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networksecurity/tlsInspectionPolicy:TlsInspectionPolicy default projects/{{project}}/locations/{{location}}/tlsInspectionPolicies/{{name}}
```

```sh
$ pulumi import gcp:networksecurity/tlsInspectionPolicy:TlsInspectionPolicy default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:networksecurity/tlsInspectionPolicy:TlsInspectionPolicy default {{location}}/{{name}}
```

J
caPool" <A CA pool resource used to issue interception certificates.
«
customTlsFeaturesB*" ©List of custom TLS cipher suites selected. This field is valid only if the selected tls_feature_profile is CUSTOM. The compute.SslPoliciesService.ListAvailableFeatures method returns the set of features that can be specified in this list. Note that Secure Web Proxy does not yet honor this field.
<
descriptionB" 'Free-text description of the resource.
ÿ
excludePublicCaSetB
 ªIf FALSE (the default), use our default set of public CAs in addition to any CAs specified in trustConfig. These public CAs are currently based on the Mozilla Root Program and are subject to change over time. If TRUE, do not accept our default set of public CAs. Only CAs specified in trustConfig will be accepted.
=
locationB" +The location of the tls inspection policy.
õ
minTlsVersionB" ÉMinimum TLS version that the firewall should use when negotiating connections with both clients and servers. If this is not set, then the default value is to allow the broadest set of clients and servers (TLS 1.0 or higher). Setting this to more restrictive values may improve security, but may also prevent the firewall from connecting to some clients or servers. Note that Secure Web Proxy does not yet honor this field.
Possible values are: `TLS_VERSION_UNSPECIFIED`, `TLS_1_0`, `TLS_1_1`, `TLS_1_2`, `TLS_1_3`.
T
nameB" FShort name of the TlsInspectionPolicy resource to be created.


- - -
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
˘
tlsFeatureProfileB" ›The selected Profile. If this is not set, then the default value is to allow the broadest set of clients and servers (\"PROFILE_COMPATIBLE\"). Setting this to more restrictive values may improve security, but may also prevent the TLS inspection proxy from connecting to some clients or servers. Note that Secure Web Proxy does not yet honor this field.
Possible values are: `PROFILE_UNSPECIFIED`, `PROFILE_COMPATIBLE`, `PROFILE_MODERN`, `PROFILE_RESTRICTED`, `PROFILE_CUSTOM`.
‹
trustConfigB" ∆A TrustConfig resource used when making a connection to the TLS server. This is a relative resource path following the form \"projects/{project}/locations/{location}/trustConfigs/{trust_config}\". This is necessary to intercept TLS connections to servers with certificates signed by a private CA or self-signed certificates. Trust config and the TLS inspection policy must be in the same region. Note that Secure Web Proxy does not yet honor this field.
"J
caPool" <A CA pool resource used to issue interception certificates.
"?

createTime" -The timestamp when the resource was created.
"«
customTlsFeaturesB*" ©List of custom TLS cipher suites selected. This field is valid only if the selected tls_feature_profile is CUSTOM. The compute.SslPoliciesService.ListAvailableFeatures method returns the set of features that can be specified in this list. Note that Secure Web Proxy does not yet honor this field.
"<
descriptionB" 'Free-text description of the resource.
"ÿ
excludePublicCaSetB
 ªIf FALSE (the default), use our default set of public CAs in addition to any CAs specified in trustConfig. These public CAs are currently based on the Mozilla Root Program and are subject to change over time. If TRUE, do not accept our default set of public CAs. Only CAs specified in trustConfig will be accepted.
"=
locationB" +The location of the tls inspection policy.
"õ
minTlsVersionB" ÉMinimum TLS version that the firewall should use when negotiating connections with both clients and servers. If this is not set, then the default value is to allow the broadest set of clients and servers (TLS 1.0 or higher). Setting this to more restrictive values may improve security, but may also prevent the firewall from connecting to some clients or servers. Note that Secure Web Proxy does not yet honor this field.
Possible values are: `TLS_VERSION_UNSPECIFIED`, `TLS_1_0`, `TLS_1_1`, `TLS_1_2`, `TLS_1_3`.
"R
name" FShort name of the TlsInspectionPolicy resource to be created.


- - -
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"˘
tlsFeatureProfileB" ›The selected Profile. If this is not set, then the default value is to allow the broadest set of clients and servers (\"PROFILE_COMPATIBLE\"). Setting this to more restrictive values may improve security, but may also prevent the TLS inspection proxy from connecting to some clients or servers. Note that Secure Web Proxy does not yet honor this field.
Possible values are: `PROFILE_UNSPECIFIED`, `PROFILE_COMPATIBLE`, `PROFILE_MODERN`, `PROFILE_RESTRICTED`, `PROFILE_CUSTOM`.
"‹
trustConfigB" ∆A TrustConfig resource used when making a connection to the TLS server. This is a relative resource path following the form \"projects/{project}/locations/{location}/trustConfigs/{trust_config}\". This is necessary to intercept TLS connections to servers with certificates signed by a private CA or self-signed certificates. Trust config and the TLS inspection policy must be in the same region. Note that Secure Web Proxy does not yet honor this field.
"?

updateTime" -The timestamp when the resource was updated.
*Æ>
?
networksecurityUrlList#gcp:networksecurity/urlList:UrlListç2UrlList proto helps users to set reusable, independently manageable lists of hosts, host patterns, URLs, URL patterns.


To get more information about UrlLists, see:

* [API documentation](https://cloud.google.com/secure-web-proxy/docs/reference/network-security/rest/v1/projects.locations.urlLists)
* How-to Guides
    * Use UrlLists

## Example Usage

### Network Security Url Lists Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networksecurity.UrlList("default", {
    name: "my-url-lists",
    location: "us-central1",
    values: ["www.example.com"],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networksecurity.UrlList("default",
    name="my-url-lists",
    location="us-central1",
    values=["www.example.com"])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkSecurity.UrlList("default", new()
    {
        Name = "my-url-lists",
        Location = "us-central1",
        Values = new[]
        {
            "www.example.com",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networksecurity.NewUrlList(ctx, "default", &networksecurity.UrlListArgs{
			Name:     pulumi.String("my-url-lists"),
			Location: pulumi.String("us-central1"),
			Values: pulumi.StringArray{
				pulumi.String("www.example.com"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networksecurity.UrlList;
import com.pulumi.gcp.networksecurity.UrlListArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new UrlList("default", UrlListArgs.builder()
            .name("my-url-lists")
            .location("us-central1")
            .values("www.example.com")
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networksecurity:UrlList
    properties:
      name: my-url-lists
      location: us-central1
      values:
        - www.example.com
```
<!--End PulumiCodeChooser -->
### Network Security Url Lists Advanced


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networksecurity.UrlList("default", {
    name: "my-url-lists",
    location: "us-central1",
    description: "my description",
    values: [
        "www.example.com",
        "about.example.com",
        "github.com/example-org/*",
    ],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networksecurity.UrlList("default",
    name="my-url-lists",
    location="us-central1",
    description="my description",
    values=[
        "www.example.com",
        "about.example.com",
        "github.com/example-org/*",
    ])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkSecurity.UrlList("default", new()
    {
        Name = "my-url-lists",
        Location = "us-central1",
        Description = "my description",
        Values = new[]
        {
            "www.example.com",
            "about.example.com",
            "github.com/example-org/*",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networksecurity.NewUrlList(ctx, "default", &networksecurity.UrlListArgs{
			Name:        pulumi.String("my-url-lists"),
			Location:    pulumi.String("us-central1"),
			Description: pulumi.String("my description"),
			Values: pulumi.StringArray{
				pulumi.String("www.example.com"),
				pulumi.String("about.example.com"),
				pulumi.String("github.com/example-org/*"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networksecurity.UrlList;
import com.pulumi.gcp.networksecurity.UrlListArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new UrlList("default", UrlListArgs.builder()
            .name("my-url-lists")
            .location("us-central1")
            .description("my description")
            .values(            
                "www.example.com",
                "about.example.com",
                "github.com/example-org/*")
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networksecurity:UrlList
    properties:
      name: my-url-lists
      location: us-central1
      description: my description
      values:
        - www.example.com
        - about.example.com
        - github.com/example-org/*
```
<!--End PulumiCodeChooser -->

## Import

UrlLists can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/urlLists/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

When using the `pulumi import` command, UrlLists can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networksecurity/urlList:UrlList default projects/{{project}}/locations/{{location}}/urlLists/{{name}}
```

```sh
$ pulumi import gcp:networksecurity/urlList:UrlList default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:networksecurity/urlList:UrlList default {{location}}/{{name}}
```

<
descriptionB" 'Free-text description of the resource.
7
location" 'The location of the url lists.


- - -
‹
nameB" ÕShort name of the UrlList resource to be created.
This value should be 1-63 characters long, containing only letters, numbers, hyphens, and underscores, and should not start with a number. E.g. 'urlList'.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
 
values*" FQDNs and URLs.
"¯

createTime" ÂOutput only. Time when the security policy was created.
A timestamp in RFC3339 UTC 'Zulu' format, with nanosecond resolution and up to nine fractional digits.
Examples: '2014-10-02T15:01:23Z' and '2014-10-02T15:01:23.045123456Z'
"<
descriptionB" 'Free-text description of the resource.
"7
location" 'The location of the url lists.


- - -
"⁄
name" ÕShort name of the UrlList resource to be created.
This value should be 1-63 characters long, containing only letters, numbers, hyphens, and underscores, and should not start with a number. E.g. 'urlList'.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"˘

updateTime" ÊOutput only. Time when the security policy was updated.
A timestamp in RFC3339 UTC 'Zulu' format, with nanosecond resolution and up to nine fractional digits.
Examples: '2014-10-02T15:01:23Z' and '2014-10-02T15:01:23.045123456Z'.
" 
values*" FQDNs and URLs.
*∞l
T
networkservicesAuthzExtension1gcp:networkservices/authzExtension:AuthzExtensionà8AuthzExtension is a resource that allows traffic forwarding to a callout backend service to make an authorization decision.


To get more information about AuthzExtension, see:

* [API documentation](https://cloud.google.com/service-extensions/docs/reference/rest/v1beta1/projects.locations.authzExtensions)

## Example Usage

### Network Services Authz Extension Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.compute.RegionBackendService("default", {
    name: "authz-service",
    project: "my-project-name",
    region: "us-west1",
    protocol: "HTTP2",
    loadBalancingScheme: "INTERNAL_MANAGED",
    portName: "grpc",
});
const defaultAuthzExtension = new gcp.networkservices.AuthzExtension("default", {
    name: "my-authz-ext",
    project: "my-project-name",
    location: "us-west1",
    description: "my description",
    loadBalancingScheme: "INTERNAL_MANAGED",
    authority: "ext11.com",
    service: _default.selfLink,
    timeout: "0.1s",
    failOpen: false,
    forwardHeaders: ["Authorization"],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.compute.RegionBackendService("default",
    name="authz-service",
    project="my-project-name",
    region="us-west1",
    protocol="HTTP2",
    load_balancing_scheme="INTERNAL_MANAGED",
    port_name="grpc")
default_authz_extension = gcp.networkservices.AuthzExtension("default",
    name="my-authz-ext",
    project="my-project-name",
    location="us-west1",
    description="my description",
    load_balancing_scheme="INTERNAL_MANAGED",
    authority="ext11.com",
    service=default.self_link,
    timeout="0.1s",
    fail_open=False,
    forward_headers=["Authorization"])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.Compute.RegionBackendService("default", new()
    {
        Name = "authz-service",
        Project = "my-project-name",
        Region = "us-west1",
        Protocol = "HTTP2",
        LoadBalancingScheme = "INTERNAL_MANAGED",
        PortName = "grpc",
    });

    var defaultAuthzExtension = new Gcp.NetworkServices.AuthzExtension("default", new()
    {
        Name = "my-authz-ext",
        Project = "my-project-name",
        Location = "us-west1",
        Description = "my description",
        LoadBalancingScheme = "INTERNAL_MANAGED",
        Authority = "ext11.com",
        Service = @default.SelfLink,
        Timeout = "0.1s",
        FailOpen = false,
        ForwardHeaders = new[]
        {
            "Authorization",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := compute.NewRegionBackendService(ctx, "default", &compute.RegionBackendServiceArgs{
			Name:                pulumi.String("authz-service"),
			Project:             pulumi.String("my-project-name"),
			Region:              pulumi.String("us-west1"),
			Protocol:            pulumi.String("HTTP2"),
			LoadBalancingScheme: pulumi.String("INTERNAL_MANAGED"),
			PortName:            pulumi.String("grpc"),
		})
		if err != nil {
			return err
		}
		_, err = networkservices.NewAuthzExtension(ctx, "default", &networkservices.AuthzExtensionArgs{
			Name:                pulumi.String("my-authz-ext"),
			Project:             pulumi.String("my-project-name"),
			Location:            pulumi.String("us-west1"),
			Description:         pulumi.String("my description"),
			LoadBalancingScheme: pulumi.String("INTERNAL_MANAGED"),
			Authority:           pulumi.String("ext11.com"),
			Service:             _default.SelfLink,
			Timeout:             pulumi.String("0.1s"),
			FailOpen:            pulumi.Bool(false),
			ForwardHeaders: pulumi.StringArray{
				pulumi.String("Authorization"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.RegionBackendService;
import com.pulumi.gcp.compute.RegionBackendServiceArgs;
import com.pulumi.gcp.networkservices.AuthzExtension;
import com.pulumi.gcp.networkservices.AuthzExtensionArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new RegionBackendService("default", RegionBackendServiceArgs.builder()
            .name("authz-service")
            .project("my-project-name")
            .region("us-west1")
            .protocol("HTTP2")
            .loadBalancingScheme("INTERNAL_MANAGED")
            .portName("grpc")
            .build());

        var defaultAuthzExtension = new AuthzExtension("defaultAuthzExtension", AuthzExtensionArgs.builder()
            .name("my-authz-ext")
            .project("my-project-name")
            .location("us-west1")
            .description("my description")
            .loadBalancingScheme("INTERNAL_MANAGED")
            .authority("ext11.com")
            .service(default_.selfLink())
            .timeout("0.1s")
            .failOpen(false)
            .forwardHeaders("Authorization")
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:compute:RegionBackendService
    properties:
      name: authz-service
      project: my-project-name
      region: us-west1
      protocol: HTTP2
      loadBalancingScheme: INTERNAL_MANAGED
      portName: grpc
  defaultAuthzExtension:
    type: gcp:networkservices:AuthzExtension
    name: default
    properties:
      name: my-authz-ext
      project: my-project-name
      location: us-west1
      description: my description
      loadBalancingScheme: INTERNAL_MANAGED
      authority: ext11.com
      service: ${default.selfLink}
      timeout: 0.1s
      failOpen: false
      forwardHeaders:
        - Authorization
```
<!--End PulumiCodeChooser -->

## Import

AuthzExtension can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/authzExtensions/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

* `{{name}}`

When using the `pulumi import` command, AuthzExtension can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkservices/authzExtension:AuthzExtension default projects/{{project}}/locations/{{location}}/authzExtensions/{{name}}
```

```sh
$ pulumi import gcp:networkservices/authzExtension:AuthzExtension default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:networkservices/authzExtension:AuthzExtension default {{location}}/{{name}}
```

```sh
$ pulumi import gcp:networkservices/authzExtension:AuthzExtension default {{name}}
```

e
	authority" TThe :authority header in the gRPC request sent from Envoy to the extension service.
C
descriptionB" .A human-readable description of the resource.
Ü
failOpenB
 ÛDetermines how the proxy behaves if the call to the extension fails or times out.
When set to TRUE, request or response processing continues without error. Any subsequent extensions in the extension chain are also executed. When set to FALSE or the default setting of FALSE is used, one of the following happens:
* If response headers have not been delivered to the downstream client, a generic 500 error is returned to the client. The error response can be tailored by configuring a custom error response in the load balancer.
* If response headers have been delivered, then the HTTP stream to the downstream client is reset.
∫
forwardHeadersB*" üList of the HTTP headers to forward to the extension (from the client). If omitted, all headers are sent. Each element is a string indicating the header name.
ï
labelsB2" ÇSet of labels associated with the AuthzExtension resource.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
≈
loadBalancingScheme" ©All backend services and forwarding rules referenced by this extension must share the same load balancing scheme.
For more information, refer to [Backend services overview](https://cloud.google.com/load-balancing/docs/backend-service).
Possible values are: `INTERNAL_MANAGED`, `EXTERNAL_MANAGED`.
6
location" &The location of the resource.


- - -
∞
metadataB2" õThe metadata provided here is included as part of the metadata_context (of type google.protobuf.Struct) in the ProcessingRequest message sent to the extension server. The metadata is available under the namespace com.google.authz_extension.<resourceName>. The following variables are supported in the metadata Struct:
{forwarding_rule_id} - substituted with the forwarding rule's fully qualified resource name.
?
nameB" 1Identifier. Name of the AuthzExtension resource.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
”
service" √The reference to the service that runs the extension.
To configure a callout extension, service must be a fully-qualified reference to a [backend service](https://cloud.google.com/compute/docs/reference/rest/v1/backendServices) in the format:
https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/backendServices/{backendService} or https://www.googleapis.com/compute/v1/projects/{project}/global/backendServices/{backendService}.
É
timeout" tSpecifies the timeout for each individual message on the stream. The timeout must be between 10-10000 milliseconds.
∏

wireFormatB" £The format of communication supported by the callout extension.
Default value is `EXT_PROC_GRPC`.
Possible values are: `WIRE_FORMAT_UNSPECIFIED`, `EXT_PROC_GRPC`.
"e
	authority" TThe :authority header in the gRPC request sent from Envoy to the extension service.
"?

createTime" -The timestamp when the resource was created.
"C
descriptionB" .A human-readable description of the resource.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"Ñ
failOpen
 ÛDetermines how the proxy behaves if the call to the extension fails or times out.
When set to TRUE, request or response processing continues without error. Any subsequent extensions in the extension chain are also executed. When set to FALSE or the default setting of FALSE is used, one of the following happens:
* If response headers have not been delivered to the downstream client, a generic 500 error is returned to the client. The error response can be tailored by configuring a custom error response in the load balancer.
* If response headers have been delivered, then the HTTP stream to the downstream client is reset.
"∫
forwardHeadersB*" üList of the HTTP headers to forward to the extension (from the client). If omitted, all headers are sent. Each element is a string indicating the header name.
"ï
labelsB2" ÇSet of labels associated with the AuthzExtension resource.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"≈
loadBalancingScheme" ©All backend services and forwarding rules referenced by this extension must share the same load balancing scheme.
For more information, refer to [Backend services overview](https://cloud.google.com/load-balancing/docs/backend-service).
Possible values are: `INTERNAL_MANAGED`, `EXTERNAL_MANAGED`.
"6
location" &The location of the resource.


- - -
"∞
metadataB2" õThe metadata provided here is included as part of the metadata_context (of type google.protobuf.Struct) in the ProcessingRequest message sent to the extension server. The metadata is available under the namespace com.google.authz_extension.<resourceName>. The following variables are supported in the metadata Struct:
{forwarding_rule_id} - substituted with the forwarding rule's fully qualified resource name.
"=
name" 1Identifier. Name of the AuthzExtension resource.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"”
service" √The reference to the service that runs the extension.
To configure a callout extension, service must be a fully-qualified reference to a [backend service](https://cloud.google.com/compute/docs/reference/rest/v1/backendServices) in the format:
https://www.googleapis.com/compute/v1/projects/{project}/regions/{region}/backendServices/{backendService} or https://www.googleapis.com/compute/v1/projects/{project}/global/backendServices/{backendService}.
"É
timeout" tSpecifies the timeout for each individual message on the stream. The timeout must be between 10-10000 milliseconds.
"?

updateTime" -The timestamp when the resource was updated.
"∏

wireFormatB" £The format of communication supported by the callout extension.
Default value is `EXT_PROC_GRPC`.
Possible values are: `WIRE_FORMAT_UNSPECIFIED`, `EXT_PROC_GRPC`.
*ÇÉ
W
networkservicesEdgeCacheKeyset3gcp:networkservices/edgeCacheKeyset:EdgeCacheKeysetŸ]EdgeCacheKeyset represents a collection of public keys used for validating signed requests.


To get more information about EdgeCacheKeyset, see:

* [API documentation](https://cloud.google.com/media-cdn/docs/reference/rest/v1/projects.locations.edgeCacheKeysets)
* How-to Guides
    * [Create keysets](https://cloud.google.com/media-cdn/docs/create-keyset)



## Example Usage

### Network Services Edge Cache Keyset Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networkservices.EdgeCacheKeyset("default", {
    name: "my-keyset",
    description: "The default keyset",
    publicKeys: [
        {
            id: "my-public-key",
            value: "FHsTyFHNmvNpw4o7-rp-M1yqMyBF8vXSBRkZtkQ0RKY",
        },
        {
            id: "my-public-key-2",
            value: "hzd03llxB1u5FOLKFkZ6_wCJqC7jtN0bg7xlBqS6WVM",
        },
    ],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networkservices.EdgeCacheKeyset("default",
    name="my-keyset",
    description="The default keyset",
    public_keys=[
        {
            "id": "my-public-key",
            "value": "FHsTyFHNmvNpw4o7-rp-M1yqMyBF8vXSBRkZtkQ0RKY",
        },
        {
            "id": "my-public-key-2",
            "value": "hzd03llxB1u5FOLKFkZ6_wCJqC7jtN0bg7xlBqS6WVM",
        },
    ])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkServices.EdgeCacheKeyset("default", new()
    {
        Name = "my-keyset",
        Description = "The default keyset",
        PublicKeys = new[]
        {
            new Gcp.NetworkServices.Inputs.EdgeCacheKeysetPublicKeyArgs
            {
                Id = "my-public-key",
                Value = "FHsTyFHNmvNpw4o7-rp-M1yqMyBF8vXSBRkZtkQ0RKY",
            },
            new Gcp.NetworkServices.Inputs.EdgeCacheKeysetPublicKeyArgs
            {
                Id = "my-public-key-2",
                Value = "hzd03llxB1u5FOLKFkZ6_wCJqC7jtN0bg7xlBqS6WVM",
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networkservices.NewEdgeCacheKeyset(ctx, "default", &networkservices.EdgeCacheKeysetArgs{
			Name:        pulumi.String("my-keyset"),
			Description: pulumi.String("The default keyset"),
			PublicKeys: networkservices.EdgeCacheKeysetPublicKeyArray{
				&networkservices.EdgeCacheKeysetPublicKeyArgs{
					Id:    pulumi.String("my-public-key"),
					Value: pulumi.String("FHsTyFHNmvNpw4o7-rp-M1yqMyBF8vXSBRkZtkQ0RKY"),
				},
				&networkservices.EdgeCacheKeysetPublicKeyArgs{
					Id:    pulumi.String("my-public-key-2"),
					Value: pulumi.String("hzd03llxB1u5FOLKFkZ6_wCJqC7jtN0bg7xlBqS6WVM"),
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networkservices.EdgeCacheKeyset;
import com.pulumi.gcp.networkservices.EdgeCacheKeysetArgs;
import com.pulumi.gcp.networkservices.inputs.EdgeCacheKeysetPublicKeyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new EdgeCacheKeyset("default", EdgeCacheKeysetArgs.builder()
            .name("my-keyset")
            .description("The default keyset")
            .publicKeys(            
                EdgeCacheKeysetPublicKeyArgs.builder()
                    .id("my-public-key")
                    .value("FHsTyFHNmvNpw4o7-rp-M1yqMyBF8vXSBRkZtkQ0RKY")
                    .build(),
                EdgeCacheKeysetPublicKeyArgs.builder()
                    .id("my-public-key-2")
                    .value("hzd03llxB1u5FOLKFkZ6_wCJqC7jtN0bg7xlBqS6WVM")
                    .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkservices:EdgeCacheKeyset
    properties:
      name: my-keyset
      description: The default keyset
      publicKeys:
        - id: my-public-key
          value: FHsTyFHNmvNpw4o7-rp-M1yqMyBF8vXSBRkZtkQ0RKY
        - id: my-public-key-2
          value: hzd03llxB1u5FOLKFkZ6_wCJqC7jtN0bg7xlBqS6WVM
```
<!--End PulumiCodeChooser -->
### Network Services Edge Cache Keyset Dual Token


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const secret_basic = new gcp.secretmanager.Secret("secret-basic", {
    secretId: "secret-name",
    replication: {
        auto: {},
    },
});
const secret_version_basic = new gcp.secretmanager.SecretVersion("secret-version-basic", {
    secret: secret_basic.id,
    secretData: "secret-data",
});
const _default = new gcp.networkservices.EdgeCacheKeyset("default", {
    name: "my-keyset",
    description: "The default keyset",
    publicKeys: [{
        id: "my-public-key",
        managed: true,
    }],
    validationSharedKeys: [{
        secretVersion: secret_version_basic.id,
    }],
});
```
```python
import pulumi
import pulumi_gcp as gcp

secret_basic = gcp.secretmanager.Secret("secret-basic",
    secret_id="secret-name",
    replication={
        "auto": {},
    })
secret_version_basic = gcp.secretmanager.SecretVersion("secret-version-basic",
    secret=secret_basic.id,
    secret_data="secret-data")
default = gcp.networkservices.EdgeCacheKeyset("default",
    name="my-keyset",
    description="The default keyset",
    public_keys=[{
        "id": "my-public-key",
        "managed": True,
    }],
    validation_shared_keys=[{
        "secret_version": secret_version_basic.id,
    }])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var secret_basic = new Gcp.SecretManager.Secret("secret-basic", new()
    {
        SecretId = "secret-name",
        Replication = new Gcp.SecretManager.Inputs.SecretReplicationArgs
        {
            Auto = null,
        },
    });

    var secret_version_basic = new Gcp.SecretManager.SecretVersion("secret-version-basic", new()
    {
        Secret = secret_basic.Id,
        SecretData = "secret-data",
    });

    var @default = new Gcp.NetworkServices.EdgeCacheKeyset("default", new()
    {
        Name = "my-keyset",
        Description = "The default keyset",
        PublicKeys = new[]
        {
            new Gcp.NetworkServices.Inputs.EdgeCacheKeysetPublicKeyArgs
            {
                Id = "my-public-key",
                Managed = true,
            },
        },
        ValidationSharedKeys = new[]
        {
            new Gcp.NetworkServices.Inputs.EdgeCacheKeysetValidationSharedKeyArgs
            {
                SecretVersion = secret_version_basic.Id,
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/secretmanager"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := secretmanager.NewSecret(ctx, "secret-basic", &secretmanager.SecretArgs{
			SecretId: pulumi.String("secret-name"),
			Replication: &secretmanager.SecretReplicationArgs{
				Auto: &secretmanager.SecretReplicationAutoArgs{},
			},
		})
		if err != nil {
			return err
		}
		_, err = secretmanager.NewSecretVersion(ctx, "secret-version-basic", &secretmanager.SecretVersionArgs{
			Secret:     secret_basic.ID(),
			SecretData: pulumi.String("secret-data"),
		})
		if err != nil {
			return err
		}
		_, err = networkservices.NewEdgeCacheKeyset(ctx, "default", &networkservices.EdgeCacheKeysetArgs{
			Name:        pulumi.String("my-keyset"),
			Description: pulumi.String("The default keyset"),
			PublicKeys: networkservices.EdgeCacheKeysetPublicKeyArray{
				&networkservices.EdgeCacheKeysetPublicKeyArgs{
					Id:      pulumi.String("my-public-key"),
					Managed: pulumi.Bool(true),
				},
			},
			ValidationSharedKeys: networkservices.EdgeCacheKeysetValidationSharedKeyArray{
				&networkservices.EdgeCacheKeysetValidationSharedKeyArgs{
					SecretVersion: secret_version_basic.ID(),
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.secretmanager.Secret;
import com.pulumi.gcp.secretmanager.SecretArgs;
import com.pulumi.gcp.secretmanager.inputs.SecretReplicationArgs;
import com.pulumi.gcp.secretmanager.inputs.SecretReplicationAutoArgs;
import com.pulumi.gcp.secretmanager.SecretVersion;
import com.pulumi.gcp.secretmanager.SecretVersionArgs;
import com.pulumi.gcp.networkservices.EdgeCacheKeyset;
import com.pulumi.gcp.networkservices.EdgeCacheKeysetArgs;
import com.pulumi.gcp.networkservices.inputs.EdgeCacheKeysetPublicKeyArgs;
import com.pulumi.gcp.networkservices.inputs.EdgeCacheKeysetValidationSharedKeyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var secret_basic = new Secret("secret-basic", SecretArgs.builder()
            .secretId("secret-name")
            .replication(SecretReplicationArgs.builder()
                .auto()
                .build())
            .build());

        var secret_version_basic = new SecretVersion("secret-version-basic", SecretVersionArgs.builder()
            .secret(secret_basic.id())
            .secretData("secret-data")
            .build());

        var default_ = new EdgeCacheKeyset("default", EdgeCacheKeysetArgs.builder()
            .name("my-keyset")
            .description("The default keyset")
            .publicKeys(EdgeCacheKeysetPublicKeyArgs.builder()
                .id("my-public-key")
                .managed(true)
                .build())
            .validationSharedKeys(EdgeCacheKeysetValidationSharedKeyArgs.builder()
                .secretVersion(secret_version_basic.id())
                .build())
            .build());

    }
}
```
```yaml
resources:
  secret-basic:
    type: gcp:secretmanager:Secret
    properties:
      secretId: secret-name
      replication:
        auto: {}
  secret-version-basic:
    type: gcp:secretmanager:SecretVersion
    properties:
      secret: ${["secret-basic"].id}
      secretData: secret-data
  default:
    type: gcp:networkservices:EdgeCacheKeyset
    properties:
      name: my-keyset
      description: The default keyset
      publicKeys:
        - id: my-public-key
          managed: true
      validationSharedKeys:
        - secretVersion: ${["secret-version-basic"].id}
```
<!--End PulumiCodeChooser -->

## Import

EdgeCacheKeyset can be imported using any of these accepted formats:

* `projects/{{project}}/locations/global/edgeCacheKeysets/{{name}}`

* `{{project}}/{{name}}`

* `{{name}}`

When using the `pulumi import` command, EdgeCacheKeyset can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkservices/edgeCacheKeyset:EdgeCacheKeyset default projects/{{project}}/locations/global/edgeCacheKeysets/{{name}}
```

```sh
$ pulumi import gcp:networkservices/edgeCacheKeyset:EdgeCacheKeyset default {{project}}/{{name}}
```

```sh
$ pulumi import gcp:networkservices/edgeCacheKeyset:EdgeCacheKeyset default {{name}}
```

C
descriptionB" .A human-readable description of the resource.
ì
labelsB2" ÄSet of label tags associated with the EdgeCache resource.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
Ω
nameB" ÆName of the resource; provided by the client when the resource is created.
The name must be 1-64 characters long, and match the regular expression [a-zA-Z][a-zA-Z0-9_-]* which means the first character must be a letter,
and all following characters must be a dash, underscore, letter or digit.


- - -
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
˚

publicKeyszBx*v:t
r
networkservicesEdgeCacheKeysetPublicKeyEgcp:networkservices/EdgeCacheKeysetPublicKey:EdgeCacheKeysetPublicKeyAn ordered list of Ed25519 public keys to use for validating signed requests.
You must specify `public_keys` or `validation_shared_keys` (or both). The keys in `public_keys` are checked first.
You may specify no more than one Google-managed public key.
If you specify `public_keys`, you must specify at least one (1) key and may specify up to three (3) keys.
Ed25519 public keys are not secret, and only allow Google to validate a request was signed by your corresponding private key.
Ensure that the private key is kept secret, and that only authorized users can add public keys to a keyset.
Structure is documented below.
¯
validationSharedKeysúBô*ñ:ì
ê
networkservices"EdgeCacheKeysetValidationSharedKeyYgcp:networkservices/EdgeCacheKeysetValidationSharedKey:EdgeCacheKeysetValidationSharedKey¿An ordered list of shared keys to use for validating signed requests.
Shared keys are secret.  Ensure that only authorized users can add `validation_shared_keys` to a keyset.
You can rotate keys by appending (pushing) a new key to the list of `validation_shared_keys` and removing any superseded keys.
You must specify `public_keys` or `validation_shared_keys` (or both). The keys in `public_keys` are checked first.
Structure is documented below.
"C
descriptionB" .A human-readable description of the resource.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"ì
labelsB2" ÄSet of label tags associated with the EdgeCache resource.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"ª
name" ÆName of the resource; provided by the client when the resource is created.
The name must be 1-64 characters long, and match the regular expression [a-zA-Z][a-zA-Z0-9_-]* which means the first character must be a letter,
and all following characters must be a dash, underscore, letter or digit.


- - -
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"˚

publicKeyszBx*v:t
r
networkservicesEdgeCacheKeysetPublicKeyEgcp:networkservices/EdgeCacheKeysetPublicKey:EdgeCacheKeysetPublicKeyAn ordered list of Ed25519 public keys to use for validating signed requests.
You must specify `public_keys` or `validation_shared_keys` (or both). The keys in `public_keys` are checked first.
You may specify no more than one Google-managed public key.
If you specify `public_keys`, you must specify at least one (1) key and may specify up to three (3) keys.
Ed25519 public keys are not secret, and only allow Google to validate a request was signed by your corresponding private key.
Ensure that the private key is kept secret, and that only authorized users can add public keys to a keyset.
Structure is documented below.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"¯
validationSharedKeysúBô*ñ:ì
ê
networkservices"EdgeCacheKeysetValidationSharedKeyYgcp:networkservices/EdgeCacheKeysetValidationSharedKey:EdgeCacheKeysetValidationSharedKey¿An ordered list of shared keys to use for validating signed requests.
Shared keys are secret.  Ensure that only authorized users can add `validation_shared_keys` to a keyset.
You can rotate keys by appending (pushing) a new key to the list of `validation_shared_keys` and removing any superseded keys.
You must specify `public_keys` or `validation_shared_keys` (or both). The keys in `public_keys` are checked first.
Structure is documented below.
*”å
W
networkservicesEdgeCacheOrigin3gcp:networkservices/edgeCacheOrigin:EdgeCacheOriginó≤EdgeCacheOrigin represents a HTTP-reachable backend for an EdgeCacheService.


To get more information about EdgeCacheOrigin, see:

* [API documentation](https://cloud.google.com/media-cdn/docs/reference/rest/v1/projects.locations.edgeCacheOrigins)

## Example Usage

### Network Services Edge Cache Origin Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networkservices.EdgeCacheOrigin("default", {
    name: "my-origin",
    originAddress: "gs://media-edge-default",
    description: "The default bucket for media edge test",
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networkservices.EdgeCacheOrigin("default",
    name="my-origin",
    origin_address="gs://media-edge-default",
    description="The default bucket for media edge test")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkServices.EdgeCacheOrigin("default", new()
    {
        Name = "my-origin",
        OriginAddress = "gs://media-edge-default",
        Description = "The default bucket for media edge test",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networkservices.NewEdgeCacheOrigin(ctx, "default", &networkservices.EdgeCacheOriginArgs{
			Name:          pulumi.String("my-origin"),
			OriginAddress: pulumi.String("gs://media-edge-default"),
			Description:   pulumi.String("The default bucket for media edge test"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networkservices.EdgeCacheOrigin;
import com.pulumi.gcp.networkservices.EdgeCacheOriginArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new EdgeCacheOrigin("default", EdgeCacheOriginArgs.builder()
            .name("my-origin")
            .originAddress("gs://media-edge-default")
            .description("The default bucket for media edge test")
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkservices:EdgeCacheOrigin
    properties:
      name: my-origin
      originAddress: gs://media-edge-default
      description: The default bucket for media edge test
```
<!--End PulumiCodeChooser -->
### Network Services Edge Cache Origin Advanced


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const fallback = new gcp.networkservices.EdgeCacheOrigin("fallback", {
    name: "my-fallback",
    originAddress: "fallback.example.com",
    description: "The default bucket for media edge test",
    maxAttempts: 3,
    protocol: "HTTP",
    port: 80,
    retryConditions: [
        "CONNECT_FAILURE",
        "NOT_FOUND",
        "HTTP_5XX",
        "FORBIDDEN",
    ],
    timeout: {
        connectTimeout: "10s",
        maxAttemptsTimeout: "20s",
        responseTimeout: "60s",
        readTimeout: "5s",
    },
    originOverrideAction: {
        urlRewrite: {
            hostRewrite: "example.com",
        },
        headerAction: {
            requestHeadersToAdds: [{
                headerName: "x-header",
                headerValue: "value",
                replace: true,
            }],
        },
    },
    originRedirect: {
        redirectConditions: [
            "MOVED_PERMANENTLY",
            "FOUND",
            "SEE_OTHER",
            "TEMPORARY_REDIRECT",
            "PERMANENT_REDIRECT",
        ],
    },
});
const _default = new gcp.networkservices.EdgeCacheOrigin("default", {
    name: "my-origin",
    originAddress: "gs://media-edge-default",
    failoverOrigin: fallback.id,
    description: "The default bucket for media edge test",
    maxAttempts: 2,
    labels: {
        a: "b",
    },
    timeout: {
        connectTimeout: "10s",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

fallback = gcp.networkservices.EdgeCacheOrigin("fallback",
    name="my-fallback",
    origin_address="fallback.example.com",
    description="The default bucket for media edge test",
    max_attempts=3,
    protocol="HTTP",
    port=80,
    retry_conditions=[
        "CONNECT_FAILURE",
        "NOT_FOUND",
        "HTTP_5XX",
        "FORBIDDEN",
    ],
    timeout={
        "connect_timeout": "10s",
        "max_attempts_timeout": "20s",
        "response_timeout": "60s",
        "read_timeout": "5s",
    },
    origin_override_action={
        "url_rewrite": {
            "host_rewrite": "example.com",
        },
        "header_action": {
            "request_headers_to_adds": [{
                "header_name": "x-header",
                "header_value": "value",
                "replace": True,
            }],
        },
    },
    origin_redirect={
        "redirect_conditions": [
            "MOVED_PERMANENTLY",
            "FOUND",
            "SEE_OTHER",
            "TEMPORARY_REDIRECT",
            "PERMANENT_REDIRECT",
        ],
    })
default = gcp.networkservices.EdgeCacheOrigin("default",
    name="my-origin",
    origin_address="gs://media-edge-default",
    failover_origin=fallback.id,
    description="The default bucket for media edge test",
    max_attempts=2,
    labels={
        "a": "b",
    },
    timeout={
        "connect_timeout": "10s",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var fallback = new Gcp.NetworkServices.EdgeCacheOrigin("fallback", new()
    {
        Name = "my-fallback",
        OriginAddress = "fallback.example.com",
        Description = "The default bucket for media edge test",
        MaxAttempts = 3,
        Protocol = "HTTP",
        Port = 80,
        RetryConditions = new[]
        {
            "CONNECT_FAILURE",
            "NOT_FOUND",
            "HTTP_5XX",
            "FORBIDDEN",
        },
        Timeout = new Gcp.NetworkServices.Inputs.EdgeCacheOriginTimeoutArgs
        {
            ConnectTimeout = "10s",
            MaxAttemptsTimeout = "20s",
            ResponseTimeout = "60s",
            ReadTimeout = "5s",
        },
        OriginOverrideAction = new Gcp.NetworkServices.Inputs.EdgeCacheOriginOriginOverrideActionArgs
        {
            UrlRewrite = new Gcp.NetworkServices.Inputs.EdgeCacheOriginOriginOverrideActionUrlRewriteArgs
            {
                HostRewrite = "example.com",
            },
            HeaderAction = new Gcp.NetworkServices.Inputs.EdgeCacheOriginOriginOverrideActionHeaderActionArgs
            {
                RequestHeadersToAdds = new[]
                {
                    new Gcp.NetworkServices.Inputs.EdgeCacheOriginOriginOverrideActionHeaderActionRequestHeadersToAddArgs
                    {
                        HeaderName = "x-header",
                        HeaderValue = "value",
                        Replace = true,
                    },
                },
            },
        },
        OriginRedirect = new Gcp.NetworkServices.Inputs.EdgeCacheOriginOriginRedirectArgs
        {
            RedirectConditions = new[]
            {
                "MOVED_PERMANENTLY",
                "FOUND",
                "SEE_OTHER",
                "TEMPORARY_REDIRECT",
                "PERMANENT_REDIRECT",
            },
        },
    });

    var @default = new Gcp.NetworkServices.EdgeCacheOrigin("default", new()
    {
        Name = "my-origin",
        OriginAddress = "gs://media-edge-default",
        FailoverOrigin = fallback.Id,
        Description = "The default bucket for media edge test",
        MaxAttempts = 2,
        Labels = 
        {
            { "a", "b" },
        },
        Timeout = new Gcp.NetworkServices.Inputs.EdgeCacheOriginTimeoutArgs
        {
            ConnectTimeout = "10s",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		fallback, err := networkservices.NewEdgeCacheOrigin(ctx, "fallback", &networkservices.EdgeCacheOriginArgs{
			Name:          pulumi.String("my-fallback"),
			OriginAddress: pulumi.String("fallback.example.com"),
			Description:   pulumi.String("The default bucket for media edge test"),
			MaxAttempts:   pulumi.Int(3),
			Protocol:      pulumi.String("HTTP"),
			Port:          pulumi.Int(80),
			RetryConditions: pulumi.StringArray{
				pulumi.String("CONNECT_FAILURE"),
				pulumi.String("NOT_FOUND"),
				pulumi.String("HTTP_5XX"),
				pulumi.String("FORBIDDEN"),
			},
			Timeout: &networkservices.EdgeCacheOriginTimeoutArgs{
				ConnectTimeout:     pulumi.String("10s"),
				MaxAttemptsTimeout: pulumi.String("20s"),
				ResponseTimeout:    pulumi.String("60s"),
				ReadTimeout:        pulumi.String("5s"),
			},
			OriginOverrideAction: &networkservices.EdgeCacheOriginOriginOverrideActionArgs{
				UrlRewrite: &networkservices.EdgeCacheOriginOriginOverrideActionUrlRewriteArgs{
					HostRewrite: pulumi.String("example.com"),
				},
				HeaderAction: &networkservices.EdgeCacheOriginOriginOverrideActionHeaderActionArgs{
					RequestHeadersToAdds: networkservices.EdgeCacheOriginOriginOverrideActionHeaderActionRequestHeadersToAddArray{
						&networkservices.EdgeCacheOriginOriginOverrideActionHeaderActionRequestHeadersToAddArgs{
							HeaderName:  pulumi.String("x-header"),
							HeaderValue: pulumi.String("value"),
							Replace:     pulumi.Bool(true),
						},
					},
				},
			},
			OriginRedirect: &networkservices.EdgeCacheOriginOriginRedirectArgs{
				RedirectConditions: pulumi.StringArray{
					pulumi.String("MOVED_PERMANENTLY"),
					pulumi.String("FOUND"),
					pulumi.String("SEE_OTHER"),
					pulumi.String("TEMPORARY_REDIRECT"),
					pulumi.String("PERMANENT_REDIRECT"),
				},
			},
		})
		if err != nil {
			return err
		}
		_, err = networkservices.NewEdgeCacheOrigin(ctx, "default", &networkservices.EdgeCacheOriginArgs{
			Name:           pulumi.String("my-origin"),
			OriginAddress:  pulumi.String("gs://media-edge-default"),
			FailoverOrigin: fallback.ID(),
			Description:    pulumi.String("The default bucket for media edge test"),
			MaxAttempts:    pulumi.Int(2),
			Labels: pulumi.StringMap{
				"a": pulumi.String("b"),
			},
			Timeout: &networkservices.EdgeCacheOriginTimeoutArgs{
				ConnectTimeout: pulumi.String("10s"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networkservices.EdgeCacheOrigin;
import com.pulumi.gcp.networkservices.EdgeCacheOriginArgs;
import com.pulumi.gcp.networkservices.inputs.EdgeCacheOriginTimeoutArgs;
import com.pulumi.gcp.networkservices.inputs.EdgeCacheOriginOriginOverrideActionArgs;
import com.pulumi.gcp.networkservices.inputs.EdgeCacheOriginOriginOverrideActionUrlRewriteArgs;
import com.pulumi.gcp.networkservices.inputs.EdgeCacheOriginOriginOverrideActionHeaderActionArgs;
import com.pulumi.gcp.networkservices.inputs.EdgeCacheOriginOriginRedirectArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var fallback = new EdgeCacheOrigin("fallback", EdgeCacheOriginArgs.builder()
            .name("my-fallback")
            .originAddress("fallback.example.com")
            .description("The default bucket for media edge test")
            .maxAttempts(3)
            .protocol("HTTP")
            .port(80)
            .retryConditions(            
                "CONNECT_FAILURE",
                "NOT_FOUND",
                "HTTP_5XX",
                "FORBIDDEN")
            .timeout(EdgeCacheOriginTimeoutArgs.builder()
                .connectTimeout("10s")
                .maxAttemptsTimeout("20s")
                .responseTimeout("60s")
                .readTimeout("5s")
                .build())
            .originOverrideAction(EdgeCacheOriginOriginOverrideActionArgs.builder()
                .urlRewrite(EdgeCacheOriginOriginOverrideActionUrlRewriteArgs.builder()
                    .hostRewrite("example.com")
                    .build())
                .headerAction(EdgeCacheOriginOriginOverrideActionHeaderActionArgs.builder()
                    .requestHeadersToAdds(EdgeCacheOriginOriginOverrideActionHeaderActionRequestHeadersToAddArgs.builder()
                        .headerName("x-header")
                        .headerValue("value")
                        .replace(true)
                        .build())
                    .build())
                .build())
            .originRedirect(EdgeCacheOriginOriginRedirectArgs.builder()
                .redirectConditions(                
                    "MOVED_PERMANENTLY",
                    "FOUND",
                    "SEE_OTHER",
                    "TEMPORARY_REDIRECT",
                    "PERMANENT_REDIRECT")
                .build())
            .build());

        var default_ = new EdgeCacheOrigin("default", EdgeCacheOriginArgs.builder()
            .name("my-origin")
            .originAddress("gs://media-edge-default")
            .failoverOrigin(fallback.id())
            .description("The default bucket for media edge test")
            .maxAttempts(2)
            .labels(Map.of("a", "b"))
            .timeout(EdgeCacheOriginTimeoutArgs.builder()
                .connectTimeout("10s")
                .build())
            .build());

    }
}
```
```yaml
resources:
  fallback:
    type: gcp:networkservices:EdgeCacheOrigin
    properties:
      name: my-fallback
      originAddress: fallback.example.com
      description: The default bucket for media edge test
      maxAttempts: 3
      protocol: HTTP
      port: 80
      retryConditions:
        - CONNECT_FAILURE
        - NOT_FOUND
        - HTTP_5XX
        - FORBIDDEN
      timeout:
        connectTimeout: 10s
        maxAttemptsTimeout: 20s
        responseTimeout: 60s
        readTimeout: 5s
      originOverrideAction:
        urlRewrite:
          hostRewrite: example.com
        headerAction:
          requestHeadersToAdds:
            - headerName: x-header
              headerValue: value
              replace: true
      originRedirect:
        redirectConditions:
          - MOVED_PERMANENTLY
          - FOUND
          - SEE_OTHER
          - TEMPORARY_REDIRECT
          - PERMANENT_REDIRECT
  default:
    type: gcp:networkservices:EdgeCacheOrigin
    properties:
      name: my-origin
      originAddress: gs://media-edge-default
      failoverOrigin: ${fallback.id}
      description: The default bucket for media edge test
      maxAttempts: 2
      labels:
        a: b
      timeout:
        connectTimeout: 10s
```
<!--End PulumiCodeChooser -->
### Network Services Edge Cache Origin V4auth


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const secret_basic = new gcp.secretmanager.Secret("secret-basic", {
    secretId: "secret-name",
    replication: {
        auto: {},
    },
});
const secret_version_basic = new gcp.secretmanager.SecretVersion("secret-version-basic", {
    secret: secret_basic.id,
    secretData: "secret-data",
});
const _default = new gcp.networkservices.EdgeCacheOrigin("default", {
    name: "my-origin",
    originAddress: "gs://media-edge-default",
    description: "The default bucket for V4 authentication",
    awsV4Authentication: {
        accessKeyId: "ACCESSKEYID",
        secretAccessKeyVersion: secret_version_basic.id,
        originRegion: "auto",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

secret_basic = gcp.secretmanager.Secret("secret-basic",
    secret_id="secret-name",
    replication={
        "auto": {},
    })
secret_version_basic = gcp.secretmanager.SecretVersion("secret-version-basic",
    secret=secret_basic.id,
    secret_data="secret-data")
default = gcp.networkservices.EdgeCacheOrigin("default",
    name="my-origin",
    origin_address="gs://media-edge-default",
    description="The default bucket for V4 authentication",
    aws_v4_authentication={
        "access_key_id": "ACCESSKEYID",
        "secret_access_key_version": secret_version_basic.id,
        "origin_region": "auto",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var secret_basic = new Gcp.SecretManager.Secret("secret-basic", new()
    {
        SecretId = "secret-name",
        Replication = new Gcp.SecretManager.Inputs.SecretReplicationArgs
        {
            Auto = null,
        },
    });

    var secret_version_basic = new Gcp.SecretManager.SecretVersion("secret-version-basic", new()
    {
        Secret = secret_basic.Id,
        SecretData = "secret-data",
    });

    var @default = new Gcp.NetworkServices.EdgeCacheOrigin("default", new()
    {
        Name = "my-origin",
        OriginAddress = "gs://media-edge-default",
        Description = "The default bucket for V4 authentication",
        AwsV4Authentication = new Gcp.NetworkServices.Inputs.EdgeCacheOriginAwsV4AuthenticationArgs
        {
            AccessKeyId = "ACCESSKEYID",
            SecretAccessKeyVersion = secret_version_basic.Id,
            OriginRegion = "auto",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/secretmanager"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := secretmanager.NewSecret(ctx, "secret-basic", &secretmanager.SecretArgs{
			SecretId: pulumi.String("secret-name"),
			Replication: &secretmanager.SecretReplicationArgs{
				Auto: &secretmanager.SecretReplicationAutoArgs{},
			},
		})
		if err != nil {
			return err
		}
		_, err = secretmanager.NewSecretVersion(ctx, "secret-version-basic", &secretmanager.SecretVersionArgs{
			Secret:     secret_basic.ID(),
			SecretData: pulumi.String("secret-data"),
		})
		if err != nil {
			return err
		}
		_, err = networkservices.NewEdgeCacheOrigin(ctx, "default", &networkservices.EdgeCacheOriginArgs{
			Name:          pulumi.String("my-origin"),
			OriginAddress: pulumi.String("gs://media-edge-default"),
			Description:   pulumi.String("The default bucket for V4 authentication"),
			AwsV4Authentication: &networkservices.EdgeCacheOriginAwsV4AuthenticationArgs{
				AccessKeyId:            pulumi.String("ACCESSKEYID"),
				SecretAccessKeyVersion: secret_version_basic.ID(),
				OriginRegion:           pulumi.String("auto"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.secretmanager.Secret;
import com.pulumi.gcp.secretmanager.SecretArgs;
import com.pulumi.gcp.secretmanager.inputs.SecretReplicationArgs;
import com.pulumi.gcp.secretmanager.inputs.SecretReplicationAutoArgs;
import com.pulumi.gcp.secretmanager.SecretVersion;
import com.pulumi.gcp.secretmanager.SecretVersionArgs;
import com.pulumi.gcp.networkservices.EdgeCacheOrigin;
import com.pulumi.gcp.networkservices.EdgeCacheOriginArgs;
import com.pulumi.gcp.networkservices.inputs.EdgeCacheOriginAwsV4AuthenticationArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var secret_basic = new Secret("secret-basic", SecretArgs.builder()
            .secretId("secret-name")
            .replication(SecretReplicationArgs.builder()
                .auto()
                .build())
            .build());

        var secret_version_basic = new SecretVersion("secret-version-basic", SecretVersionArgs.builder()
            .secret(secret_basic.id())
            .secretData("secret-data")
            .build());

        var default_ = new EdgeCacheOrigin("default", EdgeCacheOriginArgs.builder()
            .name("my-origin")
            .originAddress("gs://media-edge-default")
            .description("The default bucket for V4 authentication")
            .awsV4Authentication(EdgeCacheOriginAwsV4AuthenticationArgs.builder()
                .accessKeyId("ACCESSKEYID")
                .secretAccessKeyVersion(secret_version_basic.id())
                .originRegion("auto")
                .build())
            .build());

    }
}
```
```yaml
resources:
  secret-basic:
    type: gcp:secretmanager:Secret
    properties:
      secretId: secret-name
      replication:
        auto: {}
  secret-version-basic:
    type: gcp:secretmanager:SecretVersion
    properties:
      secret: ${["secret-basic"].id}
      secretData: secret-data
  default:
    type: gcp:networkservices:EdgeCacheOrigin
    properties:
      name: my-origin
      originAddress: gs://media-edge-default
      description: The default bucket for V4 authentication
      awsV4Authentication:
        accessKeyId: ACCESSKEYID
        secretAccessKeyVersion: ${["secret-version-basic"].id}
        originRegion: auto
```
<!--End PulumiCodeChooser -->

## Import

EdgeCacheOrigin can be imported using any of these accepted formats:

* `projects/{{project}}/locations/global/edgeCacheOrigins/{{name}}`

* `{{project}}/{{name}}`

* `{{name}}`

When using the `pulumi import` command, EdgeCacheOrigin can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkservices/edgeCacheOrigin:EdgeCacheOrigin default projects/{{project}}/locations/global/edgeCacheOrigins/{{name}}
```

```sh
$ pulumi import gcp:networkservices/edgeCacheOrigin:EdgeCacheOrigin default {{project}}/{{name}}
```

```sh
$ pulumi import gcp:networkservices/edgeCacheOrigin:EdgeCacheOrigin default {{name}}
```

à
awsV4AuthenticationôBñ:ì
ê
networkservices"EdgeCacheOriginAwsV4AuthenticationYgcp:networkservices/EdgeCacheOriginAwsV4Authentication:EdgeCacheOriginAwsV4AuthenticationUEnable AWS Signature Version 4 origin authentication.
Structure is documented below.
C
descriptionB" .A human-readable description of the resource.
±
failoverOriginB" òThe Origin resource to try when the current origin cannot be reached.
After maxAttempts is reached, the configured failoverOrigin will be used to fulfil the request.
The value of timeout.maxAttemptsTimeout dictates the timeout across all origins.
A reference to a Topic resource.
ì
labelsB2" ÄSet of label tags associated with the EdgeCache resource.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
”
maxAttemptsB ΩThe maximum number of attempts to cache fill from this origin. Another attempt is made when a cache fill fails with one of the retryConditions.
Once maxAttempts to this origin have failed the failoverOrigin will be used, if one is specified. That failoverOrigin may specify its own maxAttempts,
retryConditions and failoverOrigin to control its own cache fill failures.
The total number of allowed attempts to cache fill across this and failover origins is limited to four.
The total time allowed for cache fill attempts across this and failover origins can be controlled with maxAttemptsTimeout.
The last valid, non-retried response from all origins will be returned to the client.
If no origin returns a valid response, an HTTP 502 will be returned to the client.
Defaults to 1. Must be a value greater than 0 and less than 4.
Ω
nameB" ÆName of the resource; provided by the client when the resource is created.
The name must be 1-64 characters long, and match the regular expression [a-zA-Z][a-zA-Z0-9_-]* which means the first character must be a letter,
and all following characters must be a dash, underscore, letter or digit.


- - -
—
originAddress" ªA fully qualified domain name (FQDN) or IP address reachable over the public Internet, or the address of a Google Cloud Storage bucket.
This address will be used as the origin for cache requests - e.g. FQDN: media-backend.example.com, IPv4: 35.218.1.1, IPv6: 2607:f8b0:4012:809::200e, Cloud Storage: gs://bucketname
When providing an FQDN (hostname), it must be publicly resolvable (e.g. via Google public DNS) and IP addresses must be publicly routable.  It must not contain a protocol (e.g., https://) and it must not contain any slashes.
If a Cloud Storage bucket is provided, it must be in the canonical "gs://bucketname" format. Other forms, such as "storage.googleapis.com", will be rejected.
Ω
originOverrideActionúBô:ñ
ì
networkservices#EdgeCacheOriginOriginOverrideAction[gcp:networkservices/EdgeCacheOriginOriginOverrideAction:EdgeCacheOriginOriginOverrideActionÖThe override actions, including url rewrites and header
additions, for requests that use this origin.
Structure is documented below.
·
originRedirectäBá:Ñ
Å
networkservicesEdgeCacheOriginOriginRedirectOgcp:networkservices/EdgeCacheOriginOriginRedirect:EdgeCacheOriginOriginRedirectBFollow redirects from this origin.
Structure is documented below.
~
portB pThe port to connect to the origin on.
Defaults to port 443 for HTTP2 and HTTPS protocols, and port 80 for HTTP.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.

protocolB" ›The protocol to use to connect to the configured origin. Defaults to HTTP2, and it is strongly recommended that users use HTTP2 for both security & performance.
When using HTTP2 or HTTPS as the protocol, a valid, publicly-signed, unexpired TLS (SSL) certificate must be presented by the origin server.
Possible values are: `HTTP2`, `HTTPS`, `HTTP`.
‚

retryConditionsB*" ∆
Specifies one or more retry conditions for the configured origin.
If the failure mode during a connection attempt to the origin matches the configured retryCondition(s),
the origin request will be retried up to maxAttempts times. The failoverOrigin, if configured, will then be used to satisfy the request.
The default retryCondition is "CONNECT_FAILURE".
retryConditions apply to this origin, and not subsequent failoverOrigin(s),
which may specify their own retryConditions and maxAttempts.
Valid values are:
- CONNECT_FAILURE: Retry on failures connecting to origins, for example due to connection timeouts.
- HTTP_5XX: Retry if the origin responds with any 5xx response code, or if the origin does not respond at all, example: disconnects, reset, read timeout, connection failure, and refused streams.
- GATEWAY_ERROR: Similar to 5xx, but only applies to response codes 502, 503 or 504.
- RETRIABLE_4XX: Retry for retriable 4xx response codes, which include HTTP 409 (Conflict) and HTTP 429 (Too Many Requests)
- NOT_FOUND: Retry if the origin returns a HTTP 404 (Not Found). This can be useful when generating video content, and the segment is not available yet.
- FORBIDDEN: Retry if the origin returns a HTTP 403 (Forbidden).
Each value may be one of: `CONNECT_FAILURE`, `HTTP_5XX`, `GATEWAY_ERROR`, `RETRIABLE_4XX`, `NOT_FOUND`, `FORBIDDEN`.
›
timeoutrBp:n
l
networkservicesEdgeCacheOriginTimeoutAgcp:networkservices/EdgeCacheOriginTimeout:EdgeCacheOriginTimeout^The connection and HTTP timeout configuration for this origin.
Structure is documented below.
"à
awsV4AuthenticationôBñ:ì
ê
networkservices"EdgeCacheOriginAwsV4AuthenticationYgcp:networkservices/EdgeCacheOriginAwsV4Authentication:EdgeCacheOriginAwsV4AuthenticationUEnable AWS Signature Version 4 origin authentication.
Structure is documented below.
"C
descriptionB" .A human-readable description of the resource.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"±
failoverOriginB" òThe Origin resource to try when the current origin cannot be reached.
After maxAttempts is reached, the configured failoverOrigin will be used to fulfil the request.
The value of timeout.maxAttemptsTimeout dictates the timeout across all origins.
A reference to a Topic resource.
"ì
labelsB2" ÄSet of label tags associated with the EdgeCache resource.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"”
maxAttemptsB ΩThe maximum number of attempts to cache fill from this origin. Another attempt is made when a cache fill fails with one of the retryConditions.
Once maxAttempts to this origin have failed the failoverOrigin will be used, if one is specified. That failoverOrigin may specify its own maxAttempts,
retryConditions and failoverOrigin to control its own cache fill failures.
The total number of allowed attempts to cache fill across this and failover origins is limited to four.
The total time allowed for cache fill attempts across this and failover origins can be controlled with maxAttemptsTimeout.
The last valid, non-retried response from all origins will be returned to the client.
If no origin returns a valid response, an HTTP 502 will be returned to the client.
Defaults to 1. Must be a value greater than 0 and less than 4.
"ª
name" ÆName of the resource; provided by the client when the resource is created.
The name must be 1-64 characters long, and match the regular expression [a-zA-Z][a-zA-Z0-9_-]* which means the first character must be a letter,
and all following characters must be a dash, underscore, letter or digit.


- - -
"—
originAddress" ªA fully qualified domain name (FQDN) or IP address reachable over the public Internet, or the address of a Google Cloud Storage bucket.
This address will be used as the origin for cache requests - e.g. FQDN: media-backend.example.com, IPv4: 35.218.1.1, IPv6: 2607:f8b0:4012:809::200e, Cloud Storage: gs://bucketname
When providing an FQDN (hostname), it must be publicly resolvable (e.g. via Google public DNS) and IP addresses must be publicly routable.  It must not contain a protocol (e.g., https://) and it must not contain any slashes.
If a Cloud Storage bucket is provided, it must be in the canonical "gs://bucketname" format. Other forms, such as "storage.googleapis.com", will be rejected.
"Ω
originOverrideActionúBô:ñ
ì
networkservices#EdgeCacheOriginOriginOverrideAction[gcp:networkservices/EdgeCacheOriginOriginOverrideAction:EdgeCacheOriginOriginOverrideActionÖThe override actions, including url rewrites and header
additions, for requests that use this origin.
Structure is documented below.
"·
originRedirectäBá:Ñ
Å
networkservicesEdgeCacheOriginOriginRedirectOgcp:networkservices/EdgeCacheOriginOriginRedirect:EdgeCacheOriginOriginRedirectBFollow redirects from this origin.
Structure is documented below.
"|
port pThe port to connect to the origin on.
Defaults to port 443 for HTTP2 and HTTPS protocols, and port 80 for HTTP.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"Ó
protocol" ›The protocol to use to connect to the configured origin. Defaults to HTTP2, and it is strongly recommended that users use HTTP2 for both security & performance.
When using HTTP2 or HTTPS as the protocol, a valid, publicly-signed, unexpired TLS (SSL) certificate must be presented by the origin server.
Possible values are: `HTTP2`, `HTTPS`, `HTTP`.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"‡

retryConditions*" ∆
Specifies one or more retry conditions for the configured origin.
If the failure mode during a connection attempt to the origin matches the configured retryCondition(s),
the origin request will be retried up to maxAttempts times. The failoverOrigin, if configured, will then be used to satisfy the request.
The default retryCondition is "CONNECT_FAILURE".
retryConditions apply to this origin, and not subsequent failoverOrigin(s),
which may specify their own retryConditions and maxAttempts.
Valid values are:
- CONNECT_FAILURE: Retry on failures connecting to origins, for example due to connection timeouts.
- HTTP_5XX: Retry if the origin responds with any 5xx response code, or if the origin does not respond at all, example: disconnects, reset, read timeout, connection failure, and refused streams.
- GATEWAY_ERROR: Similar to 5xx, but only applies to response codes 502, 503 or 504.
- RETRIABLE_4XX: Retry for retriable 4xx response codes, which include HTTP 409 (Conflict) and HTTP 429 (Too Many Requests)
- NOT_FOUND: Retry if the origin returns a HTTP 404 (Not Found). This can be useful when generating video content, and the segment is not available yet.
- FORBIDDEN: Retry if the origin returns a HTTP 403 (Forbidden).
Each value may be one of: `CONNECT_FAILURE`, `HTTP_5XX`, `GATEWAY_ERROR`, `RETRIABLE_4XX`, `NOT_FOUND`, `FORBIDDEN`.
"›
timeoutrBp:n
l
networkservicesEdgeCacheOriginTimeoutAgcp:networkservices/EdgeCacheOriginTimeout:EdgeCacheOriginTimeout^The connection and HTTP timeout configuration for this origin.
Structure is documented below.
*¿§
Z
networkservicesEdgeCacheService5gcp:networkservices/edgeCacheService:EdgeCacheServiceÂˆEdgeCacheService defines the IP addresses, protocols, security policies, cache policies and routing configuration.



> **Warning:** These resources require allow-listing to use, and are not openly available to all Cloud customers. Engage with your Cloud account team to discuss how to onboard.

## Example Usage

### Network Services Edge Cache Service Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const dest = new gcp.storage.Bucket("dest", {
    name: "my-bucket",
    location: "US",
    forceDestroy: true,
});
const instance = new gcp.networkservices.EdgeCacheOrigin("instance", {
    name: "my-origin",
    originAddress: dest.url,
    description: "The default bucket for media edge test",
    maxAttempts: 2,
    timeout: {
        connectTimeout: "10s",
    },
});
const instanceEdgeCacheService = new gcp.networkservices.EdgeCacheService("instance", {
    name: "my-service",
    description: "some description",
    routing: {
        hostRules: [{
            description: "host rule description",
            hosts: ["sslcert.tf-test.club"],
            pathMatcher: "routes",
        }],
        pathMatchers: [{
            name: "routes",
            routeRules: [{
                description: "a route rule to match against",
                priority: "1",
                matchRules: [{
                    prefixMatch: "/",
                }],
                origin: instance.name,
                routeAction: {
                    cdnPolicy: {
                        cacheMode: "CACHE_ALL_STATIC",
                        defaultTtl: "3600s",
                    },
                },
                headerAction: {
                    responseHeaderToAdds: [{
                        headerName: "x-cache-status",
                        headerValue: "{cdn_cache_status}",
                    }],
                },
            }],
        }],
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

dest = gcp.storage.Bucket("dest",
    name="my-bucket",
    location="US",
    force_destroy=True)
instance = gcp.networkservices.EdgeCacheOrigin("instance",
    name="my-origin",
    origin_address=dest.url,
    description="The default bucket for media edge test",
    max_attempts=2,
    timeout={
        "connect_timeout": "10s",
    })
instance_edge_cache_service = gcp.networkservices.EdgeCacheService("instance",
    name="my-service",
    description="some description",
    routing={
        "host_rules": [{
            "description": "host rule description",
            "hosts": ["sslcert.tf-test.club"],
            "path_matcher": "routes",
        }],
        "path_matchers": [{
            "name": "routes",
            "route_rules": [{
                "description": "a route rule to match against",
                "priority": "1",
                "match_rules": [{
                    "prefix_match": "/",
                }],
                "origin": instance.name,
                "route_action": {
                    "cdn_policy": {
                        "cache_mode": "CACHE_ALL_STATIC",
                        "default_ttl": "3600s",
                    },
                },
                "header_action": {
                    "response_header_to_adds": [{
                        "header_name": "x-cache-status",
                        "header_value": "{cdn_cache_status}",
                    }],
                },
            }],
        }],
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var dest = new Gcp.Storage.Bucket("dest", new()
    {
        Name = "my-bucket",
        Location = "US",
        ForceDestroy = true,
    });

    var instance = new Gcp.NetworkServices.EdgeCacheOrigin("instance", new()
    {
        Name = "my-origin",
        OriginAddress = dest.Url,
        Description = "The default bucket for media edge test",
        MaxAttempts = 2,
        Timeout = new Gcp.NetworkServices.Inputs.EdgeCacheOriginTimeoutArgs
        {
            ConnectTimeout = "10s",
        },
    });

    var instanceEdgeCacheService = new Gcp.NetworkServices.EdgeCacheService("instance", new()
    {
        Name = "my-service",
        Description = "some description",
        Routing = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingArgs
        {
            HostRules = new[]
            {
                new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingHostRuleArgs
                {
                    Description = "host rule description",
                    Hosts = new[]
                    {
                        "sslcert.tf-test.club",
                    },
                    PathMatcher = "routes",
                },
            },
            PathMatchers = new[]
            {
                new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherArgs
                {
                    Name = "routes",
                    RouteRules = new[]
                    {
                        new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleArgs
                        {
                            Description = "a route rule to match against",
                            Priority = "1",
                            MatchRules = new[]
                            {
                                new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs
                                {
                                    PrefixMatch = "/",
                                },
                            },
                            Origin = instance.Name,
                            RouteAction = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionArgs
                            {
                                CdnPolicy = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyArgs
                                {
                                    CacheMode = "CACHE_ALL_STATIC",
                                    DefaultTtl = "3600s",
                                },
                            },
                            HeaderAction = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionArgs
                            {
                                ResponseHeaderToAdds = new[]
                                {
                                    new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToAddArgs
                                    {
                                        HeaderName = "x-cache-status",
                                        HeaderValue = "{cdn_cache_status}",
                                    },
                                },
                            },
                        },
                    },
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/storage"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		dest, err := storage.NewBucket(ctx, "dest", &storage.BucketArgs{
			Name:         pulumi.String("my-bucket"),
			Location:     pulumi.String("US"),
			ForceDestroy: pulumi.Bool(true),
		})
		if err != nil {
			return err
		}
		instance, err := networkservices.NewEdgeCacheOrigin(ctx, "instance", &networkservices.EdgeCacheOriginArgs{
			Name:          pulumi.String("my-origin"),
			OriginAddress: dest.Url,
			Description:   pulumi.String("The default bucket for media edge test"),
			MaxAttempts:   pulumi.Int(2),
			Timeout: &networkservices.EdgeCacheOriginTimeoutArgs{
				ConnectTimeout: pulumi.String("10s"),
			},
		})
		if err != nil {
			return err
		}
		_, err = networkservices.NewEdgeCacheService(ctx, "instance", &networkservices.EdgeCacheServiceArgs{
			Name:        pulumi.String("my-service"),
			Description: pulumi.String("some description"),
			Routing: &networkservices.EdgeCacheServiceRoutingArgs{
				HostRules: networkservices.EdgeCacheServiceRoutingHostRuleArray{
					&networkservices.EdgeCacheServiceRoutingHostRuleArgs{
						Description: pulumi.String("host rule description"),
						Hosts: pulumi.StringArray{
							pulumi.String("sslcert.tf-test.club"),
						},
						PathMatcher: pulumi.String("routes"),
					},
				},
				PathMatchers: networkservices.EdgeCacheServiceRoutingPathMatcherArray{
					&networkservices.EdgeCacheServiceRoutingPathMatcherArgs{
						Name: pulumi.String("routes"),
						RouteRules: networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleArray{
							&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleArgs{
								Description: pulumi.String("a route rule to match against"),
								Priority:    pulumi.String("1"),
								MatchRules: networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArray{
									&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs{
										PrefixMatch: pulumi.String("/"),
									},
								},
								Origin: instance.Name,
								RouteAction: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionArgs{
									CdnPolicy: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyArgs{
										CacheMode:  pulumi.String("CACHE_ALL_STATIC"),
										DefaultTtl: pulumi.String("3600s"),
									},
								},
								HeaderAction: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionArgs{
									ResponseHeaderToAdds: networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToAddArray{
										&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToAddArgs{
											HeaderName:  pulumi.String("x-cache-status"),
											HeaderValue: pulumi.String("{cdn_cache_status}"),
										},
									},
								},
							},
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.storage.Bucket;
import com.pulumi.gcp.storage.BucketArgs;
import com.pulumi.gcp.networkservices.EdgeCacheOrigin;
import com.pulumi.gcp.networkservices.EdgeCacheOriginArgs;
import com.pulumi.gcp.networkservices.inputs.EdgeCacheOriginTimeoutArgs;
import com.pulumi.gcp.networkservices.EdgeCacheService;
import com.pulumi.gcp.networkservices.EdgeCacheServiceArgs;
import com.pulumi.gcp.networkservices.inputs.EdgeCacheServiceRoutingArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var dest = new Bucket("dest", BucketArgs.builder()
            .name("my-bucket")
            .location("US")
            .forceDestroy(true)
            .build());

        var instance = new EdgeCacheOrigin("instance", EdgeCacheOriginArgs.builder()
            .name("my-origin")
            .originAddress(dest.url())
            .description("The default bucket for media edge test")
            .maxAttempts(2)
            .timeout(EdgeCacheOriginTimeoutArgs.builder()
                .connectTimeout("10s")
                .build())
            .build());

        var instanceEdgeCacheService = new EdgeCacheService("instanceEdgeCacheService", EdgeCacheServiceArgs.builder()
            .name("my-service")
            .description("some description")
            .routing(EdgeCacheServiceRoutingArgs.builder()
                .hostRules(EdgeCacheServiceRoutingHostRuleArgs.builder()
                    .description("host rule description")
                    .hosts("sslcert.tf-test.club")
                    .pathMatcher("routes")
                    .build())
                .pathMatchers(EdgeCacheServiceRoutingPathMatcherArgs.builder()
                    .name("routes")
                    .routeRules(EdgeCacheServiceRoutingPathMatcherRouteRuleArgs.builder()
                        .description("a route rule to match against")
                        .priority(1)
                        .matchRules(EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs.builder()
                            .prefixMatch("/")
                            .build())
                        .origin(instance.name())
                        .routeAction(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionArgs.builder()
                            .cdnPolicy(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyArgs.builder()
                                .cacheMode("CACHE_ALL_STATIC")
                                .defaultTtl("3600s")
                                .build())
                            .build())
                        .headerAction(EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionArgs.builder()
                            .responseHeaderToAdds(EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToAddArgs.builder()
                                .headerName("x-cache-status")
                                .headerValue("{cdn_cache_status}")
                                .build())
                            .build())
                        .build())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  dest:
    type: gcp:storage:Bucket
    properties:
      name: my-bucket
      location: US
      forceDestroy: true
  instance:
    type: gcp:networkservices:EdgeCacheOrigin
    properties:
      name: my-origin
      originAddress: ${dest.url}
      description: The default bucket for media edge test
      maxAttempts: 2
      timeout:
        connectTimeout: 10s
  instanceEdgeCacheService:
    type: gcp:networkservices:EdgeCacheService
    name: instance
    properties:
      name: my-service
      description: some description
      routing:
        hostRules:
          - description: host rule description
            hosts:
              - sslcert.tf-test.club
            pathMatcher: routes
        pathMatchers:
          - name: routes
            routeRules:
              - description: a route rule to match against
                priority: 1
                matchRules:
                  - prefixMatch: /
                origin: ${instance.name}
                routeAction:
                  cdnPolicy:
                    cacheMode: CACHE_ALL_STATIC
                    defaultTtl: 3600s
                headerAction:
                  responseHeaderToAdds:
                    - headerName: x-cache-status
                      headerValue: '{cdn_cache_status}'
```
<!--End PulumiCodeChooser -->
### Network Services Edge Cache Service Advanced


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const dest = new gcp.storage.Bucket("dest", {
    name: "my-bucket",
    location: "US",
    forceDestroy: true,
});
const google = new gcp.networkservices.EdgeCacheOrigin("google", {
    name: "origin-google",
    originAddress: "google.com",
    description: "The default bucket for media edge test",
    maxAttempts: 2,
    timeout: {
        connectTimeout: "10s",
    },
});
const instance = new gcp.networkservices.EdgeCacheOrigin("instance", {
    name: "my-origin",
    originAddress: dest.url,
    description: "The default bucket for media edge test",
    maxAttempts: 2,
    timeout: {
        connectTimeout: "10s",
    },
});
const instanceEdgeCacheService = new gcp.networkservices.EdgeCacheService("instance", {
    name: "my-service",
    description: "some description",
    disableQuic: true,
    disableHttp2: true,
    labels: {
        a: "b",
    },
    routing: {
        hostRules: [
            {
                description: "host rule description",
                hosts: ["sslcert.tf-test.club"],
                pathMatcher: "routes",
            },
            {
                description: "host rule2",
                hosts: ["sslcert.tf-test2.club"],
                pathMatcher: "routes",
            },
            {
                description: "host rule3",
                hosts: ["sslcert.tf-test3.club"],
                pathMatcher: "routesAdvanced",
            },
        ],
        pathMatchers: [
            {
                name: "routes",
                routeRules: [{
                    description: "a route rule to match against",
                    priority: "1",
                    matchRules: [{
                        prefixMatch: "/",
                    }],
                    origin: instance.name,
                    routeAction: {
                        cdnPolicy: {
                            cacheMode: "CACHE_ALL_STATIC",
                            defaultTtl: "3600s",
                        },
                    },
                    headerAction: {
                        responseHeaderToAdds: [{
                            headerName: "x-cache-status",
                            headerValue: "{cdn_cache_status}",
                        }],
                    },
                }],
            },
            {
                name: "routesAdvanced",
                description: "an advanced ruleset",
                routeRules: [
                    {
                        description: "an advanced route rule to match against",
                        priority: "1",
                        matchRules: [
                            {
                                prefixMatch: "/potato/",
                                queryParameterMatches: [
                                    {
                                        name: "debug",
                                        presentMatch: true,
                                    },
                                    {
                                        name: "state",
                                        exactMatch: "debug",
                                    },
                                ],
                            },
                            {
                                fullPathMatch: "/apple",
                            },
                        ],
                        headerAction: {
                            requestHeaderToAdds: [
                                {
                                    headerName: "debug",
                                    headerValue: "true",
                                    replace: true,
                                },
                                {
                                    headerName: "potato",
                                    headerValue: "plant",
                                },
                            ],
                            responseHeaderToAdds: [{
                                headerName: "potato",
                                headerValue: "plant",
                                replace: true,
                            }],
                            requestHeaderToRemoves: [{
                                headerName: "prod",
                            }],
                            responseHeaderToRemoves: [{
                                headerName: "prod",
                            }],
                        },
                        origin: instance.name,
                        routeAction: {
                            cdnPolicy: {
                                cacheMode: "CACHE_ALL_STATIC",
                                defaultTtl: "3800s",
                                clientTtl: "3600s",
                                maxTtl: "9000s",
                                cacheKeyPolicy: {
                                    includeProtocol: true,
                                    excludeHost: true,
                                    includedQueryParameters: [
                                        "apple",
                                        "dev",
                                        "santa",
                                        "claus",
                                    ],
                                    includedHeaderNames: ["banana"],
                                    includedCookieNames: ["orange"],
                                },
                                negativeCaching: true,
                                signedRequestMode: "DISABLED",
                                negativeCachingPolicy: {
                                    "500": "3000s",
                                },
                            },
                            urlRewrite: {
                                pathPrefixRewrite: "/dev",
                                hostRewrite: "dev.club",
                            },
                            corsPolicy: {
                                maxAge: "2500s",
                                allowCredentials: true,
                                allowOrigins: ["*"],
                                allowMethods: ["GET"],
                                allowHeaders: ["dev"],
                                exposeHeaders: ["prod"],
                            },
                        },
                    },
                    {
                        description: "a second route rule to match against",
                        priority: "2",
                        matchRules: [{
                            fullPathMatch: "/yay",
                        }],
                        origin: instance.name,
                        routeAction: {
                            cdnPolicy: {
                                cacheMode: "CACHE_ALL_STATIC",
                                defaultTtl: "3600s",
                                cacheKeyPolicy: {
                                    excludedQueryParameters: ["dev"],
                                },
                            },
                            corsPolicy: {
                                maxAge: "3000s",
                                allowHeaders: ["dev"],
                                disabled: true,
                            },
                        },
                    },
                ],
            },
        ],
    },
    logConfig: {
        enable: true,
        sampleRate: 0.01,
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

dest = gcp.storage.Bucket("dest",
    name="my-bucket",
    location="US",
    force_destroy=True)
google = gcp.networkservices.EdgeCacheOrigin("google",
    name="origin-google",
    origin_address="google.com",
    description="The default bucket for media edge test",
    max_attempts=2,
    timeout={
        "connect_timeout": "10s",
    })
instance = gcp.networkservices.EdgeCacheOrigin("instance",
    name="my-origin",
    origin_address=dest.url,
    description="The default bucket for media edge test",
    max_attempts=2,
    timeout={
        "connect_timeout": "10s",
    })
instance_edge_cache_service = gcp.networkservices.EdgeCacheService("instance",
    name="my-service",
    description="some description",
    disable_quic=True,
    disable_http2=True,
    labels={
        "a": "b",
    },
    routing={
        "host_rules": [
            {
                "description": "host rule description",
                "hosts": ["sslcert.tf-test.club"],
                "path_matcher": "routes",
            },
            {
                "description": "host rule2",
                "hosts": ["sslcert.tf-test2.club"],
                "path_matcher": "routes",
            },
            {
                "description": "host rule3",
                "hosts": ["sslcert.tf-test3.club"],
                "path_matcher": "routesAdvanced",
            },
        ],
        "path_matchers": [
            {
                "name": "routes",
                "route_rules": [{
                    "description": "a route rule to match against",
                    "priority": "1",
                    "match_rules": [{
                        "prefix_match": "/",
                    }],
                    "origin": instance.name,
                    "route_action": {
                        "cdn_policy": {
                            "cache_mode": "CACHE_ALL_STATIC",
                            "default_ttl": "3600s",
                        },
                    },
                    "header_action": {
                        "response_header_to_adds": [{
                            "header_name": "x-cache-status",
                            "header_value": "{cdn_cache_status}",
                        }],
                    },
                }],
            },
            {
                "name": "routesAdvanced",
                "description": "an advanced ruleset",
                "route_rules": [
                    {
                        "description": "an advanced route rule to match against",
                        "priority": "1",
                        "match_rules": [
                            {
                                "prefix_match": "/potato/",
                                "query_parameter_matches": [
                                    {
                                        "name": "debug",
                                        "present_match": True,
                                    },
                                    {
                                        "name": "state",
                                        "exact_match": "debug",
                                    },
                                ],
                            },
                            {
                                "full_path_match": "/apple",
                            },
                        ],
                        "header_action": {
                            "request_header_to_adds": [
                                {
                                    "header_name": "debug",
                                    "header_value": "true",
                                    "replace": True,
                                },
                                {
                                    "header_name": "potato",
                                    "header_value": "plant",
                                },
                            ],
                            "response_header_to_adds": [{
                                "header_name": "potato",
                                "header_value": "plant",
                                "replace": True,
                            }],
                            "request_header_to_removes": [{
                                "header_name": "prod",
                            }],
                            "response_header_to_removes": [{
                                "header_name": "prod",
                            }],
                        },
                        "origin": instance.name,
                        "route_action": {
                            "cdn_policy": {
                                "cache_mode": "CACHE_ALL_STATIC",
                                "default_ttl": "3800s",
                                "client_ttl": "3600s",
                                "max_ttl": "9000s",
                                "cache_key_policy": {
                                    "include_protocol": True,
                                    "exclude_host": True,
                                    "included_query_parameters": [
                                        "apple",
                                        "dev",
                                        "santa",
                                        "claus",
                                    ],
                                    "included_header_names": ["banana"],
                                    "included_cookie_names": ["orange"],
                                },
                                "negative_caching": True,
                                "signed_request_mode": "DISABLED",
                                "negative_caching_policy": {
                                    "500": "3000s",
                                },
                            },
                            "url_rewrite": {
                                "path_prefix_rewrite": "/dev",
                                "host_rewrite": "dev.club",
                            },
                            "cors_policy": {
                                "max_age": "2500s",
                                "allow_credentials": True,
                                "allow_origins": ["*"],
                                "allow_methods": ["GET"],
                                "allow_headers": ["dev"],
                                "expose_headers": ["prod"],
                            },
                        },
                    },
                    {
                        "description": "a second route rule to match against",
                        "priority": "2",
                        "match_rules": [{
                            "full_path_match": "/yay",
                        }],
                        "origin": instance.name,
                        "route_action": {
                            "cdn_policy": {
                                "cache_mode": "CACHE_ALL_STATIC",
                                "default_ttl": "3600s",
                                "cache_key_policy": {
                                    "excluded_query_parameters": ["dev"],
                                },
                            },
                            "cors_policy": {
                                "max_age": "3000s",
                                "allow_headers": ["dev"],
                                "disabled": True,
                            },
                        },
                    },
                ],
            },
        ],
    },
    log_config={
        "enable": True,
        "sample_rate": 0.01,
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var dest = new Gcp.Storage.Bucket("dest", new()
    {
        Name = "my-bucket",
        Location = "US",
        ForceDestroy = true,
    });

    var google = new Gcp.NetworkServices.EdgeCacheOrigin("google", new()
    {
        Name = "origin-google",
        OriginAddress = "google.com",
        Description = "The default bucket for media edge test",
        MaxAttempts = 2,
        Timeout = new Gcp.NetworkServices.Inputs.EdgeCacheOriginTimeoutArgs
        {
            ConnectTimeout = "10s",
        },
    });

    var instance = new Gcp.NetworkServices.EdgeCacheOrigin("instance", new()
    {
        Name = "my-origin",
        OriginAddress = dest.Url,
        Description = "The default bucket for media edge test",
        MaxAttempts = 2,
        Timeout = new Gcp.NetworkServices.Inputs.EdgeCacheOriginTimeoutArgs
        {
            ConnectTimeout = "10s",
        },
    });

    var instanceEdgeCacheService = new Gcp.NetworkServices.EdgeCacheService("instance", new()
    {
        Name = "my-service",
        Description = "some description",
        DisableQuic = true,
        DisableHttp2 = true,
        Labels = 
        {
            { "a", "b" },
        },
        Routing = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingArgs
        {
            HostRules = new[]
            {
                new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingHostRuleArgs
                {
                    Description = "host rule description",
                    Hosts = new[]
                    {
                        "sslcert.tf-test.club",
                    },
                    PathMatcher = "routes",
                },
                new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingHostRuleArgs
                {
                    Description = "host rule2",
                    Hosts = new[]
                    {
                        "sslcert.tf-test2.club",
                    },
                    PathMatcher = "routes",
                },
                new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingHostRuleArgs
                {
                    Description = "host rule3",
                    Hosts = new[]
                    {
                        "sslcert.tf-test3.club",
                    },
                    PathMatcher = "routesAdvanced",
                },
            },
            PathMatchers = new[]
            {
                new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherArgs
                {
                    Name = "routes",
                    RouteRules = new[]
                    {
                        new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleArgs
                        {
                            Description = "a route rule to match against",
                            Priority = "1",
                            MatchRules = new[]
                            {
                                new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs
                                {
                                    PrefixMatch = "/",
                                },
                            },
                            Origin = instance.Name,
                            RouteAction = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionArgs
                            {
                                CdnPolicy = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyArgs
                                {
                                    CacheMode = "CACHE_ALL_STATIC",
                                    DefaultTtl = "3600s",
                                },
                            },
                            HeaderAction = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionArgs
                            {
                                ResponseHeaderToAdds = new[]
                                {
                                    new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToAddArgs
                                    {
                                        HeaderName = "x-cache-status",
                                        HeaderValue = "{cdn_cache_status}",
                                    },
                                },
                            },
                        },
                    },
                },
                new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherArgs
                {
                    Name = "routesAdvanced",
                    Description = "an advanced ruleset",
                    RouteRules = new[]
                    {
                        new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleArgs
                        {
                            Description = "an advanced route rule to match against",
                            Priority = "1",
                            MatchRules = new[]
                            {
                                new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs
                                {
                                    PrefixMatch = "/potato/",
                                    QueryParameterMatches = new[]
                                    {
                                        new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleQueryParameterMatchArgs
                                        {
                                            Name = "debug",
                                            PresentMatch = true,
                                        },
                                        new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleQueryParameterMatchArgs
                                        {
                                            Name = "state",
                                            ExactMatch = "debug",
                                        },
                                    },
                                },
                                new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs
                                {
                                    FullPathMatch = "/apple",
                                },
                            },
                            HeaderAction = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionArgs
                            {
                                RequestHeaderToAdds = new[]
                                {
                                    new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToAddArgs
                                    {
                                        HeaderName = "debug",
                                        HeaderValue = "true",
                                        Replace = true,
                                    },
                                    new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToAddArgs
                                    {
                                        HeaderName = "potato",
                                        HeaderValue = "plant",
                                    },
                                },
                                ResponseHeaderToAdds = new[]
                                {
                                    new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToAddArgs
                                    {
                                        HeaderName = "potato",
                                        HeaderValue = "plant",
                                        Replace = true,
                                    },
                                },
                                RequestHeaderToRemoves = new[]
                                {
                                    new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToRemoveArgs
                                    {
                                        HeaderName = "prod",
                                    },
                                },
                                ResponseHeaderToRemoves = new[]
                                {
                                    new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToRemoveArgs
                                    {
                                        HeaderName = "prod",
                                    },
                                },
                            },
                            Origin = instance.Name,
                            RouteAction = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionArgs
                            {
                                CdnPolicy = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyArgs
                                {
                                    CacheMode = "CACHE_ALL_STATIC",
                                    DefaultTtl = "3800s",
                                    ClientTtl = "3600s",
                                    MaxTtl = "9000s",
                                    CacheKeyPolicy = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyCacheKeyPolicyArgs
                                    {
                                        IncludeProtocol = true,
                                        ExcludeHost = true,
                                        IncludedQueryParameters = new[]
                                        {
                                            "apple",
                                            "dev",
                                            "santa",
                                            "claus",
                                        },
                                        IncludedHeaderNames = new[]
                                        {
                                            "banana",
                                        },
                                        IncludedCookieNames = new[]
                                        {
                                            "orange",
                                        },
                                    },
                                    NegativeCaching = true,
                                    SignedRequestMode = "DISABLED",
                                    NegativeCachingPolicy = 
                                    {
                                        { "500", "3000s" },
                                    },
                                },
                                UrlRewrite = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionUrlRewriteArgs
                                {
                                    PathPrefixRewrite = "/dev",
                                    HostRewrite = "dev.club",
                                },
                                CorsPolicy = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCorsPolicyArgs
                                {
                                    MaxAge = "2500s",
                                    AllowCredentials = true,
                                    AllowOrigins = new[]
                                    {
                                        "*",
                                    },
                                    AllowMethods = new[]
                                    {
                                        "GET",
                                    },
                                    AllowHeaders = new[]
                                    {
                                        "dev",
                                    },
                                    ExposeHeaders = new[]
                                    {
                                        "prod",
                                    },
                                },
                            },
                        },
                        new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleArgs
                        {
                            Description = "a second route rule to match against",
                            Priority = "2",
                            MatchRules = new[]
                            {
                                new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs
                                {
                                    FullPathMatch = "/yay",
                                },
                            },
                            Origin = instance.Name,
                            RouteAction = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionArgs
                            {
                                CdnPolicy = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyArgs
                                {
                                    CacheMode = "CACHE_ALL_STATIC",
                                    DefaultTtl = "3600s",
                                    CacheKeyPolicy = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyCacheKeyPolicyArgs
                                    {
                                        ExcludedQueryParameters = new[]
                                        {
                                            "dev",
                                        },
                                    },
                                },
                                CorsPolicy = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCorsPolicyArgs
                                {
                                    MaxAge = "3000s",
                                    AllowHeaders = new[]
                                    {
                                        "dev",
                                    },
                                    Disabled = true,
                                },
                            },
                        },
                    },
                },
            },
        },
        LogConfig = new Gcp.NetworkServices.Inputs.EdgeCacheServiceLogConfigArgs
        {
            Enable = true,
            SampleRate = 0.01,
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/storage"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		dest, err := storage.NewBucket(ctx, "dest", &storage.BucketArgs{
			Name:         pulumi.String("my-bucket"),
			Location:     pulumi.String("US"),
			ForceDestroy: pulumi.Bool(true),
		})
		if err != nil {
			return err
		}
		_, err = networkservices.NewEdgeCacheOrigin(ctx, "google", &networkservices.EdgeCacheOriginArgs{
			Name:          pulumi.String("origin-google"),
			OriginAddress: pulumi.String("google.com"),
			Description:   pulumi.String("The default bucket for media edge test"),
			MaxAttempts:   pulumi.Int(2),
			Timeout: &networkservices.EdgeCacheOriginTimeoutArgs{
				ConnectTimeout: pulumi.String("10s"),
			},
		})
		if err != nil {
			return err
		}
		instance, err := networkservices.NewEdgeCacheOrigin(ctx, "instance", &networkservices.EdgeCacheOriginArgs{
			Name:          pulumi.String("my-origin"),
			OriginAddress: dest.Url,
			Description:   pulumi.String("The default bucket for media edge test"),
			MaxAttempts:   pulumi.Int(2),
			Timeout: &networkservices.EdgeCacheOriginTimeoutArgs{
				ConnectTimeout: pulumi.String("10s"),
			},
		})
		if err != nil {
			return err
		}
		_, err = networkservices.NewEdgeCacheService(ctx, "instance", &networkservices.EdgeCacheServiceArgs{
			Name:         pulumi.String("my-service"),
			Description:  pulumi.String("some description"),
			DisableQuic:  pulumi.Bool(true),
			DisableHttp2: pulumi.Bool(true),
			Labels: pulumi.StringMap{
				"a": pulumi.String("b"),
			},
			Routing: &networkservices.EdgeCacheServiceRoutingArgs{
				HostRules: networkservices.EdgeCacheServiceRoutingHostRuleArray{
					&networkservices.EdgeCacheServiceRoutingHostRuleArgs{
						Description: pulumi.String("host rule description"),
						Hosts: pulumi.StringArray{
							pulumi.String("sslcert.tf-test.club"),
						},
						PathMatcher: pulumi.String("routes"),
					},
					&networkservices.EdgeCacheServiceRoutingHostRuleArgs{
						Description: pulumi.String("host rule2"),
						Hosts: pulumi.StringArray{
							pulumi.String("sslcert.tf-test2.club"),
						},
						PathMatcher: pulumi.String("routes"),
					},
					&networkservices.EdgeCacheServiceRoutingHostRuleArgs{
						Description: pulumi.String("host rule3"),
						Hosts: pulumi.StringArray{
							pulumi.String("sslcert.tf-test3.club"),
						},
						PathMatcher: pulumi.String("routesAdvanced"),
					},
				},
				PathMatchers: networkservices.EdgeCacheServiceRoutingPathMatcherArray{
					&networkservices.EdgeCacheServiceRoutingPathMatcherArgs{
						Name: pulumi.String("routes"),
						RouteRules: networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleArray{
							&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleArgs{
								Description: pulumi.String("a route rule to match against"),
								Priority:    pulumi.String("1"),
								MatchRules: networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArray{
									&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs{
										PrefixMatch: pulumi.String("/"),
									},
								},
								Origin: instance.Name,
								RouteAction: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionArgs{
									CdnPolicy: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyArgs{
										CacheMode:  pulumi.String("CACHE_ALL_STATIC"),
										DefaultTtl: pulumi.String("3600s"),
									},
								},
								HeaderAction: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionArgs{
									ResponseHeaderToAdds: networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToAddArray{
										&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToAddArgs{
											HeaderName:  pulumi.String("x-cache-status"),
											HeaderValue: pulumi.String("{cdn_cache_status}"),
										},
									},
								},
							},
						},
					},
					&networkservices.EdgeCacheServiceRoutingPathMatcherArgs{
						Name:        pulumi.String("routesAdvanced"),
						Description: pulumi.String("an advanced ruleset"),
						RouteRules: networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleArray{
							&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleArgs{
								Description: pulumi.String("an advanced route rule to match against"),
								Priority:    pulumi.String("1"),
								MatchRules: networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArray{
									&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs{
										PrefixMatch: pulumi.String("/potato/"),
										QueryParameterMatches: networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleQueryParameterMatchArray{
											&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleQueryParameterMatchArgs{
												Name:         pulumi.String("debug"),
												PresentMatch: pulumi.Bool(true),
											},
											&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleQueryParameterMatchArgs{
												Name:       pulumi.String("state"),
												ExactMatch: pulumi.String("debug"),
											},
										},
									},
									&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs{
										FullPathMatch: pulumi.String("/apple"),
									},
								},
								HeaderAction: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionArgs{
									RequestHeaderToAdds: networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToAddArray{
										&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToAddArgs{
											HeaderName:  pulumi.String("debug"),
											HeaderValue: pulumi.String("true"),
											Replace:     pulumi.Bool(true),
										},
										&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToAddArgs{
											HeaderName:  pulumi.String("potato"),
											HeaderValue: pulumi.String("plant"),
										},
									},
									ResponseHeaderToAdds: networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToAddArray{
										&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToAddArgs{
											HeaderName:  pulumi.String("potato"),
											HeaderValue: pulumi.String("plant"),
											Replace:     pulumi.Bool(true),
										},
									},
									RequestHeaderToRemoves: networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToRemoveArray{
										&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToRemoveArgs{
											HeaderName: pulumi.String("prod"),
										},
									},
									ResponseHeaderToRemoves: networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToRemoveArray{
										&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToRemoveArgs{
											HeaderName: pulumi.String("prod"),
										},
									},
								},
								Origin: instance.Name,
								RouteAction: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionArgs{
									CdnPolicy: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyArgs{
										CacheMode:  pulumi.String("CACHE_ALL_STATIC"),
										DefaultTtl: pulumi.String("3800s"),
										ClientTtl:  pulumi.String("3600s"),
										MaxTtl:     pulumi.String("9000s"),
										CacheKeyPolicy: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyCacheKeyPolicyArgs{
											IncludeProtocol: pulumi.Bool(true),
											ExcludeHost:     pulumi.Bool(true),
											IncludedQueryParameters: pulumi.StringArray{
												pulumi.String("apple"),
												pulumi.String("dev"),
												pulumi.String("santa"),
												pulumi.String("claus"),
											},
											IncludedHeaderNames: pulumi.StringArray{
												pulumi.String("banana"),
											},
											IncludedCookieNames: pulumi.StringArray{
												pulumi.String("orange"),
											},
										},
										NegativeCaching:   pulumi.Bool(true),
										SignedRequestMode: pulumi.String("DISABLED"),
										NegativeCachingPolicy: pulumi.StringMap{
											"500": pulumi.String("3000s"),
										},
									},
									UrlRewrite: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionUrlRewriteArgs{
										PathPrefixRewrite: pulumi.String("/dev"),
										HostRewrite:       pulumi.String("dev.club"),
									},
									CorsPolicy: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCorsPolicyArgs{
										MaxAge:           pulumi.String("2500s"),
										AllowCredentials: pulumi.Bool(true),
										AllowOrigins: pulumi.StringArray{
											pulumi.String("*"),
										},
										AllowMethods: pulumi.StringArray{
											pulumi.String("GET"),
										},
										AllowHeaders: pulumi.StringArray{
											pulumi.String("dev"),
										},
										ExposeHeaders: pulumi.StringArray{
											pulumi.String("prod"),
										},
									},
								},
							},
							&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleArgs{
								Description: pulumi.String("a second route rule to match against"),
								Priority:    pulumi.String("2"),
								MatchRules: networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArray{
									&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs{
										FullPathMatch: pulumi.String("/yay"),
									},
								},
								Origin: instance.Name,
								RouteAction: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionArgs{
									CdnPolicy: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyArgs{
										CacheMode:  pulumi.String("CACHE_ALL_STATIC"),
										DefaultTtl: pulumi.String("3600s"),
										CacheKeyPolicy: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyCacheKeyPolicyArgs{
											ExcludedQueryParameters: pulumi.StringArray{
												pulumi.String("dev"),
											},
										},
									},
									CorsPolicy: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCorsPolicyArgs{
										MaxAge: pulumi.String("3000s"),
										AllowHeaders: pulumi.StringArray{
											pulumi.String("dev"),
										},
										Disabled: pulumi.Bool(true),
									},
								},
							},
						},
					},
				},
			},
			LogConfig: &networkservices.EdgeCacheServiceLogConfigArgs{
				Enable:     pulumi.Bool(true),
				SampleRate: pulumi.Float64(0.01),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.storage.Bucket;
import com.pulumi.gcp.storage.BucketArgs;
import com.pulumi.gcp.networkservices.EdgeCacheOrigin;
import com.pulumi.gcp.networkservices.EdgeCacheOriginArgs;
import com.pulumi.gcp.networkservices.inputs.EdgeCacheOriginTimeoutArgs;
import com.pulumi.gcp.networkservices.EdgeCacheService;
import com.pulumi.gcp.networkservices.EdgeCacheServiceArgs;
import com.pulumi.gcp.networkservices.inputs.EdgeCacheServiceRoutingArgs;
import com.pulumi.gcp.networkservices.inputs.EdgeCacheServiceLogConfigArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var dest = new Bucket("dest", BucketArgs.builder()
            .name("my-bucket")
            .location("US")
            .forceDestroy(true)
            .build());

        var google = new EdgeCacheOrigin("google", EdgeCacheOriginArgs.builder()
            .name("origin-google")
            .originAddress("google.com")
            .description("The default bucket for media edge test")
            .maxAttempts(2)
            .timeout(EdgeCacheOriginTimeoutArgs.builder()
                .connectTimeout("10s")
                .build())
            .build());

        var instance = new EdgeCacheOrigin("instance", EdgeCacheOriginArgs.builder()
            .name("my-origin")
            .originAddress(dest.url())
            .description("The default bucket for media edge test")
            .maxAttempts(2)
            .timeout(EdgeCacheOriginTimeoutArgs.builder()
                .connectTimeout("10s")
                .build())
            .build());

        var instanceEdgeCacheService = new EdgeCacheService("instanceEdgeCacheService", EdgeCacheServiceArgs.builder()
            .name("my-service")
            .description("some description")
            .disableQuic(true)
            .disableHttp2(true)
            .labels(Map.of("a", "b"))
            .routing(EdgeCacheServiceRoutingArgs.builder()
                .hostRules(                
                    EdgeCacheServiceRoutingHostRuleArgs.builder()
                        .description("host rule description")
                        .hosts("sslcert.tf-test.club")
                        .pathMatcher("routes")
                        .build(),
                    EdgeCacheServiceRoutingHostRuleArgs.builder()
                        .description("host rule2")
                        .hosts("sslcert.tf-test2.club")
                        .pathMatcher("routes")
                        .build(),
                    EdgeCacheServiceRoutingHostRuleArgs.builder()
                        .description("host rule3")
                        .hosts("sslcert.tf-test3.club")
                        .pathMatcher("routesAdvanced")
                        .build())
                .pathMatchers(                
                    EdgeCacheServiceRoutingPathMatcherArgs.builder()
                        .name("routes")
                        .routeRules(EdgeCacheServiceRoutingPathMatcherRouteRuleArgs.builder()
                            .description("a route rule to match against")
                            .priority(1)
                            .matchRules(EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs.builder()
                                .prefixMatch("/")
                                .build())
                            .origin(instance.name())
                            .routeAction(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionArgs.builder()
                                .cdnPolicy(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyArgs.builder()
                                    .cacheMode("CACHE_ALL_STATIC")
                                    .defaultTtl("3600s")
                                    .build())
                                .build())
                            .headerAction(EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionArgs.builder()
                                .responseHeaderToAdds(EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToAddArgs.builder()
                                    .headerName("x-cache-status")
                                    .headerValue("{cdn_cache_status}")
                                    .build())
                                .build())
                            .build())
                        .build(),
                    EdgeCacheServiceRoutingPathMatcherArgs.builder()
                        .name("routesAdvanced")
                        .description("an advanced ruleset")
                        .routeRules(                        
                            EdgeCacheServiceRoutingPathMatcherRouteRuleArgs.builder()
                                .description("an advanced route rule to match against")
                                .priority(1)
                                .matchRules(                                
                                    EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs.builder()
                                        .prefixMatch("/potato/")
                                        .queryParameterMatches(                                        
                                            EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleQueryParameterMatchArgs.builder()
                                                .name("debug")
                                                .presentMatch(true)
                                                .build(),
                                            EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleQueryParameterMatchArgs.builder()
                                                .name("state")
                                                .exactMatch("debug")
                                                .build())
                                        .build(),
                                    EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs.builder()
                                        .fullPathMatch("/apple")
                                        .build())
                                .headerAction(EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionArgs.builder()
                                    .requestHeaderToAdds(                                    
                                        EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToAddArgs.builder()
                                            .headerName("debug")
                                            .headerValue("true")
                                            .replace(true)
                                            .build(),
                                        EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToAddArgs.builder()
                                            .headerName("potato")
                                            .headerValue("plant")
                                            .build())
                                    .responseHeaderToAdds(EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToAddArgs.builder()
                                        .headerName("potato")
                                        .headerValue("plant")
                                        .replace(true)
                                        .build())
                                    .requestHeaderToRemoves(EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToRemoveArgs.builder()
                                        .headerName("prod")
                                        .build())
                                    .responseHeaderToRemoves(EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToRemoveArgs.builder()
                                        .headerName("prod")
                                        .build())
                                    .build())
                                .origin(instance.name())
                                .routeAction(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionArgs.builder()
                                    .cdnPolicy(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyArgs.builder()
                                        .cacheMode("CACHE_ALL_STATIC")
                                        .defaultTtl("3800s")
                                        .clientTtl("3600s")
                                        .maxTtl("9000s")
                                        .cacheKeyPolicy(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyCacheKeyPolicyArgs.builder()
                                            .includeProtocol(true)
                                            .excludeHost(true)
                                            .includedQueryParameters(                                            
                                                "apple",
                                                "dev",
                                                "santa",
                                                "claus")
                                            .includedHeaderNames("banana")
                                            .includedCookieNames("orange")
                                            .build())
                                        .negativeCaching(true)
                                        .signedRequestMode("DISABLED")
                                        .negativeCachingPolicy(Map.of("500", "3000s"))
                                        .build())
                                    .urlRewrite(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionUrlRewriteArgs.builder()
                                        .pathPrefixRewrite("/dev")
                                        .hostRewrite("dev.club")
                                        .build())
                                    .corsPolicy(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCorsPolicyArgs.builder()
                                        .maxAge("2500s")
                                        .allowCredentials(true)
                                        .allowOrigins("*")
                                        .allowMethods("GET")
                                        .allowHeaders("dev")
                                        .exposeHeaders("prod")
                                        .build())
                                    .build())
                                .build(),
                            EdgeCacheServiceRoutingPathMatcherRouteRuleArgs.builder()
                                .description("a second route rule to match against")
                                .priority(2)
                                .matchRules(EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs.builder()
                                    .fullPathMatch("/yay")
                                    .build())
                                .origin(instance.name())
                                .routeAction(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionArgs.builder()
                                    .cdnPolicy(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyArgs.builder()
                                        .cacheMode("CACHE_ALL_STATIC")
                                        .defaultTtl("3600s")
                                        .cacheKeyPolicy(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyCacheKeyPolicyArgs.builder()
                                            .excludedQueryParameters("dev")
                                            .build())
                                        .build())
                                    .corsPolicy(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCorsPolicyArgs.builder()
                                        .maxAge("3000s")
                                        .allowHeaders("dev")
                                        .disabled(true)
                                        .build())
                                    .build())
                                .build())
                        .build())
                .build())
            .logConfig(EdgeCacheServiceLogConfigArgs.builder()
                .enable(true)
                .sampleRate(0.01)
                .build())
            .build());

    }
}
```
```yaml
resources:
  dest:
    type: gcp:storage:Bucket
    properties:
      name: my-bucket
      location: US
      forceDestroy: true
  google:
    type: gcp:networkservices:EdgeCacheOrigin
    properties:
      name: origin-google
      originAddress: google.com
      description: The default bucket for media edge test
      maxAttempts: 2
      timeout:
        connectTimeout: 10s
  instance:
    type: gcp:networkservices:EdgeCacheOrigin
    properties:
      name: my-origin
      originAddress: ${dest.url}
      description: The default bucket for media edge test
      maxAttempts: 2
      timeout:
        connectTimeout: 10s
  instanceEdgeCacheService:
    type: gcp:networkservices:EdgeCacheService
    name: instance
    properties:
      name: my-service
      description: some description
      disableQuic: true
      disableHttp2: true
      labels:
        a: b
      routing:
        hostRules:
          - description: host rule description
            hosts:
              - sslcert.tf-test.club
            pathMatcher: routes
          - description: host rule2
            hosts:
              - sslcert.tf-test2.club
            pathMatcher: routes
          - description: host rule3
            hosts:
              - sslcert.tf-test3.club
            pathMatcher: routesAdvanced
        pathMatchers:
          - name: routes
            routeRules:
              - description: a route rule to match against
                priority: 1
                matchRules:
                  - prefixMatch: /
                origin: ${instance.name}
                routeAction:
                  cdnPolicy:
                    cacheMode: CACHE_ALL_STATIC
                    defaultTtl: 3600s
                headerAction:
                  responseHeaderToAdds:
                    - headerName: x-cache-status
                      headerValue: '{cdn_cache_status}'
          - name: routesAdvanced
            description: an advanced ruleset
            routeRules:
              - description: an advanced route rule to match against
                priority: 1
                matchRules:
                  - prefixMatch: /potato/
                    queryParameterMatches:
                      - name: debug
                        presentMatch: true
                      - name: state
                        exactMatch: debug
                  - fullPathMatch: /apple
                headerAction:
                  requestHeaderToAdds:
                    - headerName: debug
                      headerValue: 'true'
                      replace: true
                    - headerName: potato
                      headerValue: plant
                  responseHeaderToAdds:
                    - headerName: potato
                      headerValue: plant
                      replace: true
                  requestHeaderToRemoves:
                    - headerName: prod
                  responseHeaderToRemoves:
                    - headerName: prod
                origin: ${instance.name}
                routeAction:
                  cdnPolicy:
                    cacheMode: CACHE_ALL_STATIC
                    defaultTtl: 3800s
                    clientTtl: 3600s
                    maxTtl: 9000s
                    cacheKeyPolicy:
                      includeProtocol: true
                      excludeHost: true
                      includedQueryParameters:
                        - apple
                        - dev
                        - santa
                        - claus
                      includedHeaderNames:
                        - banana
                      includedCookieNames:
                        - orange
                    negativeCaching: true
                    signedRequestMode: DISABLED
                    negativeCachingPolicy:
                      '500': 3000s
                  urlRewrite:
                    pathPrefixRewrite: /dev
                    hostRewrite: dev.club
                  corsPolicy:
                    maxAge: 2500s
                    allowCredentials: true
                    allowOrigins:
                      - '*'
                    allowMethods:
                      - GET
                    allowHeaders:
                      - dev
                    exposeHeaders:
                      - prod
              - description: a second route rule to match against
                priority: 2
                matchRules:
                  - fullPathMatch: /yay
                origin: ${instance.name}
                routeAction:
                  cdnPolicy:
                    cacheMode: CACHE_ALL_STATIC
                    defaultTtl: 3600s
                    cacheKeyPolicy:
                      excludedQueryParameters:
                        - dev
                  corsPolicy:
                    maxAge: 3000s
                    allowHeaders:
                      - dev
                    disabled: true
      logConfig:
        enable: true
        sampleRate: 0.01
```
<!--End PulumiCodeChooser -->
### Network Services Edge Cache Service Dual Token


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const secret_basic = new gcp.secretmanager.Secret("secret-basic", {
    secretId: "secret-name",
    replication: {
        auto: {},
    },
});
const secret_version_basic = new gcp.secretmanager.SecretVersion("secret-version-basic", {
    secret: secret_basic.id,
    secretData: "secret-data",
});
const keyset = new gcp.networkservices.EdgeCacheKeyset("keyset", {
    name: "keyset-name",
    description: "The default keyset",
    publicKeys: [{
        id: "my-public-key",
        managed: true,
    }],
    validationSharedKeys: [{
        secretVersion: secret_version_basic.id,
    }],
});
const instance = new gcp.networkservices.EdgeCacheOrigin("instance", {
    name: "my-origin",
    originAddress: "gs://media-edge-default",
    description: "The default bucket for media edge test",
});
const instanceEdgeCacheService = new gcp.networkservices.EdgeCacheService("instance", {
    name: "my-service",
    description: "some description",
    routing: {
        hostRules: [{
            description: "host rule description",
            hosts: ["sslcert.tf-test.club"],
            pathMatcher: "routes",
        }],
        pathMatchers: [{
            name: "routes",
            routeRules: [
                {
                    description: "a route rule to match against master playlist",
                    priority: "1",
                    matchRules: [{
                        pathTemplateMatch: "/master.m3u8",
                    }],
                    origin: instance.name,
                    routeAction: {
                        cdnPolicy: {
                            signedRequestMode: "REQUIRE_TOKENS",
                            signedRequestKeyset: keyset.id,
                            signedTokenOptions: {
                                tokenQueryParameter: "edge-cache-token",
                            },
                            signedRequestMaximumExpirationTtl: "600s",
                            addSignatures: {
                                actions: "GENERATE_COOKIE",
                                keyset: keyset.id,
                                copiedParameters: [
                                    "PathGlobs",
                                    "SessionID",
                                ],
                            },
                        },
                    },
                },
                {
                    description: "a route rule to match against all playlists",
                    priority: "2",
                    matchRules: [{
                        pathTemplateMatch: "/*.m3u8",
                    }],
                    origin: instance.name,
                    routeAction: {
                        cdnPolicy: {
                            signedRequestMode: "REQUIRE_TOKENS",
                            signedRequestKeyset: keyset.id,
                            signedTokenOptions: {
                                tokenQueryParameter: "hdnts",
                                allowedSignatureAlgorithms: [
                                    "ED25519",
                                    "HMAC_SHA_256",
                                    "HMAC_SHA1",
                                ],
                            },
                            addSignatures: {
                                actions: "GENERATE_TOKEN_HLS_COOKIELESS",
                                keyset: keyset.id,
                                tokenTtl: "1200s",
                                tokenQueryParameter: "hdntl",
                                copiedParameters: ["URLPrefix"],
                            },
                        },
                    },
                },
                {
                    description: "a route rule to match against",
                    priority: "3",
                    matchRules: [{
                        pathTemplateMatch: "/**.m3u8",
                    }],
                    origin: instance.name,
                    routeAction: {
                        cdnPolicy: {
                            signedRequestMode: "REQUIRE_TOKENS",
                            signedRequestKeyset: keyset.id,
                            signedTokenOptions: {
                                tokenQueryParameter: "hdntl",
                            },
                            addSignatures: {
                                actions: "PROPAGATE_TOKEN_HLS_COOKIELESS",
                                tokenQueryParameter: "hdntl",
                            },
                        },
                    },
                },
            ],
        }],
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

secret_basic = gcp.secretmanager.Secret("secret-basic",
    secret_id="secret-name",
    replication={
        "auto": {},
    })
secret_version_basic = gcp.secretmanager.SecretVersion("secret-version-basic",
    secret=secret_basic.id,
    secret_data="secret-data")
keyset = gcp.networkservices.EdgeCacheKeyset("keyset",
    name="keyset-name",
    description="The default keyset",
    public_keys=[{
        "id": "my-public-key",
        "managed": True,
    }],
    validation_shared_keys=[{
        "secret_version": secret_version_basic.id,
    }])
instance = gcp.networkservices.EdgeCacheOrigin("instance",
    name="my-origin",
    origin_address="gs://media-edge-default",
    description="The default bucket for media edge test")
instance_edge_cache_service = gcp.networkservices.EdgeCacheService("instance",
    name="my-service",
    description="some description",
    routing={
        "host_rules": [{
            "description": "host rule description",
            "hosts": ["sslcert.tf-test.club"],
            "path_matcher": "routes",
        }],
        "path_matchers": [{
            "name": "routes",
            "route_rules": [
                {
                    "description": "a route rule to match against master playlist",
                    "priority": "1",
                    "match_rules": [{
                        "path_template_match": "/master.m3u8",
                    }],
                    "origin": instance.name,
                    "route_action": {
                        "cdn_policy": {
                            "signed_request_mode": "REQUIRE_TOKENS",
                            "signed_request_keyset": keyset.id,
                            "signed_token_options": {
                                "token_query_parameter": "edge-cache-token",
                            },
                            "signed_request_maximum_expiration_ttl": "600s",
                            "add_signatures": {
                                "actions": "GENERATE_COOKIE",
                                "keyset": keyset.id,
                                "copied_parameters": [
                                    "PathGlobs",
                                    "SessionID",
                                ],
                            },
                        },
                    },
                },
                {
                    "description": "a route rule to match against all playlists",
                    "priority": "2",
                    "match_rules": [{
                        "path_template_match": "/*.m3u8",
                    }],
                    "origin": instance.name,
                    "route_action": {
                        "cdn_policy": {
                            "signed_request_mode": "REQUIRE_TOKENS",
                            "signed_request_keyset": keyset.id,
                            "signed_token_options": {
                                "token_query_parameter": "hdnts",
                                "allowed_signature_algorithms": [
                                    "ED25519",
                                    "HMAC_SHA_256",
                                    "HMAC_SHA1",
                                ],
                            },
                            "add_signatures": {
                                "actions": "GENERATE_TOKEN_HLS_COOKIELESS",
                                "keyset": keyset.id,
                                "token_ttl": "1200s",
                                "token_query_parameter": "hdntl",
                                "copied_parameters": ["URLPrefix"],
                            },
                        },
                    },
                },
                {
                    "description": "a route rule to match against",
                    "priority": "3",
                    "match_rules": [{
                        "path_template_match": "/**.m3u8",
                    }],
                    "origin": instance.name,
                    "route_action": {
                        "cdn_policy": {
                            "signed_request_mode": "REQUIRE_TOKENS",
                            "signed_request_keyset": keyset.id,
                            "signed_token_options": {
                                "token_query_parameter": "hdntl",
                            },
                            "add_signatures": {
                                "actions": "PROPAGATE_TOKEN_HLS_COOKIELESS",
                                "token_query_parameter": "hdntl",
                            },
                        },
                    },
                },
            ],
        }],
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var secret_basic = new Gcp.SecretManager.Secret("secret-basic", new()
    {
        SecretId = "secret-name",
        Replication = new Gcp.SecretManager.Inputs.SecretReplicationArgs
        {
            Auto = null,
        },
    });

    var secret_version_basic = new Gcp.SecretManager.SecretVersion("secret-version-basic", new()
    {
        Secret = secret_basic.Id,
        SecretData = "secret-data",
    });

    var keyset = new Gcp.NetworkServices.EdgeCacheKeyset("keyset", new()
    {
        Name = "keyset-name",
        Description = "The default keyset",
        PublicKeys = new[]
        {
            new Gcp.NetworkServices.Inputs.EdgeCacheKeysetPublicKeyArgs
            {
                Id = "my-public-key",
                Managed = true,
            },
        },
        ValidationSharedKeys = new[]
        {
            new Gcp.NetworkServices.Inputs.EdgeCacheKeysetValidationSharedKeyArgs
            {
                SecretVersion = secret_version_basic.Id,
            },
        },
    });

    var instance = new Gcp.NetworkServices.EdgeCacheOrigin("instance", new()
    {
        Name = "my-origin",
        OriginAddress = "gs://media-edge-default",
        Description = "The default bucket for media edge test",
    });

    var instanceEdgeCacheService = new Gcp.NetworkServices.EdgeCacheService("instance", new()
    {
        Name = "my-service",
        Description = "some description",
        Routing = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingArgs
        {
            HostRules = new[]
            {
                new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingHostRuleArgs
                {
                    Description = "host rule description",
                    Hosts = new[]
                    {
                        "sslcert.tf-test.club",
                    },
                    PathMatcher = "routes",
                },
            },
            PathMatchers = new[]
            {
                new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherArgs
                {
                    Name = "routes",
                    RouteRules = new[]
                    {
                        new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleArgs
                        {
                            Description = "a route rule to match against master playlist",
                            Priority = "1",
                            MatchRules = new[]
                            {
                                new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs
                                {
                                    PathTemplateMatch = "/master.m3u8",
                                },
                            },
                            Origin = instance.Name,
                            RouteAction = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionArgs
                            {
                                CdnPolicy = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyArgs
                                {
                                    SignedRequestMode = "REQUIRE_TOKENS",
                                    SignedRequestKeyset = keyset.Id,
                                    SignedTokenOptions = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicySignedTokenOptionsArgs
                                    {
                                        TokenQueryParameter = "edge-cache-token",
                                    },
                                    SignedRequestMaximumExpirationTtl = "600s",
                                    AddSignatures = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyAddSignaturesArgs
                                    {
                                        Actions = "GENERATE_COOKIE",
                                        Keyset = keyset.Id,
                                        CopiedParameters = new[]
                                        {
                                            "PathGlobs",
                                            "SessionID",
                                        },
                                    },
                                },
                            },
                        },
                        new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleArgs
                        {
                            Description = "a route rule to match against all playlists",
                            Priority = "2",
                            MatchRules = new[]
                            {
                                new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs
                                {
                                    PathTemplateMatch = "/*.m3u8",
                                },
                            },
                            Origin = instance.Name,
                            RouteAction = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionArgs
                            {
                                CdnPolicy = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyArgs
                                {
                                    SignedRequestMode = "REQUIRE_TOKENS",
                                    SignedRequestKeyset = keyset.Id,
                                    SignedTokenOptions = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicySignedTokenOptionsArgs
                                    {
                                        TokenQueryParameter = "hdnts",
                                        AllowedSignatureAlgorithms = new[]
                                        {
                                            "ED25519",
                                            "HMAC_SHA_256",
                                            "HMAC_SHA1",
                                        },
                                    },
                                    AddSignatures = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyAddSignaturesArgs
                                    {
                                        Actions = "GENERATE_TOKEN_HLS_COOKIELESS",
                                        Keyset = keyset.Id,
                                        TokenTtl = "1200s",
                                        TokenQueryParameter = "hdntl",
                                        CopiedParameters = new[]
                                        {
                                            "URLPrefix",
                                        },
                                    },
                                },
                            },
                        },
                        new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleArgs
                        {
                            Description = "a route rule to match against",
                            Priority = "3",
                            MatchRules = new[]
                            {
                                new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs
                                {
                                    PathTemplateMatch = "/**.m3u8",
                                },
                            },
                            Origin = instance.Name,
                            RouteAction = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionArgs
                            {
                                CdnPolicy = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyArgs
                                {
                                    SignedRequestMode = "REQUIRE_TOKENS",
                                    SignedRequestKeyset = keyset.Id,
                                    SignedTokenOptions = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicySignedTokenOptionsArgs
                                    {
                                        TokenQueryParameter = "hdntl",
                                    },
                                    AddSignatures = new Gcp.NetworkServices.Inputs.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyAddSignaturesArgs
                                    {
                                        Actions = "PROPAGATE_TOKEN_HLS_COOKIELESS",
                                        TokenQueryParameter = "hdntl",
                                    },
                                },
                            },
                        },
                    },
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/secretmanager"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := secretmanager.NewSecret(ctx, "secret-basic", &secretmanager.SecretArgs{
			SecretId: pulumi.String("secret-name"),
			Replication: &secretmanager.SecretReplicationArgs{
				Auto: &secretmanager.SecretReplicationAutoArgs{},
			},
		})
		if err != nil {
			return err
		}
		_, err = secretmanager.NewSecretVersion(ctx, "secret-version-basic", &secretmanager.SecretVersionArgs{
			Secret:     secret_basic.ID(),
			SecretData: pulumi.String("secret-data"),
		})
		if err != nil {
			return err
		}
		keyset, err := networkservices.NewEdgeCacheKeyset(ctx, "keyset", &networkservices.EdgeCacheKeysetArgs{
			Name:        pulumi.String("keyset-name"),
			Description: pulumi.String("The default keyset"),
			PublicKeys: networkservices.EdgeCacheKeysetPublicKeyArray{
				&networkservices.EdgeCacheKeysetPublicKeyArgs{
					Id:      pulumi.String("my-public-key"),
					Managed: pulumi.Bool(true),
				},
			},
			ValidationSharedKeys: networkservices.EdgeCacheKeysetValidationSharedKeyArray{
				&networkservices.EdgeCacheKeysetValidationSharedKeyArgs{
					SecretVersion: secret_version_basic.ID(),
				},
			},
		})
		if err != nil {
			return err
		}
		instance, err := networkservices.NewEdgeCacheOrigin(ctx, "instance", &networkservices.EdgeCacheOriginArgs{
			Name:          pulumi.String("my-origin"),
			OriginAddress: pulumi.String("gs://media-edge-default"),
			Description:   pulumi.String("The default bucket for media edge test"),
		})
		if err != nil {
			return err
		}
		_, err = networkservices.NewEdgeCacheService(ctx, "instance", &networkservices.EdgeCacheServiceArgs{
			Name:        pulumi.String("my-service"),
			Description: pulumi.String("some description"),
			Routing: &networkservices.EdgeCacheServiceRoutingArgs{
				HostRules: networkservices.EdgeCacheServiceRoutingHostRuleArray{
					&networkservices.EdgeCacheServiceRoutingHostRuleArgs{
						Description: pulumi.String("host rule description"),
						Hosts: pulumi.StringArray{
							pulumi.String("sslcert.tf-test.club"),
						},
						PathMatcher: pulumi.String("routes"),
					},
				},
				PathMatchers: networkservices.EdgeCacheServiceRoutingPathMatcherArray{
					&networkservices.EdgeCacheServiceRoutingPathMatcherArgs{
						Name: pulumi.String("routes"),
						RouteRules: networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleArray{
							&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleArgs{
								Description: pulumi.String("a route rule to match against master playlist"),
								Priority:    pulumi.String("1"),
								MatchRules: networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArray{
									&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs{
										PathTemplateMatch: pulumi.String("/master.m3u8"),
									},
								},
								Origin: instance.Name,
								RouteAction: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionArgs{
									CdnPolicy: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyArgs{
										SignedRequestMode:   pulumi.String("REQUIRE_TOKENS"),
										SignedRequestKeyset: keyset.ID(),
										SignedTokenOptions: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicySignedTokenOptionsArgs{
											TokenQueryParameter: pulumi.String("edge-cache-token"),
										},
										SignedRequestMaximumExpirationTtl: pulumi.String("600s"),
										AddSignatures: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyAddSignaturesArgs{
											Actions: pulumi.String("GENERATE_COOKIE"),
											Keyset:  keyset.ID(),
											CopiedParameters: pulumi.StringArray{
												pulumi.String("PathGlobs"),
												pulumi.String("SessionID"),
											},
										},
									},
								},
							},
							&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleArgs{
								Description: pulumi.String("a route rule to match against all playlists"),
								Priority:    pulumi.String("2"),
								MatchRules: networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArray{
									&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs{
										PathTemplateMatch: pulumi.String("/*.m3u8"),
									},
								},
								Origin: instance.Name,
								RouteAction: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionArgs{
									CdnPolicy: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyArgs{
										SignedRequestMode:   pulumi.String("REQUIRE_TOKENS"),
										SignedRequestKeyset: keyset.ID(),
										SignedTokenOptions: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicySignedTokenOptionsArgs{
											TokenQueryParameter: pulumi.String("hdnts"),
											AllowedSignatureAlgorithms: pulumi.StringArray{
												pulumi.String("ED25519"),
												pulumi.String("HMAC_SHA_256"),
												pulumi.String("HMAC_SHA1"),
											},
										},
										AddSignatures: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyAddSignaturesArgs{
											Actions:             pulumi.String("GENERATE_TOKEN_HLS_COOKIELESS"),
											Keyset:              keyset.ID(),
											TokenTtl:            pulumi.String("1200s"),
											TokenQueryParameter: pulumi.String("hdntl"),
											CopiedParameters: pulumi.StringArray{
												pulumi.String("URLPrefix"),
											},
										},
									},
								},
							},
							&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleArgs{
								Description: pulumi.String("a route rule to match against"),
								Priority:    pulumi.String("3"),
								MatchRules: networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArray{
									&networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs{
										PathTemplateMatch: pulumi.String("/**.m3u8"),
									},
								},
								Origin: instance.Name,
								RouteAction: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionArgs{
									CdnPolicy: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyArgs{
										SignedRequestMode:   pulumi.String("REQUIRE_TOKENS"),
										SignedRequestKeyset: keyset.ID(),
										SignedTokenOptions: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicySignedTokenOptionsArgs{
											TokenQueryParameter: pulumi.String("hdntl"),
										},
										AddSignatures: &networkservices.EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyAddSignaturesArgs{
											Actions:             pulumi.String("PROPAGATE_TOKEN_HLS_COOKIELESS"),
											TokenQueryParameter: pulumi.String("hdntl"),
										},
									},
								},
							},
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.secretmanager.Secret;
import com.pulumi.gcp.secretmanager.SecretArgs;
import com.pulumi.gcp.secretmanager.inputs.SecretReplicationArgs;
import com.pulumi.gcp.secretmanager.inputs.SecretReplicationAutoArgs;
import com.pulumi.gcp.secretmanager.SecretVersion;
import com.pulumi.gcp.secretmanager.SecretVersionArgs;
import com.pulumi.gcp.networkservices.EdgeCacheKeyset;
import com.pulumi.gcp.networkservices.EdgeCacheKeysetArgs;
import com.pulumi.gcp.networkservices.inputs.EdgeCacheKeysetPublicKeyArgs;
import com.pulumi.gcp.networkservices.inputs.EdgeCacheKeysetValidationSharedKeyArgs;
import com.pulumi.gcp.networkservices.EdgeCacheOrigin;
import com.pulumi.gcp.networkservices.EdgeCacheOriginArgs;
import com.pulumi.gcp.networkservices.EdgeCacheService;
import com.pulumi.gcp.networkservices.EdgeCacheServiceArgs;
import com.pulumi.gcp.networkservices.inputs.EdgeCacheServiceRoutingArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var secret_basic = new Secret("secret-basic", SecretArgs.builder()
            .secretId("secret-name")
            .replication(SecretReplicationArgs.builder()
                .auto()
                .build())
            .build());

        var secret_version_basic = new SecretVersion("secret-version-basic", SecretVersionArgs.builder()
            .secret(secret_basic.id())
            .secretData("secret-data")
            .build());

        var keyset = new EdgeCacheKeyset("keyset", EdgeCacheKeysetArgs.builder()
            .name("keyset-name")
            .description("The default keyset")
            .publicKeys(EdgeCacheKeysetPublicKeyArgs.builder()
                .id("my-public-key")
                .managed(true)
                .build())
            .validationSharedKeys(EdgeCacheKeysetValidationSharedKeyArgs.builder()
                .secretVersion(secret_version_basic.id())
                .build())
            .build());

        var instance = new EdgeCacheOrigin("instance", EdgeCacheOriginArgs.builder()
            .name("my-origin")
            .originAddress("gs://media-edge-default")
            .description("The default bucket for media edge test")
            .build());

        var instanceEdgeCacheService = new EdgeCacheService("instanceEdgeCacheService", EdgeCacheServiceArgs.builder()
            .name("my-service")
            .description("some description")
            .routing(EdgeCacheServiceRoutingArgs.builder()
                .hostRules(EdgeCacheServiceRoutingHostRuleArgs.builder()
                    .description("host rule description")
                    .hosts("sslcert.tf-test.club")
                    .pathMatcher("routes")
                    .build())
                .pathMatchers(EdgeCacheServiceRoutingPathMatcherArgs.builder()
                    .name("routes")
                    .routeRules(                    
                        EdgeCacheServiceRoutingPathMatcherRouteRuleArgs.builder()
                            .description("a route rule to match against master playlist")
                            .priority(1)
                            .matchRules(EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs.builder()
                                .pathTemplateMatch("/master.m3u8")
                                .build())
                            .origin(instance.name())
                            .routeAction(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionArgs.builder()
                                .cdnPolicy(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyArgs.builder()
                                    .signedRequestMode("REQUIRE_TOKENS")
                                    .signedRequestKeyset(keyset.id())
                                    .signedTokenOptions(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicySignedTokenOptionsArgs.builder()
                                        .tokenQueryParameter("edge-cache-token")
                                        .build())
                                    .signedRequestMaximumExpirationTtl("600s")
                                    .addSignatures(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyAddSignaturesArgs.builder()
                                        .actions("GENERATE_COOKIE")
                                        .keyset(keyset.id())
                                        .copiedParameters(                                        
                                            "PathGlobs",
                                            "SessionID")
                                        .build())
                                    .build())
                                .build())
                            .build(),
                        EdgeCacheServiceRoutingPathMatcherRouteRuleArgs.builder()
                            .description("a route rule to match against all playlists")
                            .priority(2)
                            .matchRules(EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs.builder()
                                .pathTemplateMatch("/*.m3u8")
                                .build())
                            .origin(instance.name())
                            .routeAction(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionArgs.builder()
                                .cdnPolicy(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyArgs.builder()
                                    .signedRequestMode("REQUIRE_TOKENS")
                                    .signedRequestKeyset(keyset.id())
                                    .signedTokenOptions(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicySignedTokenOptionsArgs.builder()
                                        .tokenQueryParameter("hdnts")
                                        .allowedSignatureAlgorithms(                                        
                                            "ED25519",
                                            "HMAC_SHA_256",
                                            "HMAC_SHA1")
                                        .build())
                                    .addSignatures(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyAddSignaturesArgs.builder()
                                        .actions("GENERATE_TOKEN_HLS_COOKIELESS")
                                        .keyset(keyset.id())
                                        .tokenTtl("1200s")
                                        .tokenQueryParameter("hdntl")
                                        .copiedParameters("URLPrefix")
                                        .build())
                                    .build())
                                .build())
                            .build(),
                        EdgeCacheServiceRoutingPathMatcherRouteRuleArgs.builder()
                            .description("a route rule to match against")
                            .priority(3)
                            .matchRules(EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleArgs.builder()
                                .pathTemplateMatch("/**.m3u8")
                                .build())
                            .origin(instance.name())
                            .routeAction(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionArgs.builder()
                                .cdnPolicy(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyArgs.builder()
                                    .signedRequestMode("REQUIRE_TOKENS")
                                    .signedRequestKeyset(keyset.id())
                                    .signedTokenOptions(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicySignedTokenOptionsArgs.builder()
                                        .tokenQueryParameter("hdntl")
                                        .build())
                                    .addSignatures(EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyAddSignaturesArgs.builder()
                                        .actions("PROPAGATE_TOKEN_HLS_COOKIELESS")
                                        .tokenQueryParameter("hdntl")
                                        .build())
                                    .build())
                                .build())
                            .build())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  secret-basic:
    type: gcp:secretmanager:Secret
    properties:
      secretId: secret-name
      replication:
        auto: {}
  secret-version-basic:
    type: gcp:secretmanager:SecretVersion
    properties:
      secret: ${["secret-basic"].id}
      secretData: secret-data
  keyset:
    type: gcp:networkservices:EdgeCacheKeyset
    properties:
      name: keyset-name
      description: The default keyset
      publicKeys:
        - id: my-public-key
          managed: true
      validationSharedKeys:
        - secretVersion: ${["secret-version-basic"].id}
  instance:
    type: gcp:networkservices:EdgeCacheOrigin
    properties:
      name: my-origin
      originAddress: gs://media-edge-default
      description: The default bucket for media edge test
  instanceEdgeCacheService:
    type: gcp:networkservices:EdgeCacheService
    name: instance
    properties:
      name: my-service
      description: some description
      routing:
        hostRules:
          - description: host rule description
            hosts:
              - sslcert.tf-test.club
            pathMatcher: routes
        pathMatchers:
          - name: routes
            routeRules:
              - description: a route rule to match against master playlist
                priority: 1
                matchRules:
                  - pathTemplateMatch: /master.m3u8
                origin: ${instance.name}
                routeAction:
                  cdnPolicy:
                    signedRequestMode: REQUIRE_TOKENS
                    signedRequestKeyset: ${keyset.id}
                    signedTokenOptions:
                      tokenQueryParameter: edge-cache-token
                    signedRequestMaximumExpirationTtl: 600s
                    addSignatures:
                      actions: GENERATE_COOKIE
                      keyset: ${keyset.id}
                      copiedParameters:
                        - PathGlobs
                        - SessionID
              - description: a route rule to match against all playlists
                priority: 2
                matchRules:
                  - pathTemplateMatch: /*.m3u8
                origin: ${instance.name}
                routeAction:
                  cdnPolicy:
                    signedRequestMode: REQUIRE_TOKENS
                    signedRequestKeyset: ${keyset.id}
                    signedTokenOptions:
                      tokenQueryParameter: hdnts
                      allowedSignatureAlgorithms:
                        - ED25519
                        - HMAC_SHA_256
                        - HMAC_SHA1
                    addSignatures:
                      actions: GENERATE_TOKEN_HLS_COOKIELESS
                      keyset: ${keyset.id}
                      tokenTtl: 1200s
                      tokenQueryParameter: hdntl
                      copiedParameters:
                        - URLPrefix
              - description: a route rule to match against
                priority: 3
                matchRules:
                  - pathTemplateMatch: /**.m3u8
                origin: ${instance.name}
                routeAction:
                  cdnPolicy:
                    signedRequestMode: REQUIRE_TOKENS
                    signedRequestKeyset: ${keyset.id}
                    signedTokenOptions:
                      tokenQueryParameter: hdntl
                    addSignatures:
                      actions: PROPAGATE_TOKEN_HLS_COOKIELESS
                      tokenQueryParameter: hdntl
```
<!--End PulumiCodeChooser -->

## Import

EdgeCacheService can be imported using any of these accepted formats:

* `projects/{{project}}/locations/global/edgeCacheServices/{{name}}`

* `{{project}}/{{name}}`

* `{{name}}`

When using the `pulumi import` command, EdgeCacheService can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkservices/edgeCacheService:EdgeCacheService default projects/{{project}}/locations/global/edgeCacheServices/{{name}}
```

```sh
$ pulumi import gcp:networkservices/edgeCacheService:EdgeCacheService default {{project}}/{{name}}
```

```sh
$ pulumi import gcp:networkservices/edgeCacheService:EdgeCacheService default {{name}}
```

C
descriptionB" .A human-readable description of the resource.
ü
disableHttp2B
 àDisables HTTP/2. HTTP/2 (h2) is enabled by default and recommended for performance. HTTP/2 improves connection re-use
and reduces connection setup overhead by sending multiple streams over the same connection. Some legacy HTTP clients may
have issues with HTTP/2 connections due to broken HTTP/2 implementations. Setting this to true will prevent HTTP/2 from
being advertised and negotiated.
P
disableQuicB
 ;HTTP/3 (IETF QUIC) and Google QUIC are enabled by default.
õ
edgeSecurityPolicyB" Resource URL that points at the Cloud Armor edge security policy that is applied on each request against the
EdgeCacheService.
ˇ
edgeSslCertificatesB*" ﬂURLs to sslCertificate resources that are used to authenticate connections between users and the EdgeCacheService. Note
that only "global" certificates with a "scope" of "EDGE_CACHE" can be attached to an EdgeCacheService.
ì
labelsB2" ÄSet of label tags associated with the EdgeCache resource. **Note**: This field is non-authoritative, and will only
manage the labels present in your configuration. Please refer to the field 'effective_labels' for all of the labels
present on the resource.
ê
	logConfig{By:w
u
networkservicesEdgeCacheServiceLogConfigGgcp:networkservices/EdgeCacheServiceLogConfig:EdgeCacheServiceLogConfigÖSpecifies the logging options for the traffic served by this service. If logging is enabled, logs will be exported to
Cloud Logging.
µ
nameB" ¶Name of the resource; provided by the client when the resource is created.
The name must be 1-64 characters long, and match the regular expression [a-zA-Z][a-zA-Z0-9_-]* which means the first character must be a letter,
and all following characters must be a dash, underscore, letter or digit.

projectB" à

requireTlsB
 ÛRequire TLS (HTTPS) for all clients connecting to this service. Clients who connect over HTTP (port 80) will receive a
HTTP 301 to the same URL over HTTPS (port 443). You must have at least one (1) edgeSslCertificate specified to enable
this.
˝
routings:q
o
networkservicesEdgeCacheServiceRoutingCgcp:networkservices/EdgeCacheServiceRouting:EdgeCacheServiceRouting}Defines how requests are routed, modified, cached and/or which origin content is filled from.
Structure is documented below.
—
	sslPolicyB" ΩURL of the SslPolicy resource that will be associated with the EdgeCacheService. If not set, the EdgeCacheService has no
SSL policy configured, and will default to the "COMPATIBLE" policy.
"C
descriptionB" .A human-readable description of the resource.
"ü
disableHttp2B
 àDisables HTTP/2. HTTP/2 (h2) is enabled by default and recommended for performance. HTTP/2 improves connection re-use
and reduces connection setup overhead by sending multiple streams over the same connection. Some legacy HTTP clients may
have issues with HTTP/2 connections due to broken HTTP/2 implementations. Setting this to true will prevent HTTP/2 from
being advertised and negotiated.
"N
disableQuic
 ;HTTP/3 (IETF QUIC) and Google QUIC are enabled by default.
"õ
edgeSecurityPolicyB" Resource URL that points at the Cloud Armor edge security policy that is applied on each request against the
EdgeCacheService.
"ˇ
edgeSslCertificatesB*" ﬂURLs to sslCertificate resources that are used to authenticate connections between users and the EdgeCacheService. Note
that only "global" certificates with a "scope" of "EDGE_CACHE" can be attached to an EdgeCacheService.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"~
ipv4Addresses*" gThe IPv4 addresses associated with this service. Addresses are static for the lifetime of the service.
"~
ipv6Addresses*" gThe IPv6 addresses associated with this service. Addresses are static for the lifetime of the service.
"ì
labelsB2" ÄSet of label tags associated with the EdgeCache resource. **Note**: This field is non-authoritative, and will only
manage the labels present in your configuration. Please refer to the field 'effective_labels' for all of the labels
present on the resource.
"ê
	logConfig{By:w
u
networkservicesEdgeCacheServiceLogConfigGgcp:networkservices/EdgeCacheServiceLogConfig:EdgeCacheServiceLogConfigÖSpecifies the logging options for the traffic served by this service. If logging is enabled, logs will be exported to
Cloud Logging.
"≥
name" ¶Name of the resource; provided by the client when the resource is created.
The name must be 1-64 characters long, and match the regular expression [a-zA-Z][a-zA-Z0-9_-]* which means the first character must be a letter,
and all following characters must be a dash, underscore, letter or digit.
"
project" "É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"Ü

requireTls
 ÛRequire TLS (HTTPS) for all clients connecting to this service. Clients who connect over HTTP (port 80) will receive a
HTTP 301 to the same URL over HTTPS (port 443). You must have at least one (1) edgeSslCertificate specified to enable
this.
"˝
routings:q
o
networkservicesEdgeCacheServiceRoutingCgcp:networkservices/EdgeCacheServiceRouting:EdgeCacheServiceRouting}Defines how requests are routed, modified, cached and/or which origin content is filled from.
Structure is documented below.
"—
	sslPolicyB" ΩURL of the SslPolicy resource that will be associated with the EdgeCacheService. If not set, the EdgeCacheService has no
SSL policy configured, and will default to the "COMPATIBLE" policy.
*ày
T
networkservicesEndpointPolicy1gcp:networkservices/endpointPolicy:EndpointPolicyˆY## Example Usage

### Network Services Endpoint Policy Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networkservices.EndpointPolicy("default", {
    name: "my-endpoint-policy",
    labels: {
        foo: "bar",
    },
    description: "my description",
    type: "SIDECAR_PROXY",
    trafficPortSelector: {
        ports: ["8081"],
    },
    endpointMatcher: {
        metadataLabelMatcher: {
            metadataLabelMatchCriteria: "MATCH_ANY",
            metadataLabels: [{
                labelName: "foo",
                labelValue: "bar",
            }],
        },
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networkservices.EndpointPolicy("default",
    name="my-endpoint-policy",
    labels={
        "foo": "bar",
    },
    description="my description",
    type="SIDECAR_PROXY",
    traffic_port_selector={
        "ports": ["8081"],
    },
    endpoint_matcher={
        "metadata_label_matcher": {
            "metadata_label_match_criteria": "MATCH_ANY",
            "metadata_labels": [{
                "label_name": "foo",
                "label_value": "bar",
            }],
        },
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkServices.EndpointPolicy("default", new()
    {
        Name = "my-endpoint-policy",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        Type = "SIDECAR_PROXY",
        TrafficPortSelector = new Gcp.NetworkServices.Inputs.EndpointPolicyTrafficPortSelectorArgs
        {
            Ports = new[]
            {
                "8081",
            },
        },
        EndpointMatcher = new Gcp.NetworkServices.Inputs.EndpointPolicyEndpointMatcherArgs
        {
            MetadataLabelMatcher = new Gcp.NetworkServices.Inputs.EndpointPolicyEndpointMatcherMetadataLabelMatcherArgs
            {
                MetadataLabelMatchCriteria = "MATCH_ANY",
                MetadataLabels = new[]
                {
                    new Gcp.NetworkServices.Inputs.EndpointPolicyEndpointMatcherMetadataLabelMatcherMetadataLabelArgs
                    {
                        LabelName = "foo",
                        LabelValue = "bar",
                    },
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networkservices.NewEndpointPolicy(ctx, "default", &networkservices.EndpointPolicyArgs{
			Name: pulumi.String("my-endpoint-policy"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			Type:        pulumi.String("SIDECAR_PROXY"),
			TrafficPortSelector: &networkservices.EndpointPolicyTrafficPortSelectorArgs{
				Ports: pulumi.StringArray{
					pulumi.String("8081"),
				},
			},
			EndpointMatcher: &networkservices.EndpointPolicyEndpointMatcherArgs{
				MetadataLabelMatcher: &networkservices.EndpointPolicyEndpointMatcherMetadataLabelMatcherArgs{
					MetadataLabelMatchCriteria: pulumi.String("MATCH_ANY"),
					MetadataLabels: networkservices.EndpointPolicyEndpointMatcherMetadataLabelMatcherMetadataLabelArray{
						&networkservices.EndpointPolicyEndpointMatcherMetadataLabelMatcherMetadataLabelArgs{
							LabelName:  pulumi.String("foo"),
							LabelValue: pulumi.String("bar"),
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networkservices.EndpointPolicy;
import com.pulumi.gcp.networkservices.EndpointPolicyArgs;
import com.pulumi.gcp.networkservices.inputs.EndpointPolicyTrafficPortSelectorArgs;
import com.pulumi.gcp.networkservices.inputs.EndpointPolicyEndpointMatcherArgs;
import com.pulumi.gcp.networkservices.inputs.EndpointPolicyEndpointMatcherMetadataLabelMatcherArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new EndpointPolicy("default", EndpointPolicyArgs.builder()
            .name("my-endpoint-policy")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .type("SIDECAR_PROXY")
            .trafficPortSelector(EndpointPolicyTrafficPortSelectorArgs.builder()
                .ports("8081")
                .build())
            .endpointMatcher(EndpointPolicyEndpointMatcherArgs.builder()
                .metadataLabelMatcher(EndpointPolicyEndpointMatcherMetadataLabelMatcherArgs.builder()
                    .metadataLabelMatchCriteria("MATCH_ANY")
                    .metadataLabels(EndpointPolicyEndpointMatcherMetadataLabelMatcherMetadataLabelArgs.builder()
                        .labelName("foo")
                        .labelValue("bar")
                        .build())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkservices:EndpointPolicy
    properties:
      name: my-endpoint-policy
      labels:
        foo: bar
      description: my description
      type: SIDECAR_PROXY
      trafficPortSelector:
        ports:
          - '8081'
      endpointMatcher:
        metadataLabelMatcher:
          metadataLabelMatchCriteria: MATCH_ANY
          metadataLabels:
            - labelName: foo
              labelValue: bar
```
<!--End PulumiCodeChooser -->
### Network Services Endpoint Policy Empty Match


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networkservices.EndpointPolicy("default", {
    name: "my-endpoint-policy",
    labels: {
        foo: "bar",
    },
    description: "my description",
    type: "SIDECAR_PROXY",
    trafficPortSelector: {
        ports: ["8081"],
    },
    endpointMatcher: {
        metadataLabelMatcher: {
            metadataLabelMatchCriteria: "MATCH_ANY",
        },
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networkservices.EndpointPolicy("default",
    name="my-endpoint-policy",
    labels={
        "foo": "bar",
    },
    description="my description",
    type="SIDECAR_PROXY",
    traffic_port_selector={
        "ports": ["8081"],
    },
    endpoint_matcher={
        "metadata_label_matcher": {
            "metadata_label_match_criteria": "MATCH_ANY",
        },
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkServices.EndpointPolicy("default", new()
    {
        Name = "my-endpoint-policy",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        Type = "SIDECAR_PROXY",
        TrafficPortSelector = new Gcp.NetworkServices.Inputs.EndpointPolicyTrafficPortSelectorArgs
        {
            Ports = new[]
            {
                "8081",
            },
        },
        EndpointMatcher = new Gcp.NetworkServices.Inputs.EndpointPolicyEndpointMatcherArgs
        {
            MetadataLabelMatcher = new Gcp.NetworkServices.Inputs.EndpointPolicyEndpointMatcherMetadataLabelMatcherArgs
            {
                MetadataLabelMatchCriteria = "MATCH_ANY",
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networkservices.NewEndpointPolicy(ctx, "default", &networkservices.EndpointPolicyArgs{
			Name: pulumi.String("my-endpoint-policy"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			Type:        pulumi.String("SIDECAR_PROXY"),
			TrafficPortSelector: &networkservices.EndpointPolicyTrafficPortSelectorArgs{
				Ports: pulumi.StringArray{
					pulumi.String("8081"),
				},
			},
			EndpointMatcher: &networkservices.EndpointPolicyEndpointMatcherArgs{
				MetadataLabelMatcher: &networkservices.EndpointPolicyEndpointMatcherMetadataLabelMatcherArgs{
					MetadataLabelMatchCriteria: pulumi.String("MATCH_ANY"),
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networkservices.EndpointPolicy;
import com.pulumi.gcp.networkservices.EndpointPolicyArgs;
import com.pulumi.gcp.networkservices.inputs.EndpointPolicyTrafficPortSelectorArgs;
import com.pulumi.gcp.networkservices.inputs.EndpointPolicyEndpointMatcherArgs;
import com.pulumi.gcp.networkservices.inputs.EndpointPolicyEndpointMatcherMetadataLabelMatcherArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new EndpointPolicy("default", EndpointPolicyArgs.builder()
            .name("my-endpoint-policy")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .type("SIDECAR_PROXY")
            .trafficPortSelector(EndpointPolicyTrafficPortSelectorArgs.builder()
                .ports("8081")
                .build())
            .endpointMatcher(EndpointPolicyEndpointMatcherArgs.builder()
                .metadataLabelMatcher(EndpointPolicyEndpointMatcherMetadataLabelMatcherArgs.builder()
                    .metadataLabelMatchCriteria("MATCH_ANY")
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkservices:EndpointPolicy
    properties:
      name: my-endpoint-policy
      labels:
        foo: bar
      description: my description
      type: SIDECAR_PROXY
      trafficPortSelector:
        ports:
          - '8081'
      endpointMatcher:
        metadataLabelMatcher:
          metadataLabelMatchCriteria: MATCH_ANY
```
<!--End PulumiCodeChooser -->

## Import

EndpointPolicy can be imported using any of these accepted formats:

* `projects/{{project}}/locations/global/endpointPolicies/{{name}}`

* `{{project}}/{{name}}`

* `{{name}}`

When using the `pulumi import` command, EndpointPolicy can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkservices/endpointPolicy:EndpointPolicy default projects/{{project}}/locations/global/endpointPolicies/{{name}}
```

```sh
$ pulumi import gcp:networkservices/endpointPolicy:EndpointPolicy default {{project}}/{{name}}
```

```sh
$ pulumi import gcp:networkservices/endpointPolicy:EndpointPolicy default {{name}}
```

∞
authorizationPolicyB" íThis field specifies the URL of AuthorizationPolicy resource that applies authorization policies to the inbound traffic
at the matched endpoints.
∂
clientTlsPolicyB" úA URL referring to a ClientTlsPolicy resource. ClientTlsPolicy can be set to specify the authentication for traffic from
the proxy to the actual endpoints.
Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
ê
endpointMatcherá:Ñ
Å
networkservicesEndpointPolicyEndpointMatcherOgcp:networkservices/EndpointPolicyEndpointMatcher:EndpointPolicyEndpointMatchersRequired. A matcher that selects endpoints to which the policies should be applied.
Structure is documented below.
í
labelsB2" ˇSet of label tags associated with the TcpRoute resource. **Note**: This field is non-authoritative, and will only manage
the labels present in your configuration. Please refer to the field 'effective_labels' for all of the labels present on
the resource.
3
nameB" %Name of the EndpointPolicy resource.

projectB" —
serverTlsPolicyB" ∑A URL referring to ServerTlsPolicy resource. ServerTlsPolicy is used to determine the authentication policy to be
applied to terminate the inbound traffic at the identified backends.
®
trafficPortSelectorñBì:ê
ç
networkservices!EndpointPolicyTrafficPortSelectorWgcp:networkservices/EndpointPolicyTrafficPortSelector:EndpointPolicyTrafficPortSelectorxPort selector for the (matched) endpoints. If no port selector is provided, the matched config is applied to all ports.
ï
type" àThe type of endpoint policy. This is primarily used to validate the configuration.
Possible values are: `SIDECAR_PROXY`, `GRPC_SERVER`.
"∞
authorizationPolicyB" íThis field specifies the URL of AuthorizationPolicy resource that applies authorization policies to the inbound traffic
at the matched endpoints.
"∂
clientTlsPolicyB" úA URL referring to a ClientTlsPolicy resource. ClientTlsPolicy can be set to specify the authentication for traffic from
the proxy to the actual endpoints.
"8

createTime" &Time the TcpRoute was created in UTC.
"Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"ê
endpointMatcherá:Ñ
Å
networkservicesEndpointPolicyEndpointMatcherOgcp:networkservices/EndpointPolicyEndpointMatcher:EndpointPolicyEndpointMatchersRequired. A matcher that selects endpoints to which the policies should be applied.
Structure is documented below.
"í
labelsB2" ˇSet of label tags associated with the TcpRoute resource. **Note**: This field is non-authoritative, and will only manage
the labels present in your configuration. Please refer to the field 'effective_labels' for all of the labels present on
the resource.
"1
name" %Name of the EndpointPolicy resource.
"
project" "É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"—
serverTlsPolicyB" ∑A URL referring to ServerTlsPolicy resource. ServerTlsPolicy is used to determine the authentication policy to be
applied to terminate the inbound traffic at the identified backends.
"®
trafficPortSelectorñBì:ê
ç
networkservices!EndpointPolicyTrafficPortSelectorWgcp:networkservices/EndpointPolicyTrafficPortSelector:EndpointPolicyTrafficPortSelectorxPort selector for the (matched) endpoints. If no port selector is provided, the matched config is applied to all ports.
"ï
type" àThe type of endpoint policy. This is primarily used to validate the configuration.
Possible values are: `SIDECAR_PROXY`, `GRPC_SERVER`.
"8

updateTime" &Time the TcpRoute was updated in UTC.
*¢ô
?
networkservicesGateway#gcp:networkservices/gateway:Gateway˝›Gateway represents the configuration for a proxy, typically a load balancer.
It captures the ip:port over which the services are exposed by the proxy,
along with any policy configurations. Routes have reference to to Gateways
to dictate how requests should be routed by this Gateway.


To get more information about Gateway, see:

* [API documentation](https://cloud.google.com/traffic-director/docs/reference/network-services/rest/v1/projects.locations.gateways)

## Example Usage

### Network Services Gateway Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networkservices.Gateway("default", {
    name: "my-gateway",
    scope: "default-scope-basic",
    type: "OPEN_MESH",
    ports: [443],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networkservices.Gateway("default",
    name="my-gateway",
    scope="default-scope-basic",
    type="OPEN_MESH",
    ports=[443])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkServices.Gateway("default", new()
    {
        Name = "my-gateway",
        Scope = "default-scope-basic",
        Type = "OPEN_MESH",
        Ports = new[]
        {
            443,
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networkservices.NewGateway(ctx, "default", &networkservices.GatewayArgs{
			Name:  pulumi.String("my-gateway"),
			Scope: pulumi.String("default-scope-basic"),
			Type:  pulumi.String("OPEN_MESH"),
			Ports: pulumi.IntArray{
				pulumi.Int(443),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networkservices.Gateway;
import com.pulumi.gcp.networkservices.GatewayArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new Gateway("default", GatewayArgs.builder()
            .name("my-gateway")
            .scope("default-scope-basic")
            .type("OPEN_MESH")
            .ports(443)
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkservices:Gateway
    properties:
      name: my-gateway
      scope: default-scope-basic
      type: OPEN_MESH
      ports:
        - 443
```
<!--End PulumiCodeChooser -->
### Network Services Gateway Advanced


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networkservices.Gateway("default", {
    name: "my-gateway",
    labels: {
        foo: "bar",
    },
    description: "my description",
    type: "OPEN_MESH",
    ports: [443],
    scope: "default-scope-advance",
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networkservices.Gateway("default",
    name="my-gateway",
    labels={
        "foo": "bar",
    },
    description="my description",
    type="OPEN_MESH",
    ports=[443],
    scope="default-scope-advance")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkServices.Gateway("default", new()
    {
        Name = "my-gateway",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        Type = "OPEN_MESH",
        Ports = new[]
        {
            443,
        },
        Scope = "default-scope-advance",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networkservices.NewGateway(ctx, "default", &networkservices.GatewayArgs{
			Name: pulumi.String("my-gateway"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			Type:        pulumi.String("OPEN_MESH"),
			Ports: pulumi.IntArray{
				pulumi.Int(443),
			},
			Scope: pulumi.String("default-scope-advance"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networkservices.Gateway;
import com.pulumi.gcp.networkservices.GatewayArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new Gateway("default", GatewayArgs.builder()
            .name("my-gateway")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .type("OPEN_MESH")
            .ports(443)
            .scope("default-scope-advance")
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkservices:Gateway
    properties:
      name: my-gateway
      labels:
        foo: bar
      description: my description
      type: OPEN_MESH
      ports:
        - 443
      scope: default-scope-advance
```
<!--End PulumiCodeChooser -->
### Network Services Gateway Secure Web Proxy


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";
import * as std from "@pulumi/std";

const _default = new gcp.certificatemanager.Certificate("default", {
    name: "my-certificate",
    location: "us-central1",
    selfManaged: {
        pemCertificate: std.file({
            input: "test-fixtures/cert.pem",
        }).then(invoke => invoke.result),
        pemPrivateKey: std.file({
            input: "test-fixtures/private-key.pem",
        }).then(invoke => invoke.result),
    },
});
const defaultNetwork = new gcp.compute.Network("default", {
    name: "my-network",
    routingMode: "REGIONAL",
    autoCreateSubnetworks: false,
});
const defaultSubnetwork = new gcp.compute.Subnetwork("default", {
    name: "my-subnetwork-name",
    purpose: "PRIVATE",
    ipCidrRange: "10.128.0.0/20",
    region: "us-central1",
    network: defaultNetwork.id,
    role: "ACTIVE",
});
const proxyonlysubnet = new gcp.compute.Subnetwork("proxyonlysubnet", {
    name: "my-proxy-only-subnetwork",
    purpose: "REGIONAL_MANAGED_PROXY",
    ipCidrRange: "192.168.0.0/23",
    region: "us-central1",
    network: defaultNetwork.id,
    role: "ACTIVE",
});
const defaultGatewaySecurityPolicy = new gcp.networksecurity.GatewaySecurityPolicy("default", {
    name: "my-policy-name",
    location: "us-central1",
});
const defaultGatewaySecurityPolicyRule = new gcp.networksecurity.GatewaySecurityPolicyRule("default", {
    name: "my-policyrule-name",
    location: "us-central1",
    gatewaySecurityPolicy: defaultGatewaySecurityPolicy.name,
    enabled: true,
    priority: 1,
    sessionMatcher: "host() == 'example.com'",
    basicProfile: "ALLOW",
});
const defaultGateway = new gcp.networkservices.Gateway("default", {
    name: "my-gateway1",
    location: "us-central1",
    addresses: ["10.128.0.99"],
    type: "SECURE_WEB_GATEWAY",
    ports: [443],
    scope: "my-default-scope1",
    certificateUrls: [_default.id],
    gatewaySecurityPolicy: defaultGatewaySecurityPolicy.id,
    network: defaultNetwork.id,
    subnetwork: defaultSubnetwork.id,
    deleteSwgAutogenRouterOnDestroy: true,
}, {
    dependsOn: [proxyonlysubnet],
});
```
```python
import pulumi
import pulumi_gcp as gcp
import pulumi_std as std

default = gcp.certificatemanager.Certificate("default",
    name="my-certificate",
    location="us-central1",
    self_managed={
        "pem_certificate": std.file(input="test-fixtures/cert.pem").result,
        "pem_private_key": std.file(input="test-fixtures/private-key.pem").result,
    })
default_network = gcp.compute.Network("default",
    name="my-network",
    routing_mode="REGIONAL",
    auto_create_subnetworks=False)
default_subnetwork = gcp.compute.Subnetwork("default",
    name="my-subnetwork-name",
    purpose="PRIVATE",
    ip_cidr_range="10.128.0.0/20",
    region="us-central1",
    network=default_network.id,
    role="ACTIVE")
proxyonlysubnet = gcp.compute.Subnetwork("proxyonlysubnet",
    name="my-proxy-only-subnetwork",
    purpose="REGIONAL_MANAGED_PROXY",
    ip_cidr_range="192.168.0.0/23",
    region="us-central1",
    network=default_network.id,
    role="ACTIVE")
default_gateway_security_policy = gcp.networksecurity.GatewaySecurityPolicy("default",
    name="my-policy-name",
    location="us-central1")
default_gateway_security_policy_rule = gcp.networksecurity.GatewaySecurityPolicyRule("default",
    name="my-policyrule-name",
    location="us-central1",
    gateway_security_policy=default_gateway_security_policy.name,
    enabled=True,
    priority=1,
    session_matcher="host() == 'example.com'",
    basic_profile="ALLOW")
default_gateway = gcp.networkservices.Gateway("default",
    name="my-gateway1",
    location="us-central1",
    addresses=["10.128.0.99"],
    type="SECURE_WEB_GATEWAY",
    ports=[443],
    scope="my-default-scope1",
    certificate_urls=[default.id],
    gateway_security_policy=default_gateway_security_policy.id,
    network=default_network.id,
    subnetwork=default_subnetwork.id,
    delete_swg_autogen_router_on_destroy=True,
    opts = pulumi.ResourceOptions(depends_on=[proxyonlysubnet]))
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;
using Std = Pulumi.Std;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.CertificateManager.Certificate("default", new()
    {
        Name = "my-certificate",
        Location = "us-central1",
        SelfManaged = new Gcp.CertificateManager.Inputs.CertificateSelfManagedArgs
        {
            PemCertificate = Std.File.Invoke(new()
            {
                Input = "test-fixtures/cert.pem",
            }).Apply(invoke => invoke.Result),
            PemPrivateKey = Std.File.Invoke(new()
            {
                Input = "test-fixtures/private-key.pem",
            }).Apply(invoke => invoke.Result),
        },
    });

    var defaultNetwork = new Gcp.Compute.Network("default", new()
    {
        Name = "my-network",
        RoutingMode = "REGIONAL",
        AutoCreateSubnetworks = false,
    });

    var defaultSubnetwork = new Gcp.Compute.Subnetwork("default", new()
    {
        Name = "my-subnetwork-name",
        Purpose = "PRIVATE",
        IpCidrRange = "10.128.0.0/20",
        Region = "us-central1",
        Network = defaultNetwork.Id,
        Role = "ACTIVE",
    });

    var proxyonlysubnet = new Gcp.Compute.Subnetwork("proxyonlysubnet", new()
    {
        Name = "my-proxy-only-subnetwork",
        Purpose = "REGIONAL_MANAGED_PROXY",
        IpCidrRange = "192.168.0.0/23",
        Region = "us-central1",
        Network = defaultNetwork.Id,
        Role = "ACTIVE",
    });

    var defaultGatewaySecurityPolicy = new Gcp.NetworkSecurity.GatewaySecurityPolicy("default", new()
    {
        Name = "my-policy-name",
        Location = "us-central1",
    });

    var defaultGatewaySecurityPolicyRule = new Gcp.NetworkSecurity.GatewaySecurityPolicyRule("default", new()
    {
        Name = "my-policyrule-name",
        Location = "us-central1",
        GatewaySecurityPolicy = defaultGatewaySecurityPolicy.Name,
        Enabled = true,
        Priority = 1,
        SessionMatcher = "host() == 'example.com'",
        BasicProfile = "ALLOW",
    });

    var defaultGateway = new Gcp.NetworkServices.Gateway("default", new()
    {
        Name = "my-gateway1",
        Location = "us-central1",
        Addresses = new[]
        {
            "10.128.0.99",
        },
        Type = "SECURE_WEB_GATEWAY",
        Ports = new[]
        {
            443,
        },
        Scope = "my-default-scope1",
        CertificateUrls = new[]
        {
            @default.Id,
        },
        GatewaySecurityPolicy = defaultGatewaySecurityPolicy.Id,
        Network = defaultNetwork.Id,
        Subnetwork = defaultSubnetwork.Id,
        DeleteSwgAutogenRouterOnDestroy = true,
    }, new CustomResourceOptions
    {
        DependsOn =
        {
            proxyonlysubnet,
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/certificatemanager"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi-std/sdk/go/std"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		invokeFile, err := std.File(ctx, &std.FileArgs{
			Input: "test-fixtures/cert.pem",
		}, nil)
		if err != nil {
			return err
		}
		invokeFile1, err := std.File(ctx, &std.FileArgs{
			Input: "test-fixtures/private-key.pem",
		}, nil)
		if err != nil {
			return err
		}
		_, err = certificatemanager.NewCertificate(ctx, "default", &certificatemanager.CertificateArgs{
			Name:     pulumi.String("my-certificate"),
			Location: pulumi.String("us-central1"),
			SelfManaged: &certificatemanager.CertificateSelfManagedArgs{
				PemCertificate: pulumi.String(invokeFile.Result),
				PemPrivateKey:  pulumi.String(invokeFile1.Result),
			},
		})
		if err != nil {
			return err
		}
		defaultNetwork, err := compute.NewNetwork(ctx, "default", &compute.NetworkArgs{
			Name:                  pulumi.String("my-network"),
			RoutingMode:           pulumi.String("REGIONAL"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		defaultSubnetwork, err := compute.NewSubnetwork(ctx, "default", &compute.SubnetworkArgs{
			Name:        pulumi.String("my-subnetwork-name"),
			Purpose:     pulumi.String("PRIVATE"),
			IpCidrRange: pulumi.String("10.128.0.0/20"),
			Region:      pulumi.String("us-central1"),
			Network:     defaultNetwork.ID(),
			Role:        pulumi.String("ACTIVE"),
		})
		if err != nil {
			return err
		}
		proxyonlysubnet, err := compute.NewSubnetwork(ctx, "proxyonlysubnet", &compute.SubnetworkArgs{
			Name:        pulumi.String("my-proxy-only-subnetwork"),
			Purpose:     pulumi.String("REGIONAL_MANAGED_PROXY"),
			IpCidrRange: pulumi.String("192.168.0.0/23"),
			Region:      pulumi.String("us-central1"),
			Network:     defaultNetwork.ID(),
			Role:        pulumi.String("ACTIVE"),
		})
		if err != nil {
			return err
		}
		defaultGatewaySecurityPolicy, err := networksecurity.NewGatewaySecurityPolicy(ctx, "default", &networksecurity.GatewaySecurityPolicyArgs{
			Name:     pulumi.String("my-policy-name"),
			Location: pulumi.String("us-central1"),
		})
		if err != nil {
			return err
		}
		_, err = networksecurity.NewGatewaySecurityPolicyRule(ctx, "default", &networksecurity.GatewaySecurityPolicyRuleArgs{
			Name:                  pulumi.String("my-policyrule-name"),
			Location:              pulumi.String("us-central1"),
			GatewaySecurityPolicy: defaultGatewaySecurityPolicy.Name,
			Enabled:               pulumi.Bool(true),
			Priority:              pulumi.Int(1),
			SessionMatcher:        pulumi.String("host() == 'example.com'"),
			BasicProfile:          pulumi.String("ALLOW"),
		})
		if err != nil {
			return err
		}
		_, err = networkservices.NewGateway(ctx, "default", &networkservices.GatewayArgs{
			Name:     pulumi.String("my-gateway1"),
			Location: pulumi.String("us-central1"),
			Addresses: pulumi.StringArray{
				pulumi.String("10.128.0.99"),
			},
			Type: pulumi.String("SECURE_WEB_GATEWAY"),
			Ports: pulumi.IntArray{
				pulumi.Int(443),
			},
			Scope: pulumi.String("my-default-scope1"),
			CertificateUrls: pulumi.StringArray{
				_default.ID(),
			},
			GatewaySecurityPolicy:           defaultGatewaySecurityPolicy.ID(),
			Network:                         defaultNetwork.ID(),
			Subnetwork:                      defaultSubnetwork.ID(),
			DeleteSwgAutogenRouterOnDestroy: pulumi.Bool(true),
		}, pulumi.DependsOn([]pulumi.Resource{
			proxyonlysubnet,
		}))
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.certificatemanager.Certificate;
import com.pulumi.gcp.certificatemanager.CertificateArgs;
import com.pulumi.gcp.certificatemanager.inputs.CertificateSelfManagedArgs;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.Subnetwork;
import com.pulumi.gcp.compute.SubnetworkArgs;
import com.pulumi.gcp.networksecurity.GatewaySecurityPolicy;
import com.pulumi.gcp.networksecurity.GatewaySecurityPolicyArgs;
import com.pulumi.gcp.networksecurity.GatewaySecurityPolicyRule;
import com.pulumi.gcp.networksecurity.GatewaySecurityPolicyRuleArgs;
import com.pulumi.gcp.networkservices.Gateway;
import com.pulumi.gcp.networkservices.GatewayArgs;
import com.pulumi.resources.CustomResourceOptions;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new Certificate("default", CertificateArgs.builder()
            .name("my-certificate")
            .location("us-central1")
            .selfManaged(CertificateSelfManagedArgs.builder()
                .pemCertificate(StdFunctions.file(FileArgs.builder()
                    .input("test-fixtures/cert.pem")
                    .build()).result())
                .pemPrivateKey(StdFunctions.file(FileArgs.builder()
                    .input("test-fixtures/private-key.pem")
                    .build()).result())
                .build())
            .build());

        var defaultNetwork = new Network("defaultNetwork", NetworkArgs.builder()
            .name("my-network")
            .routingMode("REGIONAL")
            .autoCreateSubnetworks(false)
            .build());

        var defaultSubnetwork = new Subnetwork("defaultSubnetwork", SubnetworkArgs.builder()
            .name("my-subnetwork-name")
            .purpose("PRIVATE")
            .ipCidrRange("10.128.0.0/20")
            .region("us-central1")
            .network(defaultNetwork.id())
            .role("ACTIVE")
            .build());

        var proxyonlysubnet = new Subnetwork("proxyonlysubnet", SubnetworkArgs.builder()
            .name("my-proxy-only-subnetwork")
            .purpose("REGIONAL_MANAGED_PROXY")
            .ipCidrRange("192.168.0.0/23")
            .region("us-central1")
            .network(defaultNetwork.id())
            .role("ACTIVE")
            .build());

        var defaultGatewaySecurityPolicy = new GatewaySecurityPolicy("defaultGatewaySecurityPolicy", GatewaySecurityPolicyArgs.builder()
            .name("my-policy-name")
            .location("us-central1")
            .build());

        var defaultGatewaySecurityPolicyRule = new GatewaySecurityPolicyRule("defaultGatewaySecurityPolicyRule", GatewaySecurityPolicyRuleArgs.builder()
            .name("my-policyrule-name")
            .location("us-central1")
            .gatewaySecurityPolicy(defaultGatewaySecurityPolicy.name())
            .enabled(true)
            .priority(1)
            .sessionMatcher("host() == 'example.com'")
            .basicProfile("ALLOW")
            .build());

        var defaultGateway = new Gateway("defaultGateway", GatewayArgs.builder()
            .name("my-gateway1")
            .location("us-central1")
            .addresses("10.128.0.99")
            .type("SECURE_WEB_GATEWAY")
            .ports(443)
            .scope("my-default-scope1")
            .certificateUrls(default_.id())
            .gatewaySecurityPolicy(defaultGatewaySecurityPolicy.id())
            .network(defaultNetwork.id())
            .subnetwork(defaultSubnetwork.id())
            .deleteSwgAutogenRouterOnDestroy(true)
            .build(), CustomResourceOptions.builder()
                .dependsOn(proxyonlysubnet)
                .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:certificatemanager:Certificate
    properties:
      name: my-certificate
      location: us-central1
      selfManaged:
        pemCertificate:
          fn::invoke:
            function: std:file
            arguments:
              input: test-fixtures/cert.pem
            return: result
        pemPrivateKey:
          fn::invoke:
            function: std:file
            arguments:
              input: test-fixtures/private-key.pem
            return: result
  defaultNetwork:
    type: gcp:compute:Network
    name: default
    properties:
      name: my-network
      routingMode: REGIONAL
      autoCreateSubnetworks: false
  defaultSubnetwork:
    type: gcp:compute:Subnetwork
    name: default
    properties:
      name: my-subnetwork-name
      purpose: PRIVATE
      ipCidrRange: 10.128.0.0/20
      region: us-central1
      network: ${defaultNetwork.id}
      role: ACTIVE
  proxyonlysubnet:
    type: gcp:compute:Subnetwork
    properties:
      name: my-proxy-only-subnetwork
      purpose: REGIONAL_MANAGED_PROXY
      ipCidrRange: 192.168.0.0/23
      region: us-central1
      network: ${defaultNetwork.id}
      role: ACTIVE
  defaultGatewaySecurityPolicy:
    type: gcp:networksecurity:GatewaySecurityPolicy
    name: default
    properties:
      name: my-policy-name
      location: us-central1
  defaultGatewaySecurityPolicyRule:
    type: gcp:networksecurity:GatewaySecurityPolicyRule
    name: default
    properties:
      name: my-policyrule-name
      location: us-central1
      gatewaySecurityPolicy: ${defaultGatewaySecurityPolicy.name}
      enabled: true
      priority: 1
      sessionMatcher: host() == 'example.com'
      basicProfile: ALLOW
  defaultGateway:
    type: gcp:networkservices:Gateway
    name: default
    properties:
      name: my-gateway1
      location: us-central1
      addresses:
        - 10.128.0.99
      type: SECURE_WEB_GATEWAY
      ports:
        - 443
      scope: my-default-scope1
      certificateUrls:
        - ${default.id}
      gatewaySecurityPolicy: ${defaultGatewaySecurityPolicy.id}
      network: ${defaultNetwork.id}
      subnetwork: ${defaultSubnetwork.id}
      deleteSwgAutogenRouterOnDestroy: true
    options:
      dependsOn:
        - ${proxyonlysubnet}
```
<!--End PulumiCodeChooser -->
### Network Services Gateway Multiple Swp Same Network


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";
import * as std from "@pulumi/std";

const _default = new gcp.certificatemanager.Certificate("default", {
    name: "my-certificate",
    location: "us-south1",
    selfManaged: {
        pemCertificate: std.file({
            input: "test-fixtures/cert.pem",
        }).then(invoke => invoke.result),
        pemPrivateKey: std.file({
            input: "test-fixtures/private-key.pem",
        }).then(invoke => invoke.result),
    },
});
const defaultNetwork = new gcp.compute.Network("default", {
    name: "my-network",
    routingMode: "REGIONAL",
    autoCreateSubnetworks: false,
});
const defaultSubnetwork = new gcp.compute.Subnetwork("default", {
    name: "my-subnetwork-name",
    purpose: "PRIVATE",
    ipCidrRange: "10.128.0.0/20",
    region: "us-south1",
    network: defaultNetwork.id,
    role: "ACTIVE",
});
const proxyonlysubnet = new gcp.compute.Subnetwork("proxyonlysubnet", {
    name: "my-proxy-only-subnetwork",
    purpose: "REGIONAL_MANAGED_PROXY",
    ipCidrRange: "192.168.0.0/23",
    region: "us-south1",
    network: defaultNetwork.id,
    role: "ACTIVE",
});
const defaultGatewaySecurityPolicy = new gcp.networksecurity.GatewaySecurityPolicy("default", {
    name: "my-policy-name",
    location: "us-south1",
});
const defaultGatewaySecurityPolicyRule = new gcp.networksecurity.GatewaySecurityPolicyRule("default", {
    name: "my-policyrule-name",
    location: "us-south1",
    gatewaySecurityPolicy: defaultGatewaySecurityPolicy.name,
    enabled: true,
    priority: 1,
    sessionMatcher: "host() == 'example.com'",
    basicProfile: "ALLOW",
});
const defaultGateway = new gcp.networkservices.Gateway("default", {
    name: "my-gateway1",
    location: "us-south1",
    addresses: ["10.128.0.99"],
    type: "SECURE_WEB_GATEWAY",
    ports: [443],
    scope: "my-default-scope1",
    certificateUrls: [_default.id],
    gatewaySecurityPolicy: defaultGatewaySecurityPolicy.id,
    network: defaultNetwork.id,
    subnetwork: defaultSubnetwork.id,
    deleteSwgAutogenRouterOnDestroy: true,
}, {
    dependsOn: [proxyonlysubnet],
});
const gateway2 = new gcp.networkservices.Gateway("gateway2", {
    name: "my-gateway2",
    location: "us-south1",
    addresses: ["10.128.0.98"],
    type: "SECURE_WEB_GATEWAY",
    ports: [443],
    scope: "my-default-scope2",
    certificateUrls: [_default.id],
    gatewaySecurityPolicy: defaultGatewaySecurityPolicy.id,
    network: defaultNetwork.id,
    subnetwork: defaultSubnetwork.id,
    deleteSwgAutogenRouterOnDestroy: true,
}, {
    dependsOn: [proxyonlysubnet],
});
```
```python
import pulumi
import pulumi_gcp as gcp
import pulumi_std as std

default = gcp.certificatemanager.Certificate("default",
    name="my-certificate",
    location="us-south1",
    self_managed={
        "pem_certificate": std.file(input="test-fixtures/cert.pem").result,
        "pem_private_key": std.file(input="test-fixtures/private-key.pem").result,
    })
default_network = gcp.compute.Network("default",
    name="my-network",
    routing_mode="REGIONAL",
    auto_create_subnetworks=False)
default_subnetwork = gcp.compute.Subnetwork("default",
    name="my-subnetwork-name",
    purpose="PRIVATE",
    ip_cidr_range="10.128.0.0/20",
    region="us-south1",
    network=default_network.id,
    role="ACTIVE")
proxyonlysubnet = gcp.compute.Subnetwork("proxyonlysubnet",
    name="my-proxy-only-subnetwork",
    purpose="REGIONAL_MANAGED_PROXY",
    ip_cidr_range="192.168.0.0/23",
    region="us-south1",
    network=default_network.id,
    role="ACTIVE")
default_gateway_security_policy = gcp.networksecurity.GatewaySecurityPolicy("default",
    name="my-policy-name",
    location="us-south1")
default_gateway_security_policy_rule = gcp.networksecurity.GatewaySecurityPolicyRule("default",
    name="my-policyrule-name",
    location="us-south1",
    gateway_security_policy=default_gateway_security_policy.name,
    enabled=True,
    priority=1,
    session_matcher="host() == 'example.com'",
    basic_profile="ALLOW")
default_gateway = gcp.networkservices.Gateway("default",
    name="my-gateway1",
    location="us-south1",
    addresses=["10.128.0.99"],
    type="SECURE_WEB_GATEWAY",
    ports=[443],
    scope="my-default-scope1",
    certificate_urls=[default.id],
    gateway_security_policy=default_gateway_security_policy.id,
    network=default_network.id,
    subnetwork=default_subnetwork.id,
    delete_swg_autogen_router_on_destroy=True,
    opts = pulumi.ResourceOptions(depends_on=[proxyonlysubnet]))
gateway2 = gcp.networkservices.Gateway("gateway2",
    name="my-gateway2",
    location="us-south1",
    addresses=["10.128.0.98"],
    type="SECURE_WEB_GATEWAY",
    ports=[443],
    scope="my-default-scope2",
    certificate_urls=[default.id],
    gateway_security_policy=default_gateway_security_policy.id,
    network=default_network.id,
    subnetwork=default_subnetwork.id,
    delete_swg_autogen_router_on_destroy=True,
    opts = pulumi.ResourceOptions(depends_on=[proxyonlysubnet]))
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;
using Std = Pulumi.Std;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.CertificateManager.Certificate("default", new()
    {
        Name = "my-certificate",
        Location = "us-south1",
        SelfManaged = new Gcp.CertificateManager.Inputs.CertificateSelfManagedArgs
        {
            PemCertificate = Std.File.Invoke(new()
            {
                Input = "test-fixtures/cert.pem",
            }).Apply(invoke => invoke.Result),
            PemPrivateKey = Std.File.Invoke(new()
            {
                Input = "test-fixtures/private-key.pem",
            }).Apply(invoke => invoke.Result),
        },
    });

    var defaultNetwork = new Gcp.Compute.Network("default", new()
    {
        Name = "my-network",
        RoutingMode = "REGIONAL",
        AutoCreateSubnetworks = false,
    });

    var defaultSubnetwork = new Gcp.Compute.Subnetwork("default", new()
    {
        Name = "my-subnetwork-name",
        Purpose = "PRIVATE",
        IpCidrRange = "10.128.0.0/20",
        Region = "us-south1",
        Network = defaultNetwork.Id,
        Role = "ACTIVE",
    });

    var proxyonlysubnet = new Gcp.Compute.Subnetwork("proxyonlysubnet", new()
    {
        Name = "my-proxy-only-subnetwork",
        Purpose = "REGIONAL_MANAGED_PROXY",
        IpCidrRange = "192.168.0.0/23",
        Region = "us-south1",
        Network = defaultNetwork.Id,
        Role = "ACTIVE",
    });

    var defaultGatewaySecurityPolicy = new Gcp.NetworkSecurity.GatewaySecurityPolicy("default", new()
    {
        Name = "my-policy-name",
        Location = "us-south1",
    });

    var defaultGatewaySecurityPolicyRule = new Gcp.NetworkSecurity.GatewaySecurityPolicyRule("default", new()
    {
        Name = "my-policyrule-name",
        Location = "us-south1",
        GatewaySecurityPolicy = defaultGatewaySecurityPolicy.Name,
        Enabled = true,
        Priority = 1,
        SessionMatcher = "host() == 'example.com'",
        BasicProfile = "ALLOW",
    });

    var defaultGateway = new Gcp.NetworkServices.Gateway("default", new()
    {
        Name = "my-gateway1",
        Location = "us-south1",
        Addresses = new[]
        {
            "10.128.0.99",
        },
        Type = "SECURE_WEB_GATEWAY",
        Ports = new[]
        {
            443,
        },
        Scope = "my-default-scope1",
        CertificateUrls = new[]
        {
            @default.Id,
        },
        GatewaySecurityPolicy = defaultGatewaySecurityPolicy.Id,
        Network = defaultNetwork.Id,
        Subnetwork = defaultSubnetwork.Id,
        DeleteSwgAutogenRouterOnDestroy = true,
    }, new CustomResourceOptions
    {
        DependsOn =
        {
            proxyonlysubnet,
        },
    });

    var gateway2 = new Gcp.NetworkServices.Gateway("gateway2", new()
    {
        Name = "my-gateway2",
        Location = "us-south1",
        Addresses = new[]
        {
            "10.128.0.98",
        },
        Type = "SECURE_WEB_GATEWAY",
        Ports = new[]
        {
            443,
        },
        Scope = "my-default-scope2",
        CertificateUrls = new[]
        {
            @default.Id,
        },
        GatewaySecurityPolicy = defaultGatewaySecurityPolicy.Id,
        Network = defaultNetwork.Id,
        Subnetwork = defaultSubnetwork.Id,
        DeleteSwgAutogenRouterOnDestroy = true,
    }, new CustomResourceOptions
    {
        DependsOn =
        {
            proxyonlysubnet,
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/certificatemanager"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networksecurity"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi-std/sdk/go/std"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		invokeFile, err := std.File(ctx, &std.FileArgs{
			Input: "test-fixtures/cert.pem",
		}, nil)
		if err != nil {
			return err
		}
		invokeFile1, err := std.File(ctx, &std.FileArgs{
			Input: "test-fixtures/private-key.pem",
		}, nil)
		if err != nil {
			return err
		}
		_, err = certificatemanager.NewCertificate(ctx, "default", &certificatemanager.CertificateArgs{
			Name:     pulumi.String("my-certificate"),
			Location: pulumi.String("us-south1"),
			SelfManaged: &certificatemanager.CertificateSelfManagedArgs{
				PemCertificate: pulumi.String(invokeFile.Result),
				PemPrivateKey:  pulumi.String(invokeFile1.Result),
			},
		})
		if err != nil {
			return err
		}
		defaultNetwork, err := compute.NewNetwork(ctx, "default", &compute.NetworkArgs{
			Name:                  pulumi.String("my-network"),
			RoutingMode:           pulumi.String("REGIONAL"),
			AutoCreateSubnetworks: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		defaultSubnetwork, err := compute.NewSubnetwork(ctx, "default", &compute.SubnetworkArgs{
			Name:        pulumi.String("my-subnetwork-name"),
			Purpose:     pulumi.String("PRIVATE"),
			IpCidrRange: pulumi.String("10.128.0.0/20"),
			Region:      pulumi.String("us-south1"),
			Network:     defaultNetwork.ID(),
			Role:        pulumi.String("ACTIVE"),
		})
		if err != nil {
			return err
		}
		proxyonlysubnet, err := compute.NewSubnetwork(ctx, "proxyonlysubnet", &compute.SubnetworkArgs{
			Name:        pulumi.String("my-proxy-only-subnetwork"),
			Purpose:     pulumi.String("REGIONAL_MANAGED_PROXY"),
			IpCidrRange: pulumi.String("192.168.0.0/23"),
			Region:      pulumi.String("us-south1"),
			Network:     defaultNetwork.ID(),
			Role:        pulumi.String("ACTIVE"),
		})
		if err != nil {
			return err
		}
		defaultGatewaySecurityPolicy, err := networksecurity.NewGatewaySecurityPolicy(ctx, "default", &networksecurity.GatewaySecurityPolicyArgs{
			Name:     pulumi.String("my-policy-name"),
			Location: pulumi.String("us-south1"),
		})
		if err != nil {
			return err
		}
		_, err = networksecurity.NewGatewaySecurityPolicyRule(ctx, "default", &networksecurity.GatewaySecurityPolicyRuleArgs{
			Name:                  pulumi.String("my-policyrule-name"),
			Location:              pulumi.String("us-south1"),
			GatewaySecurityPolicy: defaultGatewaySecurityPolicy.Name,
			Enabled:               pulumi.Bool(true),
			Priority:              pulumi.Int(1),
			SessionMatcher:        pulumi.String("host() == 'example.com'"),
			BasicProfile:          pulumi.String("ALLOW"),
		})
		if err != nil {
			return err
		}
		_, err = networkservices.NewGateway(ctx, "default", &networkservices.GatewayArgs{
			Name:     pulumi.String("my-gateway1"),
			Location: pulumi.String("us-south1"),
			Addresses: pulumi.StringArray{
				pulumi.String("10.128.0.99"),
			},
			Type: pulumi.String("SECURE_WEB_GATEWAY"),
			Ports: pulumi.IntArray{
				pulumi.Int(443),
			},
			Scope: pulumi.String("my-default-scope1"),
			CertificateUrls: pulumi.StringArray{
				_default.ID(),
			},
			GatewaySecurityPolicy:           defaultGatewaySecurityPolicy.ID(),
			Network:                         defaultNetwork.ID(),
			Subnetwork:                      defaultSubnetwork.ID(),
			DeleteSwgAutogenRouterOnDestroy: pulumi.Bool(true),
		}, pulumi.DependsOn([]pulumi.Resource{
			proxyonlysubnet,
		}))
		if err != nil {
			return err
		}
		_, err = networkservices.NewGateway(ctx, "gateway2", &networkservices.GatewayArgs{
			Name:     pulumi.String("my-gateway2"),
			Location: pulumi.String("us-south1"),
			Addresses: pulumi.StringArray{
				pulumi.String("10.128.0.98"),
			},
			Type: pulumi.String("SECURE_WEB_GATEWAY"),
			Ports: pulumi.IntArray{
				pulumi.Int(443),
			},
			Scope: pulumi.String("my-default-scope2"),
			CertificateUrls: pulumi.StringArray{
				_default.ID(),
			},
			GatewaySecurityPolicy:           defaultGatewaySecurityPolicy.ID(),
			Network:                         defaultNetwork.ID(),
			Subnetwork:                      defaultSubnetwork.ID(),
			DeleteSwgAutogenRouterOnDestroy: pulumi.Bool(true),
		}, pulumi.DependsOn([]pulumi.Resource{
			proxyonlysubnet,
		}))
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.certificatemanager.Certificate;
import com.pulumi.gcp.certificatemanager.CertificateArgs;
import com.pulumi.gcp.certificatemanager.inputs.CertificateSelfManagedArgs;
import com.pulumi.gcp.compute.Network;
import com.pulumi.gcp.compute.NetworkArgs;
import com.pulumi.gcp.compute.Subnetwork;
import com.pulumi.gcp.compute.SubnetworkArgs;
import com.pulumi.gcp.networksecurity.GatewaySecurityPolicy;
import com.pulumi.gcp.networksecurity.GatewaySecurityPolicyArgs;
import com.pulumi.gcp.networksecurity.GatewaySecurityPolicyRule;
import com.pulumi.gcp.networksecurity.GatewaySecurityPolicyRuleArgs;
import com.pulumi.gcp.networkservices.Gateway;
import com.pulumi.gcp.networkservices.GatewayArgs;
import com.pulumi.resources.CustomResourceOptions;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new Certificate("default", CertificateArgs.builder()
            .name("my-certificate")
            .location("us-south1")
            .selfManaged(CertificateSelfManagedArgs.builder()
                .pemCertificate(StdFunctions.file(FileArgs.builder()
                    .input("test-fixtures/cert.pem")
                    .build()).result())
                .pemPrivateKey(StdFunctions.file(FileArgs.builder()
                    .input("test-fixtures/private-key.pem")
                    .build()).result())
                .build())
            .build());

        var defaultNetwork = new Network("defaultNetwork", NetworkArgs.builder()
            .name("my-network")
            .routingMode("REGIONAL")
            .autoCreateSubnetworks(false)
            .build());

        var defaultSubnetwork = new Subnetwork("defaultSubnetwork", SubnetworkArgs.builder()
            .name("my-subnetwork-name")
            .purpose("PRIVATE")
            .ipCidrRange("10.128.0.0/20")
            .region("us-south1")
            .network(defaultNetwork.id())
            .role("ACTIVE")
            .build());

        var proxyonlysubnet = new Subnetwork("proxyonlysubnet", SubnetworkArgs.builder()
            .name("my-proxy-only-subnetwork")
            .purpose("REGIONAL_MANAGED_PROXY")
            .ipCidrRange("192.168.0.0/23")
            .region("us-south1")
            .network(defaultNetwork.id())
            .role("ACTIVE")
            .build());

        var defaultGatewaySecurityPolicy = new GatewaySecurityPolicy("defaultGatewaySecurityPolicy", GatewaySecurityPolicyArgs.builder()
            .name("my-policy-name")
            .location("us-south1")
            .build());

        var defaultGatewaySecurityPolicyRule = new GatewaySecurityPolicyRule("defaultGatewaySecurityPolicyRule", GatewaySecurityPolicyRuleArgs.builder()
            .name("my-policyrule-name")
            .location("us-south1")
            .gatewaySecurityPolicy(defaultGatewaySecurityPolicy.name())
            .enabled(true)
            .priority(1)
            .sessionMatcher("host() == 'example.com'")
            .basicProfile("ALLOW")
            .build());

        var defaultGateway = new Gateway("defaultGateway", GatewayArgs.builder()
            .name("my-gateway1")
            .location("us-south1")
            .addresses("10.128.0.99")
            .type("SECURE_WEB_GATEWAY")
            .ports(443)
            .scope("my-default-scope1")
            .certificateUrls(default_.id())
            .gatewaySecurityPolicy(defaultGatewaySecurityPolicy.id())
            .network(defaultNetwork.id())
            .subnetwork(defaultSubnetwork.id())
            .deleteSwgAutogenRouterOnDestroy(true)
            .build(), CustomResourceOptions.builder()
                .dependsOn(proxyonlysubnet)
                .build());

        var gateway2 = new Gateway("gateway2", GatewayArgs.builder()
            .name("my-gateway2")
            .location("us-south1")
            .addresses("10.128.0.98")
            .type("SECURE_WEB_GATEWAY")
            .ports(443)
            .scope("my-default-scope2")
            .certificateUrls(default_.id())
            .gatewaySecurityPolicy(defaultGatewaySecurityPolicy.id())
            .network(defaultNetwork.id())
            .subnetwork(defaultSubnetwork.id())
            .deleteSwgAutogenRouterOnDestroy(true)
            .build(), CustomResourceOptions.builder()
                .dependsOn(proxyonlysubnet)
                .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:certificatemanager:Certificate
    properties:
      name: my-certificate
      location: us-south1
      selfManaged:
        pemCertificate:
          fn::invoke:
            function: std:file
            arguments:
              input: test-fixtures/cert.pem
            return: result
        pemPrivateKey:
          fn::invoke:
            function: std:file
            arguments:
              input: test-fixtures/private-key.pem
            return: result
  defaultNetwork:
    type: gcp:compute:Network
    name: default
    properties:
      name: my-network
      routingMode: REGIONAL
      autoCreateSubnetworks: false
  defaultSubnetwork:
    type: gcp:compute:Subnetwork
    name: default
    properties:
      name: my-subnetwork-name
      purpose: PRIVATE
      ipCidrRange: 10.128.0.0/20
      region: us-south1
      network: ${defaultNetwork.id}
      role: ACTIVE
  proxyonlysubnet:
    type: gcp:compute:Subnetwork
    properties:
      name: my-proxy-only-subnetwork
      purpose: REGIONAL_MANAGED_PROXY
      ipCidrRange: 192.168.0.0/23
      region: us-south1
      network: ${defaultNetwork.id}
      role: ACTIVE
  defaultGatewaySecurityPolicy:
    type: gcp:networksecurity:GatewaySecurityPolicy
    name: default
    properties:
      name: my-policy-name
      location: us-south1
  defaultGatewaySecurityPolicyRule:
    type: gcp:networksecurity:GatewaySecurityPolicyRule
    name: default
    properties:
      name: my-policyrule-name
      location: us-south1
      gatewaySecurityPolicy: ${defaultGatewaySecurityPolicy.name}
      enabled: true
      priority: 1
      sessionMatcher: host() == 'example.com'
      basicProfile: ALLOW
  defaultGateway:
    type: gcp:networkservices:Gateway
    name: default
    properties:
      name: my-gateway1
      location: us-south1
      addresses:
        - 10.128.0.99
      type: SECURE_WEB_GATEWAY
      ports:
        - 443
      scope: my-default-scope1
      certificateUrls:
        - ${default.id}
      gatewaySecurityPolicy: ${defaultGatewaySecurityPolicy.id}
      network: ${defaultNetwork.id}
      subnetwork: ${defaultSubnetwork.id}
      deleteSwgAutogenRouterOnDestroy: true
    options:
      dependsOn:
        - ${proxyonlysubnet}
  gateway2:
    type: gcp:networkservices:Gateway
    properties:
      name: my-gateway2
      location: us-south1
      addresses:
        - 10.128.0.98
      type: SECURE_WEB_GATEWAY
      ports:
        - 443
      scope: my-default-scope2
      certificateUrls:
        - ${default.id}
      gatewaySecurityPolicy: ${defaultGatewaySecurityPolicy.id}
      network: ${defaultNetwork.id}
      subnetwork: ${defaultSubnetwork.id}
      deleteSwgAutogenRouterOnDestroy: true
    options:
      dependsOn:
        - ${proxyonlysubnet}
```
<!--End PulumiCodeChooser -->

## Import

Gateway can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/gateways/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

When using the `pulumi import` command, Gateway can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkservices/gateway:Gateway default projects/{{project}}/locations/{{location}}/gateways/{{name}}
```

```sh
$ pulumi import gcp:networkservices/gateway:Gateway default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:networkservices/gateway:Gateway default {{location}}/{{name}}
```

î
	addressesB*" ˛Zero or one IPv4-address on which the Gateway will receive the traffic. When no address is provided,
an IP from the subnetwork is allocated This field only applies to gateways of type 'SECURE_WEB_GATEWAY'.
Gateways of type 'OPEN_MESH' listen on 0.0.0.0.
Î
certificateUrlsB*" œA fully-qualified Certificates URL reference. The proxy presents a Certificate (selected based on SNI) when establishing a TLS connection.
This feature only applies to gateways of type 'SECURE_WEB_GATEWAY'.
®
deleteSwgAutogenRouterOnDestroyB
 ˛When deleting a gateway of type 'SECURE_WEB_GATEWAY', this boolean option will also delete auto generated router by the gateway creation.
If there is no other gateway of type 'SECURE_WEB_GATEWAY' remaining for that region and network it will be deleted.
Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
≈
gatewaySecurityPolicyB" •A fully-qualified GatewaySecurityPolicy URL reference. Defines how a server should apply security policy to inbound (VM to Proxy) initiated connections.
For example: `projects/*/locations/*/gatewaySecurityPolicies/swg-policy`.
This policy is specific to gateways of type 'SECURE_WEB_GATEWAY'.
ë
labelsB2" ˛Set of label tags associated with the Gateway resource.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
N
locationB" <The location of the gateway.
The default value is `global`.
H
nameB" :Short name of the Gateway resource to be created.


- - -
Ï
networkB" ⁄The relative resource name identifying the VPC network that is using this configuration.
For example: `projects/*/global/networks/network-1`.
Currently, this field is specific to gateways of type 'SECURE_WEB_GATEWAY'.
è
ports* ˇOne or more port numbers (1-65535), on which the Gateway will receive traffic.
The proxy binds to the specified ports. Gateways of type 'SECURE_WEB_GATEWAY' are
limited to 1 port. Gateways of type 'OPEN_MESH' listen on 0.0.0.0 and support multiple ports.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
Ó
routingModeB" ÿThe routing mode of the Gateway. This field is configurable only for gateways of type SECURE_WEB_GATEWAY. This field is required for gateways of type SECURE_WEB_GATEWAY.
Possible values are: `NEXT_HOP_ROUTING_MODE`.
Í
scopeB" ⁄Immutable. Scope determines how configuration across multiple Gateway instances are merged.
The configuration for multiple Gateway instances with the same scope will be merged as presented as
a single coniguration to the proxy/load balancer.
Max length 64 characters. Scope should start with a letter and can only have letters, numbers, hyphens.
õ
serverTlsPolicyB" ÅA fully-qualified ServerTLSPolicy URL reference. Specifies how TLS traffic is terminated.
If empty, TLS termination is disabled.
˚

subnetworkB" ÊThe relative resource name identifying the subnetwork in which this SWG is allocated.
For example: `projects/*/regions/us-central1/subnetworks/network-1`.
Currently, this field is specific to gateways of type 'SECURE_WEB_GATEWAY.
≈
type" ∏Immutable. The type of the customer-managed gateway. Possible values are: * OPEN_MESH * SECURE_WEB_GATEWAY.
Possible values are: `TYPE_UNSPECIFIED`, `OPEN_MESH`, `SECURE_WEB_GATEWAY`.
"í
	addresses*" ˛Zero or one IPv4-address on which the Gateway will receive the traffic. When no address is provided,
an IP from the subnetwork is allocated This field only applies to gateways of type 'SECURE_WEB_GATEWAY'.
Gateways of type 'OPEN_MESH' listen on 0.0.0.0.
"Î
certificateUrlsB*" œA fully-qualified Certificates URL reference. The proxy presents a Certificate (selected based on SNI) when establishing a TLS connection.
This feature only applies to gateways of type 'SECURE_WEB_GATEWAY'.
"<

createTime" *Time the AccessPolicy was created in UTC.
"®
deleteSwgAutogenRouterOnDestroyB
 ˛When deleting a gateway of type 'SECURE_WEB_GATEWAY', this boolean option will also delete auto generated router by the gateway creation.
If there is no other gateway of type 'SECURE_WEB_GATEWAY' remaining for that region and network it will be deleted.
"Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"≈
gatewaySecurityPolicyB" •A fully-qualified GatewaySecurityPolicy URL reference. Defines how a server should apply security policy to inbound (VM to Proxy) initiated connections.
For example: `projects/*/locations/*/gatewaySecurityPolicies/swg-policy`.
This policy is specific to gateways of type 'SECURE_WEB_GATEWAY'.
"ë
labelsB2" ˛Set of label tags associated with the Gateway resource.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"N
locationB" <The location of the gateway.
The default value is `global`.
"F
name" :Short name of the Gateway resource to be created.


- - -
"Ï
networkB" ⁄The relative resource name identifying the VPC network that is using this configuration.
For example: `projects/*/global/networks/network-1`.
Currently, this field is specific to gateways of type 'SECURE_WEB_GATEWAY'.
"è
ports* ˇOne or more port numbers (1-65535), on which the Gateway will receive traffic.
The proxy binds to the specified ports. Gateways of type 'SECURE_WEB_GATEWAY' are
limited to 1 port. Gateways of type 'OPEN_MESH' listen on 0.0.0.0 and support multiple ports.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"Ó
routingModeB" ÿThe routing mode of the Gateway. This field is configurable only for gateways of type SECURE_WEB_GATEWAY. This field is required for gateways of type SECURE_WEB_GATEWAY.
Possible values are: `NEXT_HOP_ROUTING_MODE`.
"Í
scopeB" ⁄Immutable. Scope determines how configuration across multiple Gateway instances are merged.
The configuration for multiple Gateway instances with the same scope will be merged as presented as
a single coniguration to the proxy/load balancer.
Max length 64 characters. Scope should start with a letter and can only have letters, numbers, hyphens.
"5
selfLink" %Server-defined URL of this resource.
"õ
serverTlsPolicyB" ÅA fully-qualified ServerTLSPolicy URL reference. Specifies how TLS traffic is terminated.
If empty, TLS termination is disabled.
"˚

subnetworkB" ÊThe relative resource name identifying the subnetwork in which this SWG is allocated.
For example: `projects/*/regions/us-central1/subnetworks/network-1`.
Currently, this field is specific to gateways of type 'SECURE_WEB_GATEWAY.
"≈
type" ∏Immutable. The type of the customer-managed gateway. Possible values are: * OPEN_MESH * SECURE_WEB_GATEWAY.
Possible values are: `TYPE_UNSPECIFIED`, `OPEN_MESH`, `SECURE_WEB_GATEWAY`.
"<

updateTime" *Time the AccessPolicy was updated in UTC.
*¢ﬁ
E
networkservices	GrpcRoute'gcp:networkservices/grpcRoute:GrpcRouteó ## Example Usage

### Network Services Grpc Route Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networkservices.GrpcRoute("default", {
    name: "my-grpc-route",
    labels: {
        foo: "bar",
    },
    description: "my description",
    hostnames: ["example"],
    rules: [{
        matches: [{
            headers: [{
                key: "key",
                value: "value",
            }],
        }],
        action: {
            retryPolicy: {
                retryConditions: ["cancelled"],
                numRetries: 1,
            },
        },
    }],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networkservices.GrpcRoute("default",
    name="my-grpc-route",
    labels={
        "foo": "bar",
    },
    description="my description",
    hostnames=["example"],
    rules=[{
        "matches": [{
            "headers": [{
                "key": "key",
                "value": "value",
            }],
        }],
        "action": {
            "retry_policy": {
                "retry_conditions": ["cancelled"],
                "num_retries": 1,
            },
        },
    }])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkServices.GrpcRoute("default", new()
    {
        Name = "my-grpc-route",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        Hostnames = new[]
        {
            "example",
        },
        Rules = new[]
        {
            new Gcp.NetworkServices.Inputs.GrpcRouteRuleArgs
            {
                Matches = new[]
                {
                    new Gcp.NetworkServices.Inputs.GrpcRouteRuleMatchArgs
                    {
                        Headers = new[]
                        {
                            new Gcp.NetworkServices.Inputs.GrpcRouteRuleMatchHeaderArgs
                            {
                                Key = "key",
                                Value = "value",
                            },
                        },
                    },
                },
                Action = new Gcp.NetworkServices.Inputs.GrpcRouteRuleActionArgs
                {
                    RetryPolicy = new Gcp.NetworkServices.Inputs.GrpcRouteRuleActionRetryPolicyArgs
                    {
                        RetryConditions = new[]
                        {
                            "cancelled",
                        },
                        NumRetries = 1,
                    },
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networkservices.NewGrpcRoute(ctx, "default", &networkservices.GrpcRouteArgs{
			Name: pulumi.String("my-grpc-route"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			Hostnames: pulumi.StringArray{
				pulumi.String("example"),
			},
			Rules: networkservices.GrpcRouteRuleArray{
				&networkservices.GrpcRouteRuleArgs{
					Matches: networkservices.GrpcRouteRuleMatchArray{
						&networkservices.GrpcRouteRuleMatchArgs{
							Headers: networkservices.GrpcRouteRuleMatchHeaderArray{
								&networkservices.GrpcRouteRuleMatchHeaderArgs{
									Key:   pulumi.String("key"),
									Value: pulumi.String("value"),
								},
							},
						},
					},
					Action: &networkservices.GrpcRouteRuleActionArgs{
						RetryPolicy: &networkservices.GrpcRouteRuleActionRetryPolicyArgs{
							RetryConditions: pulumi.StringArray{
								pulumi.String("cancelled"),
							},
							NumRetries: pulumi.Int(1),
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networkservices.GrpcRoute;
import com.pulumi.gcp.networkservices.GrpcRouteArgs;
import com.pulumi.gcp.networkservices.inputs.GrpcRouteRuleArgs;
import com.pulumi.gcp.networkservices.inputs.GrpcRouteRuleActionArgs;
import com.pulumi.gcp.networkservices.inputs.GrpcRouteRuleActionRetryPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new GrpcRoute("default", GrpcRouteArgs.builder()
            .name("my-grpc-route")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .hostnames("example")
            .rules(GrpcRouteRuleArgs.builder()
                .matches(GrpcRouteRuleMatchArgs.builder()
                    .headers(GrpcRouteRuleMatchHeaderArgs.builder()
                        .key("key")
                        .value("value")
                        .build())
                    .build())
                .action(GrpcRouteRuleActionArgs.builder()
                    .retryPolicy(GrpcRouteRuleActionRetryPolicyArgs.builder()
                        .retryConditions("cancelled")
                        .numRetries(1)
                        .build())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkservices:GrpcRoute
    properties:
      name: my-grpc-route
      labels:
        foo: bar
      description: my description
      hostnames:
        - example
      rules:
        - matches:
            - headers:
                - key: key
                  value: value
          action:
            retryPolicy:
              retryConditions:
                - cancelled
              numRetries: 1
```
<!--End PulumiCodeChooser -->
### Network Services Grpc Route Matches And Actions


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networkservices.GrpcRoute("default", {
    name: "my-grpc-route",
    labels: {
        foo: "bar",
    },
    description: "my description",
    hostnames: ["example"],
    rules: [{
        matches: [
            {
                headers: [{
                    key: "key",
                    value: "value",
                }],
            },
            {
                headers: [{
                    key: "key",
                    value: "value",
                }],
                method: {
                    grpcService: "foo",
                    grpcMethod: "bar",
                    caseSensitive: true,
                },
            },
        ],
        action: {
            faultInjectionPolicy: {
                delay: {
                    fixedDelay: "1s",
                    percentage: 1,
                },
                abort: {
                    httpStatus: 500,
                    percentage: 1,
                },
            },
            retryPolicy: {
                retryConditions: ["cancelled"],
                numRetries: 1,
            },
        },
    }],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networkservices.GrpcRoute("default",
    name="my-grpc-route",
    labels={
        "foo": "bar",
    },
    description="my description",
    hostnames=["example"],
    rules=[{
        "matches": [
            {
                "headers": [{
                    "key": "key",
                    "value": "value",
                }],
            },
            {
                "headers": [{
                    "key": "key",
                    "value": "value",
                }],
                "method": {
                    "grpc_service": "foo",
                    "grpc_method": "bar",
                    "case_sensitive": True,
                },
            },
        ],
        "action": {
            "fault_injection_policy": {
                "delay": {
                    "fixed_delay": "1s",
                    "percentage": 1,
                },
                "abort": {
                    "http_status": 500,
                    "percentage": 1,
                },
            },
            "retry_policy": {
                "retry_conditions": ["cancelled"],
                "num_retries": 1,
            },
        },
    }])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkServices.GrpcRoute("default", new()
    {
        Name = "my-grpc-route",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        Hostnames = new[]
        {
            "example",
        },
        Rules = new[]
        {
            new Gcp.NetworkServices.Inputs.GrpcRouteRuleArgs
            {
                Matches = new[]
                {
                    new Gcp.NetworkServices.Inputs.GrpcRouteRuleMatchArgs
                    {
                        Headers = new[]
                        {
                            new Gcp.NetworkServices.Inputs.GrpcRouteRuleMatchHeaderArgs
                            {
                                Key = "key",
                                Value = "value",
                            },
                        },
                    },
                    new Gcp.NetworkServices.Inputs.GrpcRouteRuleMatchArgs
                    {
                        Headers = new[]
                        {
                            new Gcp.NetworkServices.Inputs.GrpcRouteRuleMatchHeaderArgs
                            {
                                Key = "key",
                                Value = "value",
                            },
                        },
                        Method = new Gcp.NetworkServices.Inputs.GrpcRouteRuleMatchMethodArgs
                        {
                            GrpcService = "foo",
                            GrpcMethod = "bar",
                            CaseSensitive = true,
                        },
                    },
                },
                Action = new Gcp.NetworkServices.Inputs.GrpcRouteRuleActionArgs
                {
                    FaultInjectionPolicy = new Gcp.NetworkServices.Inputs.GrpcRouteRuleActionFaultInjectionPolicyArgs
                    {
                        Delay = new Gcp.NetworkServices.Inputs.GrpcRouteRuleActionFaultInjectionPolicyDelayArgs
                        {
                            FixedDelay = "1s",
                            Percentage = 1,
                        },
                        Abort = new Gcp.NetworkServices.Inputs.GrpcRouteRuleActionFaultInjectionPolicyAbortArgs
                        {
                            HttpStatus = 500,
                            Percentage = 1,
                        },
                    },
                    RetryPolicy = new Gcp.NetworkServices.Inputs.GrpcRouteRuleActionRetryPolicyArgs
                    {
                        RetryConditions = new[]
                        {
                            "cancelled",
                        },
                        NumRetries = 1,
                    },
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networkservices.NewGrpcRoute(ctx, "default", &networkservices.GrpcRouteArgs{
			Name: pulumi.String("my-grpc-route"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			Hostnames: pulumi.StringArray{
				pulumi.String("example"),
			},
			Rules: networkservices.GrpcRouteRuleArray{
				&networkservices.GrpcRouteRuleArgs{
					Matches: networkservices.GrpcRouteRuleMatchArray{
						&networkservices.GrpcRouteRuleMatchArgs{
							Headers: networkservices.GrpcRouteRuleMatchHeaderArray{
								&networkservices.GrpcRouteRuleMatchHeaderArgs{
									Key:   pulumi.String("key"),
									Value: pulumi.String("value"),
								},
							},
						},
						&networkservices.GrpcRouteRuleMatchArgs{
							Headers: networkservices.GrpcRouteRuleMatchHeaderArray{
								&networkservices.GrpcRouteRuleMatchHeaderArgs{
									Key:   pulumi.String("key"),
									Value: pulumi.String("value"),
								},
							},
							Method: &networkservices.GrpcRouteRuleMatchMethodArgs{
								GrpcService:   pulumi.String("foo"),
								GrpcMethod:    pulumi.String("bar"),
								CaseSensitive: pulumi.Bool(true),
							},
						},
					},
					Action: &networkservices.GrpcRouteRuleActionArgs{
						FaultInjectionPolicy: &networkservices.GrpcRouteRuleActionFaultInjectionPolicyArgs{
							Delay: &networkservices.GrpcRouteRuleActionFaultInjectionPolicyDelayArgs{
								FixedDelay: pulumi.String("1s"),
								Percentage: pulumi.Int(1),
							},
							Abort: &networkservices.GrpcRouteRuleActionFaultInjectionPolicyAbortArgs{
								HttpStatus: pulumi.Int(500),
								Percentage: pulumi.Int(1),
							},
						},
						RetryPolicy: &networkservices.GrpcRouteRuleActionRetryPolicyArgs{
							RetryConditions: pulumi.StringArray{
								pulumi.String("cancelled"),
							},
							NumRetries: pulumi.Int(1),
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networkservices.GrpcRoute;
import com.pulumi.gcp.networkservices.GrpcRouteArgs;
import com.pulumi.gcp.networkservices.inputs.GrpcRouteRuleArgs;
import com.pulumi.gcp.networkservices.inputs.GrpcRouteRuleActionArgs;
import com.pulumi.gcp.networkservices.inputs.GrpcRouteRuleActionFaultInjectionPolicyArgs;
import com.pulumi.gcp.networkservices.inputs.GrpcRouteRuleActionFaultInjectionPolicyDelayArgs;
import com.pulumi.gcp.networkservices.inputs.GrpcRouteRuleActionFaultInjectionPolicyAbortArgs;
import com.pulumi.gcp.networkservices.inputs.GrpcRouteRuleActionRetryPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new GrpcRoute("default", GrpcRouteArgs.builder()
            .name("my-grpc-route")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .hostnames("example")
            .rules(GrpcRouteRuleArgs.builder()
                .matches(                
                    GrpcRouteRuleMatchArgs.builder()
                        .headers(GrpcRouteRuleMatchHeaderArgs.builder()
                            .key("key")
                            .value("value")
                            .build())
                        .build(),
                    GrpcRouteRuleMatchArgs.builder()
                        .headers(GrpcRouteRuleMatchHeaderArgs.builder()
                            .key("key")
                            .value("value")
                            .build())
                        .method(GrpcRouteRuleMatchMethodArgs.builder()
                            .grpcService("foo")
                            .grpcMethod("bar")
                            .caseSensitive(true)
                            .build())
                        .build())
                .action(GrpcRouteRuleActionArgs.builder()
                    .faultInjectionPolicy(GrpcRouteRuleActionFaultInjectionPolicyArgs.builder()
                        .delay(GrpcRouteRuleActionFaultInjectionPolicyDelayArgs.builder()
                            .fixedDelay("1s")
                            .percentage(1)
                            .build())
                        .abort(GrpcRouteRuleActionFaultInjectionPolicyAbortArgs.builder()
                            .httpStatus(500)
                            .percentage(1)
                            .build())
                        .build())
                    .retryPolicy(GrpcRouteRuleActionRetryPolicyArgs.builder()
                        .retryConditions("cancelled")
                        .numRetries(1)
                        .build())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkservices:GrpcRoute
    properties:
      name: my-grpc-route
      labels:
        foo: bar
      description: my description
      hostnames:
        - example
      rules:
        - matches:
            - headers:
                - key: key
                  value: value
            - headers:
                - key: key
                  value: value
              method:
                grpcService: foo
                grpcMethod: bar
                caseSensitive: true
          action:
            faultInjectionPolicy:
              delay:
                fixedDelay: 1s
                percentage: 1
              abort:
                httpStatus: 500
                percentage: 1
            retryPolicy:
              retryConditions:
                - cancelled
              numRetries: 1
```
<!--End PulumiCodeChooser -->
### Network Services Grpc Route Actions


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networkservices.GrpcRoute("default", {
    name: "my-grpc-route",
    labels: {
        foo: "bar",
    },
    description: "my description",
    hostnames: ["example"],
    rules: [{
        action: {
            faultInjectionPolicy: {
                delay: {
                    fixedDelay: "1s",
                    percentage: 1,
                },
                abort: {
                    httpStatus: 500,
                    percentage: 1,
                },
            },
            retryPolicy: {
                retryConditions: ["cancelled"],
                numRetries: 1,
            },
        },
    }],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networkservices.GrpcRoute("default",
    name="my-grpc-route",
    labels={
        "foo": "bar",
    },
    description="my description",
    hostnames=["example"],
    rules=[{
        "action": {
            "fault_injection_policy": {
                "delay": {
                    "fixed_delay": "1s",
                    "percentage": 1,
                },
                "abort": {
                    "http_status": 500,
                    "percentage": 1,
                },
            },
            "retry_policy": {
                "retry_conditions": ["cancelled"],
                "num_retries": 1,
            },
        },
    }])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkServices.GrpcRoute("default", new()
    {
        Name = "my-grpc-route",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        Hostnames = new[]
        {
            "example",
        },
        Rules = new[]
        {
            new Gcp.NetworkServices.Inputs.GrpcRouteRuleArgs
            {
                Action = new Gcp.NetworkServices.Inputs.GrpcRouteRuleActionArgs
                {
                    FaultInjectionPolicy = new Gcp.NetworkServices.Inputs.GrpcRouteRuleActionFaultInjectionPolicyArgs
                    {
                        Delay = new Gcp.NetworkServices.Inputs.GrpcRouteRuleActionFaultInjectionPolicyDelayArgs
                        {
                            FixedDelay = "1s",
                            Percentage = 1,
                        },
                        Abort = new Gcp.NetworkServices.Inputs.GrpcRouteRuleActionFaultInjectionPolicyAbortArgs
                        {
                            HttpStatus = 500,
                            Percentage = 1,
                        },
                    },
                    RetryPolicy = new Gcp.NetworkServices.Inputs.GrpcRouteRuleActionRetryPolicyArgs
                    {
                        RetryConditions = new[]
                        {
                            "cancelled",
                        },
                        NumRetries = 1,
                    },
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networkservices.NewGrpcRoute(ctx, "default", &networkservices.GrpcRouteArgs{
			Name: pulumi.String("my-grpc-route"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			Hostnames: pulumi.StringArray{
				pulumi.String("example"),
			},
			Rules: networkservices.GrpcRouteRuleArray{
				&networkservices.GrpcRouteRuleArgs{
					Action: &networkservices.GrpcRouteRuleActionArgs{
						FaultInjectionPolicy: &networkservices.GrpcRouteRuleActionFaultInjectionPolicyArgs{
							Delay: &networkservices.GrpcRouteRuleActionFaultInjectionPolicyDelayArgs{
								FixedDelay: pulumi.String("1s"),
								Percentage: pulumi.Int(1),
							},
							Abort: &networkservices.GrpcRouteRuleActionFaultInjectionPolicyAbortArgs{
								HttpStatus: pulumi.Int(500),
								Percentage: pulumi.Int(1),
							},
						},
						RetryPolicy: &networkservices.GrpcRouteRuleActionRetryPolicyArgs{
							RetryConditions: pulumi.StringArray{
								pulumi.String("cancelled"),
							},
							NumRetries: pulumi.Int(1),
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networkservices.GrpcRoute;
import com.pulumi.gcp.networkservices.GrpcRouteArgs;
import com.pulumi.gcp.networkservices.inputs.GrpcRouteRuleArgs;
import com.pulumi.gcp.networkservices.inputs.GrpcRouteRuleActionArgs;
import com.pulumi.gcp.networkservices.inputs.GrpcRouteRuleActionFaultInjectionPolicyArgs;
import com.pulumi.gcp.networkservices.inputs.GrpcRouteRuleActionFaultInjectionPolicyDelayArgs;
import com.pulumi.gcp.networkservices.inputs.GrpcRouteRuleActionFaultInjectionPolicyAbortArgs;
import com.pulumi.gcp.networkservices.inputs.GrpcRouteRuleActionRetryPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new GrpcRoute("default", GrpcRouteArgs.builder()
            .name("my-grpc-route")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .hostnames("example")
            .rules(GrpcRouteRuleArgs.builder()
                .action(GrpcRouteRuleActionArgs.builder()
                    .faultInjectionPolicy(GrpcRouteRuleActionFaultInjectionPolicyArgs.builder()
                        .delay(GrpcRouteRuleActionFaultInjectionPolicyDelayArgs.builder()
                            .fixedDelay("1s")
                            .percentage(1)
                            .build())
                        .abort(GrpcRouteRuleActionFaultInjectionPolicyAbortArgs.builder()
                            .httpStatus(500)
                            .percentage(1)
                            .build())
                        .build())
                    .retryPolicy(GrpcRouteRuleActionRetryPolicyArgs.builder()
                        .retryConditions("cancelled")
                        .numRetries(1)
                        .build())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkservices:GrpcRoute
    properties:
      name: my-grpc-route
      labels:
        foo: bar
      description: my description
      hostnames:
        - example
      rules:
        - action:
            faultInjectionPolicy:
              delay:
                fixedDelay: 1s
                percentage: 1
              abort:
                httpStatus: 500
                percentage: 1
            retryPolicy:
              retryConditions:
                - cancelled
              numRetries: 1
```
<!--End PulumiCodeChooser -->

## Import

GrpcRoute can be imported using any of these accepted formats:

* `projects/{{project}}/locations/global/grpcRoutes/{{name}}`

* `{{project}}/{{name}}`

* `{{name}}`

When using the `pulumi import` command, GrpcRoute can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkservices/grpcRoute:GrpcRoute default projects/{{project}}/locations/global/grpcRoutes/{{name}}
```

```sh
$ pulumi import gcp:networkservices/grpcRoute:GrpcRoute default {{project}}/{{name}}
```

```sh
$ pulumi import gcp:networkservices/grpcRoute:GrpcRoute default {{name}}
```

Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
ç
gatewaysB*" yList of gateways this GrpcRoute is attached to, as one of the routing rules to route the requests served by the gateway.
m
	hostnames*" ZRequired. Service hostnames with an optional port for which this route describes traffic.
ì
labelsB2" ÄSet of label tags associated with the GrpcRoute resource. **Note**: This field is non-authoritative, and will only
manage the labels present in your configuration. Please refer to the field 'effective_labels' for all of the labels
present on the resource.
Ü
meshesB*" tList of meshes this GrpcRoute is attached to, as one of the routing rules to route the requests served by the mesh.
.
nameB"  Name of the GrpcRoute resource.

projectB" ∂
rulesW*U:S
Q
networkservicesGrpcRouteRule/gcp:networkservices/GrpcRouteRule:GrpcRouteRuleTRules that define how traffic is routed and handled.
Structure is documented below.
"9

createTime" 'Time the GrpcRoute was created in UTC.
"Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"ç
gatewaysB*" yList of gateways this GrpcRoute is attached to, as one of the routing rules to route the requests served by the gateway.
"m
	hostnames*" ZRequired. Service hostnames with an optional port for which this route describes traffic.
"ì
labelsB2" ÄSet of label tags associated with the GrpcRoute resource. **Note**: This field is non-authoritative, and will only
manage the labels present in your configuration. Please refer to the field 'effective_labels' for all of the labels
present on the resource.
"Ü
meshesB*" tList of meshes this GrpcRoute is attached to, as one of the routing rules to route the requests served by the mesh.
",
name"  Name of the GrpcRoute resource.
"
project" "É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"∂
rulesW*U:S
Q
networkservicesGrpcRouteRule/gcp:networkservices/GrpcRouteRule:GrpcRouteRuleTRules that define how traffic is routed and handled.
Structure is documented below.
"5
selfLink" %Server-defined URL of this resource.
"9

updateTime" 'Time the GrpcRoute was updated in UTC.
*˜…
E
networkservices	HttpRoute'gcp:networkservices/httpRoute:HttpRouteú±## Example Usage

### Network Services Http Route Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networkservices.HttpRoute("default", {
    name: "my-http-route",
    labels: {
        foo: "bar",
    },
    description: "my description",
    hostnames: ["example"],
    rules: [{
        matches: [{
            queryParameters: [{
                queryParameter: "key",
                exactMatch: "value",
            }],
            fullPathMatch: "example",
        }],
    }],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networkservices.HttpRoute("default",
    name="my-http-route",
    labels={
        "foo": "bar",
    },
    description="my description",
    hostnames=["example"],
    rules=[{
        "matches": [{
            "query_parameters": [{
                "query_parameter": "key",
                "exact_match": "value",
            }],
            "full_path_match": "example",
        }],
    }])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkServices.HttpRoute("default", new()
    {
        Name = "my-http-route",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        Hostnames = new[]
        {
            "example",
        },
        Rules = new[]
        {
            new Gcp.NetworkServices.Inputs.HttpRouteRuleArgs
            {
                Matches = new[]
                {
                    new Gcp.NetworkServices.Inputs.HttpRouteRuleMatchArgs
                    {
                        QueryParameters = new[]
                        {
                            new Gcp.NetworkServices.Inputs.HttpRouteRuleMatchQueryParameterArgs
                            {
                                QueryParameter = "key",
                                ExactMatch = "value",
                            },
                        },
                        FullPathMatch = "example",
                    },
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networkservices.NewHttpRoute(ctx, "default", &networkservices.HttpRouteArgs{
			Name: pulumi.String("my-http-route"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			Hostnames: pulumi.StringArray{
				pulumi.String("example"),
			},
			Rules: networkservices.HttpRouteRuleArray{
				&networkservices.HttpRouteRuleArgs{
					Matches: networkservices.HttpRouteRuleMatchArray{
						&networkservices.HttpRouteRuleMatchArgs{
							QueryParameters: networkservices.HttpRouteRuleMatchQueryParameterArray{
								&networkservices.HttpRouteRuleMatchQueryParameterArgs{
									QueryParameter: pulumi.String("key"),
									ExactMatch:     pulumi.String("value"),
								},
							},
							FullPathMatch: pulumi.String("example"),
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networkservices.HttpRoute;
import com.pulumi.gcp.networkservices.HttpRouteArgs;
import com.pulumi.gcp.networkservices.inputs.HttpRouteRuleArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new HttpRoute("default", HttpRouteArgs.builder()
            .name("my-http-route")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .hostnames("example")
            .rules(HttpRouteRuleArgs.builder()
                .matches(HttpRouteRuleMatchArgs.builder()
                    .queryParameters(HttpRouteRuleMatchQueryParameterArgs.builder()
                        .queryParameter("key")
                        .exactMatch("value")
                        .build())
                    .fullPathMatch("example")
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkservices:HttpRoute
    properties:
      name: my-http-route
      labels:
        foo: bar
      description: my description
      hostnames:
        - example
      rules:
        - matches:
            - queryParameters:
                - queryParameter: key
                  exactMatch: value
              fullPathMatch: example
```
<!--End PulumiCodeChooser -->
### Network Services Http Route Matches And Actions


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networkservices.HttpRoute("default", {
    name: "my-http-route",
    labels: {
        foo: "bar",
    },
    description: "my description",
    hostnames: ["example"],
    rules: [{
        matches: [
            {
                headers: [{
                    header: "header",
                    invertMatch: false,
                    regexMatch: "header-value",
                }],
                queryParameters: [{
                    queryParameter: "key",
                    exactMatch: "value",
                }],
                prefixMatch: "example",
                ignoreCase: false,
            },
            {
                headers: [{
                    header: "header",
                    invertMatch: false,
                    presentMatch: true,
                }],
                queryParameters: [{
                    queryParameter: "key",
                    regexMatch: "value",
                }],
                regexMatch: "example",
                ignoreCase: false,
            },
            {
                headers: [{
                    header: "header",
                    invertMatch: false,
                    presentMatch: true,
                }],
                queryParameters: [{
                    queryParameter: "key",
                    presentMatch: true,
                }],
                fullPathMatch: "example",
                ignoreCase: false,
            },
        ],
        action: {
            redirect: {
                hostRedirect: "new-host",
                pathRedirect: "new-path",
                prefixRewrite: "new-prefix",
                httpsRedirect: true,
                stripQuery: true,
                portRedirect: 8081,
            },
            urlRewrite: {
                pathPrefixRewrite: "new-prefix",
                hostRewrite: "new-host",
            },
            retryPolicy: {
                retryConditions: ["server_error"],
                numRetries: 1,
                perTryTimeout: "1s",
            },
            requestMirrorPolicy: {
                destination: {
                    serviceName: "new",
                    weight: 1,
                },
            },
            corsPolicy: {
                allowOrigins: ["example"],
                allowMethods: [
                    "GET",
                    "PUT",
                ],
                allowHeaders: [
                    "version",
                    "type",
                ],
                exposeHeaders: [
                    "version",
                    "type",
                ],
                maxAge: "1s",
                allowCredentials: true,
                disabled: false,
            },
        },
    }],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networkservices.HttpRoute("default",
    name="my-http-route",
    labels={
        "foo": "bar",
    },
    description="my description",
    hostnames=["example"],
    rules=[{
        "matches": [
            {
                "headers": [{
                    "header": "header",
                    "invert_match": False,
                    "regex_match": "header-value",
                }],
                "query_parameters": [{
                    "query_parameter": "key",
                    "exact_match": "value",
                }],
                "prefix_match": "example",
                "ignore_case": False,
            },
            {
                "headers": [{
                    "header": "header",
                    "invert_match": False,
                    "present_match": True,
                }],
                "query_parameters": [{
                    "query_parameter": "key",
                    "regex_match": "value",
                }],
                "regex_match": "example",
                "ignore_case": False,
            },
            {
                "headers": [{
                    "header": "header",
                    "invert_match": False,
                    "present_match": True,
                }],
                "query_parameters": [{
                    "query_parameter": "key",
                    "present_match": True,
                }],
                "full_path_match": "example",
                "ignore_case": False,
            },
        ],
        "action": {
            "redirect": {
                "host_redirect": "new-host",
                "path_redirect": "new-path",
                "prefix_rewrite": "new-prefix",
                "https_redirect": True,
                "strip_query": True,
                "port_redirect": 8081,
            },
            "url_rewrite": {
                "path_prefix_rewrite": "new-prefix",
                "host_rewrite": "new-host",
            },
            "retry_policy": {
                "retry_conditions": ["server_error"],
                "num_retries": 1,
                "per_try_timeout": "1s",
            },
            "request_mirror_policy": {
                "destination": {
                    "service_name": "new",
                    "weight": 1,
                },
            },
            "cors_policy": {
                "allow_origins": ["example"],
                "allow_methods": [
                    "GET",
                    "PUT",
                ],
                "allow_headers": [
                    "version",
                    "type",
                ],
                "expose_headers": [
                    "version",
                    "type",
                ],
                "max_age": "1s",
                "allow_credentials": True,
                "disabled": False,
            },
        },
    }])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkServices.HttpRoute("default", new()
    {
        Name = "my-http-route",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        Hostnames = new[]
        {
            "example",
        },
        Rules = new[]
        {
            new Gcp.NetworkServices.Inputs.HttpRouteRuleArgs
            {
                Matches = new[]
                {
                    new Gcp.NetworkServices.Inputs.HttpRouteRuleMatchArgs
                    {
                        Headers = new[]
                        {
                            new Gcp.NetworkServices.Inputs.HttpRouteRuleMatchHeaderArgs
                            {
                                Header = "header",
                                InvertMatch = false,
                                RegexMatch = "header-value",
                            },
                        },
                        QueryParameters = new[]
                        {
                            new Gcp.NetworkServices.Inputs.HttpRouteRuleMatchQueryParameterArgs
                            {
                                QueryParameter = "key",
                                ExactMatch = "value",
                            },
                        },
                        PrefixMatch = "example",
                        IgnoreCase = false,
                    },
                    new Gcp.NetworkServices.Inputs.HttpRouteRuleMatchArgs
                    {
                        Headers = new[]
                        {
                            new Gcp.NetworkServices.Inputs.HttpRouteRuleMatchHeaderArgs
                            {
                                Header = "header",
                                InvertMatch = false,
                                PresentMatch = true,
                            },
                        },
                        QueryParameters = new[]
                        {
                            new Gcp.NetworkServices.Inputs.HttpRouteRuleMatchQueryParameterArgs
                            {
                                QueryParameter = "key",
                                RegexMatch = "value",
                            },
                        },
                        RegexMatch = "example",
                        IgnoreCase = false,
                    },
                    new Gcp.NetworkServices.Inputs.HttpRouteRuleMatchArgs
                    {
                        Headers = new[]
                        {
                            new Gcp.NetworkServices.Inputs.HttpRouteRuleMatchHeaderArgs
                            {
                                Header = "header",
                                InvertMatch = false,
                                PresentMatch = true,
                            },
                        },
                        QueryParameters = new[]
                        {
                            new Gcp.NetworkServices.Inputs.HttpRouteRuleMatchQueryParameterArgs
                            {
                                QueryParameter = "key",
                                PresentMatch = true,
                            },
                        },
                        FullPathMatch = "example",
                        IgnoreCase = false,
                    },
                },
                Action = new Gcp.NetworkServices.Inputs.HttpRouteRuleActionArgs
                {
                    Redirect = new Gcp.NetworkServices.Inputs.HttpRouteRuleActionRedirectArgs
                    {
                        HostRedirect = "new-host",
                        PathRedirect = "new-path",
                        PrefixRewrite = "new-prefix",
                        HttpsRedirect = true,
                        StripQuery = true,
                        PortRedirect = 8081,
                    },
                    UrlRewrite = new Gcp.NetworkServices.Inputs.HttpRouteRuleActionUrlRewriteArgs
                    {
                        PathPrefixRewrite = "new-prefix",
                        HostRewrite = "new-host",
                    },
                    RetryPolicy = new Gcp.NetworkServices.Inputs.HttpRouteRuleActionRetryPolicyArgs
                    {
                        RetryConditions = new[]
                        {
                            "server_error",
                        },
                        NumRetries = 1,
                        PerTryTimeout = "1s",
                    },
                    RequestMirrorPolicy = new Gcp.NetworkServices.Inputs.HttpRouteRuleActionRequestMirrorPolicyArgs
                    {
                        Destination = new Gcp.NetworkServices.Inputs.HttpRouteRuleActionRequestMirrorPolicyDestinationArgs
                        {
                            ServiceName = "new",
                            Weight = 1,
                        },
                    },
                    CorsPolicy = new Gcp.NetworkServices.Inputs.HttpRouteRuleActionCorsPolicyArgs
                    {
                        AllowOrigins = new[]
                        {
                            "example",
                        },
                        AllowMethods = new[]
                        {
                            "GET",
                            "PUT",
                        },
                        AllowHeaders = new[]
                        {
                            "version",
                            "type",
                        },
                        ExposeHeaders = new[]
                        {
                            "version",
                            "type",
                        },
                        MaxAge = "1s",
                        AllowCredentials = true,
                        Disabled = false,
                    },
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networkservices.NewHttpRoute(ctx, "default", &networkservices.HttpRouteArgs{
			Name: pulumi.String("my-http-route"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			Hostnames: pulumi.StringArray{
				pulumi.String("example"),
			},
			Rules: networkservices.HttpRouteRuleArray{
				&networkservices.HttpRouteRuleArgs{
					Matches: networkservices.HttpRouteRuleMatchArray{
						&networkservices.HttpRouteRuleMatchArgs{
							Headers: networkservices.HttpRouteRuleMatchHeaderArray{
								&networkservices.HttpRouteRuleMatchHeaderArgs{
									Header:      pulumi.String("header"),
									InvertMatch: pulumi.Bool(false),
									RegexMatch:  pulumi.String("header-value"),
								},
							},
							QueryParameters: networkservices.HttpRouteRuleMatchQueryParameterArray{
								&networkservices.HttpRouteRuleMatchQueryParameterArgs{
									QueryParameter: pulumi.String("key"),
									ExactMatch:     pulumi.String("value"),
								},
							},
							PrefixMatch: pulumi.String("example"),
							IgnoreCase:  pulumi.Bool(false),
						},
						&networkservices.HttpRouteRuleMatchArgs{
							Headers: networkservices.HttpRouteRuleMatchHeaderArray{
								&networkservices.HttpRouteRuleMatchHeaderArgs{
									Header:       pulumi.String("header"),
									InvertMatch:  pulumi.Bool(false),
									PresentMatch: pulumi.Bool(true),
								},
							},
							QueryParameters: networkservices.HttpRouteRuleMatchQueryParameterArray{
								&networkservices.HttpRouteRuleMatchQueryParameterArgs{
									QueryParameter: pulumi.String("key"),
									RegexMatch:     pulumi.String("value"),
								},
							},
							RegexMatch: pulumi.String("example"),
							IgnoreCase: pulumi.Bool(false),
						},
						&networkservices.HttpRouteRuleMatchArgs{
							Headers: networkservices.HttpRouteRuleMatchHeaderArray{
								&networkservices.HttpRouteRuleMatchHeaderArgs{
									Header:       pulumi.String("header"),
									InvertMatch:  pulumi.Bool(false),
									PresentMatch: pulumi.Bool(true),
								},
							},
							QueryParameters: networkservices.HttpRouteRuleMatchQueryParameterArray{
								&networkservices.HttpRouteRuleMatchQueryParameterArgs{
									QueryParameter: pulumi.String("key"),
									PresentMatch:   pulumi.Bool(true),
								},
							},
							FullPathMatch: pulumi.String("example"),
							IgnoreCase:    pulumi.Bool(false),
						},
					},
					Action: &networkservices.HttpRouteRuleActionArgs{
						Redirect: &networkservices.HttpRouteRuleActionRedirectArgs{
							HostRedirect:  pulumi.String("new-host"),
							PathRedirect:  pulumi.String("new-path"),
							PrefixRewrite: pulumi.String("new-prefix"),
							HttpsRedirect: pulumi.Bool(true),
							StripQuery:    pulumi.Bool(true),
							PortRedirect:  pulumi.Int(8081),
						},
						UrlRewrite: &networkservices.HttpRouteRuleActionUrlRewriteArgs{
							PathPrefixRewrite: pulumi.String("new-prefix"),
							HostRewrite:       pulumi.String("new-host"),
						},
						RetryPolicy: &networkservices.HttpRouteRuleActionRetryPolicyArgs{
							RetryConditions: pulumi.StringArray{
								pulumi.String("server_error"),
							},
							NumRetries:    pulumi.Int(1),
							PerTryTimeout: pulumi.String("1s"),
						},
						RequestMirrorPolicy: &networkservices.HttpRouteRuleActionRequestMirrorPolicyArgs{
							Destination: &networkservices.HttpRouteRuleActionRequestMirrorPolicyDestinationArgs{
								ServiceName: pulumi.String("new"),
								Weight:      pulumi.Int(1),
							},
						},
						CorsPolicy: &networkservices.HttpRouteRuleActionCorsPolicyArgs{
							AllowOrigins: pulumi.StringArray{
								pulumi.String("example"),
							},
							AllowMethods: pulumi.StringArray{
								pulumi.String("GET"),
								pulumi.String("PUT"),
							},
							AllowHeaders: pulumi.StringArray{
								pulumi.String("version"),
								pulumi.String("type"),
							},
							ExposeHeaders: pulumi.StringArray{
								pulumi.String("version"),
								pulumi.String("type"),
							},
							MaxAge:           pulumi.String("1s"),
							AllowCredentials: pulumi.Bool(true),
							Disabled:         pulumi.Bool(false),
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networkservices.HttpRoute;
import com.pulumi.gcp.networkservices.HttpRouteArgs;
import com.pulumi.gcp.networkservices.inputs.HttpRouteRuleArgs;
import com.pulumi.gcp.networkservices.inputs.HttpRouteRuleActionArgs;
import com.pulumi.gcp.networkservices.inputs.HttpRouteRuleActionRedirectArgs;
import com.pulumi.gcp.networkservices.inputs.HttpRouteRuleActionUrlRewriteArgs;
import com.pulumi.gcp.networkservices.inputs.HttpRouteRuleActionRetryPolicyArgs;
import com.pulumi.gcp.networkservices.inputs.HttpRouteRuleActionRequestMirrorPolicyArgs;
import com.pulumi.gcp.networkservices.inputs.HttpRouteRuleActionRequestMirrorPolicyDestinationArgs;
import com.pulumi.gcp.networkservices.inputs.HttpRouteRuleActionCorsPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new HttpRoute("default", HttpRouteArgs.builder()
            .name("my-http-route")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .hostnames("example")
            .rules(HttpRouteRuleArgs.builder()
                .matches(                
                    HttpRouteRuleMatchArgs.builder()
                        .headers(HttpRouteRuleMatchHeaderArgs.builder()
                            .header("header")
                            .invertMatch(false)
                            .regexMatch("header-value")
                            .build())
                        .queryParameters(HttpRouteRuleMatchQueryParameterArgs.builder()
                            .queryParameter("key")
                            .exactMatch("value")
                            .build())
                        .prefixMatch("example")
                        .ignoreCase(false)
                        .build(),
                    HttpRouteRuleMatchArgs.builder()
                        .headers(HttpRouteRuleMatchHeaderArgs.builder()
                            .header("header")
                            .invertMatch(false)
                            .presentMatch(true)
                            .build())
                        .queryParameters(HttpRouteRuleMatchQueryParameterArgs.builder()
                            .queryParameter("key")
                            .regexMatch("value")
                            .build())
                        .regexMatch("example")
                        .ignoreCase(false)
                        .build(),
                    HttpRouteRuleMatchArgs.builder()
                        .headers(HttpRouteRuleMatchHeaderArgs.builder()
                            .header("header")
                            .invertMatch(false)
                            .presentMatch(true)
                            .build())
                        .queryParameters(HttpRouteRuleMatchQueryParameterArgs.builder()
                            .queryParameter("key")
                            .presentMatch(true)
                            .build())
                        .fullPathMatch("example")
                        .ignoreCase(false)
                        .build())
                .action(HttpRouteRuleActionArgs.builder()
                    .redirect(HttpRouteRuleActionRedirectArgs.builder()
                        .hostRedirect("new-host")
                        .pathRedirect("new-path")
                        .prefixRewrite("new-prefix")
                        .httpsRedirect(true)
                        .stripQuery(true)
                        .portRedirect(8081)
                        .build())
                    .urlRewrite(HttpRouteRuleActionUrlRewriteArgs.builder()
                        .pathPrefixRewrite("new-prefix")
                        .hostRewrite("new-host")
                        .build())
                    .retryPolicy(HttpRouteRuleActionRetryPolicyArgs.builder()
                        .retryConditions("server_error")
                        .numRetries(1)
                        .perTryTimeout("1s")
                        .build())
                    .requestMirrorPolicy(HttpRouteRuleActionRequestMirrorPolicyArgs.builder()
                        .destination(HttpRouteRuleActionRequestMirrorPolicyDestinationArgs.builder()
                            .serviceName("new")
                            .weight(1)
                            .build())
                        .build())
                    .corsPolicy(HttpRouteRuleActionCorsPolicyArgs.builder()
                        .allowOrigins("example")
                        .allowMethods(                        
                            "GET",
                            "PUT")
                        .allowHeaders(                        
                            "version",
                            "type")
                        .exposeHeaders(                        
                            "version",
                            "type")
                        .maxAge("1s")
                        .allowCredentials(true)
                        .disabled(false)
                        .build())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkservices:HttpRoute
    properties:
      name: my-http-route
      labels:
        foo: bar
      description: my description
      hostnames:
        - example
      rules:
        - matches:
            - headers:
                - header: header
                  invertMatch: false
                  regexMatch: header-value
              queryParameters:
                - queryParameter: key
                  exactMatch: value
              prefixMatch: example
              ignoreCase: false
            - headers:
                - header: header
                  invertMatch: false
                  presentMatch: true
              queryParameters:
                - queryParameter: key
                  regexMatch: value
              regexMatch: example
              ignoreCase: false
            - headers:
                - header: header
                  invertMatch: false
                  presentMatch: true
              queryParameters:
                - queryParameter: key
                  presentMatch: true
              fullPathMatch: example
              ignoreCase: false
          action:
            redirect:
              hostRedirect: new-host
              pathRedirect: new-path
              prefixRewrite: new-prefix
              httpsRedirect: true
              stripQuery: true
              portRedirect: 8081
            urlRewrite:
              pathPrefixRewrite: new-prefix
              hostRewrite: new-host
            retryPolicy:
              retryConditions:
                - server_error
              numRetries: 1
              perTryTimeout: 1s
            requestMirrorPolicy:
              destination:
                serviceName: new
                weight: 1
            corsPolicy:
              allowOrigins:
                - example
              allowMethods:
                - GET
                - PUT
              allowHeaders:
                - version
                - type
              exposeHeaders:
                - version
                - type
              maxAge: 1s
              allowCredentials: true
              disabled: false
```
<!--End PulumiCodeChooser -->
### Network Services Http Route Actions


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networkservices.HttpRoute("default", {
    name: "my-http-route",
    labels: {
        foo: "bar",
    },
    description: "my description",
    hostnames: ["example"],
    rules: [{
        action: {
            faultInjectionPolicy: {
                delay: {
                    fixedDelay: "1s",
                    percentage: 1,
                },
                abort: {
                    httpStatus: 500,
                    percentage: 1,
                },
            },
            urlRewrite: {
                pathPrefixRewrite: "new-prefix",
                hostRewrite: "new-host",
            },
            retryPolicy: {
                retryConditions: ["server_error"],
                numRetries: 1,
                perTryTimeout: "1s",
            },
            requestMirrorPolicy: {
                destination: {
                    serviceName: "new",
                    weight: 1,
                },
            },
            corsPolicy: {
                allowOrigins: ["example"],
                allowMethods: [
                    "GET",
                    "PUT",
                ],
                allowHeaders: [
                    "version",
                    "type",
                ],
                exposeHeaders: [
                    "version",
                    "type",
                ],
                maxAge: "1s",
                allowCredentials: true,
                disabled: false,
            },
            requestHeaderModifier: {
                set: {
                    version: "1",
                    type: "json",
                },
                add: {
                    "minor-version": "1",
                },
                removes: ["arg"],
            },
            responseHeaderModifier: {
                set: {
                    version: "1",
                    type: "json",
                },
                add: {
                    "minor-version": "1",
                },
                removes: ["removearg"],
            },
        },
    }],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networkservices.HttpRoute("default",
    name="my-http-route",
    labels={
        "foo": "bar",
    },
    description="my description",
    hostnames=["example"],
    rules=[{
        "action": {
            "fault_injection_policy": {
                "delay": {
                    "fixed_delay": "1s",
                    "percentage": 1,
                },
                "abort": {
                    "http_status": 500,
                    "percentage": 1,
                },
            },
            "url_rewrite": {
                "path_prefix_rewrite": "new-prefix",
                "host_rewrite": "new-host",
            },
            "retry_policy": {
                "retry_conditions": ["server_error"],
                "num_retries": 1,
                "per_try_timeout": "1s",
            },
            "request_mirror_policy": {
                "destination": {
                    "service_name": "new",
                    "weight": 1,
                },
            },
            "cors_policy": {
                "allow_origins": ["example"],
                "allow_methods": [
                    "GET",
                    "PUT",
                ],
                "allow_headers": [
                    "version",
                    "type",
                ],
                "expose_headers": [
                    "version",
                    "type",
                ],
                "max_age": "1s",
                "allow_credentials": True,
                "disabled": False,
            },
            "request_header_modifier": {
                "set": {
                    "version": "1",
                    "type": "json",
                },
                "add": {
                    "minor-version": "1",
                },
                "removes": ["arg"],
            },
            "response_header_modifier": {
                "set": {
                    "version": "1",
                    "type": "json",
                },
                "add": {
                    "minor-version": "1",
                },
                "removes": ["removearg"],
            },
        },
    }])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkServices.HttpRoute("default", new()
    {
        Name = "my-http-route",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        Hostnames = new[]
        {
            "example",
        },
        Rules = new[]
        {
            new Gcp.NetworkServices.Inputs.HttpRouteRuleArgs
            {
                Action = new Gcp.NetworkServices.Inputs.HttpRouteRuleActionArgs
                {
                    FaultInjectionPolicy = new Gcp.NetworkServices.Inputs.HttpRouteRuleActionFaultInjectionPolicyArgs
                    {
                        Delay = new Gcp.NetworkServices.Inputs.HttpRouteRuleActionFaultInjectionPolicyDelayArgs
                        {
                            FixedDelay = "1s",
                            Percentage = 1,
                        },
                        Abort = new Gcp.NetworkServices.Inputs.HttpRouteRuleActionFaultInjectionPolicyAbortArgs
                        {
                            HttpStatus = 500,
                            Percentage = 1,
                        },
                    },
                    UrlRewrite = new Gcp.NetworkServices.Inputs.HttpRouteRuleActionUrlRewriteArgs
                    {
                        PathPrefixRewrite = "new-prefix",
                        HostRewrite = "new-host",
                    },
                    RetryPolicy = new Gcp.NetworkServices.Inputs.HttpRouteRuleActionRetryPolicyArgs
                    {
                        RetryConditions = new[]
                        {
                            "server_error",
                        },
                        NumRetries = 1,
                        PerTryTimeout = "1s",
                    },
                    RequestMirrorPolicy = new Gcp.NetworkServices.Inputs.HttpRouteRuleActionRequestMirrorPolicyArgs
                    {
                        Destination = new Gcp.NetworkServices.Inputs.HttpRouteRuleActionRequestMirrorPolicyDestinationArgs
                        {
                            ServiceName = "new",
                            Weight = 1,
                        },
                    },
                    CorsPolicy = new Gcp.NetworkServices.Inputs.HttpRouteRuleActionCorsPolicyArgs
                    {
                        AllowOrigins = new[]
                        {
                            "example",
                        },
                        AllowMethods = new[]
                        {
                            "GET",
                            "PUT",
                        },
                        AllowHeaders = new[]
                        {
                            "version",
                            "type",
                        },
                        ExposeHeaders = new[]
                        {
                            "version",
                            "type",
                        },
                        MaxAge = "1s",
                        AllowCredentials = true,
                        Disabled = false,
                    },
                    RequestHeaderModifier = new Gcp.NetworkServices.Inputs.HttpRouteRuleActionRequestHeaderModifierArgs
                    {
                        Set = 
                        {
                            { "version", "1" },
                            { "type", "json" },
                        },
                        Add = 
                        {
                            { "minor-version", "1" },
                        },
                        Removes = new[]
                        {
                            "arg",
                        },
                    },
                    ResponseHeaderModifier = new Gcp.NetworkServices.Inputs.HttpRouteRuleActionResponseHeaderModifierArgs
                    {
                        Set = 
                        {
                            { "version", "1" },
                            { "type", "json" },
                        },
                        Add = 
                        {
                            { "minor-version", "1" },
                        },
                        Removes = new[]
                        {
                            "removearg",
                        },
                    },
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networkservices.NewHttpRoute(ctx, "default", &networkservices.HttpRouteArgs{
			Name: pulumi.String("my-http-route"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			Hostnames: pulumi.StringArray{
				pulumi.String("example"),
			},
			Rules: networkservices.HttpRouteRuleArray{
				&networkservices.HttpRouteRuleArgs{
					Action: &networkservices.HttpRouteRuleActionArgs{
						FaultInjectionPolicy: &networkservices.HttpRouteRuleActionFaultInjectionPolicyArgs{
							Delay: &networkservices.HttpRouteRuleActionFaultInjectionPolicyDelayArgs{
								FixedDelay: pulumi.String("1s"),
								Percentage: pulumi.Int(1),
							},
							Abort: &networkservices.HttpRouteRuleActionFaultInjectionPolicyAbortArgs{
								HttpStatus: pulumi.Int(500),
								Percentage: pulumi.Int(1),
							},
						},
						UrlRewrite: &networkservices.HttpRouteRuleActionUrlRewriteArgs{
							PathPrefixRewrite: pulumi.String("new-prefix"),
							HostRewrite:       pulumi.String("new-host"),
						},
						RetryPolicy: &networkservices.HttpRouteRuleActionRetryPolicyArgs{
							RetryConditions: pulumi.StringArray{
								pulumi.String("server_error"),
							},
							NumRetries:    pulumi.Int(1),
							PerTryTimeout: pulumi.String("1s"),
						},
						RequestMirrorPolicy: &networkservices.HttpRouteRuleActionRequestMirrorPolicyArgs{
							Destination: &networkservices.HttpRouteRuleActionRequestMirrorPolicyDestinationArgs{
								ServiceName: pulumi.String("new"),
								Weight:      pulumi.Int(1),
							},
						},
						CorsPolicy: &networkservices.HttpRouteRuleActionCorsPolicyArgs{
							AllowOrigins: pulumi.StringArray{
								pulumi.String("example"),
							},
							AllowMethods: pulumi.StringArray{
								pulumi.String("GET"),
								pulumi.String("PUT"),
							},
							AllowHeaders: pulumi.StringArray{
								pulumi.String("version"),
								pulumi.String("type"),
							},
							ExposeHeaders: pulumi.StringArray{
								pulumi.String("version"),
								pulumi.String("type"),
							},
							MaxAge:           pulumi.String("1s"),
							AllowCredentials: pulumi.Bool(true),
							Disabled:         pulumi.Bool(false),
						},
						RequestHeaderModifier: &networkservices.HttpRouteRuleActionRequestHeaderModifierArgs{
							Set: pulumi.StringMap{
								"version": pulumi.String("1"),
								"type":    pulumi.String("json"),
							},
							Add: pulumi.StringMap{
								"minor-version": pulumi.String("1"),
							},
							Removes: pulumi.StringArray{
								pulumi.String("arg"),
							},
						},
						ResponseHeaderModifier: &networkservices.HttpRouteRuleActionResponseHeaderModifierArgs{
							Set: pulumi.StringMap{
								"version": pulumi.String("1"),
								"type":    pulumi.String("json"),
							},
							Add: pulumi.StringMap{
								"minor-version": pulumi.String("1"),
							},
							Removes: pulumi.StringArray{
								pulumi.String("removearg"),
							},
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networkservices.HttpRoute;
import com.pulumi.gcp.networkservices.HttpRouteArgs;
import com.pulumi.gcp.networkservices.inputs.HttpRouteRuleArgs;
import com.pulumi.gcp.networkservices.inputs.HttpRouteRuleActionArgs;
import com.pulumi.gcp.networkservices.inputs.HttpRouteRuleActionFaultInjectionPolicyArgs;
import com.pulumi.gcp.networkservices.inputs.HttpRouteRuleActionFaultInjectionPolicyDelayArgs;
import com.pulumi.gcp.networkservices.inputs.HttpRouteRuleActionFaultInjectionPolicyAbortArgs;
import com.pulumi.gcp.networkservices.inputs.HttpRouteRuleActionUrlRewriteArgs;
import com.pulumi.gcp.networkservices.inputs.HttpRouteRuleActionRetryPolicyArgs;
import com.pulumi.gcp.networkservices.inputs.HttpRouteRuleActionRequestMirrorPolicyArgs;
import com.pulumi.gcp.networkservices.inputs.HttpRouteRuleActionRequestMirrorPolicyDestinationArgs;
import com.pulumi.gcp.networkservices.inputs.HttpRouteRuleActionCorsPolicyArgs;
import com.pulumi.gcp.networkservices.inputs.HttpRouteRuleActionRequestHeaderModifierArgs;
import com.pulumi.gcp.networkservices.inputs.HttpRouteRuleActionResponseHeaderModifierArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new HttpRoute("default", HttpRouteArgs.builder()
            .name("my-http-route")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .hostnames("example")
            .rules(HttpRouteRuleArgs.builder()
                .action(HttpRouteRuleActionArgs.builder()
                    .faultInjectionPolicy(HttpRouteRuleActionFaultInjectionPolicyArgs.builder()
                        .delay(HttpRouteRuleActionFaultInjectionPolicyDelayArgs.builder()
                            .fixedDelay("1s")
                            .percentage(1)
                            .build())
                        .abort(HttpRouteRuleActionFaultInjectionPolicyAbortArgs.builder()
                            .httpStatus(500)
                            .percentage(1)
                            .build())
                        .build())
                    .urlRewrite(HttpRouteRuleActionUrlRewriteArgs.builder()
                        .pathPrefixRewrite("new-prefix")
                        .hostRewrite("new-host")
                        .build())
                    .retryPolicy(HttpRouteRuleActionRetryPolicyArgs.builder()
                        .retryConditions("server_error")
                        .numRetries(1)
                        .perTryTimeout("1s")
                        .build())
                    .requestMirrorPolicy(HttpRouteRuleActionRequestMirrorPolicyArgs.builder()
                        .destination(HttpRouteRuleActionRequestMirrorPolicyDestinationArgs.builder()
                            .serviceName("new")
                            .weight(1)
                            .build())
                        .build())
                    .corsPolicy(HttpRouteRuleActionCorsPolicyArgs.builder()
                        .allowOrigins("example")
                        .allowMethods(                        
                            "GET",
                            "PUT")
                        .allowHeaders(                        
                            "version",
                            "type")
                        .exposeHeaders(                        
                            "version",
                            "type")
                        .maxAge("1s")
                        .allowCredentials(true)
                        .disabled(false)
                        .build())
                    .requestHeaderModifier(HttpRouteRuleActionRequestHeaderModifierArgs.builder()
                        .set(Map.ofEntries(
                            Map.entry("version", "1"),
                            Map.entry("type", "json")
                        ))
                        .add(Map.of("minor-version", "1"))
                        .removes("arg")
                        .build())
                    .responseHeaderModifier(HttpRouteRuleActionResponseHeaderModifierArgs.builder()
                        .set(Map.ofEntries(
                            Map.entry("version", "1"),
                            Map.entry("type", "json")
                        ))
                        .add(Map.of("minor-version", "1"))
                        .removes("removearg")
                        .build())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkservices:HttpRoute
    properties:
      name: my-http-route
      labels:
        foo: bar
      description: my description
      hostnames:
        - example
      rules:
        - action:
            faultInjectionPolicy:
              delay:
                fixedDelay: 1s
                percentage: 1
              abort:
                httpStatus: 500
                percentage: 1
            urlRewrite:
              pathPrefixRewrite: new-prefix
              hostRewrite: new-host
            retryPolicy:
              retryConditions:
                - server_error
              numRetries: 1
              perTryTimeout: 1s
            requestMirrorPolicy:
              destination:
                serviceName: new
                weight: 1
            corsPolicy:
              allowOrigins:
                - example
              allowMethods:
                - GET
                - PUT
              allowHeaders:
                - version
                - type
              exposeHeaders:
                - version
                - type
              maxAge: 1s
              allowCredentials: true
              disabled: false
            requestHeaderModifier:
              set:
                version: '1'
                type: json
              add:
                minor-version: '1'
              removes:
                - arg
            responseHeaderModifier:
              set:
                version: '1'
                type: json
              add:
                minor-version: '1'
              removes:
                - removearg
```
<!--End PulumiCodeChooser -->
### Network Services Http Route Mesh Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networkservices.Mesh("default", {
    name: "my-http-route",
    labels: {
        foo: "bar",
    },
    description: "my description",
});
const defaultHttpRoute = new gcp.networkservices.HttpRoute("default", {
    name: "my-http-route",
    labels: {
        foo: "bar",
    },
    description: "my description",
    hostnames: ["example"],
    meshes: [_default.id],
    rules: [{
        matches: [{
            queryParameters: [{
                queryParameter: "key",
                exactMatch: "value",
            }],
            fullPathMatch: "example",
        }],
    }],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networkservices.Mesh("default",
    name="my-http-route",
    labels={
        "foo": "bar",
    },
    description="my description")
default_http_route = gcp.networkservices.HttpRoute("default",
    name="my-http-route",
    labels={
        "foo": "bar",
    },
    description="my description",
    hostnames=["example"],
    meshes=[default.id],
    rules=[{
        "matches": [{
            "query_parameters": [{
                "query_parameter": "key",
                "exact_match": "value",
            }],
            "full_path_match": "example",
        }],
    }])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkServices.Mesh("default", new()
    {
        Name = "my-http-route",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
    });

    var defaultHttpRoute = new Gcp.NetworkServices.HttpRoute("default", new()
    {
        Name = "my-http-route",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        Hostnames = new[]
        {
            "example",
        },
        Meshes = new[]
        {
            @default.Id,
        },
        Rules = new[]
        {
            new Gcp.NetworkServices.Inputs.HttpRouteRuleArgs
            {
                Matches = new[]
                {
                    new Gcp.NetworkServices.Inputs.HttpRouteRuleMatchArgs
                    {
                        QueryParameters = new[]
                        {
                            new Gcp.NetworkServices.Inputs.HttpRouteRuleMatchQueryParameterArgs
                            {
                                QueryParameter = "key",
                                ExactMatch = "value",
                            },
                        },
                        FullPathMatch = "example",
                    },
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networkservices.NewMesh(ctx, "default", &networkservices.MeshArgs{
			Name: pulumi.String("my-http-route"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
		})
		if err != nil {
			return err
		}
		_, err = networkservices.NewHttpRoute(ctx, "default", &networkservices.HttpRouteArgs{
			Name: pulumi.String("my-http-route"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			Hostnames: pulumi.StringArray{
				pulumi.String("example"),
			},
			Meshes: pulumi.StringArray{
				_default.ID(),
			},
			Rules: networkservices.HttpRouteRuleArray{
				&networkservices.HttpRouteRuleArgs{
					Matches: networkservices.HttpRouteRuleMatchArray{
						&networkservices.HttpRouteRuleMatchArgs{
							QueryParameters: networkservices.HttpRouteRuleMatchQueryParameterArray{
								&networkservices.HttpRouteRuleMatchQueryParameterArgs{
									QueryParameter: pulumi.String("key"),
									ExactMatch:     pulumi.String("value"),
								},
							},
							FullPathMatch: pulumi.String("example"),
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networkservices.Mesh;
import com.pulumi.gcp.networkservices.MeshArgs;
import com.pulumi.gcp.networkservices.HttpRoute;
import com.pulumi.gcp.networkservices.HttpRouteArgs;
import com.pulumi.gcp.networkservices.inputs.HttpRouteRuleArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new Mesh("default", MeshArgs.builder()
            .name("my-http-route")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .build());

        var defaultHttpRoute = new HttpRoute("defaultHttpRoute", HttpRouteArgs.builder()
            .name("my-http-route")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .hostnames("example")
            .meshes(default_.id())
            .rules(HttpRouteRuleArgs.builder()
                .matches(HttpRouteRuleMatchArgs.builder()
                    .queryParameters(HttpRouteRuleMatchQueryParameterArgs.builder()
                        .queryParameter("key")
                        .exactMatch("value")
                        .build())
                    .fullPathMatch("example")
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkservices:Mesh
    properties:
      name: my-http-route
      labels:
        foo: bar
      description: my description
  defaultHttpRoute:
    type: gcp:networkservices:HttpRoute
    name: default
    properties:
      name: my-http-route
      labels:
        foo: bar
      description: my description
      hostnames:
        - example
      meshes:
        - ${default.id}
      rules:
        - matches:
            - queryParameters:
                - queryParameter: key
                  exactMatch: value
              fullPathMatch: example
```
<!--End PulumiCodeChooser -->

## Import

HttpRoute can be imported using any of these accepted formats:

* `projects/{{project}}/locations/global/httpRoutes/{{name}}`

* `{{project}}/{{name}}`

* `{{name}}`

When using the `pulumi import` command, HttpRoute can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkservices/httpRoute:HttpRoute default projects/{{project}}/locations/global/httpRoutes/{{name}}
```

```sh
$ pulumi import gcp:networkservices/httpRoute:HttpRoute default {{project}}/{{name}}
```

```sh
$ pulumi import gcp:networkservices/httpRoute:HttpRoute default {{name}}
```

Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
Ü
gatewaysB*" ÒGateways defines a list of gateways this HttpRoute is attached to, as one of the routing rules to route the requests
served by the gateway. Each gateway reference should match the pattern:
projects/*/locations/global/gateways/<gateway_name>
}
	hostnames*" jSet of hosts that should match against the HTTP host header to select a HttpRoute to process the request.
ì
labelsB2" ÄSet of label tags associated with the HttpRoute resource. **Note**: This field is non-authoritative, and will only
manage the labels present in your configuration. Please refer to the field 'effective_labels' for all of the labels
present on the resource.
•
meshesB*" íMeshes defines a list of meshes this HttpRoute is attached to, as one of the routing rules to route the requests served
by the mesh. Each mesh reference should match the pattern: projects/*/locations/global/meshes/<mesh_name>. The attached
Mesh should be of a type SIDECAR.
.
nameB"  Name of the HttpRoute resource.

projectB" ∂
rulesW*U:S
Q
networkservicesHttpRouteRule/gcp:networkservices/HttpRouteRule:HttpRouteRuleTRules that define how traffic is routed and handled.
Structure is documented below.
"9

createTime" 'Time the HttpRoute was created in UTC.
"Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"Ü
gatewaysB*" ÒGateways defines a list of gateways this HttpRoute is attached to, as one of the routing rules to route the requests
served by the gateway. Each gateway reference should match the pattern:
projects/*/locations/global/gateways/<gateway_name>
"}
	hostnames*" jSet of hosts that should match against the HTTP host header to select a HttpRoute to process the request.
"ì
labelsB2" ÄSet of label tags associated with the HttpRoute resource. **Note**: This field is non-authoritative, and will only
manage the labels present in your configuration. Please refer to the field 'effective_labels' for all of the labels
present on the resource.
"•
meshesB*" íMeshes defines a list of meshes this HttpRoute is attached to, as one of the routing rules to route the requests served
by the mesh. Each mesh reference should match the pattern: projects/*/locations/global/meshes/<mesh_name>. The attached
Mesh should be of a type SIDECAR.
",
name"  Name of the HttpRoute resource.
"
project" "É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"∂
rulesW*U:S
Q
networkservicesHttpRouteRule/gcp:networkservices/HttpRouteRule:HttpRouteRuleTRules that define how traffic is routed and handled.
Structure is documented below.
"5
selfLink" %Server-defined URL of this resource.
"9

updateTime" 'Time the HttpRoute was updated in UTC.
*Ò(
Z
networkservicesLbRouteExtension5gcp:networkservices/lbRouteExtension:LbRouteExtension©	LbRouteExtension is a resource that lets you control where traffic is routed to for a given request.


To get more information about LbRouteExtension, see:

* [API documentation](https://cloud.google.com/service-extensions/docs/reference/rest/v1beta1/projects.locations.lbRouteExtensions)
* How-to Guides
    * [Configure a route extension](https://cloud.google.com/service-extensions/docs/configure-callout#configure_a_route_extension)

## Example Usage

## Import

LbRouteExtension can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/lbRouteExtensions/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

When using the `pulumi import` command, LbRouteExtension can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkservices/lbRouteExtension:LbRouteExtension default projects/{{project}}/locations/{{location}}/lbRouteExtensions/{{name}}
```

```sh
$ pulumi import gcp:networkservices/lbRouteExtension:LbRouteExtension default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:networkservices/lbRouteExtension:LbRouteExtension default {{location}}/{{name}}
```

C
descriptionB" .A human-readable description of the resource.
¨
extensionChainsç*ä:á
Ñ
networkservicesLbRouteExtensionExtensionChainQgcp:networkservices/LbRouteExtensionExtensionChain:LbRouteExtensionExtensionChainàA set of ordered extension chains that contain the match conditions and extensions to execute.
Match conditions for each extension chain are evaluated in sequence for a given request.
The first extension chain that has a condition that matches the request is executed.
Any subsequent extension chains do not execute. Limited to 5 extension chains per resource.
Structure is documented below.
Ê
forwardingRules*" ÃA list of references to the forwarding rules to which this service extension is attached to.
At least one forwarding rule is required. There can be only one LbRouteExtension resource per forwarding rule.
ñ
labelsB2" ÉSet of labels associated with the LbRouteExtension resource. **Note**: This field is non-authoritative, and will only
manage the labels present in your configuration. Please refer to the field 'effective_labels' for all of the labels
present on the resource.
¡
loadBalancingScheme" •All backend services and forwarding rules referenced by this extension must share the same load balancing scheme.
For more information, refer to [Choosing a load balancer](https://cloud.google.com/load-balancing/docs/backend-service) and
[Supported application load balancers](https://cloud.google.com/service-extensions/docs/callouts-overview#supported-lbs).
Possible values are: `INTERNAL_MANAGED`, `EXTERNAL_MANAGED`.
4
location" $The location of the route extension
õ
nameB" åName of the LbRouteExtension resource in the following format: projects/{project}/locations/{location}/lbRouteExtensions/{lbRouteExtension}

projectB" "C
descriptionB" .A human-readable description of the resource.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"¨
extensionChainsç*ä:á
Ñ
networkservicesLbRouteExtensionExtensionChainQgcp:networkservices/LbRouteExtensionExtensionChain:LbRouteExtensionExtensionChainàA set of ordered extension chains that contain the match conditions and extensions to execute.
Match conditions for each extension chain are evaluated in sequence for a given request.
The first extension chain that has a condition that matches the request is executed.
Any subsequent extension chains do not execute. Limited to 5 extension chains per resource.
Structure is documented below.
"Ê
forwardingRules*" ÃA list of references to the forwarding rules to which this service extension is attached to.
At least one forwarding rule is required. There can be only one LbRouteExtension resource per forwarding rule.
"ñ
labelsB2" ÉSet of labels associated with the LbRouteExtension resource. **Note**: This field is non-authoritative, and will only
manage the labels present in your configuration. Please refer to the field 'effective_labels' for all of the labels
present on the resource.
"¡
loadBalancingScheme" •All backend services and forwarding rules referenced by this extension must share the same load balancing scheme.
For more information, refer to [Choosing a load balancer](https://cloud.google.com/load-balancing/docs/backend-service) and
[Supported application load balancers](https://cloud.google.com/service-extensions/docs/callouts-overview#supported-lbs).
Possible values are: `INTERNAL_MANAGED`, `EXTERNAL_MANAGED`.
"4
location" $The location of the route extension
"ô
name" åName of the LbRouteExtension resource in the following format: projects/{project}/locations/{location}/lbRouteExtensions/{lbRouteExtension}
"
project" "É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
*«*
`
networkservicesLbTrafficExtension9gcp:networkservices/lbTrafficExtension:LbTrafficExtension’
LbTrafficExtension is a resource that lets the extension service modify the headers and payloads of both requests and responses without impacting the choice of backend services or any other security policies associated with the backend service.


To get more information about LbTrafficExtension, see:

* [API documentation](https://cloud.google.com/service-extensions/docs/reference/rest/v1beta1/projects.locations.lbTrafficExtensions)
* How-to Guides
    * [Configure a traffic extension](https://cloud.google.com/service-extensions/docs/configure-callout#configure_a_traffic_extension)

## Example Usage

## Import

LbTrafficExtension can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/lbTrafficExtensions/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

When using the `pulumi import` command, LbTrafficExtension can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkservices/lbTrafficExtension:LbTrafficExtension default projects/{{project}}/locations/{{location}}/lbTrafficExtensions/{{name}}
```

```sh
$ pulumi import gcp:networkservices/lbTrafficExtension:LbTrafficExtension default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:networkservices/lbTrafficExtension:LbTrafficExtension default {{location}}/{{name}}
```

C
descriptionB" .A human-readable description of the resource.
≤
extensionChainsì*ê:ç
ä
networkservices LbTrafficExtensionExtensionChainUgcp:networkservices/LbTrafficExtensionExtensionChain:LbTrafficExtensionExtensionChainàA set of ordered extension chains that contain the match conditions and extensions to execute.
Match conditions for each extension chain are evaluated in sequence for a given request.
The first extension chain that has a condition that matches the request is executed.
Any subsequent extension chains do not execute. Limited to 5 extension chains per resource.
Structure is documented below.
Ë
forwardingRules*" ŒA list of references to the forwarding rules to which this service extension is attached to.
At least one forwarding rule is required. There can be only one LBTrafficExtension resource per forwarding rule.
ò
labelsB2" ÖSet of labels associated with the LbTrafficExtension resource. **Note**: This field is non-authoritative, and will only
manage the labels present in your configuration. Please refer to the field 'effective_labels' for all of the labels
present on the resource.
¿
loadBalancingSchemeB" ¢All backend services and forwarding rules referenced by this extension must share the same load balancing scheme. For
more information, refer to [Choosing a load balancer](https://cloud.google.com/load-balancing/docs/backend-service) and
[Supported application load
balancers](https://cloud.google.com/service-extensions/docs/callouts-overview#supported-lbs). Possible values:
["INTERNAL_MANAGED", "EXTERNAL_MANAGED"]
6
location" &The location of the traffic extension
¢
nameB" ìName of the LbTrafficExtension resource in the following format: projects/{project}/locations/{location}/lbTrafficExtensions/{lbTrafficExtension}.

projectB" "C
descriptionB" .A human-readable description of the resource.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"≤
extensionChainsì*ê:ç
ä
networkservices LbTrafficExtensionExtensionChainUgcp:networkservices/LbTrafficExtensionExtensionChain:LbTrafficExtensionExtensionChainàA set of ordered extension chains that contain the match conditions and extensions to execute.
Match conditions for each extension chain are evaluated in sequence for a given request.
The first extension chain that has a condition that matches the request is executed.
Any subsequent extension chains do not execute. Limited to 5 extension chains per resource.
Structure is documented below.
"Ë
forwardingRules*" ŒA list of references to the forwarding rules to which this service extension is attached to.
At least one forwarding rule is required. There can be only one LBTrafficExtension resource per forwarding rule.
"ò
labelsB2" ÖSet of labels associated with the LbTrafficExtension resource. **Note**: This field is non-authoritative, and will only
manage the labels present in your configuration. Please refer to the field 'effective_labels' for all of the labels
present on the resource.
"¿
loadBalancingSchemeB" ¢All backend services and forwarding rules referenced by this extension must share the same load balancing scheme. For
more information, refer to [Choosing a load balancer](https://cloud.google.com/load-balancing/docs/backend-service) and
[Supported application load
balancers](https://cloud.google.com/service-extensions/docs/callouts-overview#supported-lbs). Possible values:
["INTERNAL_MANAGED", "EXTERNAL_MANAGED"]
"6
location" &The location of the traffic extension
"†
name" ìName of the LbTrafficExtension resource in the following format: projects/{project}/locations/{location}/lbTrafficExtensions/{lbTrafficExtension}.
"
project" "É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
*√=
6
networkservicesMeshgcp:networkservices/mesh:Mesh¶*## Example Usage

### Network Services Mesh Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networkservices.Mesh("default", {
    name: "my-mesh",
    labels: {
        foo: "bar",
    },
    description: "my description",
    interceptionPort: 443,
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networkservices.Mesh("default",
    name="my-mesh",
    labels={
        "foo": "bar",
    },
    description="my description",
    interception_port=443)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkServices.Mesh("default", new()
    {
        Name = "my-mesh",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        InterceptionPort = 443,
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networkservices.NewMesh(ctx, "default", &networkservices.MeshArgs{
			Name: pulumi.String("my-mesh"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description:      pulumi.String("my description"),
			InterceptionPort: pulumi.Int(443),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networkservices.Mesh;
import com.pulumi.gcp.networkservices.MeshArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new Mesh("default", MeshArgs.builder()
            .name("my-mesh")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .interceptionPort(443)
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkservices:Mesh
    properties:
      name: my-mesh
      labels:
        foo: bar
      description: my description
      interceptionPort: 443
```
<!--End PulumiCodeChooser -->
### Network Services Mesh No Port


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networkservices.Mesh("default", {
    name: "my-mesh-noport",
    labels: {
        foo: "bar",
    },
    description: "my description",
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networkservices.Mesh("default",
    name="my-mesh-noport",
    labels={
        "foo": "bar",
    },
    description="my description")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkServices.Mesh("default", new()
    {
        Name = "my-mesh-noport",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networkservices.NewMesh(ctx, "default", &networkservices.MeshArgs{
			Name: pulumi.String("my-mesh-noport"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networkservices.Mesh;
import com.pulumi.gcp.networkservices.MeshArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new Mesh("default", MeshArgs.builder()
            .name("my-mesh-noport")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkservices:Mesh
    properties:
      name: my-mesh-noport
      labels:
        foo: bar
      description: my description
```
<!--End PulumiCodeChooser -->

## Import

Mesh can be imported using any of these accepted formats:

* `projects/{{project}}/locations/global/meshes/{{name}}`

* `{{project}}/{{name}}`

* `{{name}}`

When using the `pulumi import` command, Mesh can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkservices/mesh:Mesh default projects/{{project}}/locations/global/meshes/{{name}}
```

```sh
$ pulumi import gcp:networkservices/mesh:Mesh default {{project}}/{{name}}
```

```sh
$ pulumi import gcp:networkservices/mesh:Mesh default {{name}}
```

Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
ñ
interceptionPortB ˚Optional. If set to a valid TCP port (1-65535), instructs the SIDECAR proxy to listen on the
specified port of localhost (127.0.0.1) address. The SIDECAR proxy will expect all traffic to
be redirected to this port regardless of its actual ip:port destination. If unset, a port
'15001' is used as the interception port. This will is applicable only for sidecar proxy
deployments.
é
labelsB2" ˚Set of label tags associated with the Mesh resource.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
E
nameB" 7Short name of the Mesh resource to be created.


- - -
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"4

createTime" "Time the Mesh was created in UTC.
"Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"ñ
interceptionPortB ˚Optional. If set to a valid TCP port (1-65535), instructs the SIDECAR proxy to listen on the
specified port of localhost (127.0.0.1) address. The SIDECAR proxy will expect all traffic to
be redirected to this port regardless of its actual ip:port destination. If unset, a port
'15001' is used as the interception port. This will is applicable only for sidecar proxy
deployments.
"é
labelsB2" ˚Set of label tags associated with the Mesh resource.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"C
name" 7Short name of the Mesh resource to be created.


- - -
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"5
selfLink" %Server-defined URL of this resource.
"4

updateTime" "Time the Mesh was updated in UTC.
*ë?
T
networkservicesServiceBinding1gcp:networkservices/serviceBinding:ServiceBindingø0## Example Usage

### Network Services Service Binding Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.servicedirectory.Namespace("default", {
    namespaceId: "my-namespace",
    location: "us-central1",
});
const defaultService = new gcp.servicedirectory.Service("default", {
    serviceId: "my-service",
    namespace: _default.id,
    metadata: {
        stage: "prod",
        region: "us-central1",
    },
});
const defaultServiceBinding = new gcp.networkservices.ServiceBinding("default", {
    name: "my-service-binding",
    labels: {
        foo: "bar",
    },
    description: "my description",
    service: defaultService.id,
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.servicedirectory.Namespace("default",
    namespace_id="my-namespace",
    location="us-central1")
default_service = gcp.servicedirectory.Service("default",
    service_id="my-service",
    namespace=default.id,
    metadata={
        "stage": "prod",
        "region": "us-central1",
    })
default_service_binding = gcp.networkservices.ServiceBinding("default",
    name="my-service-binding",
    labels={
        "foo": "bar",
    },
    description="my description",
    service=default_service.id)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.ServiceDirectory.Namespace("default", new()
    {
        NamespaceId = "my-namespace",
        Location = "us-central1",
    });

    var defaultService = new Gcp.ServiceDirectory.Service("default", new()
    {
        ServiceId = "my-service",
        Namespace = @default.Id,
        Metadata = 
        {
            { "stage", "prod" },
            { "region", "us-central1" },
        },
    });

    var defaultServiceBinding = new Gcp.NetworkServices.ServiceBinding("default", new()
    {
        Name = "my-service-binding",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        Service = defaultService.Id,
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/servicedirectory"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := servicedirectory.NewNamespace(ctx, "default", &servicedirectory.NamespaceArgs{
			NamespaceId: pulumi.String("my-namespace"),
			Location:    pulumi.String("us-central1"),
		})
		if err != nil {
			return err
		}
		defaultService, err := servicedirectory.NewService(ctx, "default", &servicedirectory.ServiceArgs{
			ServiceId: pulumi.String("my-service"),
			Namespace: _default.ID(),
			Metadata: pulumi.StringMap{
				"stage":  pulumi.String("prod"),
				"region": pulumi.String("us-central1"),
			},
		})
		if err != nil {
			return err
		}
		_, err = networkservices.NewServiceBinding(ctx, "default", &networkservices.ServiceBindingArgs{
			Name: pulumi.String("my-service-binding"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			Service:     defaultService.ID(),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.servicedirectory.Namespace;
import com.pulumi.gcp.servicedirectory.NamespaceArgs;
import com.pulumi.gcp.servicedirectory.Service;
import com.pulumi.gcp.servicedirectory.ServiceArgs;
import com.pulumi.gcp.networkservices.ServiceBinding;
import com.pulumi.gcp.networkservices.ServiceBindingArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new Namespace("default", NamespaceArgs.builder()
            .namespaceId("my-namespace")
            .location("us-central1")
            .build());

        var defaultService = new Service("defaultService", ServiceArgs.builder()
            .serviceId("my-service")
            .namespace(default_.id())
            .metadata(Map.ofEntries(
                Map.entry("stage", "prod"),
                Map.entry("region", "us-central1")
            ))
            .build());

        var defaultServiceBinding = new ServiceBinding("defaultServiceBinding", ServiceBindingArgs.builder()
            .name("my-service-binding")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .service(defaultService.id())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:servicedirectory:Namespace
    properties:
      namespaceId: my-namespace
      location: us-central1
  defaultService:
    type: gcp:servicedirectory:Service
    name: default
    properties:
      serviceId: my-service
      namespace: ${default.id}
      metadata:
        stage: prod
        region: us-central1
  defaultServiceBinding:
    type: gcp:networkservices:ServiceBinding
    name: default
    properties:
      name: my-service-binding
      labels:
        foo: bar
      description: my description
      service: ${defaultService.id}
```
<!--End PulumiCodeChooser -->

## Import

ServiceBinding can be imported using any of these accepted formats:

* `projects/{{project}}/locations/global/serviceBindings/{{name}}`

* `{{project}}/{{name}}`

* `{{name}}`

When using the `pulumi import` command, ServiceBinding can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkservices/serviceBinding:ServiceBinding default projects/{{project}}/locations/global/serviceBindings/{{name}}
```

```sh
$ pulumi import gcp:networkservices/serviceBinding:ServiceBinding default {{project}}/{{name}}
```

```sh
$ pulumi import gcp:networkservices/serviceBinding:ServiceBinding default {{name}}
```

Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
ò
labelsB2" ÖSet of label tags associated with the ServiceBinding resource.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
;
nameB" -Name of the ServiceBinding resource.


- - -
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
t
service" eThe full Service Directory Service name of the format
projects/*/locations/*/namespaces/*/services/*
">

createTime" ,Time the ServiceBinding was created in UTC.
"Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"ò
labelsB2" ÖSet of label tags associated with the ServiceBinding resource.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"9
name" -Name of the ServiceBinding resource.


- - -
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"t
service" eThe full Service Directory Service name of the format
projects/*/locations/*/namespaces/*/services/*
">

updateTime" ,Time the ServiceBinding was updated in UTC.
*—g
]
networkservicesServiceLbPolicies7gcp:networkservices/serviceLbPolicies:ServiceLbPolicies“J## Example Usage

### Network Services Service Lb Policies Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networkservices.ServiceLbPolicies("default", {
    name: "my-lb-policy",
    location: "global",
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networkservices.ServiceLbPolicies("default",
    name="my-lb-policy",
    location="global")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkServices.ServiceLbPolicies("default", new()
    {
        Name = "my-lb-policy",
        Location = "global",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networkservices.NewServiceLbPolicies(ctx, "default", &networkservices.ServiceLbPoliciesArgs{
			Name:     pulumi.String("my-lb-policy"),
			Location: pulumi.String("global"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networkservices.ServiceLbPolicies;
import com.pulumi.gcp.networkservices.ServiceLbPoliciesArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new ServiceLbPolicies("default", ServiceLbPoliciesArgs.builder()
            .name("my-lb-policy")
            .location("global")
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkservices:ServiceLbPolicies
    properties:
      name: my-lb-policy
      location: global
```
<!--End PulumiCodeChooser -->
### Network Services Service Lb Policies Advanced


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const _default = new gcp.networkservices.ServiceLbPolicies("default", {
    name: "my-lb-policy",
    location: "global",
    description: "my description",
    loadBalancingAlgorithm: "SPRAY_TO_REGION",
    autoCapacityDrain: {
        enable: true,
    },
    failoverConfig: {
        failoverHealthThreshold: 70,
    },
    labels: {
        foo: "bar",
    },
});
const defaultBackendService = new gcp.compute.BackendService("default", {
    name: "my-lb-backend",
    description: "my description",
    loadBalancingScheme: "INTERNAL_SELF_MANAGED",
    protocol: "HTTP",
    serviceLbPolicy: pulumi.interpolate`//networkservices.googleapis.com/${_default.id}`,
});
```
```python
import pulumi
import pulumi_gcp as gcp

default = gcp.networkservices.ServiceLbPolicies("default",
    name="my-lb-policy",
    location="global",
    description="my description",
    load_balancing_algorithm="SPRAY_TO_REGION",
    auto_capacity_drain={
        "enable": True,
    },
    failover_config={
        "failover_health_threshold": 70,
    },
    labels={
        "foo": "bar",
    })
default_backend_service = gcp.compute.BackendService("default",
    name="my-lb-backend",
    description="my description",
    load_balancing_scheme="INTERNAL_SELF_MANAGED",
    protocol="HTTP",
    service_lb_policy=default.id.apply(lambda id: f"//networkservices.googleapis.com/{id}"))
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var @default = new Gcp.NetworkServices.ServiceLbPolicies("default", new()
    {
        Name = "my-lb-policy",
        Location = "global",
        Description = "my description",
        LoadBalancingAlgorithm = "SPRAY_TO_REGION",
        AutoCapacityDrain = new Gcp.NetworkServices.Inputs.ServiceLbPoliciesAutoCapacityDrainArgs
        {
            Enable = true,
        },
        FailoverConfig = new Gcp.NetworkServices.Inputs.ServiceLbPoliciesFailoverConfigArgs
        {
            FailoverHealthThreshold = 70,
        },
        Labels = 
        {
            { "foo", "bar" },
        },
    });

    var defaultBackendService = new Gcp.Compute.BackendService("default", new()
    {
        Name = "my-lb-backend",
        Description = "my description",
        LoadBalancingScheme = "INTERNAL_SELF_MANAGED",
        Protocol = "HTTP",
        ServiceLbPolicy = @default.Id.Apply(id => $"//networkservices.googleapis.com/{id}"),
    });

});
```
```go
package main

import (
	"fmt"

	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := networkservices.NewServiceLbPolicies(ctx, "default", &networkservices.ServiceLbPoliciesArgs{
			Name:                   pulumi.String("my-lb-policy"),
			Location:               pulumi.String("global"),
			Description:            pulumi.String("my description"),
			LoadBalancingAlgorithm: pulumi.String("SPRAY_TO_REGION"),
			AutoCapacityDrain: &networkservices.ServiceLbPoliciesAutoCapacityDrainArgs{
				Enable: pulumi.Bool(true),
			},
			FailoverConfig: &networkservices.ServiceLbPoliciesFailoverConfigArgs{
				FailoverHealthThreshold: pulumi.Int(70),
			},
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
		})
		if err != nil {
			return err
		}
		_, err = compute.NewBackendService(ctx, "default", &compute.BackendServiceArgs{
			Name:                pulumi.String("my-lb-backend"),
			Description:         pulumi.String("my description"),
			LoadBalancingScheme: pulumi.String("INTERNAL_SELF_MANAGED"),
			Protocol:            pulumi.String("HTTP"),
			ServiceLbPolicy: _default.ID().ApplyT(func(id string) (string, error) {
				return fmt.Sprintf("//networkservices.googleapis.com/%v", id), nil
			}).(pulumi.StringOutput),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.networkservices.ServiceLbPolicies;
import com.pulumi.gcp.networkservices.ServiceLbPoliciesArgs;
import com.pulumi.gcp.networkservices.inputs.ServiceLbPoliciesAutoCapacityDrainArgs;
import com.pulumi.gcp.networkservices.inputs.ServiceLbPoliciesFailoverConfigArgs;
import com.pulumi.gcp.compute.BackendService;
import com.pulumi.gcp.compute.BackendServiceArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var default_ = new ServiceLbPolicies("default", ServiceLbPoliciesArgs.builder()
            .name("my-lb-policy")
            .location("global")
            .description("my description")
            .loadBalancingAlgorithm("SPRAY_TO_REGION")
            .autoCapacityDrain(ServiceLbPoliciesAutoCapacityDrainArgs.builder()
                .enable(true)
                .build())
            .failoverConfig(ServiceLbPoliciesFailoverConfigArgs.builder()
                .failoverHealthThreshold(70)
                .build())
            .labels(Map.of("foo", "bar"))
            .build());

        var defaultBackendService = new BackendService("defaultBackendService", BackendServiceArgs.builder()
            .name("my-lb-backend")
            .description("my description")
            .loadBalancingScheme("INTERNAL_SELF_MANAGED")
            .protocol("HTTP")
            .serviceLbPolicy(default_.id().applyValue(id -> String.format("//networkservices.googleapis.com/%s", id)))
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:networkservices:ServiceLbPolicies
    properties:
      name: my-lb-policy
      location: global
      description: my description
      loadBalancingAlgorithm: SPRAY_TO_REGION
      autoCapacityDrain:
        enable: true
      failoverConfig:
        failoverHealthThreshold: 70
      labels:
        foo: bar
  defaultBackendService:
    type: gcp:compute:BackendService
    name: default
    properties:
      name: my-lb-backend
      description: my description
      loadBalancingScheme: INTERNAL_SELF_MANAGED
      protocol: HTTP
      serviceLbPolicy: //networkservices.googleapis.com/${default.id}
```
<!--End PulumiCodeChooser -->

## Import

ServiceLbPolicies can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/serviceLbPolicies/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

When using the `pulumi import` command, ServiceLbPolicies can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkservices/serviceLbPolicies:ServiceLbPolicies default projects/{{project}}/locations/{{location}}/serviceLbPolicies/{{name}}
```

```sh
$ pulumi import gcp:networkservices/serviceLbPolicies:ServiceLbPolicies default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:networkservices/serviceLbPolicies:ServiceLbPolicies default {{location}}/{{name}}
```

ø
autoCapacityDrainôBñ:ì
ê
networkservices"ServiceLbPoliciesAutoCapacityDrainYgcp:networkservices/ServiceLbPoliciesAutoCapacityDrain:ServiceLbPoliciesAutoCapacityDrainçOption to specify if an unhealthy MIG/NEG should be considered for global load balancing and traffic routing.
Structure is documented below.
Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
¥
failoverConfigêBç:ä
á
networkservicesServiceLbPoliciesFailoverConfigSgcp:networkservices/ServiceLbPoliciesFailoverConfig:ServiceLbPoliciesFailoverConfigéOption to specify health based failover behavior. This is not related to Network load balancer FailoverPolicy.
Structure is documented below.
ô
labelsB2" ÜSet of label tags associated with the ServiceLbPolicy resource.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
Â
loadBalancingAlgorithmB" ƒThe type of load balancing algorithm to be used. The default behavior is WATERFALL_BY_REGION.
Possible values are: `SPRAY_TO_REGION`, `SPRAY_TO_WORLD`, `WATERFALL_BY_REGION`, `WATERFALL_BY_ZONE`.
?
location" /The location of the service lb policy.


- - -
û
nameB" èName of the ServiceLbPolicy resource. It matches pattern `projects/{project}/locations/{location}/serviceLbPolicies/{service_lb_policy_name}`.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"ø
autoCapacityDrainôBñ:ì
ê
networkservices"ServiceLbPoliciesAutoCapacityDrainYgcp:networkservices/ServiceLbPoliciesAutoCapacityDrain:ServiceLbPoliciesAutoCapacityDrainçOption to specify if an unhealthy MIG/NEG should be considered for global load balancing and traffic routing.
Structure is documented below.
"?

createTime" -Time the ServiceLbPolicy was created in UTC.
"Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"¥
failoverConfigêBç:ä
á
networkservicesServiceLbPoliciesFailoverConfigSgcp:networkservices/ServiceLbPoliciesFailoverConfig:ServiceLbPoliciesFailoverConfigéOption to specify health based failover behavior. This is not related to Network load balancer FailoverPolicy.
Structure is documented below.
"ô
labelsB2" ÜSet of label tags associated with the ServiceLbPolicy resource.
**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"Â
loadBalancingAlgorithmB" ƒThe type of load balancing algorithm to be used. The default behavior is WATERFALL_BY_REGION.
Possible values are: `SPRAY_TO_REGION`, `SPRAY_TO_WORLD`, `WATERFALL_BY_REGION`, `WATERFALL_BY_ZONE`.
"?
location" /The location of the service lb policy.


- - -
"ú
name" èName of the ServiceLbPolicy resource. It matches pattern `projects/{project}/locations/{location}/serviceLbPolicies/{service_lb_policy_name}`.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"?

updateTime" -Time the ServiceLbPolicy was updated in UTC.
*öµ
B
networkservicesTcpRoute%gcp:networkservices/tcpRoute:TcpRoute⁄ú## Example Usage

### Network Services Tcp Route Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const defaultHttpHealthCheck = new gcp.compute.HttpHealthCheck("default", {
    name: "backend-service-health-check",
    requestPath: "/",
    checkIntervalSec: 1,
    timeoutSec: 1,
});
const _default = new gcp.compute.BackendService("default", {
    name: "my-backend-service",
    healthChecks: defaultHttpHealthCheck.id,
});
const defaultTcpRoute = new gcp.networkservices.TcpRoute("default", {
    name: "my-tcp-route",
    labels: {
        foo: "bar",
    },
    description: "my description",
    rules: [{
        matches: [{
            address: "10.0.0.1/32",
            port: "8081",
        }],
        action: {
            destinations: [{
                serviceName: _default.id,
                weight: 1,
            }],
            originalDestination: false,
        },
    }],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default_http_health_check = gcp.compute.HttpHealthCheck("default",
    name="backend-service-health-check",
    request_path="/",
    check_interval_sec=1,
    timeout_sec=1)
default = gcp.compute.BackendService("default",
    name="my-backend-service",
    health_checks=default_http_health_check.id)
default_tcp_route = gcp.networkservices.TcpRoute("default",
    name="my-tcp-route",
    labels={
        "foo": "bar",
    },
    description="my description",
    rules=[{
        "matches": [{
            "address": "10.0.0.1/32",
            "port": "8081",
        }],
        "action": {
            "destinations": [{
                "service_name": default.id,
                "weight": 1,
            }],
            "original_destination": False,
        },
    }])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var defaultHttpHealthCheck = new Gcp.Compute.HttpHealthCheck("default", new()
    {
        Name = "backend-service-health-check",
        RequestPath = "/",
        CheckIntervalSec = 1,
        TimeoutSec = 1,
    });

    var @default = new Gcp.Compute.BackendService("default", new()
    {
        Name = "my-backend-service",
        HealthChecks = defaultHttpHealthCheck.Id,
    });

    var defaultTcpRoute = new Gcp.NetworkServices.TcpRoute("default", new()
    {
        Name = "my-tcp-route",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        Rules = new[]
        {
            new Gcp.NetworkServices.Inputs.TcpRouteRuleArgs
            {
                Matches = new[]
                {
                    new Gcp.NetworkServices.Inputs.TcpRouteRuleMatchArgs
                    {
                        Address = "10.0.0.1/32",
                        Port = "8081",
                    },
                },
                Action = new Gcp.NetworkServices.Inputs.TcpRouteRuleActionArgs
                {
                    Destinations = new[]
                    {
                        new Gcp.NetworkServices.Inputs.TcpRouteRuleActionDestinationArgs
                        {
                            ServiceName = @default.Id,
                            Weight = 1,
                        },
                    },
                    OriginalDestination = false,
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		defaultHttpHealthCheck, err := compute.NewHttpHealthCheck(ctx, "default", &compute.HttpHealthCheckArgs{
			Name:             pulumi.String("backend-service-health-check"),
			RequestPath:      pulumi.String("/"),
			CheckIntervalSec: pulumi.Int(1),
			TimeoutSec:       pulumi.Int(1),
		})
		if err != nil {
			return err
		}
		_, err = compute.NewBackendService(ctx, "default", &compute.BackendServiceArgs{
			Name:         pulumi.String("my-backend-service"),
			HealthChecks: defaultHttpHealthCheck.ID(),
		})
		if err != nil {
			return err
		}
		_, err = networkservices.NewTcpRoute(ctx, "default", &networkservices.TcpRouteArgs{
			Name: pulumi.String("my-tcp-route"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			Rules: networkservices.TcpRouteRuleArray{
				&networkservices.TcpRouteRuleArgs{
					Matches: networkservices.TcpRouteRuleMatchArray{
						&networkservices.TcpRouteRuleMatchArgs{
							Address: pulumi.String("10.0.0.1/32"),
							Port:    pulumi.String("8081"),
						},
					},
					Action: &networkservices.TcpRouteRuleActionArgs{
						Destinations: networkservices.TcpRouteRuleActionDestinationArray{
							&networkservices.TcpRouteRuleActionDestinationArgs{
								ServiceName: _default.ID(),
								Weight:      pulumi.Int(1),
							},
						},
						OriginalDestination: pulumi.Bool(false),
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.HttpHealthCheck;
import com.pulumi.gcp.compute.HttpHealthCheckArgs;
import com.pulumi.gcp.compute.BackendService;
import com.pulumi.gcp.compute.BackendServiceArgs;
import com.pulumi.gcp.networkservices.TcpRoute;
import com.pulumi.gcp.networkservices.TcpRouteArgs;
import com.pulumi.gcp.networkservices.inputs.TcpRouteRuleArgs;
import com.pulumi.gcp.networkservices.inputs.TcpRouteRuleActionArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var defaultHttpHealthCheck = new HttpHealthCheck("defaultHttpHealthCheck", HttpHealthCheckArgs.builder()
            .name("backend-service-health-check")
            .requestPath("/")
            .checkIntervalSec(1)
            .timeoutSec(1)
            .build());

        var default_ = new BackendService("default", BackendServiceArgs.builder()
            .name("my-backend-service")
            .healthChecks(defaultHttpHealthCheck.id())
            .build());

        var defaultTcpRoute = new TcpRoute("defaultTcpRoute", TcpRouteArgs.builder()
            .name("my-tcp-route")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .rules(TcpRouteRuleArgs.builder()
                .matches(TcpRouteRuleMatchArgs.builder()
                    .address("10.0.0.1/32")
                    .port("8081")
                    .build())
                .action(TcpRouteRuleActionArgs.builder()
                    .destinations(TcpRouteRuleActionDestinationArgs.builder()
                        .serviceName(default_.id())
                        .weight(1)
                        .build())
                    .originalDestination(false)
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:compute:BackendService
    properties:
      name: my-backend-service
      healthChecks: ${defaultHttpHealthCheck.id}
  defaultHttpHealthCheck:
    type: gcp:compute:HttpHealthCheck
    name: default
    properties:
      name: backend-service-health-check
      requestPath: /
      checkIntervalSec: 1
      timeoutSec: 1
  defaultTcpRoute:
    type: gcp:networkservices:TcpRoute
    name: default
    properties:
      name: my-tcp-route
      labels:
        foo: bar
      description: my description
      rules:
        - matches:
            - address: 10.0.0.1/32
              port: '8081'
          action:
            destinations:
              - serviceName: ${default.id}
                weight: 1
            originalDestination: false
```
<!--End PulumiCodeChooser -->
### Network Services Tcp Route Actions


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const defaultHttpHealthCheck = new gcp.compute.HttpHealthCheck("default", {
    name: "backend-service-health-check",
    requestPath: "/",
    checkIntervalSec: 1,
    timeoutSec: 1,
});
const _default = new gcp.compute.BackendService("default", {
    name: "my-backend-service",
    healthChecks: defaultHttpHealthCheck.id,
});
const defaultTcpRoute = new gcp.networkservices.TcpRoute("default", {
    name: "my-tcp-route",
    labels: {
        foo: "bar",
    },
    description: "my description",
    rules: [{
        action: {
            destinations: [{
                serviceName: _default.id,
                weight: 1,
            }],
            originalDestination: false,
            idleTimeout: "60s",
        },
    }],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default_http_health_check = gcp.compute.HttpHealthCheck("default",
    name="backend-service-health-check",
    request_path="/",
    check_interval_sec=1,
    timeout_sec=1)
default = gcp.compute.BackendService("default",
    name="my-backend-service",
    health_checks=default_http_health_check.id)
default_tcp_route = gcp.networkservices.TcpRoute("default",
    name="my-tcp-route",
    labels={
        "foo": "bar",
    },
    description="my description",
    rules=[{
        "action": {
            "destinations": [{
                "service_name": default.id,
                "weight": 1,
            }],
            "original_destination": False,
            "idle_timeout": "60s",
        },
    }])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var defaultHttpHealthCheck = new Gcp.Compute.HttpHealthCheck("default", new()
    {
        Name = "backend-service-health-check",
        RequestPath = "/",
        CheckIntervalSec = 1,
        TimeoutSec = 1,
    });

    var @default = new Gcp.Compute.BackendService("default", new()
    {
        Name = "my-backend-service",
        HealthChecks = defaultHttpHealthCheck.Id,
    });

    var defaultTcpRoute = new Gcp.NetworkServices.TcpRoute("default", new()
    {
        Name = "my-tcp-route",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        Rules = new[]
        {
            new Gcp.NetworkServices.Inputs.TcpRouteRuleArgs
            {
                Action = new Gcp.NetworkServices.Inputs.TcpRouteRuleActionArgs
                {
                    Destinations = new[]
                    {
                        new Gcp.NetworkServices.Inputs.TcpRouteRuleActionDestinationArgs
                        {
                            ServiceName = @default.Id,
                            Weight = 1,
                        },
                    },
                    OriginalDestination = false,
                    IdleTimeout = "60s",
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		defaultHttpHealthCheck, err := compute.NewHttpHealthCheck(ctx, "default", &compute.HttpHealthCheckArgs{
			Name:             pulumi.String("backend-service-health-check"),
			RequestPath:      pulumi.String("/"),
			CheckIntervalSec: pulumi.Int(1),
			TimeoutSec:       pulumi.Int(1),
		})
		if err != nil {
			return err
		}
		_, err = compute.NewBackendService(ctx, "default", &compute.BackendServiceArgs{
			Name:         pulumi.String("my-backend-service"),
			HealthChecks: defaultHttpHealthCheck.ID(),
		})
		if err != nil {
			return err
		}
		_, err = networkservices.NewTcpRoute(ctx, "default", &networkservices.TcpRouteArgs{
			Name: pulumi.String("my-tcp-route"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			Rules: networkservices.TcpRouteRuleArray{
				&networkservices.TcpRouteRuleArgs{
					Action: &networkservices.TcpRouteRuleActionArgs{
						Destinations: networkservices.TcpRouteRuleActionDestinationArray{
							&networkservices.TcpRouteRuleActionDestinationArgs{
								ServiceName: _default.ID(),
								Weight:      pulumi.Int(1),
							},
						},
						OriginalDestination: pulumi.Bool(false),
						IdleTimeout:         pulumi.String("60s"),
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.HttpHealthCheck;
import com.pulumi.gcp.compute.HttpHealthCheckArgs;
import com.pulumi.gcp.compute.BackendService;
import com.pulumi.gcp.compute.BackendServiceArgs;
import com.pulumi.gcp.networkservices.TcpRoute;
import com.pulumi.gcp.networkservices.TcpRouteArgs;
import com.pulumi.gcp.networkservices.inputs.TcpRouteRuleArgs;
import com.pulumi.gcp.networkservices.inputs.TcpRouteRuleActionArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var defaultHttpHealthCheck = new HttpHealthCheck("defaultHttpHealthCheck", HttpHealthCheckArgs.builder()
            .name("backend-service-health-check")
            .requestPath("/")
            .checkIntervalSec(1)
            .timeoutSec(1)
            .build());

        var default_ = new BackendService("default", BackendServiceArgs.builder()
            .name("my-backend-service")
            .healthChecks(defaultHttpHealthCheck.id())
            .build());

        var defaultTcpRoute = new TcpRoute("defaultTcpRoute", TcpRouteArgs.builder()
            .name("my-tcp-route")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .rules(TcpRouteRuleArgs.builder()
                .action(TcpRouteRuleActionArgs.builder()
                    .destinations(TcpRouteRuleActionDestinationArgs.builder()
                        .serviceName(default_.id())
                        .weight(1)
                        .build())
                    .originalDestination(false)
                    .idleTimeout("60s")
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:compute:BackendService
    properties:
      name: my-backend-service
      healthChecks: ${defaultHttpHealthCheck.id}
  defaultHttpHealthCheck:
    type: gcp:compute:HttpHealthCheck
    name: default
    properties:
      name: backend-service-health-check
      requestPath: /
      checkIntervalSec: 1
      timeoutSec: 1
  defaultTcpRoute:
    type: gcp:networkservices:TcpRoute
    name: default
    properties:
      name: my-tcp-route
      labels:
        foo: bar
      description: my description
      rules:
        - action:
            destinations:
              - serviceName: ${default.id}
                weight: 1
            originalDestination: false
            idleTimeout: 60s
```
<!--End PulumiCodeChooser -->
### Network Services Tcp Route Mesh Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const defaultHttpHealthCheck = new gcp.compute.HttpHealthCheck("default", {
    name: "backend-service-health-check",
    requestPath: "/",
    checkIntervalSec: 1,
    timeoutSec: 1,
});
const _default = new gcp.compute.BackendService("default", {
    name: "my-backend-service",
    healthChecks: defaultHttpHealthCheck.id,
});
const defaultMesh = new gcp.networkservices.Mesh("default", {
    name: "my-tcp-route",
    labels: {
        foo: "bar",
    },
    description: "my description",
});
const defaultTcpRoute = new gcp.networkservices.TcpRoute("default", {
    name: "my-tcp-route",
    labels: {
        foo: "bar",
    },
    description: "my description",
    meshes: [defaultMesh.id],
    rules: [{
        matches: [{
            address: "10.0.0.1/32",
            port: "8081",
        }],
        action: {
            destinations: [{
                serviceName: _default.id,
                weight: 1,
            }],
            originalDestination: false,
        },
    }],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default_http_health_check = gcp.compute.HttpHealthCheck("default",
    name="backend-service-health-check",
    request_path="/",
    check_interval_sec=1,
    timeout_sec=1)
default = gcp.compute.BackendService("default",
    name="my-backend-service",
    health_checks=default_http_health_check.id)
default_mesh = gcp.networkservices.Mesh("default",
    name="my-tcp-route",
    labels={
        "foo": "bar",
    },
    description="my description")
default_tcp_route = gcp.networkservices.TcpRoute("default",
    name="my-tcp-route",
    labels={
        "foo": "bar",
    },
    description="my description",
    meshes=[default_mesh.id],
    rules=[{
        "matches": [{
            "address": "10.0.0.1/32",
            "port": "8081",
        }],
        "action": {
            "destinations": [{
                "service_name": default.id,
                "weight": 1,
            }],
            "original_destination": False,
        },
    }])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var defaultHttpHealthCheck = new Gcp.Compute.HttpHealthCheck("default", new()
    {
        Name = "backend-service-health-check",
        RequestPath = "/",
        CheckIntervalSec = 1,
        TimeoutSec = 1,
    });

    var @default = new Gcp.Compute.BackendService("default", new()
    {
        Name = "my-backend-service",
        HealthChecks = defaultHttpHealthCheck.Id,
    });

    var defaultMesh = new Gcp.NetworkServices.Mesh("default", new()
    {
        Name = "my-tcp-route",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
    });

    var defaultTcpRoute = new Gcp.NetworkServices.TcpRoute("default", new()
    {
        Name = "my-tcp-route",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        Meshes = new[]
        {
            defaultMesh.Id,
        },
        Rules = new[]
        {
            new Gcp.NetworkServices.Inputs.TcpRouteRuleArgs
            {
                Matches = new[]
                {
                    new Gcp.NetworkServices.Inputs.TcpRouteRuleMatchArgs
                    {
                        Address = "10.0.0.1/32",
                        Port = "8081",
                    },
                },
                Action = new Gcp.NetworkServices.Inputs.TcpRouteRuleActionArgs
                {
                    Destinations = new[]
                    {
                        new Gcp.NetworkServices.Inputs.TcpRouteRuleActionDestinationArgs
                        {
                            ServiceName = @default.Id,
                            Weight = 1,
                        },
                    },
                    OriginalDestination = false,
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		defaultHttpHealthCheck, err := compute.NewHttpHealthCheck(ctx, "default", &compute.HttpHealthCheckArgs{
			Name:             pulumi.String("backend-service-health-check"),
			RequestPath:      pulumi.String("/"),
			CheckIntervalSec: pulumi.Int(1),
			TimeoutSec:       pulumi.Int(1),
		})
		if err != nil {
			return err
		}
		_, err = compute.NewBackendService(ctx, "default", &compute.BackendServiceArgs{
			Name:         pulumi.String("my-backend-service"),
			HealthChecks: defaultHttpHealthCheck.ID(),
		})
		if err != nil {
			return err
		}
		defaultMesh, err := networkservices.NewMesh(ctx, "default", &networkservices.MeshArgs{
			Name: pulumi.String("my-tcp-route"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
		})
		if err != nil {
			return err
		}
		_, err = networkservices.NewTcpRoute(ctx, "default", &networkservices.TcpRouteArgs{
			Name: pulumi.String("my-tcp-route"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			Meshes: pulumi.StringArray{
				defaultMesh.ID(),
			},
			Rules: networkservices.TcpRouteRuleArray{
				&networkservices.TcpRouteRuleArgs{
					Matches: networkservices.TcpRouteRuleMatchArray{
						&networkservices.TcpRouteRuleMatchArgs{
							Address: pulumi.String("10.0.0.1/32"),
							Port:    pulumi.String("8081"),
						},
					},
					Action: &networkservices.TcpRouteRuleActionArgs{
						Destinations: networkservices.TcpRouteRuleActionDestinationArray{
							&networkservices.TcpRouteRuleActionDestinationArgs{
								ServiceName: _default.ID(),
								Weight:      pulumi.Int(1),
							},
						},
						OriginalDestination: pulumi.Bool(false),
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.HttpHealthCheck;
import com.pulumi.gcp.compute.HttpHealthCheckArgs;
import com.pulumi.gcp.compute.BackendService;
import com.pulumi.gcp.compute.BackendServiceArgs;
import com.pulumi.gcp.networkservices.Mesh;
import com.pulumi.gcp.networkservices.MeshArgs;
import com.pulumi.gcp.networkservices.TcpRoute;
import com.pulumi.gcp.networkservices.TcpRouteArgs;
import com.pulumi.gcp.networkservices.inputs.TcpRouteRuleArgs;
import com.pulumi.gcp.networkservices.inputs.TcpRouteRuleActionArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var defaultHttpHealthCheck = new HttpHealthCheck("defaultHttpHealthCheck", HttpHealthCheckArgs.builder()
            .name("backend-service-health-check")
            .requestPath("/")
            .checkIntervalSec(1)
            .timeoutSec(1)
            .build());

        var default_ = new BackendService("default", BackendServiceArgs.builder()
            .name("my-backend-service")
            .healthChecks(defaultHttpHealthCheck.id())
            .build());

        var defaultMesh = new Mesh("defaultMesh", MeshArgs.builder()
            .name("my-tcp-route")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .build());

        var defaultTcpRoute = new TcpRoute("defaultTcpRoute", TcpRouteArgs.builder()
            .name("my-tcp-route")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .meshes(defaultMesh.id())
            .rules(TcpRouteRuleArgs.builder()
                .matches(TcpRouteRuleMatchArgs.builder()
                    .address("10.0.0.1/32")
                    .port("8081")
                    .build())
                .action(TcpRouteRuleActionArgs.builder()
                    .destinations(TcpRouteRuleActionDestinationArgs.builder()
                        .serviceName(default_.id())
                        .weight(1)
                        .build())
                    .originalDestination(false)
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:compute:BackendService
    properties:
      name: my-backend-service
      healthChecks: ${defaultHttpHealthCheck.id}
  defaultHttpHealthCheck:
    type: gcp:compute:HttpHealthCheck
    name: default
    properties:
      name: backend-service-health-check
      requestPath: /
      checkIntervalSec: 1
      timeoutSec: 1
  defaultMesh:
    type: gcp:networkservices:Mesh
    name: default
    properties:
      name: my-tcp-route
      labels:
        foo: bar
      description: my description
  defaultTcpRoute:
    type: gcp:networkservices:TcpRoute
    name: default
    properties:
      name: my-tcp-route
      labels:
        foo: bar
      description: my description
      meshes:
        - ${defaultMesh.id}
      rules:
        - matches:
            - address: 10.0.0.1/32
              port: '8081'
          action:
            destinations:
              - serviceName: ${default.id}
                weight: 1
            originalDestination: false
```
<!--End PulumiCodeChooser -->
### Network Services Tcp Route Gateway Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const defaultHttpHealthCheck = new gcp.compute.HttpHealthCheck("default", {
    name: "backend-service-health-check",
    requestPath: "/",
    checkIntervalSec: 1,
    timeoutSec: 1,
});
const _default = new gcp.compute.BackendService("default", {
    name: "my-backend-service",
    healthChecks: defaultHttpHealthCheck.id,
});
const defaultGateway = new gcp.networkservices.Gateway("default", {
    name: "my-tcp-route",
    labels: {
        foo: "bar",
    },
    description: "my description",
    scope: "my-scope",
    type: "OPEN_MESH",
    ports: [443],
});
const defaultTcpRoute = new gcp.networkservices.TcpRoute("default", {
    name: "my-tcp-route",
    labels: {
        foo: "bar",
    },
    description: "my description",
    gateways: [defaultGateway.id],
    rules: [{
        matches: [{
            address: "10.0.0.1/32",
            port: "8081",
        }],
        action: {
            destinations: [{
                serviceName: _default.id,
                weight: 1,
            }],
            originalDestination: false,
        },
    }],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default_http_health_check = gcp.compute.HttpHealthCheck("default",
    name="backend-service-health-check",
    request_path="/",
    check_interval_sec=1,
    timeout_sec=1)
default = gcp.compute.BackendService("default",
    name="my-backend-service",
    health_checks=default_http_health_check.id)
default_gateway = gcp.networkservices.Gateway("default",
    name="my-tcp-route",
    labels={
        "foo": "bar",
    },
    description="my description",
    scope="my-scope",
    type="OPEN_MESH",
    ports=[443])
default_tcp_route = gcp.networkservices.TcpRoute("default",
    name="my-tcp-route",
    labels={
        "foo": "bar",
    },
    description="my description",
    gateways=[default_gateway.id],
    rules=[{
        "matches": [{
            "address": "10.0.0.1/32",
            "port": "8081",
        }],
        "action": {
            "destinations": [{
                "service_name": default.id,
                "weight": 1,
            }],
            "original_destination": False,
        },
    }])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var defaultHttpHealthCheck = new Gcp.Compute.HttpHealthCheck("default", new()
    {
        Name = "backend-service-health-check",
        RequestPath = "/",
        CheckIntervalSec = 1,
        TimeoutSec = 1,
    });

    var @default = new Gcp.Compute.BackendService("default", new()
    {
        Name = "my-backend-service",
        HealthChecks = defaultHttpHealthCheck.Id,
    });

    var defaultGateway = new Gcp.NetworkServices.Gateway("default", new()
    {
        Name = "my-tcp-route",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        Scope = "my-scope",
        Type = "OPEN_MESH",
        Ports = new[]
        {
            443,
        },
    });

    var defaultTcpRoute = new Gcp.NetworkServices.TcpRoute("default", new()
    {
        Name = "my-tcp-route",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        Gateways = new[]
        {
            defaultGateway.Id,
        },
        Rules = new[]
        {
            new Gcp.NetworkServices.Inputs.TcpRouteRuleArgs
            {
                Matches = new[]
                {
                    new Gcp.NetworkServices.Inputs.TcpRouteRuleMatchArgs
                    {
                        Address = "10.0.0.1/32",
                        Port = "8081",
                    },
                },
                Action = new Gcp.NetworkServices.Inputs.TcpRouteRuleActionArgs
                {
                    Destinations = new[]
                    {
                        new Gcp.NetworkServices.Inputs.TcpRouteRuleActionDestinationArgs
                        {
                            ServiceName = @default.Id,
                            Weight = 1,
                        },
                    },
                    OriginalDestination = false,
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		defaultHttpHealthCheck, err := compute.NewHttpHealthCheck(ctx, "default", &compute.HttpHealthCheckArgs{
			Name:             pulumi.String("backend-service-health-check"),
			RequestPath:      pulumi.String("/"),
			CheckIntervalSec: pulumi.Int(1),
			TimeoutSec:       pulumi.Int(1),
		})
		if err != nil {
			return err
		}
		_, err = compute.NewBackendService(ctx, "default", &compute.BackendServiceArgs{
			Name:         pulumi.String("my-backend-service"),
			HealthChecks: defaultHttpHealthCheck.ID(),
		})
		if err != nil {
			return err
		}
		defaultGateway, err := networkservices.NewGateway(ctx, "default", &networkservices.GatewayArgs{
			Name: pulumi.String("my-tcp-route"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			Scope:       pulumi.String("my-scope"),
			Type:        pulumi.String("OPEN_MESH"),
			Ports: pulumi.IntArray{
				pulumi.Int(443),
			},
		})
		if err != nil {
			return err
		}
		_, err = networkservices.NewTcpRoute(ctx, "default", &networkservices.TcpRouteArgs{
			Name: pulumi.String("my-tcp-route"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			Gateways: pulumi.StringArray{
				defaultGateway.ID(),
			},
			Rules: networkservices.TcpRouteRuleArray{
				&networkservices.TcpRouteRuleArgs{
					Matches: networkservices.TcpRouteRuleMatchArray{
						&networkservices.TcpRouteRuleMatchArgs{
							Address: pulumi.String("10.0.0.1/32"),
							Port:    pulumi.String("8081"),
						},
					},
					Action: &networkservices.TcpRouteRuleActionArgs{
						Destinations: networkservices.TcpRouteRuleActionDestinationArray{
							&networkservices.TcpRouteRuleActionDestinationArgs{
								ServiceName: _default.ID(),
								Weight:      pulumi.Int(1),
							},
						},
						OriginalDestination: pulumi.Bool(false),
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.HttpHealthCheck;
import com.pulumi.gcp.compute.HttpHealthCheckArgs;
import com.pulumi.gcp.compute.BackendService;
import com.pulumi.gcp.compute.BackendServiceArgs;
import com.pulumi.gcp.networkservices.Gateway;
import com.pulumi.gcp.networkservices.GatewayArgs;
import com.pulumi.gcp.networkservices.TcpRoute;
import com.pulumi.gcp.networkservices.TcpRouteArgs;
import com.pulumi.gcp.networkservices.inputs.TcpRouteRuleArgs;
import com.pulumi.gcp.networkservices.inputs.TcpRouteRuleActionArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var defaultHttpHealthCheck = new HttpHealthCheck("defaultHttpHealthCheck", HttpHealthCheckArgs.builder()
            .name("backend-service-health-check")
            .requestPath("/")
            .checkIntervalSec(1)
            .timeoutSec(1)
            .build());

        var default_ = new BackendService("default", BackendServiceArgs.builder()
            .name("my-backend-service")
            .healthChecks(defaultHttpHealthCheck.id())
            .build());

        var defaultGateway = new Gateway("defaultGateway", GatewayArgs.builder()
            .name("my-tcp-route")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .scope("my-scope")
            .type("OPEN_MESH")
            .ports(443)
            .build());

        var defaultTcpRoute = new TcpRoute("defaultTcpRoute", TcpRouteArgs.builder()
            .name("my-tcp-route")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .gateways(defaultGateway.id())
            .rules(TcpRouteRuleArgs.builder()
                .matches(TcpRouteRuleMatchArgs.builder()
                    .address("10.0.0.1/32")
                    .port("8081")
                    .build())
                .action(TcpRouteRuleActionArgs.builder()
                    .destinations(TcpRouteRuleActionDestinationArgs.builder()
                        .serviceName(default_.id())
                        .weight(1)
                        .build())
                    .originalDestination(false)
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:compute:BackendService
    properties:
      name: my-backend-service
      healthChecks: ${defaultHttpHealthCheck.id}
  defaultHttpHealthCheck:
    type: gcp:compute:HttpHealthCheck
    name: default
    properties:
      name: backend-service-health-check
      requestPath: /
      checkIntervalSec: 1
      timeoutSec: 1
  defaultGateway:
    type: gcp:networkservices:Gateway
    name: default
    properties:
      name: my-tcp-route
      labels:
        foo: bar
      description: my description
      scope: my-scope
      type: OPEN_MESH
      ports:
        - 443
  defaultTcpRoute:
    type: gcp:networkservices:TcpRoute
    name: default
    properties:
      name: my-tcp-route
      labels:
        foo: bar
      description: my description
      gateways:
        - ${defaultGateway.id}
      rules:
        - matches:
            - address: 10.0.0.1/32
              port: '8081'
          action:
            destinations:
              - serviceName: ${default.id}
                weight: 1
            originalDestination: false
```
<!--End PulumiCodeChooser -->

## Import

TcpRoute can be imported using any of these accepted formats:

* `projects/{{project}}/locations/global/tcpRoutes/{{name}}`

* `{{project}}/{{name}}`

* `{{name}}`

When using the `pulumi import` command, TcpRoute can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkservices/tcpRoute:TcpRoute default projects/{{project}}/locations/global/tcpRoutes/{{name}}
```

```sh
$ pulumi import gcp:networkservices/tcpRoute:TcpRoute default {{project}}/{{name}}
```

```sh
$ pulumi import gcp:networkservices/tcpRoute:TcpRoute default {{name}}
```

Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
Ö
gatewaysB*" Gateways defines a list of gateways this TcpRoute is attached to, as one of the routing rules to route the requests
served by the gateway. Each gateway reference should match the pattern:
projects/*/locations/global/gateways/<gateway_name>
í
labelsB2" ˇSet of label tags associated with the TcpRoute resource. **Note**: This field is non-authoritative, and will only manage
the labels present in your configuration. Please refer to the field 'effective_labels' for all of the labels present on
the resource.
¢
meshesB*" èMeshes defines a list of meshes this TcpRoute is attached to, as one of the routing rules to route the requests served
by the mesh. Each mesh reference should match the pattern: projects/*/locations/global/meshes/<mesh_name> The attached
Mesh should be of a type SIDECAR
-
nameB" Name of the TcpRoute resource.

projectB" ∞
rulesT*R:P
N
networkservicesTcpRouteRule-gcp:networkservices/TcpRouteRule:TcpRouteRule–Rules that define how traffic is routed and handled. At least one RouteRule must be supplied.
If there are multiple rules then the action taken will be the first rule to match.
Structure is documented below.
"8

createTime" &Time the TcpRoute was created in UTC.
"Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"Ö
gatewaysB*" Gateways defines a list of gateways this TcpRoute is attached to, as one of the routing rules to route the requests
served by the gateway. Each gateway reference should match the pattern:
projects/*/locations/global/gateways/<gateway_name>
"í
labelsB2" ˇSet of label tags associated with the TcpRoute resource. **Note**: This field is non-authoritative, and will only manage
the labels present in your configuration. Please refer to the field 'effective_labels' for all of the labels present on
the resource.
"¢
meshesB*" èMeshes defines a list of meshes this TcpRoute is attached to, as one of the routing rules to route the requests served
by the mesh. Each mesh reference should match the pattern: projects/*/locations/global/meshes/<mesh_name> The attached
Mesh should be of a type SIDECAR
"+
name" Name of the TcpRoute resource.
"
project" "É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"∞
rulesT*R:P
N
networkservicesTcpRouteRule-gcp:networkservices/TcpRouteRule:TcpRouteRule–Rules that define how traffic is routed and handled. At least one RouteRule must be supplied.
If there are multiple rules then the action taken will be the first rule to match.
Structure is documented below.
"5
selfLink" %Server-defined URL of this resource.
"8

updateTime" &Time the TcpRoute was updated in UTC.
*‹Ï
B
networkservicesTlsRoute%gcp:networkservices/tlsRoute:TlsRouteÔ‹## Example Usage

### Network Services Tls Route Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const defaultHttpHealthCheck = new gcp.compute.HttpHealthCheck("default", {
    name: "backend-service-health-check",
    requestPath: "/",
    checkIntervalSec: 1,
    timeoutSec: 1,
});
const _default = new gcp.compute.BackendService("default", {
    name: "my-backend-service",
    healthChecks: defaultHttpHealthCheck.id,
});
const defaultTlsRoute = new gcp.networkservices.TlsRoute("default", {
    name: "my-tls-route",
    description: "my description",
    rules: [{
        matches: [{
            sniHosts: ["example.com"],
            alpns: ["http/1.1"],
        }],
        action: {
            destinations: [{
                serviceName: _default.id,
                weight: 1,
            }],
        },
    }],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default_http_health_check = gcp.compute.HttpHealthCheck("default",
    name="backend-service-health-check",
    request_path="/",
    check_interval_sec=1,
    timeout_sec=1)
default = gcp.compute.BackendService("default",
    name="my-backend-service",
    health_checks=default_http_health_check.id)
default_tls_route = gcp.networkservices.TlsRoute("default",
    name="my-tls-route",
    description="my description",
    rules=[{
        "matches": [{
            "sni_hosts": ["example.com"],
            "alpns": ["http/1.1"],
        }],
        "action": {
            "destinations": [{
                "service_name": default.id,
                "weight": 1,
            }],
        },
    }])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var defaultHttpHealthCheck = new Gcp.Compute.HttpHealthCheck("default", new()
    {
        Name = "backend-service-health-check",
        RequestPath = "/",
        CheckIntervalSec = 1,
        TimeoutSec = 1,
    });

    var @default = new Gcp.Compute.BackendService("default", new()
    {
        Name = "my-backend-service",
        HealthChecks = defaultHttpHealthCheck.Id,
    });

    var defaultTlsRoute = new Gcp.NetworkServices.TlsRoute("default", new()
    {
        Name = "my-tls-route",
        Description = "my description",
        Rules = new[]
        {
            new Gcp.NetworkServices.Inputs.TlsRouteRuleArgs
            {
                Matches = new[]
                {
                    new Gcp.NetworkServices.Inputs.TlsRouteRuleMatchArgs
                    {
                        SniHosts = new[]
                        {
                            "example.com",
                        },
                        Alpns = new[]
                        {
                            "http/1.1",
                        },
                    },
                },
                Action = new Gcp.NetworkServices.Inputs.TlsRouteRuleActionArgs
                {
                    Destinations = new[]
                    {
                        new Gcp.NetworkServices.Inputs.TlsRouteRuleActionDestinationArgs
                        {
                            ServiceName = @default.Id,
                            Weight = 1,
                        },
                    },
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		defaultHttpHealthCheck, err := compute.NewHttpHealthCheck(ctx, "default", &compute.HttpHealthCheckArgs{
			Name:             pulumi.String("backend-service-health-check"),
			RequestPath:      pulumi.String("/"),
			CheckIntervalSec: pulumi.Int(1),
			TimeoutSec:       pulumi.Int(1),
		})
		if err != nil {
			return err
		}
		_, err = compute.NewBackendService(ctx, "default", &compute.BackendServiceArgs{
			Name:         pulumi.String("my-backend-service"),
			HealthChecks: defaultHttpHealthCheck.ID(),
		})
		if err != nil {
			return err
		}
		_, err = networkservices.NewTlsRoute(ctx, "default", &networkservices.TlsRouteArgs{
			Name:        pulumi.String("my-tls-route"),
			Description: pulumi.String("my description"),
			Rules: networkservices.TlsRouteRuleArray{
				&networkservices.TlsRouteRuleArgs{
					Matches: networkservices.TlsRouteRuleMatchArray{
						&networkservices.TlsRouteRuleMatchArgs{
							SniHosts: pulumi.StringArray{
								pulumi.String("example.com"),
							},
							Alpns: pulumi.StringArray{
								pulumi.String("http/1.1"),
							},
						},
					},
					Action: &networkservices.TlsRouteRuleActionArgs{
						Destinations: networkservices.TlsRouteRuleActionDestinationArray{
							&networkservices.TlsRouteRuleActionDestinationArgs{
								ServiceName: _default.ID(),
								Weight:      pulumi.Int(1),
							},
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.HttpHealthCheck;
import com.pulumi.gcp.compute.HttpHealthCheckArgs;
import com.pulumi.gcp.compute.BackendService;
import com.pulumi.gcp.compute.BackendServiceArgs;
import com.pulumi.gcp.networkservices.TlsRoute;
import com.pulumi.gcp.networkservices.TlsRouteArgs;
import com.pulumi.gcp.networkservices.inputs.TlsRouteRuleArgs;
import com.pulumi.gcp.networkservices.inputs.TlsRouteRuleActionArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var defaultHttpHealthCheck = new HttpHealthCheck("defaultHttpHealthCheck", HttpHealthCheckArgs.builder()
            .name("backend-service-health-check")
            .requestPath("/")
            .checkIntervalSec(1)
            .timeoutSec(1)
            .build());

        var default_ = new BackendService("default", BackendServiceArgs.builder()
            .name("my-backend-service")
            .healthChecks(defaultHttpHealthCheck.id())
            .build());

        var defaultTlsRoute = new TlsRoute("defaultTlsRoute", TlsRouteArgs.builder()
            .name("my-tls-route")
            .description("my description")
            .rules(TlsRouteRuleArgs.builder()
                .matches(TlsRouteRuleMatchArgs.builder()
                    .sniHosts("example.com")
                    .alpns("http/1.1")
                    .build())
                .action(TlsRouteRuleActionArgs.builder()
                    .destinations(TlsRouteRuleActionDestinationArgs.builder()
                        .serviceName(default_.id())
                        .weight(1)
                        .build())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:compute:BackendService
    properties:
      name: my-backend-service
      healthChecks: ${defaultHttpHealthCheck.id}
  defaultHttpHealthCheck:
    type: gcp:compute:HttpHealthCheck
    name: default
    properties:
      name: backend-service-health-check
      requestPath: /
      checkIntervalSec: 1
      timeoutSec: 1
  defaultTlsRoute:
    type: gcp:networkservices:TlsRoute
    name: default
    properties:
      name: my-tls-route
      description: my description
      rules:
        - matches:
            - sniHosts:
                - example.com
              alpns:
                - http/1.1
          action:
            destinations:
              - serviceName: ${default.id}
                weight: 1
```
<!--End PulumiCodeChooser -->
### Network Services Tls Route Mesh Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const defaultHttpHealthCheck = new gcp.compute.HttpHealthCheck("default", {
    name: "backend-service-health-check",
    requestPath: "/",
    checkIntervalSec: 1,
    timeoutSec: 1,
});
const _default = new gcp.compute.BackendService("default", {
    name: "my-backend-service",
    healthChecks: defaultHttpHealthCheck.id,
});
const defaultMesh = new gcp.networkservices.Mesh("default", {
    name: "my-tls-route",
    labels: {
        foo: "bar",
    },
    description: "my description",
});
const defaultTlsRoute = new gcp.networkservices.TlsRoute("default", {
    name: "my-tls-route",
    description: "my description",
    meshes: [defaultMesh.id],
    rules: [{
        matches: [{
            sniHosts: ["example.com"],
            alpns: ["http/1.1"],
        }],
        action: {
            destinations: [{
                serviceName: _default.id,
                weight: 1,
            }],
        },
    }],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default_http_health_check = gcp.compute.HttpHealthCheck("default",
    name="backend-service-health-check",
    request_path="/",
    check_interval_sec=1,
    timeout_sec=1)
default = gcp.compute.BackendService("default",
    name="my-backend-service",
    health_checks=default_http_health_check.id)
default_mesh = gcp.networkservices.Mesh("default",
    name="my-tls-route",
    labels={
        "foo": "bar",
    },
    description="my description")
default_tls_route = gcp.networkservices.TlsRoute("default",
    name="my-tls-route",
    description="my description",
    meshes=[default_mesh.id],
    rules=[{
        "matches": [{
            "sni_hosts": ["example.com"],
            "alpns": ["http/1.1"],
        }],
        "action": {
            "destinations": [{
                "service_name": default.id,
                "weight": 1,
            }],
        },
    }])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var defaultHttpHealthCheck = new Gcp.Compute.HttpHealthCheck("default", new()
    {
        Name = "backend-service-health-check",
        RequestPath = "/",
        CheckIntervalSec = 1,
        TimeoutSec = 1,
    });

    var @default = new Gcp.Compute.BackendService("default", new()
    {
        Name = "my-backend-service",
        HealthChecks = defaultHttpHealthCheck.Id,
    });

    var defaultMesh = new Gcp.NetworkServices.Mesh("default", new()
    {
        Name = "my-tls-route",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
    });

    var defaultTlsRoute = new Gcp.NetworkServices.TlsRoute("default", new()
    {
        Name = "my-tls-route",
        Description = "my description",
        Meshes = new[]
        {
            defaultMesh.Id,
        },
        Rules = new[]
        {
            new Gcp.NetworkServices.Inputs.TlsRouteRuleArgs
            {
                Matches = new[]
                {
                    new Gcp.NetworkServices.Inputs.TlsRouteRuleMatchArgs
                    {
                        SniHosts = new[]
                        {
                            "example.com",
                        },
                        Alpns = new[]
                        {
                            "http/1.1",
                        },
                    },
                },
                Action = new Gcp.NetworkServices.Inputs.TlsRouteRuleActionArgs
                {
                    Destinations = new[]
                    {
                        new Gcp.NetworkServices.Inputs.TlsRouteRuleActionDestinationArgs
                        {
                            ServiceName = @default.Id,
                            Weight = 1,
                        },
                    },
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		defaultHttpHealthCheck, err := compute.NewHttpHealthCheck(ctx, "default", &compute.HttpHealthCheckArgs{
			Name:             pulumi.String("backend-service-health-check"),
			RequestPath:      pulumi.String("/"),
			CheckIntervalSec: pulumi.Int(1),
			TimeoutSec:       pulumi.Int(1),
		})
		if err != nil {
			return err
		}
		_, err = compute.NewBackendService(ctx, "default", &compute.BackendServiceArgs{
			Name:         pulumi.String("my-backend-service"),
			HealthChecks: defaultHttpHealthCheck.ID(),
		})
		if err != nil {
			return err
		}
		defaultMesh, err := networkservices.NewMesh(ctx, "default", &networkservices.MeshArgs{
			Name: pulumi.String("my-tls-route"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
		})
		if err != nil {
			return err
		}
		_, err = networkservices.NewTlsRoute(ctx, "default", &networkservices.TlsRouteArgs{
			Name:        pulumi.String("my-tls-route"),
			Description: pulumi.String("my description"),
			Meshes: pulumi.StringArray{
				defaultMesh.ID(),
			},
			Rules: networkservices.TlsRouteRuleArray{
				&networkservices.TlsRouteRuleArgs{
					Matches: networkservices.TlsRouteRuleMatchArray{
						&networkservices.TlsRouteRuleMatchArgs{
							SniHosts: pulumi.StringArray{
								pulumi.String("example.com"),
							},
							Alpns: pulumi.StringArray{
								pulumi.String("http/1.1"),
							},
						},
					},
					Action: &networkservices.TlsRouteRuleActionArgs{
						Destinations: networkservices.TlsRouteRuleActionDestinationArray{
							&networkservices.TlsRouteRuleActionDestinationArgs{
								ServiceName: _default.ID(),
								Weight:      pulumi.Int(1),
							},
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.HttpHealthCheck;
import com.pulumi.gcp.compute.HttpHealthCheckArgs;
import com.pulumi.gcp.compute.BackendService;
import com.pulumi.gcp.compute.BackendServiceArgs;
import com.pulumi.gcp.networkservices.Mesh;
import com.pulumi.gcp.networkservices.MeshArgs;
import com.pulumi.gcp.networkservices.TlsRoute;
import com.pulumi.gcp.networkservices.TlsRouteArgs;
import com.pulumi.gcp.networkservices.inputs.TlsRouteRuleArgs;
import com.pulumi.gcp.networkservices.inputs.TlsRouteRuleActionArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var defaultHttpHealthCheck = new HttpHealthCheck("defaultHttpHealthCheck", HttpHealthCheckArgs.builder()
            .name("backend-service-health-check")
            .requestPath("/")
            .checkIntervalSec(1)
            .timeoutSec(1)
            .build());

        var default_ = new BackendService("default", BackendServiceArgs.builder()
            .name("my-backend-service")
            .healthChecks(defaultHttpHealthCheck.id())
            .build());

        var defaultMesh = new Mesh("defaultMesh", MeshArgs.builder()
            .name("my-tls-route")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .build());

        var defaultTlsRoute = new TlsRoute("defaultTlsRoute", TlsRouteArgs.builder()
            .name("my-tls-route")
            .description("my description")
            .meshes(defaultMesh.id())
            .rules(TlsRouteRuleArgs.builder()
                .matches(TlsRouteRuleMatchArgs.builder()
                    .sniHosts("example.com")
                    .alpns("http/1.1")
                    .build())
                .action(TlsRouteRuleActionArgs.builder()
                    .destinations(TlsRouteRuleActionDestinationArgs.builder()
                        .serviceName(default_.id())
                        .weight(1)
                        .build())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:compute:BackendService
    properties:
      name: my-backend-service
      healthChecks: ${defaultHttpHealthCheck.id}
  defaultHttpHealthCheck:
    type: gcp:compute:HttpHealthCheck
    name: default
    properties:
      name: backend-service-health-check
      requestPath: /
      checkIntervalSec: 1
      timeoutSec: 1
  defaultMesh:
    type: gcp:networkservices:Mesh
    name: default
    properties:
      name: my-tls-route
      labels:
        foo: bar
      description: my description
  defaultTlsRoute:
    type: gcp:networkservices:TlsRoute
    name: default
    properties:
      name: my-tls-route
      description: my description
      meshes:
        - ${defaultMesh.id}
      rules:
        - matches:
            - sniHosts:
                - example.com
              alpns:
                - http/1.1
          action:
            destinations:
              - serviceName: ${default.id}
                weight: 1
```
<!--End PulumiCodeChooser -->
### Network Services Tls Route Gateway Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const defaultHttpHealthCheck = new gcp.compute.HttpHealthCheck("default", {
    name: "backend-service-health-check",
    requestPath: "/",
    checkIntervalSec: 1,
    timeoutSec: 1,
});
const _default = new gcp.compute.BackendService("default", {
    name: "my-backend-service",
    healthChecks: defaultHttpHealthCheck.id,
});
const defaultGateway = new gcp.networkservices.Gateway("default", {
    name: "my-tls-route",
    labels: {
        foo: "bar",
    },
    description: "my description",
    scope: "my-scope",
    type: "OPEN_MESH",
    ports: [443],
});
const defaultTlsRoute = new gcp.networkservices.TlsRoute("default", {
    name: "my-tls-route",
    description: "my description",
    gateways: [defaultGateway.id],
    rules: [{
        matches: [{
            sniHosts: ["example.com"],
            alpns: ["http/1.1"],
        }],
        action: {
            destinations: [{
                serviceName: _default.id,
                weight: 1,
            }],
        },
    }],
});
```
```python
import pulumi
import pulumi_gcp as gcp

default_http_health_check = gcp.compute.HttpHealthCheck("default",
    name="backend-service-health-check",
    request_path="/",
    check_interval_sec=1,
    timeout_sec=1)
default = gcp.compute.BackendService("default",
    name="my-backend-service",
    health_checks=default_http_health_check.id)
default_gateway = gcp.networkservices.Gateway("default",
    name="my-tls-route",
    labels={
        "foo": "bar",
    },
    description="my description",
    scope="my-scope",
    type="OPEN_MESH",
    ports=[443])
default_tls_route = gcp.networkservices.TlsRoute("default",
    name="my-tls-route",
    description="my description",
    gateways=[default_gateway.id],
    rules=[{
        "matches": [{
            "sni_hosts": ["example.com"],
            "alpns": ["http/1.1"],
        }],
        "action": {
            "destinations": [{
                "service_name": default.id,
                "weight": 1,
            }],
        },
    }])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var defaultHttpHealthCheck = new Gcp.Compute.HttpHealthCheck("default", new()
    {
        Name = "backend-service-health-check",
        RequestPath = "/",
        CheckIntervalSec = 1,
        TimeoutSec = 1,
    });

    var @default = new Gcp.Compute.BackendService("default", new()
    {
        Name = "my-backend-service",
        HealthChecks = defaultHttpHealthCheck.Id,
    });

    var defaultGateway = new Gcp.NetworkServices.Gateway("default", new()
    {
        Name = "my-tls-route",
        Labels = 
        {
            { "foo", "bar" },
        },
        Description = "my description",
        Scope = "my-scope",
        Type = "OPEN_MESH",
        Ports = new[]
        {
            443,
        },
    });

    var defaultTlsRoute = new Gcp.NetworkServices.TlsRoute("default", new()
    {
        Name = "my-tls-route",
        Description = "my description",
        Gateways = new[]
        {
            defaultGateway.Id,
        },
        Rules = new[]
        {
            new Gcp.NetworkServices.Inputs.TlsRouteRuleArgs
            {
                Matches = new[]
                {
                    new Gcp.NetworkServices.Inputs.TlsRouteRuleMatchArgs
                    {
                        SniHosts = new[]
                        {
                            "example.com",
                        },
                        Alpns = new[]
                        {
                            "http/1.1",
                        },
                    },
                },
                Action = new Gcp.NetworkServices.Inputs.TlsRouteRuleActionArgs
                {
                    Destinations = new[]
                    {
                        new Gcp.NetworkServices.Inputs.TlsRouteRuleActionDestinationArgs
                        {
                            ServiceName = @default.Id,
                            Weight = 1,
                        },
                    },
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/networkservices"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		defaultHttpHealthCheck, err := compute.NewHttpHealthCheck(ctx, "default", &compute.HttpHealthCheckArgs{
			Name:             pulumi.String("backend-service-health-check"),
			RequestPath:      pulumi.String("/"),
			CheckIntervalSec: pulumi.Int(1),
			TimeoutSec:       pulumi.Int(1),
		})
		if err != nil {
			return err
		}
		_, err = compute.NewBackendService(ctx, "default", &compute.BackendServiceArgs{
			Name:         pulumi.String("my-backend-service"),
			HealthChecks: defaultHttpHealthCheck.ID(),
		})
		if err != nil {
			return err
		}
		defaultGateway, err := networkservices.NewGateway(ctx, "default", &networkservices.GatewayArgs{
			Name: pulumi.String("my-tls-route"),
			Labels: pulumi.StringMap{
				"foo": pulumi.String("bar"),
			},
			Description: pulumi.String("my description"),
			Scope:       pulumi.String("my-scope"),
			Type:        pulumi.String("OPEN_MESH"),
			Ports: pulumi.IntArray{
				pulumi.Int(443),
			},
		})
		if err != nil {
			return err
		}
		_, err = networkservices.NewTlsRoute(ctx, "default", &networkservices.TlsRouteArgs{
			Name:        pulumi.String("my-tls-route"),
			Description: pulumi.String("my description"),
			Gateways: pulumi.StringArray{
				defaultGateway.ID(),
			},
			Rules: networkservices.TlsRouteRuleArray{
				&networkservices.TlsRouteRuleArgs{
					Matches: networkservices.TlsRouteRuleMatchArray{
						&networkservices.TlsRouteRuleMatchArgs{
							SniHosts: pulumi.StringArray{
								pulumi.String("example.com"),
							},
							Alpns: pulumi.StringArray{
								pulumi.String("http/1.1"),
							},
						},
					},
					Action: &networkservices.TlsRouteRuleActionArgs{
						Destinations: networkservices.TlsRouteRuleActionDestinationArray{
							&networkservices.TlsRouteRuleActionDestinationArgs{
								ServiceName: _default.ID(),
								Weight:      pulumi.Int(1),
							},
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.HttpHealthCheck;
import com.pulumi.gcp.compute.HttpHealthCheckArgs;
import com.pulumi.gcp.compute.BackendService;
import com.pulumi.gcp.compute.BackendServiceArgs;
import com.pulumi.gcp.networkservices.Gateway;
import com.pulumi.gcp.networkservices.GatewayArgs;
import com.pulumi.gcp.networkservices.TlsRoute;
import com.pulumi.gcp.networkservices.TlsRouteArgs;
import com.pulumi.gcp.networkservices.inputs.TlsRouteRuleArgs;
import com.pulumi.gcp.networkservices.inputs.TlsRouteRuleActionArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var defaultHttpHealthCheck = new HttpHealthCheck("defaultHttpHealthCheck", HttpHealthCheckArgs.builder()
            .name("backend-service-health-check")
            .requestPath("/")
            .checkIntervalSec(1)
            .timeoutSec(1)
            .build());

        var default_ = new BackendService("default", BackendServiceArgs.builder()
            .name("my-backend-service")
            .healthChecks(defaultHttpHealthCheck.id())
            .build());

        var defaultGateway = new Gateway("defaultGateway", GatewayArgs.builder()
            .name("my-tls-route")
            .labels(Map.of("foo", "bar"))
            .description("my description")
            .scope("my-scope")
            .type("OPEN_MESH")
            .ports(443)
            .build());

        var defaultTlsRoute = new TlsRoute("defaultTlsRoute", TlsRouteArgs.builder()
            .name("my-tls-route")
            .description("my description")
            .gateways(defaultGateway.id())
            .rules(TlsRouteRuleArgs.builder()
                .matches(TlsRouteRuleMatchArgs.builder()
                    .sniHosts("example.com")
                    .alpns("http/1.1")
                    .build())
                .action(TlsRouteRuleActionArgs.builder()
                    .destinations(TlsRouteRuleActionDestinationArgs.builder()
                        .serviceName(default_.id())
                        .weight(1)
                        .build())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  default:
    type: gcp:compute:BackendService
    properties:
      name: my-backend-service
      healthChecks: ${defaultHttpHealthCheck.id}
  defaultHttpHealthCheck:
    type: gcp:compute:HttpHealthCheck
    name: default
    properties:
      name: backend-service-health-check
      requestPath: /
      checkIntervalSec: 1
      timeoutSec: 1
  defaultGateway:
    type: gcp:networkservices:Gateway
    name: default
    properties:
      name: my-tls-route
      labels:
        foo: bar
      description: my description
      scope: my-scope
      type: OPEN_MESH
      ports:
        - 443
  defaultTlsRoute:
    type: gcp:networkservices:TlsRoute
    name: default
    properties:
      name: my-tls-route
      description: my description
      gateways:
        - ${defaultGateway.id}
      rules:
        - matches:
            - sniHosts:
                - example.com
              alpns:
                - http/1.1
          action:
            destinations:
              - serviceName: ${default.id}
                weight: 1
```
<!--End PulumiCodeChooser -->

## Import

TlsRoute can be imported using any of these accepted formats:

* `projects/{{project}}/locations/global/tlsRoutes/{{name}}`

* `{{project}}/{{name}}`

* `{{name}}`

When using the `pulumi import` command, TlsRoute can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:networkservices/tlsRoute:TlsRoute default projects/{{project}}/locations/global/tlsRoutes/{{name}}
```

```sh
$ pulumi import gcp:networkservices/tlsRoute:TlsRoute default {{project}}/{{name}}
```

```sh
$ pulumi import gcp:networkservices/tlsRoute:TlsRoute default {{name}}
```

Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
Ö
gatewaysB*" Gateways defines a list of gateways this TlsRoute is attached to, as one of the routing rules to route the requests
served by the gateway. Each gateway reference should match the pattern:
projects/*/locations/global/gateways/<gateway_name>
¢
meshesB*" èMeshes defines a list of meshes this TlsRoute is attached to, as one of the routing rules to route the requests served
by the mesh. Each mesh reference should match the pattern: projects/*/locations/global/meshes/<mesh_name> The attached
Mesh should be of a type SIDECAR
-
nameB" Name of the TlsRoute resource.

projectB" ≥
rulesT*R:P
N
networkservicesTlsRouteRule-gcp:networkservices/TlsRouteRule:TlsRouteRuleTRules that define how traffic is routed and handled.
Structure is documented below.
"8

createTime" &Time the TlsRoute was created in UTC.
"Z
descriptionB" EA free-text description of the resource. Max length 1024 characters.
"Ö
gatewaysB*" Gateways defines a list of gateways this TlsRoute is attached to, as one of the routing rules to route the requests
served by the gateway. Each gateway reference should match the pattern:
projects/*/locations/global/gateways/<gateway_name>
"¢
meshesB*" èMeshes defines a list of meshes this TlsRoute is attached to, as one of the routing rules to route the requests served
by the mesh. Each mesh reference should match the pattern: projects/*/locations/global/meshes/<mesh_name> The attached
Mesh should be of a type SIDECAR
"+
name" Name of the TlsRoute resource.
"
project" "≥
rulesT*R:P
N
networkservicesTlsRouteRule-gcp:networkservices/TlsRouteRule:TlsRouteRuleTRules that define how traffic is routed and handled.
Structure is documented below.
"5
selfLink" %Server-defined URL of this resource.
"8

updateTime" &Time the TlsRoute was updated in UTC.
*‹0
?
	notebooksEnvironment%gcp:notebooks/environment:Environment”A Cloud AI Platform Notebook environment.


To get more information about Environment, see:

* [API documentation](https://cloud.google.com/ai-platform/notebooks/docs/reference/rest)
* How-to Guides
    * [Official Documentation](https://cloud.google.com/ai-platform-notebooks)

## Example Usage

### Notebook Environment Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const environment = new gcp.notebooks.Environment("environment", {
    name: "notebooks-environment",
    location: "us-west1-a",
    containerImage: {
        repository: "gcr.io/deeplearning-platform-release/base-cpu",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

environment = gcp.notebooks.Environment("environment",
    name="notebooks-environment",
    location="us-west1-a",
    container_image={
        "repository": "gcr.io/deeplearning-platform-release/base-cpu",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var environment = new Gcp.Notebooks.Environment("environment", new()
    {
        Name = "notebooks-environment",
        Location = "us-west1-a",
        ContainerImage = new Gcp.Notebooks.Inputs.EnvironmentContainerImageArgs
        {
            Repository = "gcr.io/deeplearning-platform-release/base-cpu",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewEnvironment(ctx, "environment", &notebooks.EnvironmentArgs{
			Name:     pulumi.String("notebooks-environment"),
			Location: pulumi.String("us-west1-a"),
			ContainerImage: &notebooks.EnvironmentContainerImageArgs{
				Repository: pulumi.String("gcr.io/deeplearning-platform-release/base-cpu"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.Environment;
import com.pulumi.gcp.notebooks.EnvironmentArgs;
import com.pulumi.gcp.notebooks.inputs.EnvironmentContainerImageArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var environment = new Environment("environment", EnvironmentArgs.builder()
            .name("notebooks-environment")
            .location("us-west1-a")
            .containerImage(EnvironmentContainerImageArgs.builder()
                .repository("gcr.io/deeplearning-platform-release/base-cpu")
                .build())
            .build());

    }
}
```
```yaml
resources:
  environment:
    type: gcp:notebooks:Environment
    properties:
      name: notebooks-environment
      location: us-west1-a
      containerImage:
        repository: gcr.io/deeplearning-platform-release/base-cpu
```
<!--End PulumiCodeChooser -->

## Import

Environment can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/environments/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

When using the `pulumi import` command, Environment can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:notebooks/environment:Environment default projects/{{project}}/locations/{{location}}/environments/{{name}}
```

```sh
$ pulumi import gcp:notebooks/environment:Environment default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:notebooks/environment:Environment default {{location}}/{{name}}
```

ÿ
containerImageoBm:k
i
	notebooksEnvironmentContainerImageAgcp:notebooks/EnvironmentContainerImage:EnvironmentContainerImageUUse a container image to start the notebook instance.
Structure is documented below.
>
descriptionB" )A brief description of this environment.
B
displayNameB" -Display name of this environment for the UI.
K
location" ;A reference to the zone where the machine resides.


- - -
ê
nameB" ÅThe name specified for the Environment instance.
Format: projects/{project_id}/locations/{location}/environments/{environmentId}
…
postStartupScriptB" ≠Path to a Bash script that automatically runs after a notebook instance fully boots up.
The path must be a URL or Cloud Storage path. Example: "gs://path-to-file/file-name"
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
ƒ
vmImageZBX:V
T
	notebooksEnvironmentVmImage3gcp:notebooks/EnvironmentVmImage:EnvironmentVmImage]Use a Compute Engine VM image to start the notebook instance.
Structure is documented below.
"ÿ
containerImageoBm:k
i
	notebooksEnvironmentContainerImageAgcp:notebooks/EnvironmentContainerImage:EnvironmentContainerImageUUse a container image to start the notebook instance.
Structure is documented below.
")

createTime" Instance creation time
">
descriptionB" )A brief description of this environment.
"B
displayNameB" -Display name of this environment for the UI.
"K
location" ;A reference to the zone where the machine resides.


- - -
"é
name" ÅThe name specified for the Environment instance.
Format: projects/{project_id}/locations/{location}/environments/{environmentId}
"…
postStartupScriptB" ≠Path to a Bash script that automatically runs after a notebook instance fully boots up.
The path must be a URL or Cloud Storage path. Example: "gs://path-to-file/file-name"
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"ƒ
vmImageZBX:V
T
	notebooksEnvironmentVmImage3gcp:notebooks/EnvironmentVmImage:EnvironmentVmImage]Use a Compute Engine VM image to start the notebook instance.
Structure is documented below.
*˘™
6
	notebooksInstancegcp:notebooks/instance:Instance˝À> **Warning:** `google_notebook_instance` is deprecated and will be removed in a future major release. Use `gcp.workbench.Instance` instead.

A Cloud AI Platform Notebook instance.


> **Note:** Due to limitations of the Notebooks Instance API, many fields
in this resource do not properly detect drift. These fields will also not
appear in state once imported.


To get more information about Instance, see:

* [API documentation](https://cloud.google.com/ai-platform/notebooks/docs/reference/rest)
* How-to Guides
    * [Official Documentation](https://cloud.google.com/ai-platform-notebooks)

## Example Usage

### Notebook Instance Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const instance = new gcp.notebooks.Instance("instance", {
    name: "notebooks-instance",
    location: "us-west1-a",
    machineType: "e2-medium",
    vmImage: {
        project: "deeplearning-platform-release",
        imageFamily: "tf-latest-cpu",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

instance = gcp.notebooks.Instance("instance",
    name="notebooks-instance",
    location="us-west1-a",
    machine_type="e2-medium",
    vm_image={
        "project": "deeplearning-platform-release",
        "image_family": "tf-latest-cpu",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var instance = new Gcp.Notebooks.Instance("instance", new()
    {
        Name = "notebooks-instance",
        Location = "us-west1-a",
        MachineType = "e2-medium",
        VmImage = new Gcp.Notebooks.Inputs.InstanceVmImageArgs
        {
            Project = "deeplearning-platform-release",
            ImageFamily = "tf-latest-cpu",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewInstance(ctx, "instance", &notebooks.InstanceArgs{
			Name:        pulumi.String("notebooks-instance"),
			Location:    pulumi.String("us-west1-a"),
			MachineType: pulumi.String("e2-medium"),
			VmImage: &notebooks.InstanceVmImageArgs{
				Project:     pulumi.String("deeplearning-platform-release"),
				ImageFamily: pulumi.String("tf-latest-cpu"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.Instance;
import com.pulumi.gcp.notebooks.InstanceArgs;
import com.pulumi.gcp.notebooks.inputs.InstanceVmImageArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var instance = new Instance("instance", InstanceArgs.builder()
            .name("notebooks-instance")
            .location("us-west1-a")
            .machineType("e2-medium")
            .vmImage(InstanceVmImageArgs.builder()
                .project("deeplearning-platform-release")
                .imageFamily("tf-latest-cpu")
                .build())
            .build());

    }
}
```
```yaml
resources:
  instance:
    type: gcp:notebooks:Instance
    properties:
      name: notebooks-instance
      location: us-west1-a
      machineType: e2-medium
      vmImage:
        project: deeplearning-platform-release
        imageFamily: tf-latest-cpu
```
<!--End PulumiCodeChooser -->
### Notebook Instance Basic Stopped


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const instance = new gcp.notebooks.Instance("instance", {
    name: "notebooks-instance",
    location: "us-west1-a",
    machineType: "e2-medium",
    vmImage: {
        project: "deeplearning-platform-release",
        imageFamily: "tf-latest-cpu",
    },
    desiredState: "STOPPED",
});
```
```python
import pulumi
import pulumi_gcp as gcp

instance = gcp.notebooks.Instance("instance",
    name="notebooks-instance",
    location="us-west1-a",
    machine_type="e2-medium",
    vm_image={
        "project": "deeplearning-platform-release",
        "image_family": "tf-latest-cpu",
    },
    desired_state="STOPPED")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var instance = new Gcp.Notebooks.Instance("instance", new()
    {
        Name = "notebooks-instance",
        Location = "us-west1-a",
        MachineType = "e2-medium",
        VmImage = new Gcp.Notebooks.Inputs.InstanceVmImageArgs
        {
            Project = "deeplearning-platform-release",
            ImageFamily = "tf-latest-cpu",
        },
        DesiredState = "STOPPED",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewInstance(ctx, "instance", &notebooks.InstanceArgs{
			Name:        pulumi.String("notebooks-instance"),
			Location:    pulumi.String("us-west1-a"),
			MachineType: pulumi.String("e2-medium"),
			VmImage: &notebooks.InstanceVmImageArgs{
				Project:     pulumi.String("deeplearning-platform-release"),
				ImageFamily: pulumi.String("tf-latest-cpu"),
			},
			DesiredState: pulumi.String("STOPPED"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.Instance;
import com.pulumi.gcp.notebooks.InstanceArgs;
import com.pulumi.gcp.notebooks.inputs.InstanceVmImageArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var instance = new Instance("instance", InstanceArgs.builder()
            .name("notebooks-instance")
            .location("us-west1-a")
            .machineType("e2-medium")
            .vmImage(InstanceVmImageArgs.builder()
                .project("deeplearning-platform-release")
                .imageFamily("tf-latest-cpu")
                .build())
            .desiredState("STOPPED")
            .build());

    }
}
```
```yaml
resources:
  instance:
    type: gcp:notebooks:Instance
    properties:
      name: notebooks-instance
      location: us-west1-a
      machineType: e2-medium
      vmImage:
        project: deeplearning-platform-release
        imageFamily: tf-latest-cpu
      desiredState: STOPPED
```
<!--End PulumiCodeChooser -->
### Notebook Instance Basic Container


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const instance = new gcp.notebooks.Instance("instance", {
    name: "notebooks-instance",
    location: "us-west1-a",
    machineType: "e2-medium",
    metadata: {
        "proxy-mode": "service_account",
    },
    containerImage: {
        repository: "gcr.io/deeplearning-platform-release/base-cpu",
        tag: "latest",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

instance = gcp.notebooks.Instance("instance",
    name="notebooks-instance",
    location="us-west1-a",
    machine_type="e2-medium",
    metadata={
        "proxy-mode": "service_account",
    },
    container_image={
        "repository": "gcr.io/deeplearning-platform-release/base-cpu",
        "tag": "latest",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var instance = new Gcp.Notebooks.Instance("instance", new()
    {
        Name = "notebooks-instance",
        Location = "us-west1-a",
        MachineType = "e2-medium",
        Metadata = 
        {
            { "proxy-mode", "service_account" },
        },
        ContainerImage = new Gcp.Notebooks.Inputs.InstanceContainerImageArgs
        {
            Repository = "gcr.io/deeplearning-platform-release/base-cpu",
            Tag = "latest",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewInstance(ctx, "instance", &notebooks.InstanceArgs{
			Name:        pulumi.String("notebooks-instance"),
			Location:    pulumi.String("us-west1-a"),
			MachineType: pulumi.String("e2-medium"),
			Metadata: pulumi.StringMap{
				"proxy-mode": pulumi.String("service_account"),
			},
			ContainerImage: &notebooks.InstanceContainerImageArgs{
				Repository: pulumi.String("gcr.io/deeplearning-platform-release/base-cpu"),
				Tag:        pulumi.String("latest"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.Instance;
import com.pulumi.gcp.notebooks.InstanceArgs;
import com.pulumi.gcp.notebooks.inputs.InstanceContainerImageArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var instance = new Instance("instance", InstanceArgs.builder()
            .name("notebooks-instance")
            .location("us-west1-a")
            .machineType("e2-medium")
            .metadata(Map.of("proxy-mode", "service_account"))
            .containerImage(InstanceContainerImageArgs.builder()
                .repository("gcr.io/deeplearning-platform-release/base-cpu")
                .tag("latest")
                .build())
            .build());

    }
}
```
```yaml
resources:
  instance:
    type: gcp:notebooks:Instance
    properties:
      name: notebooks-instance
      location: us-west1-a
      machineType: e2-medium
      metadata:
        proxy-mode: service_account
      containerImage:
        repository: gcr.io/deeplearning-platform-release/base-cpu
        tag: latest
```
<!--End PulumiCodeChooser -->
### Notebook Instance Basic Gpu


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const instance = new gcp.notebooks.Instance("instance", {
    name: "notebooks-instance",
    location: "us-west1-a",
    machineType: "n1-standard-1",
    installGpuDriver: true,
    acceleratorConfig: {
        type: "NVIDIA_TESLA_T4",
        coreCount: 1,
    },
    vmImage: {
        project: "deeplearning-platform-release",
        imageFamily: "tf-latest-gpu",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

instance = gcp.notebooks.Instance("instance",
    name="notebooks-instance",
    location="us-west1-a",
    machine_type="n1-standard-1",
    install_gpu_driver=True,
    accelerator_config={
        "type": "NVIDIA_TESLA_T4",
        "core_count": 1,
    },
    vm_image={
        "project": "deeplearning-platform-release",
        "image_family": "tf-latest-gpu",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var instance = new Gcp.Notebooks.Instance("instance", new()
    {
        Name = "notebooks-instance",
        Location = "us-west1-a",
        MachineType = "n1-standard-1",
        InstallGpuDriver = true,
        AcceleratorConfig = new Gcp.Notebooks.Inputs.InstanceAcceleratorConfigArgs
        {
            Type = "NVIDIA_TESLA_T4",
            CoreCount = 1,
        },
        VmImage = new Gcp.Notebooks.Inputs.InstanceVmImageArgs
        {
            Project = "deeplearning-platform-release",
            ImageFamily = "tf-latest-gpu",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewInstance(ctx, "instance", &notebooks.InstanceArgs{
			Name:             pulumi.String("notebooks-instance"),
			Location:         pulumi.String("us-west1-a"),
			MachineType:      pulumi.String("n1-standard-1"),
			InstallGpuDriver: pulumi.Bool(true),
			AcceleratorConfig: &notebooks.InstanceAcceleratorConfigArgs{
				Type:      pulumi.String("NVIDIA_TESLA_T4"),
				CoreCount: pulumi.Int(1),
			},
			VmImage: &notebooks.InstanceVmImageArgs{
				Project:     pulumi.String("deeplearning-platform-release"),
				ImageFamily: pulumi.String("tf-latest-gpu"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.Instance;
import com.pulumi.gcp.notebooks.InstanceArgs;
import com.pulumi.gcp.notebooks.inputs.InstanceAcceleratorConfigArgs;
import com.pulumi.gcp.notebooks.inputs.InstanceVmImageArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var instance = new Instance("instance", InstanceArgs.builder()
            .name("notebooks-instance")
            .location("us-west1-a")
            .machineType("n1-standard-1")
            .installGpuDriver(true)
            .acceleratorConfig(InstanceAcceleratorConfigArgs.builder()
                .type("NVIDIA_TESLA_T4")
                .coreCount(1)
                .build())
            .vmImage(InstanceVmImageArgs.builder()
                .project("deeplearning-platform-release")
                .imageFamily("tf-latest-gpu")
                .build())
            .build());

    }
}
```
```yaml
resources:
  instance:
    type: gcp:notebooks:Instance
    properties:
      name: notebooks-instance
      location: us-west1-a
      machineType: n1-standard-1
      installGpuDriver: true
      acceleratorConfig:
        type: NVIDIA_TESLA_T4
        coreCount: 1
      vmImage:
        project: deeplearning-platform-release
        imageFamily: tf-latest-gpu
```
<!--End PulumiCodeChooser -->
### Notebook Instance Full


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const myNetwork = gcp.compute.getNetwork({
    name: "default",
});
const mySubnetwork = gcp.compute.getSubnetwork({
    name: "default",
    region: "us-central1",
});
const instance = new gcp.notebooks.Instance("instance", {
    name: "notebooks-instance",
    location: "us-central1-a",
    machineType: "e2-medium",
    vmImage: {
        project: "deeplearning-platform-release",
        imageFamily: "tf-latest-cpu",
    },
    instanceOwners: ["my@service-account.com"],
    serviceAccount: "my@service-account.com",
    installGpuDriver: true,
    bootDiskType: "PD_SSD",
    bootDiskSizeGb: 110,
    noPublicIp: true,
    noProxyAccess: true,
    network: myNetwork.then(myNetwork => myNetwork.id),
    subnet: mySubnetwork.then(mySubnetwork => mySubnetwork.id),
    labels: {
        k: "val",
    },
    metadata: {
        terraform: "true",
    },
    serviceAccountScopes: [
        "https://www.googleapis.com/auth/bigquery",
        "https://www.googleapis.com/auth/devstorage.read_write",
        "https://www.googleapis.com/auth/cloud-platform",
        "https://www.googleapis.com/auth/userinfo.email",
    ],
    tags: [
        "foo",
        "bar",
    ],
    diskEncryption: "CMEK",
    kmsKey: "my-crypto-key",
    desiredState: "ACTIVE",
});
```
```python
import pulumi
import pulumi_gcp as gcp

my_network = gcp.compute.get_network(name="default")
my_subnetwork = gcp.compute.get_subnetwork(name="default",
    region="us-central1")
instance = gcp.notebooks.Instance("instance",
    name="notebooks-instance",
    location="us-central1-a",
    machine_type="e2-medium",
    vm_image={
        "project": "deeplearning-platform-release",
        "image_family": "tf-latest-cpu",
    },
    instance_owners=["my@service-account.com"],
    service_account="my@service-account.com",
    install_gpu_driver=True,
    boot_disk_type="PD_SSD",
    boot_disk_size_gb=110,
    no_public_ip=True,
    no_proxy_access=True,
    network=my_network.id,
    subnet=my_subnetwork.id,
    labels={
        "k": "val",
    },
    metadata={
        "terraform": "true",
    },
    service_account_scopes=[
        "https://www.googleapis.com/auth/bigquery",
        "https://www.googleapis.com/auth/devstorage.read_write",
        "https://www.googleapis.com/auth/cloud-platform",
        "https://www.googleapis.com/auth/userinfo.email",
    ],
    tags=[
        "foo",
        "bar",
    ],
    disk_encryption="CMEK",
    kms_key="my-crypto-key",
    desired_state="ACTIVE")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var myNetwork = Gcp.Compute.GetNetwork.Invoke(new()
    {
        Name = "default",
    });

    var mySubnetwork = Gcp.Compute.GetSubnetwork.Invoke(new()
    {
        Name = "default",
        Region = "us-central1",
    });

    var instance = new Gcp.Notebooks.Instance("instance", new()
    {
        Name = "notebooks-instance",
        Location = "us-central1-a",
        MachineType = "e2-medium",
        VmImage = new Gcp.Notebooks.Inputs.InstanceVmImageArgs
        {
            Project = "deeplearning-platform-release",
            ImageFamily = "tf-latest-cpu",
        },
        InstanceOwners = new[]
        {
            "my@service-account.com",
        },
        ServiceAccount = "my@service-account.com",
        InstallGpuDriver = true,
        BootDiskType = "PD_SSD",
        BootDiskSizeGb = 110,
        NoPublicIp = true,
        NoProxyAccess = true,
        Network = myNetwork.Apply(getNetworkResult => getNetworkResult.Id),
        Subnet = mySubnetwork.Apply(getSubnetworkResult => getSubnetworkResult.Id),
        Labels = 
        {
            { "k", "val" },
        },
        Metadata = 
        {
            { "terraform", "true" },
        },
        ServiceAccountScopes = new[]
        {
            "https://www.googleapis.com/auth/bigquery",
            "https://www.googleapis.com/auth/devstorage.read_write",
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/userinfo.email",
        },
        Tags = new[]
        {
            "foo",
            "bar",
        },
        DiskEncryption = "CMEK",
        KmsKey = "my-crypto-key",
        DesiredState = "ACTIVE",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/compute"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		myNetwork, err := compute.LookupNetwork(ctx, &compute.LookupNetworkArgs{
			Name: "default",
		}, nil)
		if err != nil {
			return err
		}
		mySubnetwork, err := compute.LookupSubnetwork(ctx, &compute.LookupSubnetworkArgs{
			Name:   pulumi.StringRef("default"),
			Region: pulumi.StringRef("us-central1"),
		}, nil)
		if err != nil {
			return err
		}
		_, err = notebooks.NewInstance(ctx, "instance", &notebooks.InstanceArgs{
			Name:        pulumi.String("notebooks-instance"),
			Location:    pulumi.String("us-central1-a"),
			MachineType: pulumi.String("e2-medium"),
			VmImage: &notebooks.InstanceVmImageArgs{
				Project:     pulumi.String("deeplearning-platform-release"),
				ImageFamily: pulumi.String("tf-latest-cpu"),
			},
			InstanceOwners: pulumi.StringArray{
				pulumi.String("my@service-account.com"),
			},
			ServiceAccount:   pulumi.String("my@service-account.com"),
			InstallGpuDriver: pulumi.Bool(true),
			BootDiskType:     pulumi.String("PD_SSD"),
			BootDiskSizeGb:   pulumi.Int(110),
			NoPublicIp:       pulumi.Bool(true),
			NoProxyAccess:    pulumi.Bool(true),
			Network:          pulumi.String(myNetwork.Id),
			Subnet:           pulumi.String(mySubnetwork.Id),
			Labels: pulumi.StringMap{
				"k": pulumi.String("val"),
			},
			Metadata: pulumi.StringMap{
				"terraform": pulumi.String("true"),
			},
			ServiceAccountScopes: pulumi.StringArray{
				pulumi.String("https://www.googleapis.com/auth/bigquery"),
				pulumi.String("https://www.googleapis.com/auth/devstorage.read_write"),
				pulumi.String("https://www.googleapis.com/auth/cloud-platform"),
				pulumi.String("https://www.googleapis.com/auth/userinfo.email"),
			},
			Tags: pulumi.StringArray{
				pulumi.String("foo"),
				pulumi.String("bar"),
			},
			DiskEncryption: pulumi.String("CMEK"),
			KmsKey:         pulumi.String("my-crypto-key"),
			DesiredState:   pulumi.String("ACTIVE"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.compute.ComputeFunctions;
import com.pulumi.gcp.compute.inputs.GetNetworkArgs;
import com.pulumi.gcp.compute.inputs.GetSubnetworkArgs;
import com.pulumi.gcp.notebooks.Instance;
import com.pulumi.gcp.notebooks.InstanceArgs;
import com.pulumi.gcp.notebooks.inputs.InstanceVmImageArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var myNetwork = ComputeFunctions.getNetwork(GetNetworkArgs.builder()
            .name("default")
            .build());

        final var mySubnetwork = ComputeFunctions.getSubnetwork(GetSubnetworkArgs.builder()
            .name("default")
            .region("us-central1")
            .build());

        var instance = new Instance("instance", InstanceArgs.builder()
            .name("notebooks-instance")
            .location("us-central1-a")
            .machineType("e2-medium")
            .vmImage(InstanceVmImageArgs.builder()
                .project("deeplearning-platform-release")
                .imageFamily("tf-latest-cpu")
                .build())
            .instanceOwners("my@service-account.com")
            .serviceAccount("my@service-account.com")
            .installGpuDriver(true)
            .bootDiskType("PD_SSD")
            .bootDiskSizeGb(110)
            .noPublicIp(true)
            .noProxyAccess(true)
            .network(myNetwork.applyValue(getNetworkResult -> getNetworkResult.id()))
            .subnet(mySubnetwork.applyValue(getSubnetworkResult -> getSubnetworkResult.id()))
            .labels(Map.of("k", "val"))
            .metadata(Map.of("terraform", "true"))
            .serviceAccountScopes(            
                "https://www.googleapis.com/auth/bigquery",
                "https://www.googleapis.com/auth/devstorage.read_write",
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/userinfo.email")
            .tags(            
                "foo",
                "bar")
            .diskEncryption("CMEK")
            .kmsKey("my-crypto-key")
            .desiredState("ACTIVE")
            .build());

    }
}
```
```yaml
resources:
  instance:
    type: gcp:notebooks:Instance
    properties:
      name: notebooks-instance
      location: us-central1-a
      machineType: e2-medium
      vmImage:
        project: deeplearning-platform-release
        imageFamily: tf-latest-cpu
      instanceOwners:
        - my@service-account.com
      serviceAccount: my@service-account.com
      installGpuDriver: true
      bootDiskType: PD_SSD
      bootDiskSizeGb: 110
      noPublicIp: true
      noProxyAccess: true
      network: ${myNetwork.id}
      subnet: ${mySubnetwork.id}
      labels:
        k: val
      metadata:
        terraform: 'true'
      serviceAccountScopes:
        - https://www.googleapis.com/auth/bigquery
        - https://www.googleapis.com/auth/devstorage.read_write
        - https://www.googleapis.com/auth/cloud-platform
        - https://www.googleapis.com/auth/userinfo.email
      tags:
        - foo
        - bar
      diskEncryption: CMEK
      kmsKey: my-crypto-key
      desiredState: ACTIVE
variables:
  myNetwork:
    fn::invoke:
      function: gcp:compute:getNetwork
      arguments:
        name: default
  mySubnetwork:
    fn::invoke:
      function: gcp:compute:getSubnetwork
      arguments:
        name: default
        region: us-central1
```
<!--End PulumiCodeChooser -->

## Import

Instance can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/instances/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

When using the `pulumi import` command, Instance can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:notebooks/instance:Instance default projects/{{project}}/locations/{{location}}/instances/{{name}}
```

```sh
$ pulumi import gcp:notebooks/instance:Instance default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:notebooks/instance:Instance default {{location}}/{{name}}
```

€
acceleratorConfigoBm:k
i
	notebooksInstanceAcceleratorConfigAgcp:notebooks/InstanceAcceleratorConfig:InstanceAcceleratorConfig‘The hardware accelerator used on this instance. If you use accelerators,
make sure that your configuration has enough vCPUs and memory to support the
machineType you have selected.
Structure is documented below.
 
bootDiskSizeGbB ±The size of the boot disk in GB attached to this instance,
up to a maximum of 64000 GB (64 TB). The minimum recommended value is 100 GB.
If not specified, this defaults to 100.
ß
bootDiskTypeB" êPossible disk types for notebook instances.
Possible values are: `DISK_TYPE_UNSPECIFIED`, `PD_STANDARD`, `PD_SSD`, `PD_BALANCED`, `PD_EXTREME`.
œ
containerImagefBd:b
`
	notebooksInstanceContainerImage;gcp:notebooks/InstanceContainerImage:InstanceContainerImageUUse a container image to start the notebook instance.
Structure is documented below.
+

createTimeB" Instance creation time
™
customGpuDriverPathB" åSpecify a custom Cloud Storage path where the GPU driver is stored.
If not specified, we'll automatically choose from official GPU drivers.
¯
dataDiskSizeGbB ﬂThe size of the data disk in GB attached to this instance,
up to a maximum of 64000 GB (64 TB).
You can choose the size of the data disk based on how big your notebooks and data are.
If not specified, this defaults to 100.
ß
dataDiskTypeB" êPossible disk types for notebook instances.
Possible values are: `DISK_TYPE_UNSPECIFIED`, `PD_STANDARD`, `PD_SSD`, `PD_BALANCED`, `PD_EXTREME`.
î
desiredStateB" ~Desired state of the Notebook Instance. Set this field to `ACTIVE` to start the Instance, and `STOPPED` to stop the Instance.
ß
diskEncryptionB" éDisk encryption method used on the boot and data disks, defaults to GMEK.
Possible values are: `DISK_ENCRYPTION_UNSPECIFIED`, `GMEK`, `CMEK`.
„
installGpuDriverB
 »Whether the end user authorizes Google Cloud to install GPU driver
on this instance. If this field is empty or set to false, the GPU driver
won't be installed. Only applicable to instances with GPUs.
¸
instanceOwnersB*" ·The list of owners of this instance after creation.
Format: alias@example.com.
Currently supports one owner only.
If not specified, all of the service account users of
your VM instance's service account can use the instance.
¡
kmsKeyB" ∞The KMS key used to encrypt the disks, only applicable if diskEncryption is CMEK.
Format: projects/{project_id}/locations/{location}/keyRings/{key_ring_id}/cryptoKeys/{key_id}
¢
labelsB2" èLabels to apply to this instance. These can be later modified by the setLabels method.
An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
K
location" ;A reference to the zone where the machine resides.


- - -
H
machineType" 5A reference to a machine type which defines VM kind.
±
metadataB2" úCustom metadata to apply to this instance.
An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
<
nameB" .The name specified for the Notebook instance.
z
networkB" iThe name of the VPC that this instance is in.
Format: projects/{project_id}/global/networks/{network_id}
n
nicTypeB" ]The type of vNIC driver.
Possible values are: `UNSPECIFIED_NIC_TYPE`, `VIRTIO_NET`, `GVNIC`.
P
noProxyAccessB
 9The notebook instance will not register with the proxy..
D

noPublicIpB
 0No public IP will be assigned to this instance.
f
noRemoveDataDiskB
 LIf true, the data disk will not be auto deleted when deleting the instance.
¿
postStartupScriptB" §Path to a Bash script that automatically runs after a
notebook instance fully boots up. The path must be a URL
or Cloud Storage path (gs://path-to-file/file-name).
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
„
reservationAffinityuBs:q
o
	notebooksInstanceReservationAffinityEgcp:notebooks/InstanceReservationAffinity:InstanceReservationAffinityUReservation Affinity for consuming Zonal reservation.
Structure is documented below.
∑
serviceAccountB" ûThe service account on this instance, giving access to other
Google Cloud services. You can use any service account within
the same project, but you must have the service account user
permission to use the instance. If not specified,
the Compute Engine default service account is used.
ê
serviceAccountScopesB*" ÔOptional. The URIs of service account scopes to be included in Compute Engine instances.
If not specified, the following scopes are defined:
- https://www.googleapis.com/auth/cloud-platform
- https://www.googleapis.com/auth/userinfo.email
±
shieldedInstanceConfig~B|:z
x
	notebooksInstanceShieldedInstanceConfigKgcp:notebooks/InstanceShieldedInstanceConfig:InstanceShieldedInstanceConfigñA set of Shielded Instance options. Check [Images using supported Shielded VM features]
Not all combinations are valid
Structure is documented below.
å
subnetB" |The name of the subnet that this instance is in.
Format: projects/{project_id}/regions/{region}/subnetworks/{subnetwork_id}
<
tagsB*" ,The Compute Engine tags to add to instance.
*

updateTimeB" Instance update time.
ª
vmImageQBO:M
K
	notebooksInstanceVmImage-gcp:notebooks/InstanceVmImage:InstanceVmImage]Use a Compute Engine VM image to start the notebook instance.
Structure is documented below.
"€
acceleratorConfigoBm:k
i
	notebooksInstanceAcceleratorConfigAgcp:notebooks/InstanceAcceleratorConfig:InstanceAcceleratorConfig‘The hardware accelerator used on this instance. If you use accelerators,
make sure that your configuration has enough vCPUs and memory to support the
machineType you have selected.
Structure is documented below.
" 
bootDiskSizeGbB ±The size of the boot disk in GB attached to this instance,
up to a maximum of 64000 GB (64 TB). The minimum recommended value is 100 GB.
If not specified, this defaults to 100.
"ß
bootDiskTypeB" êPossible disk types for notebook instances.
Possible values are: `DISK_TYPE_UNSPECIFIED`, `PD_STANDARD`, `PD_SSD`, `PD_BALANCED`, `PD_EXTREME`.
"œ
containerImagefBd:b
`
	notebooksInstanceContainerImage;gcp:notebooks/InstanceContainerImage:InstanceContainerImageUUse a container image to start the notebook instance.
Structure is documented below.
")

createTime" Instance creation time
"™
customGpuDriverPathB" åSpecify a custom Cloud Storage path where the GPU driver is stored.
If not specified, we'll automatically choose from official GPU drivers.
"¯
dataDiskSizeGbB ﬂThe size of the data disk in GB attached to this instance,
up to a maximum of 64000 GB (64 TB).
You can choose the size of the data disk based on how big your notebooks and data are.
If not specified, this defaults to 100.
"ß
dataDiskTypeB" êPossible disk types for notebook instances.
Possible values are: `DISK_TYPE_UNSPECIFIED`, `PD_STANDARD`, `PD_SSD`, `PD_BALANCED`, `PD_EXTREME`.
"î
desiredStateB" ~Desired state of the Notebook Instance. Set this field to `ACTIVE` to start the Instance, and `STOPPED` to stop the Instance.
"•
diskEncryption" éDisk encryption method used on the boot and data disks, defaults to GMEK.
Possible values are: `DISK_ENCRYPTION_UNSPECIFIED`, `GMEK`, `CMEK`.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"„
installGpuDriverB
 »Whether the end user authorizes Google Cloud to install GPU driver
on this instance. If this field is empty or set to false, the GPU driver
won't be installed. Only applicable to instances with GPUs.
"¸
instanceOwnersB*" ·The list of owners of this instance after creation.
Format: alias@example.com.
Currently supports one owner only.
If not specified, all of the service account users of
your VM instance's service account can use the instance.
"¡
kmsKeyB" ∞The KMS key used to encrypt the disks, only applicable if diskEncryption is CMEK.
Format: projects/{project_id}/locations/{location}/keyRings/{key_ring_id}/cryptoKeys/{key_id}
"¢
labelsB2" èLabels to apply to this instance. These can be later modified by the setLabels method.
An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"K
location" ;A reference to the zone where the machine resides.


- - -
"H
machineType" 5A reference to a machine type which defines VM kind.
"±
metadataB2" úCustom metadata to apply to this instance.
An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
":
name" .The name specified for the Notebook instance.
"x
network" iThe name of the VPC that this instance is in.
Format: projects/{project_id}/global/networks/{network_id}
"n
nicTypeB" ]The type of vNIC driver.
Possible values are: `UNSPECIFIED_NIC_TYPE`, `VIRTIO_NET`, `GVNIC`.
"P
noProxyAccessB
 9The notebook instance will not register with the proxy..
"D

noPublicIpB
 0No public IP will be assigned to this instance.
"f
noRemoveDataDiskB
 LIf true, the data disk will not be auto deleted when deleting the instance.
"¿
postStartupScriptB" §Path to a Bash script that automatically runs after a
notebook instance fully boots up. The path must be a URL
or Cloud Storage path (gs://path-to-file/file-name).
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"È
proxyUri" ÿThe proxy endpoint that is used to access the Jupyter notebook.
Only returned when the resource is in a `PROVISIONED` state. If
needed you can utilize `pulumi up -refresh-only` to await
the population of this value.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"„
reservationAffinityuBs:q
o
	notebooksInstanceReservationAffinityEgcp:notebooks/InstanceReservationAffinity:InstanceReservationAffinityUReservation Affinity for consuming Zonal reservation.
Structure is documented below.
"µ
serviceAccount" ûThe service account on this instance, giving access to other
Google Cloud services. You can use any service account within
the same project, but you must have the service account user
permission to use the instance. If not specified,
the Compute Engine default service account is used.
"é
serviceAccountScopes*" ÔOptional. The URIs of service account scopes to be included in Compute Engine instances.
If not specified, the following scopes are defined:
- https://www.googleapis.com/auth/cloud-platform
- https://www.googleapis.com/auth/userinfo.email
"Ø
shieldedInstanceConfig|:z
x
	notebooksInstanceShieldedInstanceConfigKgcp:notebooks/InstanceShieldedInstanceConfig:InstanceShieldedInstanceConfigñA set of Shielded Instance options. Check [Images using supported Shielded VM features]
Not all combinations are valid
Structure is documented below.
")
state" The state of this instance.
"ä
subnet" |The name of the subnet that this instance is in.
Format: projects/{project_id}/regions/{region}/subnetworks/{subnetwork_id}
":
tags*" ,The Compute Engine tags to add to instance.
"(

updateTime" Instance update time.
"ª
vmImageQBO:M
K
	notebooksInstanceVmImage-gcp:notebooks/InstanceVmImage:InstanceVmImage]Use a Compute Engine VM image to start the notebook instance.
Structure is documented below.
*∑‚
T
	notebooksInstanceIamBinding3gcp:notebooks/instanceIamBinding:InstanceIamBinding¥ΩThree different resources help you manage your IAM policy for Cloud AI Notebooks Instance. Each of these resources serves a different use case:

* `gcp.notebooks.InstanceIamPolicy`: Authoritative. Sets the IAM policy for the instance and replaces any existing policy already attached.
* `gcp.notebooks.InstanceIamBinding`: Authoritative for a given role. Updates the IAM policy to grant a role to a list of members. Other roles within the IAM policy for the instance are preserved.
* `gcp.notebooks.InstanceIamMember`: Non-authoritative. Updates the IAM policy to grant a role to a new member. Other members for the role for the instance are preserved.

A data source can be used to retrieve policy data in advent you do not need creation

* `gcp.notebooks.InstanceIamPolicy`: Retrieves the IAM policy for the instance

> **Note:** `gcp.notebooks.InstanceIamPolicy` **cannot** be used in conjunction with `gcp.notebooks.InstanceIamBinding` and `gcp.notebooks.InstanceIamMember` or they will fight over what your policy should be.

> **Note:** `gcp.notebooks.InstanceIamBinding` resources **can be** used in conjunction with `gcp.notebooks.InstanceIamMember` resources **only if** they do not grant privilege to the same role.



## gcp.notebooks.InstanceIamPolicy

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const admin = gcp.organizations.getIAMPolicy({
    bindings: [{
        role: "roles/viewer",
        members: ["user:jane@example.com"],
    }],
});
const policy = new gcp.notebooks.InstanceIamPolicy("policy", {
    project: instance.project,
    location: instance.location,
    instanceName: instance.name,
    policyData: admin.then(admin => admin.policyData),
});
```
```python
import pulumi
import pulumi_gcp as gcp

admin = gcp.organizations.get_iam_policy(bindings=[{
    "role": "roles/viewer",
    "members": ["user:jane@example.com"],
}])
policy = gcp.notebooks.InstanceIamPolicy("policy",
    project=instance["project"],
    location=instance["location"],
    instance_name=instance["name"],
    policy_data=admin.policy_data)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var admin = Gcp.Organizations.GetIAMPolicy.Invoke(new()
    {
        Bindings = new[]
        {
            new Gcp.Organizations.Inputs.GetIAMPolicyBindingInputArgs
            {
                Role = "roles/viewer",
                Members = new[]
                {
                    "user:jane@example.com",
                },
            },
        },
    });

    var policy = new Gcp.Notebooks.InstanceIamPolicy("policy", new()
    {
        Project = instance.Project,
        Location = instance.Location,
        InstanceName = instance.Name,
        PolicyData = admin.Apply(getIAMPolicyResult => getIAMPolicyResult.PolicyData),
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		admin, err := organizations.LookupIAMPolicy(ctx, &organizations.LookupIAMPolicyArgs{
			Bindings: []organizations.GetIAMPolicyBinding{
				{
					Role: "roles/viewer",
					Members: []string{
						"user:jane@example.com",
					},
				},
			},
		}, nil)
		if err != nil {
			return err
		}
		_, err = notebooks.NewInstanceIamPolicy(ctx, "policy", &notebooks.InstanceIamPolicyArgs{
			Project:      pulumi.Any(instance.Project),
			Location:     pulumi.Any(instance.Location),
			InstanceName: pulumi.Any(instance.Name),
			PolicyData:   pulumi.String(admin.PolicyData),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.organizations.OrganizationsFunctions;
import com.pulumi.gcp.organizations.inputs.GetIAMPolicyArgs;
import com.pulumi.gcp.notebooks.InstanceIamPolicy;
import com.pulumi.gcp.notebooks.InstanceIamPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var admin = OrganizationsFunctions.getIAMPolicy(GetIAMPolicyArgs.builder()
            .bindings(GetIAMPolicyBindingArgs.builder()
                .role("roles/viewer")
                .members("user:jane@example.com")
                .build())
            .build());

        var policy = new InstanceIamPolicy("policy", InstanceIamPolicyArgs.builder()
            .project(instance.project())
            .location(instance.location())
            .instanceName(instance.name())
            .policyData(admin.applyValue(getIAMPolicyResult -> getIAMPolicyResult.policyData()))
            .build());

    }
}
```
```yaml
resources:
  policy:
    type: gcp:notebooks:InstanceIamPolicy
    properties:
      project: ${instance.project}
      location: ${instance.location}
      instanceName: ${instance.name}
      policyData: ${admin.policyData}
variables:
  admin:
    fn::invoke:
      function: gcp:organizations:getIAMPolicy
      arguments:
        bindings:
          - role: roles/viewer
            members:
              - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.InstanceIamBinding

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const binding = new gcp.notebooks.InstanceIamBinding("binding", {
    project: instance.project,
    location: instance.location,
    instanceName: instance.name,
    role: "roles/viewer",
    members: ["user:jane@example.com"],
});
```
```python
import pulumi
import pulumi_gcp as gcp

binding = gcp.notebooks.InstanceIamBinding("binding",
    project=instance["project"],
    location=instance["location"],
    instance_name=instance["name"],
    role="roles/viewer",
    members=["user:jane@example.com"])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var binding = new Gcp.Notebooks.InstanceIamBinding("binding", new()
    {
        Project = instance.Project,
        Location = instance.Location,
        InstanceName = instance.Name,
        Role = "roles/viewer",
        Members = new[]
        {
            "user:jane@example.com",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewInstanceIamBinding(ctx, "binding", &notebooks.InstanceIamBindingArgs{
			Project:      pulumi.Any(instance.Project),
			Location:     pulumi.Any(instance.Location),
			InstanceName: pulumi.Any(instance.Name),
			Role:         pulumi.String("roles/viewer"),
			Members: pulumi.StringArray{
				pulumi.String("user:jane@example.com"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.InstanceIamBinding;
import com.pulumi.gcp.notebooks.InstanceIamBindingArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var binding = new InstanceIamBinding("binding", InstanceIamBindingArgs.builder()
            .project(instance.project())
            .location(instance.location())
            .instanceName(instance.name())
            .role("roles/viewer")
            .members("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  binding:
    type: gcp:notebooks:InstanceIamBinding
    properties:
      project: ${instance.project}
      location: ${instance.location}
      instanceName: ${instance.name}
      role: roles/viewer
      members:
        - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.InstanceIamMember

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const member = new gcp.notebooks.InstanceIamMember("member", {
    project: instance.project,
    location: instance.location,
    instanceName: instance.name,
    role: "roles/viewer",
    member: "user:jane@example.com",
});
```
```python
import pulumi
import pulumi_gcp as gcp

member = gcp.notebooks.InstanceIamMember("member",
    project=instance["project"],
    location=instance["location"],
    instance_name=instance["name"],
    role="roles/viewer",
    member="user:jane@example.com")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var member = new Gcp.Notebooks.InstanceIamMember("member", new()
    {
        Project = instance.Project,
        Location = instance.Location,
        InstanceName = instance.Name,
        Role = "roles/viewer",
        Member = "user:jane@example.com",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewInstanceIamMember(ctx, "member", &notebooks.InstanceIamMemberArgs{
			Project:      pulumi.Any(instance.Project),
			Location:     pulumi.Any(instance.Location),
			InstanceName: pulumi.Any(instance.Name),
			Role:         pulumi.String("roles/viewer"),
			Member:       pulumi.String("user:jane@example.com"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.InstanceIamMember;
import com.pulumi.gcp.notebooks.InstanceIamMemberArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var member = new InstanceIamMember("member", InstanceIamMemberArgs.builder()
            .project(instance.project())
            .location(instance.location())
            .instanceName(instance.name())
            .role("roles/viewer")
            .member("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  member:
    type: gcp:notebooks:InstanceIamMember
    properties:
      project: ${instance.project}
      location: ${instance.location}
      instanceName: ${instance.name}
      role: roles/viewer
      member: user:jane@example.com
```
<!--End PulumiCodeChooser -->


## This resource supports User Project Overrides.

-

# IAM policy for Cloud AI Notebooks Instance
Three different resources help you manage your IAM policy for Cloud AI Notebooks Instance. Each of these resources serves a different use case:

* `gcp.notebooks.InstanceIamPolicy`: Authoritative. Sets the IAM policy for the instance and replaces any existing policy already attached.
* `gcp.notebooks.InstanceIamBinding`: Authoritative for a given role. Updates the IAM policy to grant a role to a list of members. Other roles within the IAM policy for the instance are preserved.
* `gcp.notebooks.InstanceIamMember`: Non-authoritative. Updates the IAM policy to grant a role to a new member. Other members for the role for the instance are preserved.

A data source can be used to retrieve policy data in advent you do not need creation

* `gcp.notebooks.InstanceIamPolicy`: Retrieves the IAM policy for the instance

> **Note:** `gcp.notebooks.InstanceIamPolicy` **cannot** be used in conjunction with `gcp.notebooks.InstanceIamBinding` and `gcp.notebooks.InstanceIamMember` or they will fight over what your policy should be.

> **Note:** `gcp.notebooks.InstanceIamBinding` resources **can be** used in conjunction with `gcp.notebooks.InstanceIamMember` resources **only if** they do not grant privilege to the same role.



## gcp.notebooks.InstanceIamPolicy

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const admin = gcp.organizations.getIAMPolicy({
    bindings: [{
        role: "roles/viewer",
        members: ["user:jane@example.com"],
    }],
});
const policy = new gcp.notebooks.InstanceIamPolicy("policy", {
    project: instance.project,
    location: instance.location,
    instanceName: instance.name,
    policyData: admin.then(admin => admin.policyData),
});
```
```python
import pulumi
import pulumi_gcp as gcp

admin = gcp.organizations.get_iam_policy(bindings=[{
    "role": "roles/viewer",
    "members": ["user:jane@example.com"],
}])
policy = gcp.notebooks.InstanceIamPolicy("policy",
    project=instance["project"],
    location=instance["location"],
    instance_name=instance["name"],
    policy_data=admin.policy_data)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var admin = Gcp.Organizations.GetIAMPolicy.Invoke(new()
    {
        Bindings = new[]
        {
            new Gcp.Organizations.Inputs.GetIAMPolicyBindingInputArgs
            {
                Role = "roles/viewer",
                Members = new[]
                {
                    "user:jane@example.com",
                },
            },
        },
    });

    var policy = new Gcp.Notebooks.InstanceIamPolicy("policy", new()
    {
        Project = instance.Project,
        Location = instance.Location,
        InstanceName = instance.Name,
        PolicyData = admin.Apply(getIAMPolicyResult => getIAMPolicyResult.PolicyData),
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		admin, err := organizations.LookupIAMPolicy(ctx, &organizations.LookupIAMPolicyArgs{
			Bindings: []organizations.GetIAMPolicyBinding{
				{
					Role: "roles/viewer",
					Members: []string{
						"user:jane@example.com",
					},
				},
			},
		}, nil)
		if err != nil {
			return err
		}
		_, err = notebooks.NewInstanceIamPolicy(ctx, "policy", &notebooks.InstanceIamPolicyArgs{
			Project:      pulumi.Any(instance.Project),
			Location:     pulumi.Any(instance.Location),
			InstanceName: pulumi.Any(instance.Name),
			PolicyData:   pulumi.String(admin.PolicyData),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.organizations.OrganizationsFunctions;
import com.pulumi.gcp.organizations.inputs.GetIAMPolicyArgs;
import com.pulumi.gcp.notebooks.InstanceIamPolicy;
import com.pulumi.gcp.notebooks.InstanceIamPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var admin = OrganizationsFunctions.getIAMPolicy(GetIAMPolicyArgs.builder()
            .bindings(GetIAMPolicyBindingArgs.builder()
                .role("roles/viewer")
                .members("user:jane@example.com")
                .build())
            .build());

        var policy = new InstanceIamPolicy("policy", InstanceIamPolicyArgs.builder()
            .project(instance.project())
            .location(instance.location())
            .instanceName(instance.name())
            .policyData(admin.applyValue(getIAMPolicyResult -> getIAMPolicyResult.policyData()))
            .build());

    }
}
```
```yaml
resources:
  policy:
    type: gcp:notebooks:InstanceIamPolicy
    properties:
      project: ${instance.project}
      location: ${instance.location}
      instanceName: ${instance.name}
      policyData: ${admin.policyData}
variables:
  admin:
    fn::invoke:
      function: gcp:organizations:getIAMPolicy
      arguments:
        bindings:
          - role: roles/viewer
            members:
              - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.InstanceIamBinding

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const binding = new gcp.notebooks.InstanceIamBinding("binding", {
    project: instance.project,
    location: instance.location,
    instanceName: instance.name,
    role: "roles/viewer",
    members: ["user:jane@example.com"],
});
```
```python
import pulumi
import pulumi_gcp as gcp

binding = gcp.notebooks.InstanceIamBinding("binding",
    project=instance["project"],
    location=instance["location"],
    instance_name=instance["name"],
    role="roles/viewer",
    members=["user:jane@example.com"])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var binding = new Gcp.Notebooks.InstanceIamBinding("binding", new()
    {
        Project = instance.Project,
        Location = instance.Location,
        InstanceName = instance.Name,
        Role = "roles/viewer",
        Members = new[]
        {
            "user:jane@example.com",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewInstanceIamBinding(ctx, "binding", &notebooks.InstanceIamBindingArgs{
			Project:      pulumi.Any(instance.Project),
			Location:     pulumi.Any(instance.Location),
			InstanceName: pulumi.Any(instance.Name),
			Role:         pulumi.String("roles/viewer"),
			Members: pulumi.StringArray{
				pulumi.String("user:jane@example.com"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.InstanceIamBinding;
import com.pulumi.gcp.notebooks.InstanceIamBindingArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var binding = new InstanceIamBinding("binding", InstanceIamBindingArgs.builder()
            .project(instance.project())
            .location(instance.location())
            .instanceName(instance.name())
            .role("roles/viewer")
            .members("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  binding:
    type: gcp:notebooks:InstanceIamBinding
    properties:
      project: ${instance.project}
      location: ${instance.location}
      instanceName: ${instance.name}
      role: roles/viewer
      members:
        - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.InstanceIamMember

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const member = new gcp.notebooks.InstanceIamMember("member", {
    project: instance.project,
    location: instance.location,
    instanceName: instance.name,
    role: "roles/viewer",
    member: "user:jane@example.com",
});
```
```python
import pulumi
import pulumi_gcp as gcp

member = gcp.notebooks.InstanceIamMember("member",
    project=instance["project"],
    location=instance["location"],
    instance_name=instance["name"],
    role="roles/viewer",
    member="user:jane@example.com")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var member = new Gcp.Notebooks.InstanceIamMember("member", new()
    {
        Project = instance.Project,
        Location = instance.Location,
        InstanceName = instance.Name,
        Role = "roles/viewer",
        Member = "user:jane@example.com",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewInstanceIamMember(ctx, "member", &notebooks.InstanceIamMemberArgs{
			Project:      pulumi.Any(instance.Project),
			Location:     pulumi.Any(instance.Location),
			InstanceName: pulumi.Any(instance.Name),
			Role:         pulumi.String("roles/viewer"),
			Member:       pulumi.String("user:jane@example.com"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.InstanceIamMember;
import com.pulumi.gcp.notebooks.InstanceIamMemberArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var member = new InstanceIamMember("member", InstanceIamMemberArgs.builder()
            .project(instance.project())
            .location(instance.location())
            .instanceName(instance.name())
            .role("roles/viewer")
            .member("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  member:
    type: gcp:notebooks:InstanceIamMember
    properties:
      project: ${instance.project}
      location: ${instance.location}
      instanceName: ${instance.name}
      role: roles/viewer
      member: user:jane@example.com
```
<!--End PulumiCodeChooser -->

## Import

For all import syntaxes, the "resource in question" can take any of the following forms:

* projects/{{project}}/locations/{{location}}/instances/{{instance_name}}

* {{project}}/{{location}}/{{instance_name}}

* {{location}}/{{instance_name}}

* {{instance_name}}

Any variables not passed in the import command will be taken from the provider configuration.

Cloud AI Notebooks instance IAM resources can be imported using the resource identifiers, role, and member.

IAM member imports use space-delimited identifiers: the resource in question, the role, and the member identity, e.g.

```sh
$ pulumi import gcp:notebooks/instanceIamBinding:InstanceIamBinding editor "projects/{{project}}/locations/{{location}}/instances/{{instance_name}} roles/viewer user:jane@example.com"
```

IAM binding imports use space-delimited identifiers: the resource in question and the role, e.g.

```sh
$ pulumi import gcp:notebooks/instanceIamBinding:InstanceIamBinding editor "projects/{{project}}/locations/{{location}}/instances/{{instance_name}} roles/viewer"
```

IAM policy imports use the identifier of the resource in question, e.g.

```sh
$ pulumi import gcp:notebooks/instanceIamBinding:InstanceIamBinding editor projects/{{project}}/locations/{{location}}/instances/{{instance_name}}
```

-> **Custom Roles** If you're importing a IAM resource with a custom role, make sure to use the

 full name of the custom role, e.g. `[projects/my-project|organizations/my-org]/roles/my-custom-role`.

Ç
	conditionuBs:q
o
	notebooksInstanceIamBindingConditionEgcp:notebooks/InstanceIamBindingCondition:InstanceIamBindingConditionO
instanceName" ;Used to find the parent resource to bind the IAM policy to
ÿ
locationB" ≈A reference to the zone where the machine resides. Used to find the parent resource to bind the IAM policy to. If not specified,
the value will be parsed from the identifier of the parent resource. If no location is provided in the parent identifier and no
location is specified, it is taken from the provider configuration.
÷	
members*" ƒ	Identities that will be granted the privilege in `role`.
Each entry can have one of the following values:
* **allUsers**: A special identifier that represents anyone who is on the internet; with or without a Google account.
* **allAuthenticatedUsers**: A special identifier that represents anyone who is authenticated with a Google account or a service account.
* **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com or joe@example.com.
* **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
* **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
* **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
* **projectOwner:projectid**: Owners of the given project. For example, "projectOwner:my-example-project"
* **projectEditor:projectid**: Editors of the given project. For example, "projectEditor:my-example-project"
* **projectViewer:projectid**: Viewers of the given project. For example, "projectViewer:my-example-project"
ì
projectB" ÅThe ID of the project in which the resource belongs.
If it is not provided, the project will be parsed from the identifier of the parent resource. If no project is provided in the parent identifier and no project is specified, the provider project is used.
Ÿ
role" ÃThe role that should be applied. Only one
`gcp.notebooks.InstanceIamBinding` can be used per role. Note that custom roles must be of the format
`[projects|organizations]/{parent-name}/roles/{role-name}`.
"Ç
	conditionuBs:q
o
	notebooksInstanceIamBindingConditionEgcp:notebooks/InstanceIamBindingCondition:InstanceIamBindingCondition"3
etag" '(Computed) The etag of the IAM policy.
"O
instanceName" ;Used to find the parent resource to bind the IAM policy to
"÷
location" ≈A reference to the zone where the machine resides. Used to find the parent resource to bind the IAM policy to. If not specified,
the value will be parsed from the identifier of the parent resource. If no location is provided in the parent identifier and no
location is specified, it is taken from the provider configuration.
"÷	
members*" ƒ	Identities that will be granted the privilege in `role`.
Each entry can have one of the following values:
* **allUsers**: A special identifier that represents anyone who is on the internet; with or without a Google account.
* **allAuthenticatedUsers**: A special identifier that represents anyone who is authenticated with a Google account or a service account.
* **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com or joe@example.com.
* **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
* **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
* **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
* **projectOwner:projectid**: Owners of the given project. For example, "projectOwner:my-example-project"
* **projectEditor:projectid**: Editors of the given project. For example, "projectEditor:my-example-project"
* **projectViewer:projectid**: Viewers of the given project. For example, "projectViewer:my-example-project"
"ë
project" ÅThe ID of the project in which the resource belongs.
If it is not provided, the project will be parsed from the identifier of the parent resource. If no project is provided in the parent identifier and no project is specified, the provider project is used.
"Ÿ
role" ÃThe role that should be applied. Only one
`gcp.notebooks.InstanceIamBinding` can be used per role. Note that custom roles must be of the format
`[projects|organizations]/{parent-name}/roles/{role-name}`.
*†‚
Q
	notebooksInstanceIamMember1gcp:notebooks/instanceIamMember:InstanceIamMemberÆΩThree different resources help you manage your IAM policy for Cloud AI Notebooks Instance. Each of these resources serves a different use case:

* `gcp.notebooks.InstanceIamPolicy`: Authoritative. Sets the IAM policy for the instance and replaces any existing policy already attached.
* `gcp.notebooks.InstanceIamBinding`: Authoritative for a given role. Updates the IAM policy to grant a role to a list of members. Other roles within the IAM policy for the instance are preserved.
* `gcp.notebooks.InstanceIamMember`: Non-authoritative. Updates the IAM policy to grant a role to a new member. Other members for the role for the instance are preserved.

A data source can be used to retrieve policy data in advent you do not need creation

* `gcp.notebooks.InstanceIamPolicy`: Retrieves the IAM policy for the instance

> **Note:** `gcp.notebooks.InstanceIamPolicy` **cannot** be used in conjunction with `gcp.notebooks.InstanceIamBinding` and `gcp.notebooks.InstanceIamMember` or they will fight over what your policy should be.

> **Note:** `gcp.notebooks.InstanceIamBinding` resources **can be** used in conjunction with `gcp.notebooks.InstanceIamMember` resources **only if** they do not grant privilege to the same role.



## gcp.notebooks.InstanceIamPolicy

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const admin = gcp.organizations.getIAMPolicy({
    bindings: [{
        role: "roles/viewer",
        members: ["user:jane@example.com"],
    }],
});
const policy = new gcp.notebooks.InstanceIamPolicy("policy", {
    project: instance.project,
    location: instance.location,
    instanceName: instance.name,
    policyData: admin.then(admin => admin.policyData),
});
```
```python
import pulumi
import pulumi_gcp as gcp

admin = gcp.organizations.get_iam_policy(bindings=[{
    "role": "roles/viewer",
    "members": ["user:jane@example.com"],
}])
policy = gcp.notebooks.InstanceIamPolicy("policy",
    project=instance["project"],
    location=instance["location"],
    instance_name=instance["name"],
    policy_data=admin.policy_data)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var admin = Gcp.Organizations.GetIAMPolicy.Invoke(new()
    {
        Bindings = new[]
        {
            new Gcp.Organizations.Inputs.GetIAMPolicyBindingInputArgs
            {
                Role = "roles/viewer",
                Members = new[]
                {
                    "user:jane@example.com",
                },
            },
        },
    });

    var policy = new Gcp.Notebooks.InstanceIamPolicy("policy", new()
    {
        Project = instance.Project,
        Location = instance.Location,
        InstanceName = instance.Name,
        PolicyData = admin.Apply(getIAMPolicyResult => getIAMPolicyResult.PolicyData),
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		admin, err := organizations.LookupIAMPolicy(ctx, &organizations.LookupIAMPolicyArgs{
			Bindings: []organizations.GetIAMPolicyBinding{
				{
					Role: "roles/viewer",
					Members: []string{
						"user:jane@example.com",
					},
				},
			},
		}, nil)
		if err != nil {
			return err
		}
		_, err = notebooks.NewInstanceIamPolicy(ctx, "policy", &notebooks.InstanceIamPolicyArgs{
			Project:      pulumi.Any(instance.Project),
			Location:     pulumi.Any(instance.Location),
			InstanceName: pulumi.Any(instance.Name),
			PolicyData:   pulumi.String(admin.PolicyData),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.organizations.OrganizationsFunctions;
import com.pulumi.gcp.organizations.inputs.GetIAMPolicyArgs;
import com.pulumi.gcp.notebooks.InstanceIamPolicy;
import com.pulumi.gcp.notebooks.InstanceIamPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var admin = OrganizationsFunctions.getIAMPolicy(GetIAMPolicyArgs.builder()
            .bindings(GetIAMPolicyBindingArgs.builder()
                .role("roles/viewer")
                .members("user:jane@example.com")
                .build())
            .build());

        var policy = new InstanceIamPolicy("policy", InstanceIamPolicyArgs.builder()
            .project(instance.project())
            .location(instance.location())
            .instanceName(instance.name())
            .policyData(admin.applyValue(getIAMPolicyResult -> getIAMPolicyResult.policyData()))
            .build());

    }
}
```
```yaml
resources:
  policy:
    type: gcp:notebooks:InstanceIamPolicy
    properties:
      project: ${instance.project}
      location: ${instance.location}
      instanceName: ${instance.name}
      policyData: ${admin.policyData}
variables:
  admin:
    fn::invoke:
      function: gcp:organizations:getIAMPolicy
      arguments:
        bindings:
          - role: roles/viewer
            members:
              - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.InstanceIamBinding

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const binding = new gcp.notebooks.InstanceIamBinding("binding", {
    project: instance.project,
    location: instance.location,
    instanceName: instance.name,
    role: "roles/viewer",
    members: ["user:jane@example.com"],
});
```
```python
import pulumi
import pulumi_gcp as gcp

binding = gcp.notebooks.InstanceIamBinding("binding",
    project=instance["project"],
    location=instance["location"],
    instance_name=instance["name"],
    role="roles/viewer",
    members=["user:jane@example.com"])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var binding = new Gcp.Notebooks.InstanceIamBinding("binding", new()
    {
        Project = instance.Project,
        Location = instance.Location,
        InstanceName = instance.Name,
        Role = "roles/viewer",
        Members = new[]
        {
            "user:jane@example.com",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewInstanceIamBinding(ctx, "binding", &notebooks.InstanceIamBindingArgs{
			Project:      pulumi.Any(instance.Project),
			Location:     pulumi.Any(instance.Location),
			InstanceName: pulumi.Any(instance.Name),
			Role:         pulumi.String("roles/viewer"),
			Members: pulumi.StringArray{
				pulumi.String("user:jane@example.com"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.InstanceIamBinding;
import com.pulumi.gcp.notebooks.InstanceIamBindingArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var binding = new InstanceIamBinding("binding", InstanceIamBindingArgs.builder()
            .project(instance.project())
            .location(instance.location())
            .instanceName(instance.name())
            .role("roles/viewer")
            .members("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  binding:
    type: gcp:notebooks:InstanceIamBinding
    properties:
      project: ${instance.project}
      location: ${instance.location}
      instanceName: ${instance.name}
      role: roles/viewer
      members:
        - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.InstanceIamMember

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const member = new gcp.notebooks.InstanceIamMember("member", {
    project: instance.project,
    location: instance.location,
    instanceName: instance.name,
    role: "roles/viewer",
    member: "user:jane@example.com",
});
```
```python
import pulumi
import pulumi_gcp as gcp

member = gcp.notebooks.InstanceIamMember("member",
    project=instance["project"],
    location=instance["location"],
    instance_name=instance["name"],
    role="roles/viewer",
    member="user:jane@example.com")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var member = new Gcp.Notebooks.InstanceIamMember("member", new()
    {
        Project = instance.Project,
        Location = instance.Location,
        InstanceName = instance.Name,
        Role = "roles/viewer",
        Member = "user:jane@example.com",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewInstanceIamMember(ctx, "member", &notebooks.InstanceIamMemberArgs{
			Project:      pulumi.Any(instance.Project),
			Location:     pulumi.Any(instance.Location),
			InstanceName: pulumi.Any(instance.Name),
			Role:         pulumi.String("roles/viewer"),
			Member:       pulumi.String("user:jane@example.com"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.InstanceIamMember;
import com.pulumi.gcp.notebooks.InstanceIamMemberArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var member = new InstanceIamMember("member", InstanceIamMemberArgs.builder()
            .project(instance.project())
            .location(instance.location())
            .instanceName(instance.name())
            .role("roles/viewer")
            .member("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  member:
    type: gcp:notebooks:InstanceIamMember
    properties:
      project: ${instance.project}
      location: ${instance.location}
      instanceName: ${instance.name}
      role: roles/viewer
      member: user:jane@example.com
```
<!--End PulumiCodeChooser -->


## This resource supports User Project Overrides.

-

# IAM policy for Cloud AI Notebooks Instance
Three different resources help you manage your IAM policy for Cloud AI Notebooks Instance. Each of these resources serves a different use case:

* `gcp.notebooks.InstanceIamPolicy`: Authoritative. Sets the IAM policy for the instance and replaces any existing policy already attached.
* `gcp.notebooks.InstanceIamBinding`: Authoritative for a given role. Updates the IAM policy to grant a role to a list of members. Other roles within the IAM policy for the instance are preserved.
* `gcp.notebooks.InstanceIamMember`: Non-authoritative. Updates the IAM policy to grant a role to a new member. Other members for the role for the instance are preserved.

A data source can be used to retrieve policy data in advent you do not need creation

* `gcp.notebooks.InstanceIamPolicy`: Retrieves the IAM policy for the instance

> **Note:** `gcp.notebooks.InstanceIamPolicy` **cannot** be used in conjunction with `gcp.notebooks.InstanceIamBinding` and `gcp.notebooks.InstanceIamMember` or they will fight over what your policy should be.

> **Note:** `gcp.notebooks.InstanceIamBinding` resources **can be** used in conjunction with `gcp.notebooks.InstanceIamMember` resources **only if** they do not grant privilege to the same role.



## gcp.notebooks.InstanceIamPolicy

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const admin = gcp.organizations.getIAMPolicy({
    bindings: [{
        role: "roles/viewer",
        members: ["user:jane@example.com"],
    }],
});
const policy = new gcp.notebooks.InstanceIamPolicy("policy", {
    project: instance.project,
    location: instance.location,
    instanceName: instance.name,
    policyData: admin.then(admin => admin.policyData),
});
```
```python
import pulumi
import pulumi_gcp as gcp

admin = gcp.organizations.get_iam_policy(bindings=[{
    "role": "roles/viewer",
    "members": ["user:jane@example.com"],
}])
policy = gcp.notebooks.InstanceIamPolicy("policy",
    project=instance["project"],
    location=instance["location"],
    instance_name=instance["name"],
    policy_data=admin.policy_data)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var admin = Gcp.Organizations.GetIAMPolicy.Invoke(new()
    {
        Bindings = new[]
        {
            new Gcp.Organizations.Inputs.GetIAMPolicyBindingInputArgs
            {
                Role = "roles/viewer",
                Members = new[]
                {
                    "user:jane@example.com",
                },
            },
        },
    });

    var policy = new Gcp.Notebooks.InstanceIamPolicy("policy", new()
    {
        Project = instance.Project,
        Location = instance.Location,
        InstanceName = instance.Name,
        PolicyData = admin.Apply(getIAMPolicyResult => getIAMPolicyResult.PolicyData),
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		admin, err := organizations.LookupIAMPolicy(ctx, &organizations.LookupIAMPolicyArgs{
			Bindings: []organizations.GetIAMPolicyBinding{
				{
					Role: "roles/viewer",
					Members: []string{
						"user:jane@example.com",
					},
				},
			},
		}, nil)
		if err != nil {
			return err
		}
		_, err = notebooks.NewInstanceIamPolicy(ctx, "policy", &notebooks.InstanceIamPolicyArgs{
			Project:      pulumi.Any(instance.Project),
			Location:     pulumi.Any(instance.Location),
			InstanceName: pulumi.Any(instance.Name),
			PolicyData:   pulumi.String(admin.PolicyData),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.organizations.OrganizationsFunctions;
import com.pulumi.gcp.organizations.inputs.GetIAMPolicyArgs;
import com.pulumi.gcp.notebooks.InstanceIamPolicy;
import com.pulumi.gcp.notebooks.InstanceIamPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var admin = OrganizationsFunctions.getIAMPolicy(GetIAMPolicyArgs.builder()
            .bindings(GetIAMPolicyBindingArgs.builder()
                .role("roles/viewer")
                .members("user:jane@example.com")
                .build())
            .build());

        var policy = new InstanceIamPolicy("policy", InstanceIamPolicyArgs.builder()
            .project(instance.project())
            .location(instance.location())
            .instanceName(instance.name())
            .policyData(admin.applyValue(getIAMPolicyResult -> getIAMPolicyResult.policyData()))
            .build());

    }
}
```
```yaml
resources:
  policy:
    type: gcp:notebooks:InstanceIamPolicy
    properties:
      project: ${instance.project}
      location: ${instance.location}
      instanceName: ${instance.name}
      policyData: ${admin.policyData}
variables:
  admin:
    fn::invoke:
      function: gcp:organizations:getIAMPolicy
      arguments:
        bindings:
          - role: roles/viewer
            members:
              - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.InstanceIamBinding

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const binding = new gcp.notebooks.InstanceIamBinding("binding", {
    project: instance.project,
    location: instance.location,
    instanceName: instance.name,
    role: "roles/viewer",
    members: ["user:jane@example.com"],
});
```
```python
import pulumi
import pulumi_gcp as gcp

binding = gcp.notebooks.InstanceIamBinding("binding",
    project=instance["project"],
    location=instance["location"],
    instance_name=instance["name"],
    role="roles/viewer",
    members=["user:jane@example.com"])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var binding = new Gcp.Notebooks.InstanceIamBinding("binding", new()
    {
        Project = instance.Project,
        Location = instance.Location,
        InstanceName = instance.Name,
        Role = "roles/viewer",
        Members = new[]
        {
            "user:jane@example.com",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewInstanceIamBinding(ctx, "binding", &notebooks.InstanceIamBindingArgs{
			Project:      pulumi.Any(instance.Project),
			Location:     pulumi.Any(instance.Location),
			InstanceName: pulumi.Any(instance.Name),
			Role:         pulumi.String("roles/viewer"),
			Members: pulumi.StringArray{
				pulumi.String("user:jane@example.com"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.InstanceIamBinding;
import com.pulumi.gcp.notebooks.InstanceIamBindingArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var binding = new InstanceIamBinding("binding", InstanceIamBindingArgs.builder()
            .project(instance.project())
            .location(instance.location())
            .instanceName(instance.name())
            .role("roles/viewer")
            .members("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  binding:
    type: gcp:notebooks:InstanceIamBinding
    properties:
      project: ${instance.project}
      location: ${instance.location}
      instanceName: ${instance.name}
      role: roles/viewer
      members:
        - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.InstanceIamMember

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const member = new gcp.notebooks.InstanceIamMember("member", {
    project: instance.project,
    location: instance.location,
    instanceName: instance.name,
    role: "roles/viewer",
    member: "user:jane@example.com",
});
```
```python
import pulumi
import pulumi_gcp as gcp

member = gcp.notebooks.InstanceIamMember("member",
    project=instance["project"],
    location=instance["location"],
    instance_name=instance["name"],
    role="roles/viewer",
    member="user:jane@example.com")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var member = new Gcp.Notebooks.InstanceIamMember("member", new()
    {
        Project = instance.Project,
        Location = instance.Location,
        InstanceName = instance.Name,
        Role = "roles/viewer",
        Member = "user:jane@example.com",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewInstanceIamMember(ctx, "member", &notebooks.InstanceIamMemberArgs{
			Project:      pulumi.Any(instance.Project),
			Location:     pulumi.Any(instance.Location),
			InstanceName: pulumi.Any(instance.Name),
			Role:         pulumi.String("roles/viewer"),
			Member:       pulumi.String("user:jane@example.com"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.InstanceIamMember;
import com.pulumi.gcp.notebooks.InstanceIamMemberArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var member = new InstanceIamMember("member", InstanceIamMemberArgs.builder()
            .project(instance.project())
            .location(instance.location())
            .instanceName(instance.name())
            .role("roles/viewer")
            .member("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  member:
    type: gcp:notebooks:InstanceIamMember
    properties:
      project: ${instance.project}
      location: ${instance.location}
      instanceName: ${instance.name}
      role: roles/viewer
      member: user:jane@example.com
```
<!--End PulumiCodeChooser -->

## Import

For all import syntaxes, the "resource in question" can take any of the following forms:

* projects/{{project}}/locations/{{location}}/instances/{{instance_name}}

* {{project}}/{{location}}/{{instance_name}}

* {{location}}/{{instance_name}}

* {{instance_name}}

Any variables not passed in the import command will be taken from the provider configuration.

Cloud AI Notebooks instance IAM resources can be imported using the resource identifiers, role, and member.

IAM member imports use space-delimited identifiers: the resource in question, the role, and the member identity, e.g.

```sh
$ pulumi import gcp:notebooks/instanceIamMember:InstanceIamMember editor "projects/{{project}}/locations/{{location}}/instances/{{instance_name}} roles/viewer user:jane@example.com"
```

IAM binding imports use space-delimited identifiers: the resource in question and the role, e.g.

```sh
$ pulumi import gcp:notebooks/instanceIamMember:InstanceIamMember editor "projects/{{project}}/locations/{{location}}/instances/{{instance_name}} roles/viewer"
```

IAM policy imports use the identifier of the resource in question, e.g.

```sh
$ pulumi import gcp:notebooks/instanceIamMember:InstanceIamMember editor projects/{{project}}/locations/{{location}}/instances/{{instance_name}}
```

-> **Custom Roles** If you're importing a IAM resource with a custom role, make sure to use the

 full name of the custom role, e.g. `[projects/my-project|organizations/my-org]/roles/my-custom-role`.


	conditionrBp:n
l
	notebooksInstanceIamMemberConditionCgcp:notebooks/InstanceIamMemberCondition:InstanceIamMemberConditionO
instanceName" ;Used to find the parent resource to bind the IAM policy to
ÿ
locationB" ≈A reference to the zone where the machine resides. Used to find the parent resource to bind the IAM policy to. If not specified,
the value will be parsed from the identifier of the parent resource. If no location is provided in the parent identifier and no
location is specified, it is taken from the provider configuration.
”	
member" ƒ	Identities that will be granted the privilege in `role`.
Each entry can have one of the following values:
* **allUsers**: A special identifier that represents anyone who is on the internet; with or without a Google account.
* **allAuthenticatedUsers**: A special identifier that represents anyone who is authenticated with a Google account or a service account.
* **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com or joe@example.com.
* **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
* **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
* **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
* **projectOwner:projectid**: Owners of the given project. For example, "projectOwner:my-example-project"
* **projectEditor:projectid**: Editors of the given project. For example, "projectEditor:my-example-project"
* **projectViewer:projectid**: Viewers of the given project. For example, "projectViewer:my-example-project"
ì
projectB" ÅThe ID of the project in which the resource belongs.
If it is not provided, the project will be parsed from the identifier of the parent resource. If no project is provided in the parent identifier and no project is specified, the provider project is used.
Ÿ
role" ÃThe role that should be applied. Only one
`gcp.notebooks.InstanceIamBinding` can be used per role. Note that custom roles must be of the format
`[projects|organizations]/{parent-name}/roles/{role-name}`.
"
	conditionrBp:n
l
	notebooksInstanceIamMemberConditionCgcp:notebooks/InstanceIamMemberCondition:InstanceIamMemberCondition"3
etag" '(Computed) The etag of the IAM policy.
"O
instanceName" ;Used to find the parent resource to bind the IAM policy to
"÷
location" ≈A reference to the zone where the machine resides. Used to find the parent resource to bind the IAM policy to. If not specified,
the value will be parsed from the identifier of the parent resource. If no location is provided in the parent identifier and no
location is specified, it is taken from the provider configuration.
"”	
member" ƒ	Identities that will be granted the privilege in `role`.
Each entry can have one of the following values:
* **allUsers**: A special identifier that represents anyone who is on the internet; with or without a Google account.
* **allAuthenticatedUsers**: A special identifier that represents anyone who is authenticated with a Google account or a service account.
* **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com or joe@example.com.
* **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
* **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
* **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
* **projectOwner:projectid**: Owners of the given project. For example, "projectOwner:my-example-project"
* **projectEditor:projectid**: Editors of the given project. For example, "projectEditor:my-example-project"
* **projectViewer:projectid**: Viewers of the given project. For example, "projectViewer:my-example-project"
"ë
project" ÅThe ID of the project in which the resource belongs.
If it is not provided, the project will be parsed from the identifier of the parent resource. If no project is provided in the parent identifier and no project is specified, the provider project is used.
"Ÿ
role" ÃThe role that should be applied. Only one
`gcp.notebooks.InstanceIamBinding` can be used per role. Note that custom roles must be of the format
`[projects|organizations]/{parent-name}/roles/{role-name}`.
*¸ 
Q
	notebooksInstanceIamPolicy1gcp:notebooks/instanceIamPolicy:InstanceIamPolicyÆΩThree different resources help you manage your IAM policy for Cloud AI Notebooks Instance. Each of these resources serves a different use case:

* `gcp.notebooks.InstanceIamPolicy`: Authoritative. Sets the IAM policy for the instance and replaces any existing policy already attached.
* `gcp.notebooks.InstanceIamBinding`: Authoritative for a given role. Updates the IAM policy to grant a role to a list of members. Other roles within the IAM policy for the instance are preserved.
* `gcp.notebooks.InstanceIamMember`: Non-authoritative. Updates the IAM policy to grant a role to a new member. Other members for the role for the instance are preserved.

A data source can be used to retrieve policy data in advent you do not need creation

* `gcp.notebooks.InstanceIamPolicy`: Retrieves the IAM policy for the instance

> **Note:** `gcp.notebooks.InstanceIamPolicy` **cannot** be used in conjunction with `gcp.notebooks.InstanceIamBinding` and `gcp.notebooks.InstanceIamMember` or they will fight over what your policy should be.

> **Note:** `gcp.notebooks.InstanceIamBinding` resources **can be** used in conjunction with `gcp.notebooks.InstanceIamMember` resources **only if** they do not grant privilege to the same role.



## gcp.notebooks.InstanceIamPolicy

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const admin = gcp.organizations.getIAMPolicy({
    bindings: [{
        role: "roles/viewer",
        members: ["user:jane@example.com"],
    }],
});
const policy = new gcp.notebooks.InstanceIamPolicy("policy", {
    project: instance.project,
    location: instance.location,
    instanceName: instance.name,
    policyData: admin.then(admin => admin.policyData),
});
```
```python
import pulumi
import pulumi_gcp as gcp

admin = gcp.organizations.get_iam_policy(bindings=[{
    "role": "roles/viewer",
    "members": ["user:jane@example.com"],
}])
policy = gcp.notebooks.InstanceIamPolicy("policy",
    project=instance["project"],
    location=instance["location"],
    instance_name=instance["name"],
    policy_data=admin.policy_data)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var admin = Gcp.Organizations.GetIAMPolicy.Invoke(new()
    {
        Bindings = new[]
        {
            new Gcp.Organizations.Inputs.GetIAMPolicyBindingInputArgs
            {
                Role = "roles/viewer",
                Members = new[]
                {
                    "user:jane@example.com",
                },
            },
        },
    });

    var policy = new Gcp.Notebooks.InstanceIamPolicy("policy", new()
    {
        Project = instance.Project,
        Location = instance.Location,
        InstanceName = instance.Name,
        PolicyData = admin.Apply(getIAMPolicyResult => getIAMPolicyResult.PolicyData),
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		admin, err := organizations.LookupIAMPolicy(ctx, &organizations.LookupIAMPolicyArgs{
			Bindings: []organizations.GetIAMPolicyBinding{
				{
					Role: "roles/viewer",
					Members: []string{
						"user:jane@example.com",
					},
				},
			},
		}, nil)
		if err != nil {
			return err
		}
		_, err = notebooks.NewInstanceIamPolicy(ctx, "policy", &notebooks.InstanceIamPolicyArgs{
			Project:      pulumi.Any(instance.Project),
			Location:     pulumi.Any(instance.Location),
			InstanceName: pulumi.Any(instance.Name),
			PolicyData:   pulumi.String(admin.PolicyData),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.organizations.OrganizationsFunctions;
import com.pulumi.gcp.organizations.inputs.GetIAMPolicyArgs;
import com.pulumi.gcp.notebooks.InstanceIamPolicy;
import com.pulumi.gcp.notebooks.InstanceIamPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var admin = OrganizationsFunctions.getIAMPolicy(GetIAMPolicyArgs.builder()
            .bindings(GetIAMPolicyBindingArgs.builder()
                .role("roles/viewer")
                .members("user:jane@example.com")
                .build())
            .build());

        var policy = new InstanceIamPolicy("policy", InstanceIamPolicyArgs.builder()
            .project(instance.project())
            .location(instance.location())
            .instanceName(instance.name())
            .policyData(admin.applyValue(getIAMPolicyResult -> getIAMPolicyResult.policyData()))
            .build());

    }
}
```
```yaml
resources:
  policy:
    type: gcp:notebooks:InstanceIamPolicy
    properties:
      project: ${instance.project}
      location: ${instance.location}
      instanceName: ${instance.name}
      policyData: ${admin.policyData}
variables:
  admin:
    fn::invoke:
      function: gcp:organizations:getIAMPolicy
      arguments:
        bindings:
          - role: roles/viewer
            members:
              - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.InstanceIamBinding

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const binding = new gcp.notebooks.InstanceIamBinding("binding", {
    project: instance.project,
    location: instance.location,
    instanceName: instance.name,
    role: "roles/viewer",
    members: ["user:jane@example.com"],
});
```
```python
import pulumi
import pulumi_gcp as gcp

binding = gcp.notebooks.InstanceIamBinding("binding",
    project=instance["project"],
    location=instance["location"],
    instance_name=instance["name"],
    role="roles/viewer",
    members=["user:jane@example.com"])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var binding = new Gcp.Notebooks.InstanceIamBinding("binding", new()
    {
        Project = instance.Project,
        Location = instance.Location,
        InstanceName = instance.Name,
        Role = "roles/viewer",
        Members = new[]
        {
            "user:jane@example.com",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewInstanceIamBinding(ctx, "binding", &notebooks.InstanceIamBindingArgs{
			Project:      pulumi.Any(instance.Project),
			Location:     pulumi.Any(instance.Location),
			InstanceName: pulumi.Any(instance.Name),
			Role:         pulumi.String("roles/viewer"),
			Members: pulumi.StringArray{
				pulumi.String("user:jane@example.com"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.InstanceIamBinding;
import com.pulumi.gcp.notebooks.InstanceIamBindingArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var binding = new InstanceIamBinding("binding", InstanceIamBindingArgs.builder()
            .project(instance.project())
            .location(instance.location())
            .instanceName(instance.name())
            .role("roles/viewer")
            .members("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  binding:
    type: gcp:notebooks:InstanceIamBinding
    properties:
      project: ${instance.project}
      location: ${instance.location}
      instanceName: ${instance.name}
      role: roles/viewer
      members:
        - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.InstanceIamMember

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const member = new gcp.notebooks.InstanceIamMember("member", {
    project: instance.project,
    location: instance.location,
    instanceName: instance.name,
    role: "roles/viewer",
    member: "user:jane@example.com",
});
```
```python
import pulumi
import pulumi_gcp as gcp

member = gcp.notebooks.InstanceIamMember("member",
    project=instance["project"],
    location=instance["location"],
    instance_name=instance["name"],
    role="roles/viewer",
    member="user:jane@example.com")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var member = new Gcp.Notebooks.InstanceIamMember("member", new()
    {
        Project = instance.Project,
        Location = instance.Location,
        InstanceName = instance.Name,
        Role = "roles/viewer",
        Member = "user:jane@example.com",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewInstanceIamMember(ctx, "member", &notebooks.InstanceIamMemberArgs{
			Project:      pulumi.Any(instance.Project),
			Location:     pulumi.Any(instance.Location),
			InstanceName: pulumi.Any(instance.Name),
			Role:         pulumi.String("roles/viewer"),
			Member:       pulumi.String("user:jane@example.com"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.InstanceIamMember;
import com.pulumi.gcp.notebooks.InstanceIamMemberArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var member = new InstanceIamMember("member", InstanceIamMemberArgs.builder()
            .project(instance.project())
            .location(instance.location())
            .instanceName(instance.name())
            .role("roles/viewer")
            .member("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  member:
    type: gcp:notebooks:InstanceIamMember
    properties:
      project: ${instance.project}
      location: ${instance.location}
      instanceName: ${instance.name}
      role: roles/viewer
      member: user:jane@example.com
```
<!--End PulumiCodeChooser -->


## This resource supports User Project Overrides.

-

# IAM policy for Cloud AI Notebooks Instance
Three different resources help you manage your IAM policy for Cloud AI Notebooks Instance. Each of these resources serves a different use case:

* `gcp.notebooks.InstanceIamPolicy`: Authoritative. Sets the IAM policy for the instance and replaces any existing policy already attached.
* `gcp.notebooks.InstanceIamBinding`: Authoritative for a given role. Updates the IAM policy to grant a role to a list of members. Other roles within the IAM policy for the instance are preserved.
* `gcp.notebooks.InstanceIamMember`: Non-authoritative. Updates the IAM policy to grant a role to a new member. Other members for the role for the instance are preserved.

A data source can be used to retrieve policy data in advent you do not need creation

* `gcp.notebooks.InstanceIamPolicy`: Retrieves the IAM policy for the instance

> **Note:** `gcp.notebooks.InstanceIamPolicy` **cannot** be used in conjunction with `gcp.notebooks.InstanceIamBinding` and `gcp.notebooks.InstanceIamMember` or they will fight over what your policy should be.

> **Note:** `gcp.notebooks.InstanceIamBinding` resources **can be** used in conjunction with `gcp.notebooks.InstanceIamMember` resources **only if** they do not grant privilege to the same role.



## gcp.notebooks.InstanceIamPolicy

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const admin = gcp.organizations.getIAMPolicy({
    bindings: [{
        role: "roles/viewer",
        members: ["user:jane@example.com"],
    }],
});
const policy = new gcp.notebooks.InstanceIamPolicy("policy", {
    project: instance.project,
    location: instance.location,
    instanceName: instance.name,
    policyData: admin.then(admin => admin.policyData),
});
```
```python
import pulumi
import pulumi_gcp as gcp

admin = gcp.organizations.get_iam_policy(bindings=[{
    "role": "roles/viewer",
    "members": ["user:jane@example.com"],
}])
policy = gcp.notebooks.InstanceIamPolicy("policy",
    project=instance["project"],
    location=instance["location"],
    instance_name=instance["name"],
    policy_data=admin.policy_data)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var admin = Gcp.Organizations.GetIAMPolicy.Invoke(new()
    {
        Bindings = new[]
        {
            new Gcp.Organizations.Inputs.GetIAMPolicyBindingInputArgs
            {
                Role = "roles/viewer",
                Members = new[]
                {
                    "user:jane@example.com",
                },
            },
        },
    });

    var policy = new Gcp.Notebooks.InstanceIamPolicy("policy", new()
    {
        Project = instance.Project,
        Location = instance.Location,
        InstanceName = instance.Name,
        PolicyData = admin.Apply(getIAMPolicyResult => getIAMPolicyResult.PolicyData),
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		admin, err := organizations.LookupIAMPolicy(ctx, &organizations.LookupIAMPolicyArgs{
			Bindings: []organizations.GetIAMPolicyBinding{
				{
					Role: "roles/viewer",
					Members: []string{
						"user:jane@example.com",
					},
				},
			},
		}, nil)
		if err != nil {
			return err
		}
		_, err = notebooks.NewInstanceIamPolicy(ctx, "policy", &notebooks.InstanceIamPolicyArgs{
			Project:      pulumi.Any(instance.Project),
			Location:     pulumi.Any(instance.Location),
			InstanceName: pulumi.Any(instance.Name),
			PolicyData:   pulumi.String(admin.PolicyData),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.organizations.OrganizationsFunctions;
import com.pulumi.gcp.organizations.inputs.GetIAMPolicyArgs;
import com.pulumi.gcp.notebooks.InstanceIamPolicy;
import com.pulumi.gcp.notebooks.InstanceIamPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var admin = OrganizationsFunctions.getIAMPolicy(GetIAMPolicyArgs.builder()
            .bindings(GetIAMPolicyBindingArgs.builder()
                .role("roles/viewer")
                .members("user:jane@example.com")
                .build())
            .build());

        var policy = new InstanceIamPolicy("policy", InstanceIamPolicyArgs.builder()
            .project(instance.project())
            .location(instance.location())
            .instanceName(instance.name())
            .policyData(admin.applyValue(getIAMPolicyResult -> getIAMPolicyResult.policyData()))
            .build());

    }
}
```
```yaml
resources:
  policy:
    type: gcp:notebooks:InstanceIamPolicy
    properties:
      project: ${instance.project}
      location: ${instance.location}
      instanceName: ${instance.name}
      policyData: ${admin.policyData}
variables:
  admin:
    fn::invoke:
      function: gcp:organizations:getIAMPolicy
      arguments:
        bindings:
          - role: roles/viewer
            members:
              - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.InstanceIamBinding

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const binding = new gcp.notebooks.InstanceIamBinding("binding", {
    project: instance.project,
    location: instance.location,
    instanceName: instance.name,
    role: "roles/viewer",
    members: ["user:jane@example.com"],
});
```
```python
import pulumi
import pulumi_gcp as gcp

binding = gcp.notebooks.InstanceIamBinding("binding",
    project=instance["project"],
    location=instance["location"],
    instance_name=instance["name"],
    role="roles/viewer",
    members=["user:jane@example.com"])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var binding = new Gcp.Notebooks.InstanceIamBinding("binding", new()
    {
        Project = instance.Project,
        Location = instance.Location,
        InstanceName = instance.Name,
        Role = "roles/viewer",
        Members = new[]
        {
            "user:jane@example.com",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewInstanceIamBinding(ctx, "binding", &notebooks.InstanceIamBindingArgs{
			Project:      pulumi.Any(instance.Project),
			Location:     pulumi.Any(instance.Location),
			InstanceName: pulumi.Any(instance.Name),
			Role:         pulumi.String("roles/viewer"),
			Members: pulumi.StringArray{
				pulumi.String("user:jane@example.com"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.InstanceIamBinding;
import com.pulumi.gcp.notebooks.InstanceIamBindingArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var binding = new InstanceIamBinding("binding", InstanceIamBindingArgs.builder()
            .project(instance.project())
            .location(instance.location())
            .instanceName(instance.name())
            .role("roles/viewer")
            .members("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  binding:
    type: gcp:notebooks:InstanceIamBinding
    properties:
      project: ${instance.project}
      location: ${instance.location}
      instanceName: ${instance.name}
      role: roles/viewer
      members:
        - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.InstanceIamMember

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const member = new gcp.notebooks.InstanceIamMember("member", {
    project: instance.project,
    location: instance.location,
    instanceName: instance.name,
    role: "roles/viewer",
    member: "user:jane@example.com",
});
```
```python
import pulumi
import pulumi_gcp as gcp

member = gcp.notebooks.InstanceIamMember("member",
    project=instance["project"],
    location=instance["location"],
    instance_name=instance["name"],
    role="roles/viewer",
    member="user:jane@example.com")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var member = new Gcp.Notebooks.InstanceIamMember("member", new()
    {
        Project = instance.Project,
        Location = instance.Location,
        InstanceName = instance.Name,
        Role = "roles/viewer",
        Member = "user:jane@example.com",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewInstanceIamMember(ctx, "member", &notebooks.InstanceIamMemberArgs{
			Project:      pulumi.Any(instance.Project),
			Location:     pulumi.Any(instance.Location),
			InstanceName: pulumi.Any(instance.Name),
			Role:         pulumi.String("roles/viewer"),
			Member:       pulumi.String("user:jane@example.com"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.InstanceIamMember;
import com.pulumi.gcp.notebooks.InstanceIamMemberArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var member = new InstanceIamMember("member", InstanceIamMemberArgs.builder()
            .project(instance.project())
            .location(instance.location())
            .instanceName(instance.name())
            .role("roles/viewer")
            .member("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  member:
    type: gcp:notebooks:InstanceIamMember
    properties:
      project: ${instance.project}
      location: ${instance.location}
      instanceName: ${instance.name}
      role: roles/viewer
      member: user:jane@example.com
```
<!--End PulumiCodeChooser -->

## Import

For all import syntaxes, the "resource in question" can take any of the following forms:

* projects/{{project}}/locations/{{location}}/instances/{{instance_name}}

* {{project}}/{{location}}/{{instance_name}}

* {{location}}/{{instance_name}}

* {{instance_name}}

Any variables not passed in the import command will be taken from the provider configuration.

Cloud AI Notebooks instance IAM resources can be imported using the resource identifiers, role, and member.

IAM member imports use space-delimited identifiers: the resource in question, the role, and the member identity, e.g.

```sh
$ pulumi import gcp:notebooks/instanceIamPolicy:InstanceIamPolicy editor "projects/{{project}}/locations/{{location}}/instances/{{instance_name}} roles/viewer user:jane@example.com"
```

IAM binding imports use space-delimited identifiers: the resource in question and the role, e.g.

```sh
$ pulumi import gcp:notebooks/instanceIamPolicy:InstanceIamPolicy editor "projects/{{project}}/locations/{{location}}/instances/{{instance_name}} roles/viewer"
```

IAM policy imports use the identifier of the resource in question, e.g.

```sh
$ pulumi import gcp:notebooks/instanceIamPolicy:InstanceIamPolicy editor projects/{{project}}/locations/{{location}}/instances/{{instance_name}}
```

-> **Custom Roles** If you're importing a IAM resource with a custom role, make sure to use the

 full name of the custom role, e.g. `[projects/my-project|organizations/my-org]/roles/my-custom-role`.

O
instanceName" ;Used to find the parent resource to bind the IAM policy to
ÿ
locationB" ≈A reference to the zone where the machine resides. Used to find the parent resource to bind the IAM policy to. If not specified,
the value will be parsed from the identifier of the parent resource. If no location is provided in the parent identifier and no
location is specified, it is taken from the provider configuration.
_

policyData" MThe policy data generated by
a `gcp.organizations.getIAMPolicy` data source.
ì
projectB" ÅThe ID of the project in which the resource belongs.
If it is not provided, the project will be parsed from the identifier of the parent resource. If no project is provided in the parent identifier and no project is specified, the provider project is used.
"3
etag" '(Computed) The etag of the IAM policy.
"O
instanceName" ;Used to find the parent resource to bind the IAM policy to
"÷
location" ≈A reference to the zone where the machine resides. Used to find the parent resource to bind the IAM policy to. If not specified,
the value will be parsed from the identifier of the parent resource. If no location is provided in the parent identifier and no
location is specified, it is taken from the provider configuration.
"_

policyData" MThe policy data generated by
a `gcp.organizations.getIAMPolicy` data source.
"ë
project" ÅThe ID of the project in which the resource belongs.
If it is not provided, the project will be parsed from the identifier of the parent resource. If no project is provided in the parent identifier and no project is specified, the provider project is used.
*Ä
6
	notebooksLocationgcp:notebooks/location:LocationæRepresents a Location resource.

## Import

Location can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{name}}`

* `{{project}}/{{name}}`

* `{{name}}`

When using the `pulumi import` command, Location can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:notebooks/location:Location default projects/{{project}}/locations/{{name}}
```

```sh
$ pulumi import gcp:notebooks/location:Location default {{project}}/{{name}}
```

```sh
$ pulumi import gcp:notebooks/location:Location default {{name}}
```

-
nameB" Name of the Location resource.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"+
name" Name of the Location resource.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"1
selfLink" !The URI of the created resource.
*±À
3
	notebooksRuntimegcp:notebooks/runtime:RuntimeçÆA Cloud AI Platform Notebook runtime.


> **Note:** Due to limitations of the Notebooks Runtime API, many fields
in this resource do not properly detect drift. These fields will also not
appear in state once imported.


To get more information about Runtime, see:

* [API documentation](https://cloud.google.com/ai-platform/notebooks/docs/reference/rest)
* How-to Guides
    * [Official Documentation](https://cloud.google.com/ai-platform-notebooks)

## Example Usage

### Notebook Runtime Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const runtime = new gcp.notebooks.Runtime("runtime", {
    name: "notebooks-runtime",
    location: "us-central1",
    accessConfig: {
        accessType: "SINGLE_USER",
        runtimeOwner: "admin@hashicorptest.com",
    },
    virtualMachine: {
        virtualMachineConfig: {
            machineType: "n1-standard-4",
            dataDisk: {
                initializeParams: {
                    diskSizeGb: 100,
                    diskType: "PD_STANDARD",
                },
            },
        },
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

runtime = gcp.notebooks.Runtime("runtime",
    name="notebooks-runtime",
    location="us-central1",
    access_config={
        "access_type": "SINGLE_USER",
        "runtime_owner": "admin@hashicorptest.com",
    },
    virtual_machine={
        "virtual_machine_config": {
            "machine_type": "n1-standard-4",
            "data_disk": {
                "initialize_params": {
                    "disk_size_gb": 100,
                    "disk_type": "PD_STANDARD",
                },
            },
        },
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var runtime = new Gcp.Notebooks.Runtime("runtime", new()
    {
        Name = "notebooks-runtime",
        Location = "us-central1",
        AccessConfig = new Gcp.Notebooks.Inputs.RuntimeAccessConfigArgs
        {
            AccessType = "SINGLE_USER",
            RuntimeOwner = "admin@hashicorptest.com",
        },
        VirtualMachine = new Gcp.Notebooks.Inputs.RuntimeVirtualMachineArgs
        {
            VirtualMachineConfig = new Gcp.Notebooks.Inputs.RuntimeVirtualMachineVirtualMachineConfigArgs
            {
                MachineType = "n1-standard-4",
                DataDisk = new Gcp.Notebooks.Inputs.RuntimeVirtualMachineVirtualMachineConfigDataDiskArgs
                {
                    InitializeParams = new Gcp.Notebooks.Inputs.RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParamsArgs
                    {
                        DiskSizeGb = 100,
                        DiskType = "PD_STANDARD",
                    },
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewRuntime(ctx, "runtime", &notebooks.RuntimeArgs{
			Name:     pulumi.String("notebooks-runtime"),
			Location: pulumi.String("us-central1"),
			AccessConfig: &notebooks.RuntimeAccessConfigArgs{
				AccessType:   pulumi.String("SINGLE_USER"),
				RuntimeOwner: pulumi.String("admin@hashicorptest.com"),
			},
			VirtualMachine: &notebooks.RuntimeVirtualMachineArgs{
				VirtualMachineConfig: &notebooks.RuntimeVirtualMachineVirtualMachineConfigArgs{
					MachineType: pulumi.String("n1-standard-4"),
					DataDisk: &notebooks.RuntimeVirtualMachineVirtualMachineConfigDataDiskArgs{
						InitializeParams: &notebooks.RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParamsArgs{
							DiskSizeGb: pulumi.Int(100),
							DiskType:   pulumi.String("PD_STANDARD"),
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.Runtime;
import com.pulumi.gcp.notebooks.RuntimeArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeAccessConfigArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeVirtualMachineArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeVirtualMachineVirtualMachineConfigArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeVirtualMachineVirtualMachineConfigDataDiskArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParamsArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var runtime = new Runtime("runtime", RuntimeArgs.builder()
            .name("notebooks-runtime")
            .location("us-central1")
            .accessConfig(RuntimeAccessConfigArgs.builder()
                .accessType("SINGLE_USER")
                .runtimeOwner("admin@hashicorptest.com")
                .build())
            .virtualMachine(RuntimeVirtualMachineArgs.builder()
                .virtualMachineConfig(RuntimeVirtualMachineVirtualMachineConfigArgs.builder()
                    .machineType("n1-standard-4")
                    .dataDisk(RuntimeVirtualMachineVirtualMachineConfigDataDiskArgs.builder()
                        .initializeParams(RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParamsArgs.builder()
                            .diskSizeGb("100")
                            .diskType("PD_STANDARD")
                            .build())
                        .build())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  runtime:
    type: gcp:notebooks:Runtime
    properties:
      name: notebooks-runtime
      location: us-central1
      accessConfig:
        accessType: SINGLE_USER
        runtimeOwner: admin@hashicorptest.com
      virtualMachine:
        virtualMachineConfig:
          machineType: n1-standard-4
          dataDisk:
            initializeParams:
              diskSizeGb: '100'
              diskType: PD_STANDARD
```
<!--End PulumiCodeChooser -->
### Notebook Runtime Basic Gpu


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const runtimeGpu = new gcp.notebooks.Runtime("runtime_gpu", {
    name: "notebooks-runtime-gpu",
    location: "us-central1",
    accessConfig: {
        accessType: "SINGLE_USER",
        runtimeOwner: "admin@hashicorptest.com",
    },
    softwareConfig: {
        installGpuDriver: true,
    },
    virtualMachine: {
        virtualMachineConfig: {
            machineType: "n1-standard-4",
            dataDisk: {
                initializeParams: {
                    diskSizeGb: 100,
                    diskType: "PD_STANDARD",
                },
            },
            acceleratorConfig: {
                coreCount: 1,
                type: "NVIDIA_TESLA_V100",
            },
        },
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

runtime_gpu = gcp.notebooks.Runtime("runtime_gpu",
    name="notebooks-runtime-gpu",
    location="us-central1",
    access_config={
        "access_type": "SINGLE_USER",
        "runtime_owner": "admin@hashicorptest.com",
    },
    software_config={
        "install_gpu_driver": True,
    },
    virtual_machine={
        "virtual_machine_config": {
            "machine_type": "n1-standard-4",
            "data_disk": {
                "initialize_params": {
                    "disk_size_gb": 100,
                    "disk_type": "PD_STANDARD",
                },
            },
            "accelerator_config": {
                "core_count": 1,
                "type": "NVIDIA_TESLA_V100",
            },
        },
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var runtimeGpu = new Gcp.Notebooks.Runtime("runtime_gpu", new()
    {
        Name = "notebooks-runtime-gpu",
        Location = "us-central1",
        AccessConfig = new Gcp.Notebooks.Inputs.RuntimeAccessConfigArgs
        {
            AccessType = "SINGLE_USER",
            RuntimeOwner = "admin@hashicorptest.com",
        },
        SoftwareConfig = new Gcp.Notebooks.Inputs.RuntimeSoftwareConfigArgs
        {
            InstallGpuDriver = true,
        },
        VirtualMachine = new Gcp.Notebooks.Inputs.RuntimeVirtualMachineArgs
        {
            VirtualMachineConfig = new Gcp.Notebooks.Inputs.RuntimeVirtualMachineVirtualMachineConfigArgs
            {
                MachineType = "n1-standard-4",
                DataDisk = new Gcp.Notebooks.Inputs.RuntimeVirtualMachineVirtualMachineConfigDataDiskArgs
                {
                    InitializeParams = new Gcp.Notebooks.Inputs.RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParamsArgs
                    {
                        DiskSizeGb = 100,
                        DiskType = "PD_STANDARD",
                    },
                },
                AcceleratorConfig = new Gcp.Notebooks.Inputs.RuntimeVirtualMachineVirtualMachineConfigAcceleratorConfigArgs
                {
                    CoreCount = 1,
                    Type = "NVIDIA_TESLA_V100",
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewRuntime(ctx, "runtime_gpu", &notebooks.RuntimeArgs{
			Name:     pulumi.String("notebooks-runtime-gpu"),
			Location: pulumi.String("us-central1"),
			AccessConfig: &notebooks.RuntimeAccessConfigArgs{
				AccessType:   pulumi.String("SINGLE_USER"),
				RuntimeOwner: pulumi.String("admin@hashicorptest.com"),
			},
			SoftwareConfig: &notebooks.RuntimeSoftwareConfigArgs{
				InstallGpuDriver: pulumi.Bool(true),
			},
			VirtualMachine: &notebooks.RuntimeVirtualMachineArgs{
				VirtualMachineConfig: &notebooks.RuntimeVirtualMachineVirtualMachineConfigArgs{
					MachineType: pulumi.String("n1-standard-4"),
					DataDisk: &notebooks.RuntimeVirtualMachineVirtualMachineConfigDataDiskArgs{
						InitializeParams: &notebooks.RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParamsArgs{
							DiskSizeGb: pulumi.Int(100),
							DiskType:   pulumi.String("PD_STANDARD"),
						},
					},
					AcceleratorConfig: &notebooks.RuntimeVirtualMachineVirtualMachineConfigAcceleratorConfigArgs{
						CoreCount: pulumi.Int(1),
						Type:      pulumi.String("NVIDIA_TESLA_V100"),
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.Runtime;
import com.pulumi.gcp.notebooks.RuntimeArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeAccessConfigArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeSoftwareConfigArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeVirtualMachineArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeVirtualMachineVirtualMachineConfigArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeVirtualMachineVirtualMachineConfigDataDiskArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParamsArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeVirtualMachineVirtualMachineConfigAcceleratorConfigArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var runtimeGpu = new Runtime("runtimeGpu", RuntimeArgs.builder()
            .name("notebooks-runtime-gpu")
            .location("us-central1")
            .accessConfig(RuntimeAccessConfigArgs.builder()
                .accessType("SINGLE_USER")
                .runtimeOwner("admin@hashicorptest.com")
                .build())
            .softwareConfig(RuntimeSoftwareConfigArgs.builder()
                .installGpuDriver(true)
                .build())
            .virtualMachine(RuntimeVirtualMachineArgs.builder()
                .virtualMachineConfig(RuntimeVirtualMachineVirtualMachineConfigArgs.builder()
                    .machineType("n1-standard-4")
                    .dataDisk(RuntimeVirtualMachineVirtualMachineConfigDataDiskArgs.builder()
                        .initializeParams(RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParamsArgs.builder()
                            .diskSizeGb("100")
                            .diskType("PD_STANDARD")
                            .build())
                        .build())
                    .acceleratorConfig(RuntimeVirtualMachineVirtualMachineConfigAcceleratorConfigArgs.builder()
                        .coreCount("1")
                        .type("NVIDIA_TESLA_V100")
                        .build())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  runtimeGpu:
    type: gcp:notebooks:Runtime
    name: runtime_gpu
    properties:
      name: notebooks-runtime-gpu
      location: us-central1
      accessConfig:
        accessType: SINGLE_USER
        runtimeOwner: admin@hashicorptest.com
      softwareConfig:
        installGpuDriver: true
      virtualMachine:
        virtualMachineConfig:
          machineType: n1-standard-4
          dataDisk:
            initializeParams:
              diskSizeGb: '100'
              diskType: PD_STANDARD
          acceleratorConfig:
            coreCount: '1'
            type: NVIDIA_TESLA_V100
```
<!--End PulumiCodeChooser -->
### Notebook Runtime Basic Container


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const runtimeContainer = new gcp.notebooks.Runtime("runtime_container", {
    name: "notebooks-runtime-container",
    location: "us-central1",
    accessConfig: {
        accessType: "SINGLE_USER",
        runtimeOwner: "admin@hashicorptest.com",
    },
    virtualMachine: {
        virtualMachineConfig: {
            machineType: "n1-standard-4",
            dataDisk: {
                initializeParams: {
                    diskSizeGb: 100,
                    diskType: "PD_STANDARD",
                },
            },
            containerImages: [
                {
                    repository: "gcr.io/deeplearning-platform-release/base-cpu",
                    tag: "latest",
                },
                {
                    repository: "gcr.io/deeplearning-platform-release/beam-notebooks",
                    tag: "latest",
                },
            ],
        },
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

runtime_container = gcp.notebooks.Runtime("runtime_container",
    name="notebooks-runtime-container",
    location="us-central1",
    access_config={
        "access_type": "SINGLE_USER",
        "runtime_owner": "admin@hashicorptest.com",
    },
    virtual_machine={
        "virtual_machine_config": {
            "machine_type": "n1-standard-4",
            "data_disk": {
                "initialize_params": {
                    "disk_size_gb": 100,
                    "disk_type": "PD_STANDARD",
                },
            },
            "container_images": [
                {
                    "repository": "gcr.io/deeplearning-platform-release/base-cpu",
                    "tag": "latest",
                },
                {
                    "repository": "gcr.io/deeplearning-platform-release/beam-notebooks",
                    "tag": "latest",
                },
            ],
        },
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var runtimeContainer = new Gcp.Notebooks.Runtime("runtime_container", new()
    {
        Name = "notebooks-runtime-container",
        Location = "us-central1",
        AccessConfig = new Gcp.Notebooks.Inputs.RuntimeAccessConfigArgs
        {
            AccessType = "SINGLE_USER",
            RuntimeOwner = "admin@hashicorptest.com",
        },
        VirtualMachine = new Gcp.Notebooks.Inputs.RuntimeVirtualMachineArgs
        {
            VirtualMachineConfig = new Gcp.Notebooks.Inputs.RuntimeVirtualMachineVirtualMachineConfigArgs
            {
                MachineType = "n1-standard-4",
                DataDisk = new Gcp.Notebooks.Inputs.RuntimeVirtualMachineVirtualMachineConfigDataDiskArgs
                {
                    InitializeParams = new Gcp.Notebooks.Inputs.RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParamsArgs
                    {
                        DiskSizeGb = 100,
                        DiskType = "PD_STANDARD",
                    },
                },
                ContainerImages = new[]
                {
                    new Gcp.Notebooks.Inputs.RuntimeVirtualMachineVirtualMachineConfigContainerImageArgs
                    {
                        Repository = "gcr.io/deeplearning-platform-release/base-cpu",
                        Tag = "latest",
                    },
                    new Gcp.Notebooks.Inputs.RuntimeVirtualMachineVirtualMachineConfigContainerImageArgs
                    {
                        Repository = "gcr.io/deeplearning-platform-release/beam-notebooks",
                        Tag = "latest",
                    },
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewRuntime(ctx, "runtime_container", &notebooks.RuntimeArgs{
			Name:     pulumi.String("notebooks-runtime-container"),
			Location: pulumi.String("us-central1"),
			AccessConfig: &notebooks.RuntimeAccessConfigArgs{
				AccessType:   pulumi.String("SINGLE_USER"),
				RuntimeOwner: pulumi.String("admin@hashicorptest.com"),
			},
			VirtualMachine: &notebooks.RuntimeVirtualMachineArgs{
				VirtualMachineConfig: &notebooks.RuntimeVirtualMachineVirtualMachineConfigArgs{
					MachineType: pulumi.String("n1-standard-4"),
					DataDisk: &notebooks.RuntimeVirtualMachineVirtualMachineConfigDataDiskArgs{
						InitializeParams: &notebooks.RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParamsArgs{
							DiskSizeGb: pulumi.Int(100),
							DiskType:   pulumi.String("PD_STANDARD"),
						},
					},
					ContainerImages: notebooks.RuntimeVirtualMachineVirtualMachineConfigContainerImageArray{
						&notebooks.RuntimeVirtualMachineVirtualMachineConfigContainerImageArgs{
							Repository: pulumi.String("gcr.io/deeplearning-platform-release/base-cpu"),
							Tag:        pulumi.String("latest"),
						},
						&notebooks.RuntimeVirtualMachineVirtualMachineConfigContainerImageArgs{
							Repository: pulumi.String("gcr.io/deeplearning-platform-release/beam-notebooks"),
							Tag:        pulumi.String("latest"),
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.Runtime;
import com.pulumi.gcp.notebooks.RuntimeArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeAccessConfigArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeVirtualMachineArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeVirtualMachineVirtualMachineConfigArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeVirtualMachineVirtualMachineConfigDataDiskArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParamsArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var runtimeContainer = new Runtime("runtimeContainer", RuntimeArgs.builder()
            .name("notebooks-runtime-container")
            .location("us-central1")
            .accessConfig(RuntimeAccessConfigArgs.builder()
                .accessType("SINGLE_USER")
                .runtimeOwner("admin@hashicorptest.com")
                .build())
            .virtualMachine(RuntimeVirtualMachineArgs.builder()
                .virtualMachineConfig(RuntimeVirtualMachineVirtualMachineConfigArgs.builder()
                    .machineType("n1-standard-4")
                    .dataDisk(RuntimeVirtualMachineVirtualMachineConfigDataDiskArgs.builder()
                        .initializeParams(RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParamsArgs.builder()
                            .diskSizeGb("100")
                            .diskType("PD_STANDARD")
                            .build())
                        .build())
                    .containerImages(                    
                        RuntimeVirtualMachineVirtualMachineConfigContainerImageArgs.builder()
                            .repository("gcr.io/deeplearning-platform-release/base-cpu")
                            .tag("latest")
                            .build(),
                        RuntimeVirtualMachineVirtualMachineConfigContainerImageArgs.builder()
                            .repository("gcr.io/deeplearning-platform-release/beam-notebooks")
                            .tag("latest")
                            .build())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  runtimeContainer:
    type: gcp:notebooks:Runtime
    name: runtime_container
    properties:
      name: notebooks-runtime-container
      location: us-central1
      accessConfig:
        accessType: SINGLE_USER
        runtimeOwner: admin@hashicorptest.com
      virtualMachine:
        virtualMachineConfig:
          machineType: n1-standard-4
          dataDisk:
            initializeParams:
              diskSizeGb: '100'
              diskType: PD_STANDARD
          containerImages:
            - repository: gcr.io/deeplearning-platform-release/base-cpu
              tag: latest
            - repository: gcr.io/deeplearning-platform-release/beam-notebooks
              tag: latest
```
<!--End PulumiCodeChooser -->
### Notebook Runtime Kernels


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const runtimeContainer = new gcp.notebooks.Runtime("runtime_container", {
    name: "notebooks-runtime-kernel",
    location: "us-central1",
    accessConfig: {
        accessType: "SINGLE_USER",
        runtimeOwner: "admin@hashicorptest.com",
    },
    softwareConfig: {
        kernels: [{
            repository: "gcr.io/deeplearning-platform-release/base-cpu",
            tag: "latest",
        }],
    },
    virtualMachine: {
        virtualMachineConfig: {
            machineType: "n1-standard-4",
            dataDisk: {
                initializeParams: {
                    diskSizeGb: 100,
                    diskType: "PD_STANDARD",
                },
            },
        },
    },
    labels: {
        k: "val",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

runtime_container = gcp.notebooks.Runtime("runtime_container",
    name="notebooks-runtime-kernel",
    location="us-central1",
    access_config={
        "access_type": "SINGLE_USER",
        "runtime_owner": "admin@hashicorptest.com",
    },
    software_config={
        "kernels": [{
            "repository": "gcr.io/deeplearning-platform-release/base-cpu",
            "tag": "latest",
        }],
    },
    virtual_machine={
        "virtual_machine_config": {
            "machine_type": "n1-standard-4",
            "data_disk": {
                "initialize_params": {
                    "disk_size_gb": 100,
                    "disk_type": "PD_STANDARD",
                },
            },
        },
    },
    labels={
        "k": "val",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var runtimeContainer = new Gcp.Notebooks.Runtime("runtime_container", new()
    {
        Name = "notebooks-runtime-kernel",
        Location = "us-central1",
        AccessConfig = new Gcp.Notebooks.Inputs.RuntimeAccessConfigArgs
        {
            AccessType = "SINGLE_USER",
            RuntimeOwner = "admin@hashicorptest.com",
        },
        SoftwareConfig = new Gcp.Notebooks.Inputs.RuntimeSoftwareConfigArgs
        {
            Kernels = new[]
            {
                new Gcp.Notebooks.Inputs.RuntimeSoftwareConfigKernelArgs
                {
                    Repository = "gcr.io/deeplearning-platform-release/base-cpu",
                    Tag = "latest",
                },
            },
        },
        VirtualMachine = new Gcp.Notebooks.Inputs.RuntimeVirtualMachineArgs
        {
            VirtualMachineConfig = new Gcp.Notebooks.Inputs.RuntimeVirtualMachineVirtualMachineConfigArgs
            {
                MachineType = "n1-standard-4",
                DataDisk = new Gcp.Notebooks.Inputs.RuntimeVirtualMachineVirtualMachineConfigDataDiskArgs
                {
                    InitializeParams = new Gcp.Notebooks.Inputs.RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParamsArgs
                    {
                        DiskSizeGb = 100,
                        DiskType = "PD_STANDARD",
                    },
                },
            },
        },
        Labels = 
        {
            { "k", "val" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewRuntime(ctx, "runtime_container", &notebooks.RuntimeArgs{
			Name:     pulumi.String("notebooks-runtime-kernel"),
			Location: pulumi.String("us-central1"),
			AccessConfig: &notebooks.RuntimeAccessConfigArgs{
				AccessType:   pulumi.String("SINGLE_USER"),
				RuntimeOwner: pulumi.String("admin@hashicorptest.com"),
			},
			SoftwareConfig: &notebooks.RuntimeSoftwareConfigArgs{
				Kernels: notebooks.RuntimeSoftwareConfigKernelArray{
					&notebooks.RuntimeSoftwareConfigKernelArgs{
						Repository: pulumi.String("gcr.io/deeplearning-platform-release/base-cpu"),
						Tag:        pulumi.String("latest"),
					},
				},
			},
			VirtualMachine: &notebooks.RuntimeVirtualMachineArgs{
				VirtualMachineConfig: &notebooks.RuntimeVirtualMachineVirtualMachineConfigArgs{
					MachineType: pulumi.String("n1-standard-4"),
					DataDisk: &notebooks.RuntimeVirtualMachineVirtualMachineConfigDataDiskArgs{
						InitializeParams: &notebooks.RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParamsArgs{
							DiskSizeGb: pulumi.Int(100),
							DiskType:   pulumi.String("PD_STANDARD"),
						},
					},
				},
			},
			Labels: pulumi.StringMap{
				"k": pulumi.String("val"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.Runtime;
import com.pulumi.gcp.notebooks.RuntimeArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeAccessConfigArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeSoftwareConfigArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeVirtualMachineArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeVirtualMachineVirtualMachineConfigArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeVirtualMachineVirtualMachineConfigDataDiskArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParamsArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var runtimeContainer = new Runtime("runtimeContainer", RuntimeArgs.builder()
            .name("notebooks-runtime-kernel")
            .location("us-central1")
            .accessConfig(RuntimeAccessConfigArgs.builder()
                .accessType("SINGLE_USER")
                .runtimeOwner("admin@hashicorptest.com")
                .build())
            .softwareConfig(RuntimeSoftwareConfigArgs.builder()
                .kernels(RuntimeSoftwareConfigKernelArgs.builder()
                    .repository("gcr.io/deeplearning-platform-release/base-cpu")
                    .tag("latest")
                    .build())
                .build())
            .virtualMachine(RuntimeVirtualMachineArgs.builder()
                .virtualMachineConfig(RuntimeVirtualMachineVirtualMachineConfigArgs.builder()
                    .machineType("n1-standard-4")
                    .dataDisk(RuntimeVirtualMachineVirtualMachineConfigDataDiskArgs.builder()
                        .initializeParams(RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParamsArgs.builder()
                            .diskSizeGb("100")
                            .diskType("PD_STANDARD")
                            .build())
                        .build())
                    .build())
                .build())
            .labels(Map.of("k", "val"))
            .build());

    }
}
```
```yaml
resources:
  runtimeContainer:
    type: gcp:notebooks:Runtime
    name: runtime_container
    properties:
      name: notebooks-runtime-kernel
      location: us-central1
      accessConfig:
        accessType: SINGLE_USER
        runtimeOwner: admin@hashicorptest.com
      softwareConfig:
        kernels:
          - repository: gcr.io/deeplearning-platform-release/base-cpu
            tag: latest
      virtualMachine:
        virtualMachineConfig:
          machineType: n1-standard-4
          dataDisk:
            initializeParams:
              diskSizeGb: '100'
              diskType: PD_STANDARD
      labels:
        k: val
```
<!--End PulumiCodeChooser -->
### Notebook Runtime Script


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const runtimeContainer = new gcp.notebooks.Runtime("runtime_container", {
    name: "notebooks-runtime-script",
    location: "us-central1",
    accessConfig: {
        accessType: "SINGLE_USER",
        runtimeOwner: "admin@hashicorptest.com",
    },
    softwareConfig: {
        postStartupScriptBehavior: "RUN_EVERY_START",
    },
    virtualMachine: {
        virtualMachineConfig: {
            machineType: "n1-standard-4",
            dataDisk: {
                initializeParams: {
                    diskSizeGb: 100,
                    diskType: "PD_STANDARD",
                },
            },
        },
    },
    labels: {
        k: "val",
    },
});
```
```python
import pulumi
import pulumi_gcp as gcp

runtime_container = gcp.notebooks.Runtime("runtime_container",
    name="notebooks-runtime-script",
    location="us-central1",
    access_config={
        "access_type": "SINGLE_USER",
        "runtime_owner": "admin@hashicorptest.com",
    },
    software_config={
        "post_startup_script_behavior": "RUN_EVERY_START",
    },
    virtual_machine={
        "virtual_machine_config": {
            "machine_type": "n1-standard-4",
            "data_disk": {
                "initialize_params": {
                    "disk_size_gb": 100,
                    "disk_type": "PD_STANDARD",
                },
            },
        },
    },
    labels={
        "k": "val",
    })
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var runtimeContainer = new Gcp.Notebooks.Runtime("runtime_container", new()
    {
        Name = "notebooks-runtime-script",
        Location = "us-central1",
        AccessConfig = new Gcp.Notebooks.Inputs.RuntimeAccessConfigArgs
        {
            AccessType = "SINGLE_USER",
            RuntimeOwner = "admin@hashicorptest.com",
        },
        SoftwareConfig = new Gcp.Notebooks.Inputs.RuntimeSoftwareConfigArgs
        {
            PostStartupScriptBehavior = "RUN_EVERY_START",
        },
        VirtualMachine = new Gcp.Notebooks.Inputs.RuntimeVirtualMachineArgs
        {
            VirtualMachineConfig = new Gcp.Notebooks.Inputs.RuntimeVirtualMachineVirtualMachineConfigArgs
            {
                MachineType = "n1-standard-4",
                DataDisk = new Gcp.Notebooks.Inputs.RuntimeVirtualMachineVirtualMachineConfigDataDiskArgs
                {
                    InitializeParams = new Gcp.Notebooks.Inputs.RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParamsArgs
                    {
                        DiskSizeGb = 100,
                        DiskType = "PD_STANDARD",
                    },
                },
            },
        },
        Labels = 
        {
            { "k", "val" },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewRuntime(ctx, "runtime_container", &notebooks.RuntimeArgs{
			Name:     pulumi.String("notebooks-runtime-script"),
			Location: pulumi.String("us-central1"),
			AccessConfig: &notebooks.RuntimeAccessConfigArgs{
				AccessType:   pulumi.String("SINGLE_USER"),
				RuntimeOwner: pulumi.String("admin@hashicorptest.com"),
			},
			SoftwareConfig: &notebooks.RuntimeSoftwareConfigArgs{
				PostStartupScriptBehavior: pulumi.String("RUN_EVERY_START"),
			},
			VirtualMachine: &notebooks.RuntimeVirtualMachineArgs{
				VirtualMachineConfig: &notebooks.RuntimeVirtualMachineVirtualMachineConfigArgs{
					MachineType: pulumi.String("n1-standard-4"),
					DataDisk: &notebooks.RuntimeVirtualMachineVirtualMachineConfigDataDiskArgs{
						InitializeParams: &notebooks.RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParamsArgs{
							DiskSizeGb: pulumi.Int(100),
							DiskType:   pulumi.String("PD_STANDARD"),
						},
					},
				},
			},
			Labels: pulumi.StringMap{
				"k": pulumi.String("val"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.Runtime;
import com.pulumi.gcp.notebooks.RuntimeArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeAccessConfigArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeSoftwareConfigArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeVirtualMachineArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeVirtualMachineVirtualMachineConfigArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeVirtualMachineVirtualMachineConfigDataDiskArgs;
import com.pulumi.gcp.notebooks.inputs.RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParamsArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var runtimeContainer = new Runtime("runtimeContainer", RuntimeArgs.builder()
            .name("notebooks-runtime-script")
            .location("us-central1")
            .accessConfig(RuntimeAccessConfigArgs.builder()
                .accessType("SINGLE_USER")
                .runtimeOwner("admin@hashicorptest.com")
                .build())
            .softwareConfig(RuntimeSoftwareConfigArgs.builder()
                .postStartupScriptBehavior("RUN_EVERY_START")
                .build())
            .virtualMachine(RuntimeVirtualMachineArgs.builder()
                .virtualMachineConfig(RuntimeVirtualMachineVirtualMachineConfigArgs.builder()
                    .machineType("n1-standard-4")
                    .dataDisk(RuntimeVirtualMachineVirtualMachineConfigDataDiskArgs.builder()
                        .initializeParams(RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParamsArgs.builder()
                            .diskSizeGb("100")
                            .diskType("PD_STANDARD")
                            .build())
                        .build())
                    .build())
                .build())
            .labels(Map.of("k", "val"))
            .build());

    }
}
```
```yaml
resources:
  runtimeContainer:
    type: gcp:notebooks:Runtime
    name: runtime_container
    properties:
      name: notebooks-runtime-script
      location: us-central1
      accessConfig:
        accessType: SINGLE_USER
        runtimeOwner: admin@hashicorptest.com
      softwareConfig:
        postStartupScriptBehavior: RUN_EVERY_START
      virtualMachine:
        virtualMachineConfig:
          machineType: n1-standard-4
          dataDisk:
            initializeParams:
              diskSizeGb: '100'
              diskType: PD_STANDARD
      labels:
        k: val
```
<!--End PulumiCodeChooser -->

## Import

Runtime can be imported using any of these accepted formats:

* `projects/{{project}}/locations/{{location}}/runtimes/{{name}}`

* `{{project}}/{{location}}/{{name}}`

* `{{location}}/{{name}}`

When using the `pulumi import` command, Runtime can be imported using one of the formats above. For example:

```sh
$ pulumi import gcp:notebooks/runtime:Runtime default projects/{{project}}/locations/{{location}}/runtimes/{{name}}
```

```sh
$ pulumi import gcp:notebooks/runtime:Runtime default {{project}}/{{location}}/{{name}}
```

```sh
$ pulumi import gcp:notebooks/runtime:Runtime default {{location}}/{{name}}
```

π
accessConfig]B[:Y
W
	notebooksRuntimeAccessConfig5gcp:notebooks/RuntimeAccessConfig:RuntimeAccessConfigJThe config settings for accessing runtime.
Structure is documented below.
Ã
labelsB2" πThe labels to associate with this runtime. Label **keys** must
contain 1 to 63 characters, and must conform to [RFC 1035]
(https://www.ietf.org/rfc/rfc1035.txt). Label **values** may be
empty, but, if present, must contain 1 to 63 characters, and must
conform to [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt). No
more than 32 labels can be associated with a cluster.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
K
location" ;A reference to the zone where the machine resides.


- - -
;
nameB" -The name specified for the Notebook runtime.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
À
softwareConfigcBa:_
]
	notebooksRuntimeSoftwareConfig9gcp:notebooks/RuntimeSoftwareConfig:RuntimeSoftwareConfigTThe config settings for software inside the runtime.
Structure is documented below.
‹
virtualMachinecBa:_
]
	notebooksRuntimeVirtualMachine9gcp:notebooks/RuntimeVirtualMachine:RuntimeVirtualMachineeUse a Compute Engine VM image to start the managed notebook instance.
Structure is documented below.
"π
accessConfig]B[:Y
W
	notebooksRuntimeAccessConfig5gcp:notebooks/RuntimeAccessConfig:RuntimeAccessConfigJThe config settings for accessing runtime.
Structure is documented below.
"¶
effectiveLabels2" åAll of labels (key/value pairs) present on the resource in GCP, including the labels configured through Pulumi, other clients and services.
"–
healthState" ºThe health state of this runtime. For a list of possible output
values, see `https://cloud.google.com/vertex-ai/docs/workbench/
reference/rest/v1/projects.locations.runtimes#healthstate`.
"Ã
labelsB2" πThe labels to associate with this runtime. Label **keys** must
contain 1 to 63 characters, and must conform to [RFC 1035]
(https://www.ietf.org/rfc/rfc1035.txt). Label **values** may be
empty, but, if present, must contain 1 to 63 characters, and must
conform to [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt). No
more than 32 labels can be associated with a cluster.

**Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
Please refer to the field `effective_labels` for all of the labels present on the resource.
"K
location" ;A reference to the zone where the machine resides.


- - -
"ƒ
metricsK*I:G
E
	notebooksRuntimeMetric)gcp:notebooks/RuntimeMetric:RuntimeMetriclContains Runtime daemon metrics such as Service status and JupyterLab
status
Structure is documented below.
"9
name" -The name specified for the Notebook runtime.
"y
project" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"É
pulumiLabels2" mThe combination of labels configured directly on the resource
and default labels configured on the provider.
"…
softwareConfiga:_
]
	notebooksRuntimeSoftwareConfig9gcp:notebooks/RuntimeSoftwareConfig:RuntimeSoftwareConfigTThe config settings for software inside the runtime.
Structure is documented below.
"(
state" The state of this runtime.
"‹
virtualMachinecBa:_
]
	notebooksRuntimeVirtualMachine9gcp:notebooks/RuntimeVirtualMachine:RuntimeVirtualMachineeUse a Compute Engine VM image to start the managed notebook instance.
Structure is documented below.
*ì‡
Q
	notebooksRuntimeIamBinding1gcp:notebooks/runtimeIamBinding:RuntimeIamBindingüªThree different resources help you manage your IAM policy for Cloud AI Notebooks Runtime. Each of these resources serves a different use case:

* `gcp.notebooks.RuntimeIamPolicy`: Authoritative. Sets the IAM policy for the runtime and replaces any existing policy already attached.
* `gcp.notebooks.RuntimeIamBinding`: Authoritative for a given role. Updates the IAM policy to grant a role to a list of members. Other roles within the IAM policy for the runtime are preserved.
* `gcp.notebooks.RuntimeIamMember`: Non-authoritative. Updates the IAM policy to grant a role to a new member. Other members for the role for the runtime are preserved.

A data source can be used to retrieve policy data in advent you do not need creation

* `gcp.notebooks.RuntimeIamPolicy`: Retrieves the IAM policy for the runtime

> **Note:** `gcp.notebooks.RuntimeIamPolicy` **cannot** be used in conjunction with `gcp.notebooks.RuntimeIamBinding` and `gcp.notebooks.RuntimeIamMember` or they will fight over what your policy should be.

> **Note:** `gcp.notebooks.RuntimeIamBinding` resources **can be** used in conjunction with `gcp.notebooks.RuntimeIamMember` resources **only if** they do not grant privilege to the same role.



## gcp.notebooks.RuntimeIamPolicy

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const admin = gcp.organizations.getIAMPolicy({
    bindings: [{
        role: "roles/viewer",
        members: ["user:jane@example.com"],
    }],
});
const policy = new gcp.notebooks.RuntimeIamPolicy("policy", {
    project: runtime.project,
    location: runtime.location,
    runtimeName: runtime.name,
    policyData: admin.then(admin => admin.policyData),
});
```
```python
import pulumi
import pulumi_gcp as gcp

admin = gcp.organizations.get_iam_policy(bindings=[{
    "role": "roles/viewer",
    "members": ["user:jane@example.com"],
}])
policy = gcp.notebooks.RuntimeIamPolicy("policy",
    project=runtime["project"],
    location=runtime["location"],
    runtime_name=runtime["name"],
    policy_data=admin.policy_data)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var admin = Gcp.Organizations.GetIAMPolicy.Invoke(new()
    {
        Bindings = new[]
        {
            new Gcp.Organizations.Inputs.GetIAMPolicyBindingInputArgs
            {
                Role = "roles/viewer",
                Members = new[]
                {
                    "user:jane@example.com",
                },
            },
        },
    });

    var policy = new Gcp.Notebooks.RuntimeIamPolicy("policy", new()
    {
        Project = runtime.Project,
        Location = runtime.Location,
        RuntimeName = runtime.Name,
        PolicyData = admin.Apply(getIAMPolicyResult => getIAMPolicyResult.PolicyData),
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		admin, err := organizations.LookupIAMPolicy(ctx, &organizations.LookupIAMPolicyArgs{
			Bindings: []organizations.GetIAMPolicyBinding{
				{
					Role: "roles/viewer",
					Members: []string{
						"user:jane@example.com",
					},
				},
			},
		}, nil)
		if err != nil {
			return err
		}
		_, err = notebooks.NewRuntimeIamPolicy(ctx, "policy", &notebooks.RuntimeIamPolicyArgs{
			Project:     pulumi.Any(runtime.Project),
			Location:    pulumi.Any(runtime.Location),
			RuntimeName: pulumi.Any(runtime.Name),
			PolicyData:  pulumi.String(admin.PolicyData),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.organizations.OrganizationsFunctions;
import com.pulumi.gcp.organizations.inputs.GetIAMPolicyArgs;
import com.pulumi.gcp.notebooks.RuntimeIamPolicy;
import com.pulumi.gcp.notebooks.RuntimeIamPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var admin = OrganizationsFunctions.getIAMPolicy(GetIAMPolicyArgs.builder()
            .bindings(GetIAMPolicyBindingArgs.builder()
                .role("roles/viewer")
                .members("user:jane@example.com")
                .build())
            .build());

        var policy = new RuntimeIamPolicy("policy", RuntimeIamPolicyArgs.builder()
            .project(runtime.project())
            .location(runtime.location())
            .runtimeName(runtime.name())
            .policyData(admin.applyValue(getIAMPolicyResult -> getIAMPolicyResult.policyData()))
            .build());

    }
}
```
```yaml
resources:
  policy:
    type: gcp:notebooks:RuntimeIamPolicy
    properties:
      project: ${runtime.project}
      location: ${runtime.location}
      runtimeName: ${runtime.name}
      policyData: ${admin.policyData}
variables:
  admin:
    fn::invoke:
      function: gcp:organizations:getIAMPolicy
      arguments:
        bindings:
          - role: roles/viewer
            members:
              - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.RuntimeIamBinding

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const binding = new gcp.notebooks.RuntimeIamBinding("binding", {
    project: runtime.project,
    location: runtime.location,
    runtimeName: runtime.name,
    role: "roles/viewer",
    members: ["user:jane@example.com"],
});
```
```python
import pulumi
import pulumi_gcp as gcp

binding = gcp.notebooks.RuntimeIamBinding("binding",
    project=runtime["project"],
    location=runtime["location"],
    runtime_name=runtime["name"],
    role="roles/viewer",
    members=["user:jane@example.com"])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var binding = new Gcp.Notebooks.RuntimeIamBinding("binding", new()
    {
        Project = runtime.Project,
        Location = runtime.Location,
        RuntimeName = runtime.Name,
        Role = "roles/viewer",
        Members = new[]
        {
            "user:jane@example.com",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewRuntimeIamBinding(ctx, "binding", &notebooks.RuntimeIamBindingArgs{
			Project:     pulumi.Any(runtime.Project),
			Location:    pulumi.Any(runtime.Location),
			RuntimeName: pulumi.Any(runtime.Name),
			Role:        pulumi.String("roles/viewer"),
			Members: pulumi.StringArray{
				pulumi.String("user:jane@example.com"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.RuntimeIamBinding;
import com.pulumi.gcp.notebooks.RuntimeIamBindingArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var binding = new RuntimeIamBinding("binding", RuntimeIamBindingArgs.builder()
            .project(runtime.project())
            .location(runtime.location())
            .runtimeName(runtime.name())
            .role("roles/viewer")
            .members("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  binding:
    type: gcp:notebooks:RuntimeIamBinding
    properties:
      project: ${runtime.project}
      location: ${runtime.location}
      runtimeName: ${runtime.name}
      role: roles/viewer
      members:
        - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.RuntimeIamMember

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const member = new gcp.notebooks.RuntimeIamMember("member", {
    project: runtime.project,
    location: runtime.location,
    runtimeName: runtime.name,
    role: "roles/viewer",
    member: "user:jane@example.com",
});
```
```python
import pulumi
import pulumi_gcp as gcp

member = gcp.notebooks.RuntimeIamMember("member",
    project=runtime["project"],
    location=runtime["location"],
    runtime_name=runtime["name"],
    role="roles/viewer",
    member="user:jane@example.com")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var member = new Gcp.Notebooks.RuntimeIamMember("member", new()
    {
        Project = runtime.Project,
        Location = runtime.Location,
        RuntimeName = runtime.Name,
        Role = "roles/viewer",
        Member = "user:jane@example.com",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewRuntimeIamMember(ctx, "member", &notebooks.RuntimeIamMemberArgs{
			Project:     pulumi.Any(runtime.Project),
			Location:    pulumi.Any(runtime.Location),
			RuntimeName: pulumi.Any(runtime.Name),
			Role:        pulumi.String("roles/viewer"),
			Member:      pulumi.String("user:jane@example.com"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.RuntimeIamMember;
import com.pulumi.gcp.notebooks.RuntimeIamMemberArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var member = new RuntimeIamMember("member", RuntimeIamMemberArgs.builder()
            .project(runtime.project())
            .location(runtime.location())
            .runtimeName(runtime.name())
            .role("roles/viewer")
            .member("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  member:
    type: gcp:notebooks:RuntimeIamMember
    properties:
      project: ${runtime.project}
      location: ${runtime.location}
      runtimeName: ${runtime.name}
      role: roles/viewer
      member: user:jane@example.com
```
<!--End PulumiCodeChooser -->


## This resource supports User Project Overrides.

-

# IAM policy for Cloud AI Notebooks Runtime
Three different resources help you manage your IAM policy for Cloud AI Notebooks Runtime. Each of these resources serves a different use case:

* `gcp.notebooks.RuntimeIamPolicy`: Authoritative. Sets the IAM policy for the runtime and replaces any existing policy already attached.
* `gcp.notebooks.RuntimeIamBinding`: Authoritative for a given role. Updates the IAM policy to grant a role to a list of members. Other roles within the IAM policy for the runtime are preserved.
* `gcp.notebooks.RuntimeIamMember`: Non-authoritative. Updates the IAM policy to grant a role to a new member. Other members for the role for the runtime are preserved.

A data source can be used to retrieve policy data in advent you do not need creation

* `gcp.notebooks.RuntimeIamPolicy`: Retrieves the IAM policy for the runtime

> **Note:** `gcp.notebooks.RuntimeIamPolicy` **cannot** be used in conjunction with `gcp.notebooks.RuntimeIamBinding` and `gcp.notebooks.RuntimeIamMember` or they will fight over what your policy should be.

> **Note:** `gcp.notebooks.RuntimeIamBinding` resources **can be** used in conjunction with `gcp.notebooks.RuntimeIamMember` resources **only if** they do not grant privilege to the same role.



## gcp.notebooks.RuntimeIamPolicy

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const admin = gcp.organizations.getIAMPolicy({
    bindings: [{
        role: "roles/viewer",
        members: ["user:jane@example.com"],
    }],
});
const policy = new gcp.notebooks.RuntimeIamPolicy("policy", {
    project: runtime.project,
    location: runtime.location,
    runtimeName: runtime.name,
    policyData: admin.then(admin => admin.policyData),
});
```
```python
import pulumi
import pulumi_gcp as gcp

admin = gcp.organizations.get_iam_policy(bindings=[{
    "role": "roles/viewer",
    "members": ["user:jane@example.com"],
}])
policy = gcp.notebooks.RuntimeIamPolicy("policy",
    project=runtime["project"],
    location=runtime["location"],
    runtime_name=runtime["name"],
    policy_data=admin.policy_data)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var admin = Gcp.Organizations.GetIAMPolicy.Invoke(new()
    {
        Bindings = new[]
        {
            new Gcp.Organizations.Inputs.GetIAMPolicyBindingInputArgs
            {
                Role = "roles/viewer",
                Members = new[]
                {
                    "user:jane@example.com",
                },
            },
        },
    });

    var policy = new Gcp.Notebooks.RuntimeIamPolicy("policy", new()
    {
        Project = runtime.Project,
        Location = runtime.Location,
        RuntimeName = runtime.Name,
        PolicyData = admin.Apply(getIAMPolicyResult => getIAMPolicyResult.PolicyData),
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		admin, err := organizations.LookupIAMPolicy(ctx, &organizations.LookupIAMPolicyArgs{
			Bindings: []organizations.GetIAMPolicyBinding{
				{
					Role: "roles/viewer",
					Members: []string{
						"user:jane@example.com",
					},
				},
			},
		}, nil)
		if err != nil {
			return err
		}
		_, err = notebooks.NewRuntimeIamPolicy(ctx, "policy", &notebooks.RuntimeIamPolicyArgs{
			Project:     pulumi.Any(runtime.Project),
			Location:    pulumi.Any(runtime.Location),
			RuntimeName: pulumi.Any(runtime.Name),
			PolicyData:  pulumi.String(admin.PolicyData),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.organizations.OrganizationsFunctions;
import com.pulumi.gcp.organizations.inputs.GetIAMPolicyArgs;
import com.pulumi.gcp.notebooks.RuntimeIamPolicy;
import com.pulumi.gcp.notebooks.RuntimeIamPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var admin = OrganizationsFunctions.getIAMPolicy(GetIAMPolicyArgs.builder()
            .bindings(GetIAMPolicyBindingArgs.builder()
                .role("roles/viewer")
                .members("user:jane@example.com")
                .build())
            .build());

        var policy = new RuntimeIamPolicy("policy", RuntimeIamPolicyArgs.builder()
            .project(runtime.project())
            .location(runtime.location())
            .runtimeName(runtime.name())
            .policyData(admin.applyValue(getIAMPolicyResult -> getIAMPolicyResult.policyData()))
            .build());

    }
}
```
```yaml
resources:
  policy:
    type: gcp:notebooks:RuntimeIamPolicy
    properties:
      project: ${runtime.project}
      location: ${runtime.location}
      runtimeName: ${runtime.name}
      policyData: ${admin.policyData}
variables:
  admin:
    fn::invoke:
      function: gcp:organizations:getIAMPolicy
      arguments:
        bindings:
          - role: roles/viewer
            members:
              - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.RuntimeIamBinding

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const binding = new gcp.notebooks.RuntimeIamBinding("binding", {
    project: runtime.project,
    location: runtime.location,
    runtimeName: runtime.name,
    role: "roles/viewer",
    members: ["user:jane@example.com"],
});
```
```python
import pulumi
import pulumi_gcp as gcp

binding = gcp.notebooks.RuntimeIamBinding("binding",
    project=runtime["project"],
    location=runtime["location"],
    runtime_name=runtime["name"],
    role="roles/viewer",
    members=["user:jane@example.com"])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var binding = new Gcp.Notebooks.RuntimeIamBinding("binding", new()
    {
        Project = runtime.Project,
        Location = runtime.Location,
        RuntimeName = runtime.Name,
        Role = "roles/viewer",
        Members = new[]
        {
            "user:jane@example.com",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewRuntimeIamBinding(ctx, "binding", &notebooks.RuntimeIamBindingArgs{
			Project:     pulumi.Any(runtime.Project),
			Location:    pulumi.Any(runtime.Location),
			RuntimeName: pulumi.Any(runtime.Name),
			Role:        pulumi.String("roles/viewer"),
			Members: pulumi.StringArray{
				pulumi.String("user:jane@example.com"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.RuntimeIamBinding;
import com.pulumi.gcp.notebooks.RuntimeIamBindingArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var binding = new RuntimeIamBinding("binding", RuntimeIamBindingArgs.builder()
            .project(runtime.project())
            .location(runtime.location())
            .runtimeName(runtime.name())
            .role("roles/viewer")
            .members("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  binding:
    type: gcp:notebooks:RuntimeIamBinding
    properties:
      project: ${runtime.project}
      location: ${runtime.location}
      runtimeName: ${runtime.name}
      role: roles/viewer
      members:
        - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.RuntimeIamMember

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const member = new gcp.notebooks.RuntimeIamMember("member", {
    project: runtime.project,
    location: runtime.location,
    runtimeName: runtime.name,
    role: "roles/viewer",
    member: "user:jane@example.com",
});
```
```python
import pulumi
import pulumi_gcp as gcp

member = gcp.notebooks.RuntimeIamMember("member",
    project=runtime["project"],
    location=runtime["location"],
    runtime_name=runtime["name"],
    role="roles/viewer",
    member="user:jane@example.com")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var member = new Gcp.Notebooks.RuntimeIamMember("member", new()
    {
        Project = runtime.Project,
        Location = runtime.Location,
        RuntimeName = runtime.Name,
        Role = "roles/viewer",
        Member = "user:jane@example.com",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewRuntimeIamMember(ctx, "member", &notebooks.RuntimeIamMemberArgs{
			Project:     pulumi.Any(runtime.Project),
			Location:    pulumi.Any(runtime.Location),
			RuntimeName: pulumi.Any(runtime.Name),
			Role:        pulumi.String("roles/viewer"),
			Member:      pulumi.String("user:jane@example.com"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.RuntimeIamMember;
import com.pulumi.gcp.notebooks.RuntimeIamMemberArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var member = new RuntimeIamMember("member", RuntimeIamMemberArgs.builder()
            .project(runtime.project())
            .location(runtime.location())
            .runtimeName(runtime.name())
            .role("roles/viewer")
            .member("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  member:
    type: gcp:notebooks:RuntimeIamMember
    properties:
      project: ${runtime.project}
      location: ${runtime.location}
      runtimeName: ${runtime.name}
      role: roles/viewer
      member: user:jane@example.com
```
<!--End PulumiCodeChooser -->

## Import

For all import syntaxes, the "resource in question" can take any of the following forms:

* projects/{{project}}/locations/{{location}}/runtimes/{{runtime_name}}

* {{project}}/{{location}}/{{runtime_name}}

* {{location}}/{{runtime_name}}

* {{runtime_name}}

Any variables not passed in the import command will be taken from the provider configuration.

Cloud AI Notebooks runtime IAM resources can be imported using the resource identifiers, role, and member.

IAM member imports use space-delimited identifiers: the resource in question, the role, and the member identity, e.g.

```sh
$ pulumi import gcp:notebooks/runtimeIamBinding:RuntimeIamBinding editor "projects/{{project}}/locations/{{location}}/runtimes/{{runtime_name}} roles/viewer user:jane@example.com"
```

IAM binding imports use space-delimited identifiers: the resource in question and the role, e.g.

```sh
$ pulumi import gcp:notebooks/runtimeIamBinding:RuntimeIamBinding editor "projects/{{project}}/locations/{{location}}/runtimes/{{runtime_name}} roles/viewer"
```

IAM policy imports use the identifier of the resource in question, e.g.

```sh
$ pulumi import gcp:notebooks/runtimeIamBinding:RuntimeIamBinding editor projects/{{project}}/locations/{{location}}/runtimes/{{runtime_name}}
```

-> **Custom Roles** If you're importing a IAM resource with a custom role, make sure to use the

 full name of the custom role, e.g. `[projects/my-project|organizations/my-org]/roles/my-custom-role`.


	conditionrBp:n
l
	notebooksRuntimeIamBindingConditionCgcp:notebooks/RuntimeIamBindingCondition:RuntimeIamBindingConditionÿ
locationB" ≈A reference to the zone where the machine resides. Used to find the parent resource to bind the IAM policy to. If not specified,
the value will be parsed from the identifier of the parent resource. If no location is provided in the parent identifier and no
location is specified, it is taken from the provider configuration.
÷	
members*" ƒ	Identities that will be granted the privilege in `role`.
Each entry can have one of the following values:
* **allUsers**: A special identifier that represents anyone who is on the internet; with or without a Google account.
* **allAuthenticatedUsers**: A special identifier that represents anyone who is authenticated with a Google account or a service account.
* **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com or joe@example.com.
* **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
* **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
* **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
* **projectOwner:projectid**: Owners of the given project. For example, "projectOwner:my-example-project"
* **projectEditor:projectid**: Editors of the given project. For example, "projectEditor:my-example-project"
* **projectViewer:projectid**: Viewers of the given project. For example, "projectViewer:my-example-project"
ì
projectB" ÅThe ID of the project in which the resource belongs.
If it is not provided, the project will be parsed from the identifier of the parent resource. If no project is provided in the parent identifier and no project is specified, the provider project is used.
ÿ
role" ÀThe role that should be applied. Only one
`gcp.notebooks.RuntimeIamBinding` can be used per role. Note that custom roles must be of the format
`[projects|organizations]/{parent-name}/roles/{role-name}`.
N
runtimeName" ;Used to find the parent resource to bind the IAM policy to
"
	conditionrBp:n
l
	notebooksRuntimeIamBindingConditionCgcp:notebooks/RuntimeIamBindingCondition:RuntimeIamBindingCondition"3
etag" '(Computed) The etag of the IAM policy.
"÷
location" ≈A reference to the zone where the machine resides. Used to find the parent resource to bind the IAM policy to. If not specified,
the value will be parsed from the identifier of the parent resource. If no location is provided in the parent identifier and no
location is specified, it is taken from the provider configuration.
"÷	
members*" ƒ	Identities that will be granted the privilege in `role`.
Each entry can have one of the following values:
* **allUsers**: A special identifier that represents anyone who is on the internet; with or without a Google account.
* **allAuthenticatedUsers**: A special identifier that represents anyone who is authenticated with a Google account or a service account.
* **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com or joe@example.com.
* **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
* **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
* **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
* **projectOwner:projectid**: Owners of the given project. For example, "projectOwner:my-example-project"
* **projectEditor:projectid**: Editors of the given project. For example, "projectEditor:my-example-project"
* **projectViewer:projectid**: Viewers of the given project. For example, "projectViewer:my-example-project"
"ë
project" ÅThe ID of the project in which the resource belongs.
If it is not provided, the project will be parsed from the identifier of the parent resource. If no project is provided in the parent identifier and no project is specified, the provider project is used.
"ÿ
role" ÀThe role that should be applied. Only one
`gcp.notebooks.RuntimeIamBinding` can be used per role. Note that custom roles must be of the format
`[projects|organizations]/{parent-name}/roles/{role-name}`.
"N
runtimeName" ;Used to find the parent resource to bind the IAM policy to
*˛ﬂ
N
	notebooksRuntimeIamMember/gcp:notebooks/runtimeIamMember:RuntimeIamMemberôªThree different resources help you manage your IAM policy for Cloud AI Notebooks Runtime. Each of these resources serves a different use case:

* `gcp.notebooks.RuntimeIamPolicy`: Authoritative. Sets the IAM policy for the runtime and replaces any existing policy already attached.
* `gcp.notebooks.RuntimeIamBinding`: Authoritative for a given role. Updates the IAM policy to grant a role to a list of members. Other roles within the IAM policy for the runtime are preserved.
* `gcp.notebooks.RuntimeIamMember`: Non-authoritative. Updates the IAM policy to grant a role to a new member. Other members for the role for the runtime are preserved.

A data source can be used to retrieve policy data in advent you do not need creation

* `gcp.notebooks.RuntimeIamPolicy`: Retrieves the IAM policy for the runtime

> **Note:** `gcp.notebooks.RuntimeIamPolicy` **cannot** be used in conjunction with `gcp.notebooks.RuntimeIamBinding` and `gcp.notebooks.RuntimeIamMember` or they will fight over what your policy should be.

> **Note:** `gcp.notebooks.RuntimeIamBinding` resources **can be** used in conjunction with `gcp.notebooks.RuntimeIamMember` resources **only if** they do not grant privilege to the same role.



## gcp.notebooks.RuntimeIamPolicy

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const admin = gcp.organizations.getIAMPolicy({
    bindings: [{
        role: "roles/viewer",
        members: ["user:jane@example.com"],
    }],
});
const policy = new gcp.notebooks.RuntimeIamPolicy("policy", {
    project: runtime.project,
    location: runtime.location,
    runtimeName: runtime.name,
    policyData: admin.then(admin => admin.policyData),
});
```
```python
import pulumi
import pulumi_gcp as gcp

admin = gcp.organizations.get_iam_policy(bindings=[{
    "role": "roles/viewer",
    "members": ["user:jane@example.com"],
}])
policy = gcp.notebooks.RuntimeIamPolicy("policy",
    project=runtime["project"],
    location=runtime["location"],
    runtime_name=runtime["name"],
    policy_data=admin.policy_data)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var admin = Gcp.Organizations.GetIAMPolicy.Invoke(new()
    {
        Bindings = new[]
        {
            new Gcp.Organizations.Inputs.GetIAMPolicyBindingInputArgs
            {
                Role = "roles/viewer",
                Members = new[]
                {
                    "user:jane@example.com",
                },
            },
        },
    });

    var policy = new Gcp.Notebooks.RuntimeIamPolicy("policy", new()
    {
        Project = runtime.Project,
        Location = runtime.Location,
        RuntimeName = runtime.Name,
        PolicyData = admin.Apply(getIAMPolicyResult => getIAMPolicyResult.PolicyData),
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		admin, err := organizations.LookupIAMPolicy(ctx, &organizations.LookupIAMPolicyArgs{
			Bindings: []organizations.GetIAMPolicyBinding{
				{
					Role: "roles/viewer",
					Members: []string{
						"user:jane@example.com",
					},
				},
			},
		}, nil)
		if err != nil {
			return err
		}
		_, err = notebooks.NewRuntimeIamPolicy(ctx, "policy", &notebooks.RuntimeIamPolicyArgs{
			Project:     pulumi.Any(runtime.Project),
			Location:    pulumi.Any(runtime.Location),
			RuntimeName: pulumi.Any(runtime.Name),
			PolicyData:  pulumi.String(admin.PolicyData),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.organizations.OrganizationsFunctions;
import com.pulumi.gcp.organizations.inputs.GetIAMPolicyArgs;
import com.pulumi.gcp.notebooks.RuntimeIamPolicy;
import com.pulumi.gcp.notebooks.RuntimeIamPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var admin = OrganizationsFunctions.getIAMPolicy(GetIAMPolicyArgs.builder()
            .bindings(GetIAMPolicyBindingArgs.builder()
                .role("roles/viewer")
                .members("user:jane@example.com")
                .build())
            .build());

        var policy = new RuntimeIamPolicy("policy", RuntimeIamPolicyArgs.builder()
            .project(runtime.project())
            .location(runtime.location())
            .runtimeName(runtime.name())
            .policyData(admin.applyValue(getIAMPolicyResult -> getIAMPolicyResult.policyData()))
            .build());

    }
}
```
```yaml
resources:
  policy:
    type: gcp:notebooks:RuntimeIamPolicy
    properties:
      project: ${runtime.project}
      location: ${runtime.location}
      runtimeName: ${runtime.name}
      policyData: ${admin.policyData}
variables:
  admin:
    fn::invoke:
      function: gcp:organizations:getIAMPolicy
      arguments:
        bindings:
          - role: roles/viewer
            members:
              - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.RuntimeIamBinding

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const binding = new gcp.notebooks.RuntimeIamBinding("binding", {
    project: runtime.project,
    location: runtime.location,
    runtimeName: runtime.name,
    role: "roles/viewer",
    members: ["user:jane@example.com"],
});
```
```python
import pulumi
import pulumi_gcp as gcp

binding = gcp.notebooks.RuntimeIamBinding("binding",
    project=runtime["project"],
    location=runtime["location"],
    runtime_name=runtime["name"],
    role="roles/viewer",
    members=["user:jane@example.com"])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var binding = new Gcp.Notebooks.RuntimeIamBinding("binding", new()
    {
        Project = runtime.Project,
        Location = runtime.Location,
        RuntimeName = runtime.Name,
        Role = "roles/viewer",
        Members = new[]
        {
            "user:jane@example.com",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewRuntimeIamBinding(ctx, "binding", &notebooks.RuntimeIamBindingArgs{
			Project:     pulumi.Any(runtime.Project),
			Location:    pulumi.Any(runtime.Location),
			RuntimeName: pulumi.Any(runtime.Name),
			Role:        pulumi.String("roles/viewer"),
			Members: pulumi.StringArray{
				pulumi.String("user:jane@example.com"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.RuntimeIamBinding;
import com.pulumi.gcp.notebooks.RuntimeIamBindingArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var binding = new RuntimeIamBinding("binding", RuntimeIamBindingArgs.builder()
            .project(runtime.project())
            .location(runtime.location())
            .runtimeName(runtime.name())
            .role("roles/viewer")
            .members("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  binding:
    type: gcp:notebooks:RuntimeIamBinding
    properties:
      project: ${runtime.project}
      location: ${runtime.location}
      runtimeName: ${runtime.name}
      role: roles/viewer
      members:
        - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.RuntimeIamMember

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const member = new gcp.notebooks.RuntimeIamMember("member", {
    project: runtime.project,
    location: runtime.location,
    runtimeName: runtime.name,
    role: "roles/viewer",
    member: "user:jane@example.com",
});
```
```python
import pulumi
import pulumi_gcp as gcp

member = gcp.notebooks.RuntimeIamMember("member",
    project=runtime["project"],
    location=runtime["location"],
    runtime_name=runtime["name"],
    role="roles/viewer",
    member="user:jane@example.com")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var member = new Gcp.Notebooks.RuntimeIamMember("member", new()
    {
        Project = runtime.Project,
        Location = runtime.Location,
        RuntimeName = runtime.Name,
        Role = "roles/viewer",
        Member = "user:jane@example.com",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewRuntimeIamMember(ctx, "member", &notebooks.RuntimeIamMemberArgs{
			Project:     pulumi.Any(runtime.Project),
			Location:    pulumi.Any(runtime.Location),
			RuntimeName: pulumi.Any(runtime.Name),
			Role:        pulumi.String("roles/viewer"),
			Member:      pulumi.String("user:jane@example.com"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.RuntimeIamMember;
import com.pulumi.gcp.notebooks.RuntimeIamMemberArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var member = new RuntimeIamMember("member", RuntimeIamMemberArgs.builder()
            .project(runtime.project())
            .location(runtime.location())
            .runtimeName(runtime.name())
            .role("roles/viewer")
            .member("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  member:
    type: gcp:notebooks:RuntimeIamMember
    properties:
      project: ${runtime.project}
      location: ${runtime.location}
      runtimeName: ${runtime.name}
      role: roles/viewer
      member: user:jane@example.com
```
<!--End PulumiCodeChooser -->


## This resource supports User Project Overrides.

-

# IAM policy for Cloud AI Notebooks Runtime
Three different resources help you manage your IAM policy for Cloud AI Notebooks Runtime. Each of these resources serves a different use case:

* `gcp.notebooks.RuntimeIamPolicy`: Authoritative. Sets the IAM policy for the runtime and replaces any existing policy already attached.
* `gcp.notebooks.RuntimeIamBinding`: Authoritative for a given role. Updates the IAM policy to grant a role to a list of members. Other roles within the IAM policy for the runtime are preserved.
* `gcp.notebooks.RuntimeIamMember`: Non-authoritative. Updates the IAM policy to grant a role to a new member. Other members for the role for the runtime are preserved.

A data source can be used to retrieve policy data in advent you do not need creation

* `gcp.notebooks.RuntimeIamPolicy`: Retrieves the IAM policy for the runtime

> **Note:** `gcp.notebooks.RuntimeIamPolicy` **cannot** be used in conjunction with `gcp.notebooks.RuntimeIamBinding` and `gcp.notebooks.RuntimeIamMember` or they will fight over what your policy should be.

> **Note:** `gcp.notebooks.RuntimeIamBinding` resources **can be** used in conjunction with `gcp.notebooks.RuntimeIamMember` resources **only if** they do not grant privilege to the same role.



## gcp.notebooks.RuntimeIamPolicy

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const admin = gcp.organizations.getIAMPolicy({
    bindings: [{
        role: "roles/viewer",
        members: ["user:jane@example.com"],
    }],
});
const policy = new gcp.notebooks.RuntimeIamPolicy("policy", {
    project: runtime.project,
    location: runtime.location,
    runtimeName: runtime.name,
    policyData: admin.then(admin => admin.policyData),
});
```
```python
import pulumi
import pulumi_gcp as gcp

admin = gcp.organizations.get_iam_policy(bindings=[{
    "role": "roles/viewer",
    "members": ["user:jane@example.com"],
}])
policy = gcp.notebooks.RuntimeIamPolicy("policy",
    project=runtime["project"],
    location=runtime["location"],
    runtime_name=runtime["name"],
    policy_data=admin.policy_data)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var admin = Gcp.Organizations.GetIAMPolicy.Invoke(new()
    {
        Bindings = new[]
        {
            new Gcp.Organizations.Inputs.GetIAMPolicyBindingInputArgs
            {
                Role = "roles/viewer",
                Members = new[]
                {
                    "user:jane@example.com",
                },
            },
        },
    });

    var policy = new Gcp.Notebooks.RuntimeIamPolicy("policy", new()
    {
        Project = runtime.Project,
        Location = runtime.Location,
        RuntimeName = runtime.Name,
        PolicyData = admin.Apply(getIAMPolicyResult => getIAMPolicyResult.PolicyData),
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		admin, err := organizations.LookupIAMPolicy(ctx, &organizations.LookupIAMPolicyArgs{
			Bindings: []organizations.GetIAMPolicyBinding{
				{
					Role: "roles/viewer",
					Members: []string{
						"user:jane@example.com",
					},
				},
			},
		}, nil)
		if err != nil {
			return err
		}
		_, err = notebooks.NewRuntimeIamPolicy(ctx, "policy", &notebooks.RuntimeIamPolicyArgs{
			Project:     pulumi.Any(runtime.Project),
			Location:    pulumi.Any(runtime.Location),
			RuntimeName: pulumi.Any(runtime.Name),
			PolicyData:  pulumi.String(admin.PolicyData),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.organizations.OrganizationsFunctions;
import com.pulumi.gcp.organizations.inputs.GetIAMPolicyArgs;
import com.pulumi.gcp.notebooks.RuntimeIamPolicy;
import com.pulumi.gcp.notebooks.RuntimeIamPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var admin = OrganizationsFunctions.getIAMPolicy(GetIAMPolicyArgs.builder()
            .bindings(GetIAMPolicyBindingArgs.builder()
                .role("roles/viewer")
                .members("user:jane@example.com")
                .build())
            .build());

        var policy = new RuntimeIamPolicy("policy", RuntimeIamPolicyArgs.builder()
            .project(runtime.project())
            .location(runtime.location())
            .runtimeName(runtime.name())
            .policyData(admin.applyValue(getIAMPolicyResult -> getIAMPolicyResult.policyData()))
            .build());

    }
}
```
```yaml
resources:
  policy:
    type: gcp:notebooks:RuntimeIamPolicy
    properties:
      project: ${runtime.project}
      location: ${runtime.location}
      runtimeName: ${runtime.name}
      policyData: ${admin.policyData}
variables:
  admin:
    fn::invoke:
      function: gcp:organizations:getIAMPolicy
      arguments:
        bindings:
          - role: roles/viewer
            members:
              - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.RuntimeIamBinding

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const binding = new gcp.notebooks.RuntimeIamBinding("binding", {
    project: runtime.project,
    location: runtime.location,
    runtimeName: runtime.name,
    role: "roles/viewer",
    members: ["user:jane@example.com"],
});
```
```python
import pulumi
import pulumi_gcp as gcp

binding = gcp.notebooks.RuntimeIamBinding("binding",
    project=runtime["project"],
    location=runtime["location"],
    runtime_name=runtime["name"],
    role="roles/viewer",
    members=["user:jane@example.com"])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var binding = new Gcp.Notebooks.RuntimeIamBinding("binding", new()
    {
        Project = runtime.Project,
        Location = runtime.Location,
        RuntimeName = runtime.Name,
        Role = "roles/viewer",
        Members = new[]
        {
            "user:jane@example.com",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewRuntimeIamBinding(ctx, "binding", &notebooks.RuntimeIamBindingArgs{
			Project:     pulumi.Any(runtime.Project),
			Location:    pulumi.Any(runtime.Location),
			RuntimeName: pulumi.Any(runtime.Name),
			Role:        pulumi.String("roles/viewer"),
			Members: pulumi.StringArray{
				pulumi.String("user:jane@example.com"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.RuntimeIamBinding;
import com.pulumi.gcp.notebooks.RuntimeIamBindingArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var binding = new RuntimeIamBinding("binding", RuntimeIamBindingArgs.builder()
            .project(runtime.project())
            .location(runtime.location())
            .runtimeName(runtime.name())
            .role("roles/viewer")
            .members("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  binding:
    type: gcp:notebooks:RuntimeIamBinding
    properties:
      project: ${runtime.project}
      location: ${runtime.location}
      runtimeName: ${runtime.name}
      role: roles/viewer
      members:
        - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.RuntimeIamMember

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const member = new gcp.notebooks.RuntimeIamMember("member", {
    project: runtime.project,
    location: runtime.location,
    runtimeName: runtime.name,
    role: "roles/viewer",
    member: "user:jane@example.com",
});
```
```python
import pulumi
import pulumi_gcp as gcp

member = gcp.notebooks.RuntimeIamMember("member",
    project=runtime["project"],
    location=runtime["location"],
    runtime_name=runtime["name"],
    role="roles/viewer",
    member="user:jane@example.com")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var member = new Gcp.Notebooks.RuntimeIamMember("member", new()
    {
        Project = runtime.Project,
        Location = runtime.Location,
        RuntimeName = runtime.Name,
        Role = "roles/viewer",
        Member = "user:jane@example.com",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewRuntimeIamMember(ctx, "member", &notebooks.RuntimeIamMemberArgs{
			Project:     pulumi.Any(runtime.Project),
			Location:    pulumi.Any(runtime.Location),
			RuntimeName: pulumi.Any(runtime.Name),
			Role:        pulumi.String("roles/viewer"),
			Member:      pulumi.String("user:jane@example.com"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.RuntimeIamMember;
import com.pulumi.gcp.notebooks.RuntimeIamMemberArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var member = new RuntimeIamMember("member", RuntimeIamMemberArgs.builder()
            .project(runtime.project())
            .location(runtime.location())
            .runtimeName(runtime.name())
            .role("roles/viewer")
            .member("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  member:
    type: gcp:notebooks:RuntimeIamMember
    properties:
      project: ${runtime.project}
      location: ${runtime.location}
      runtimeName: ${runtime.name}
      role: roles/viewer
      member: user:jane@example.com
```
<!--End PulumiCodeChooser -->

## Import

For all import syntaxes, the "resource in question" can take any of the following forms:

* projects/{{project}}/locations/{{location}}/runtimes/{{runtime_name}}

* {{project}}/{{location}}/{{runtime_name}}

* {{location}}/{{runtime_name}}

* {{runtime_name}}

Any variables not passed in the import command will be taken from the provider configuration.

Cloud AI Notebooks runtime IAM resources can be imported using the resource identifiers, role, and member.

IAM member imports use space-delimited identifiers: the resource in question, the role, and the member identity, e.g.

```sh
$ pulumi import gcp:notebooks/runtimeIamMember:RuntimeIamMember editor "projects/{{project}}/locations/{{location}}/runtimes/{{runtime_name}} roles/viewer user:jane@example.com"
```

IAM binding imports use space-delimited identifiers: the resource in question and the role, e.g.

```sh
$ pulumi import gcp:notebooks/runtimeIamMember:RuntimeIamMember editor "projects/{{project}}/locations/{{location}}/runtimes/{{runtime_name}} roles/viewer"
```

IAM policy imports use the identifier of the resource in question, e.g.

```sh
$ pulumi import gcp:notebooks/runtimeIamMember:RuntimeIamMember editor projects/{{project}}/locations/{{location}}/runtimes/{{runtime_name}}
```

-> **Custom Roles** If you're importing a IAM resource with a custom role, make sure to use the

 full name of the custom role, e.g. `[projects/my-project|organizations/my-org]/roles/my-custom-role`.

|
	conditionoBm:k
i
	notebooksRuntimeIamMemberConditionAgcp:notebooks/RuntimeIamMemberCondition:RuntimeIamMemberConditionÿ
locationB" ≈A reference to the zone where the machine resides. Used to find the parent resource to bind the IAM policy to. If not specified,
the value will be parsed from the identifier of the parent resource. If no location is provided in the parent identifier and no
location is specified, it is taken from the provider configuration.
”	
member" ƒ	Identities that will be granted the privilege in `role`.
Each entry can have one of the following values:
* **allUsers**: A special identifier that represents anyone who is on the internet; with or without a Google account.
* **allAuthenticatedUsers**: A special identifier that represents anyone who is authenticated with a Google account or a service account.
* **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com or joe@example.com.
* **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
* **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
* **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
* **projectOwner:projectid**: Owners of the given project. For example, "projectOwner:my-example-project"
* **projectEditor:projectid**: Editors of the given project. For example, "projectEditor:my-example-project"
* **projectViewer:projectid**: Viewers of the given project. For example, "projectViewer:my-example-project"
ì
projectB" ÅThe ID of the project in which the resource belongs.
If it is not provided, the project will be parsed from the identifier of the parent resource. If no project is provided in the parent identifier and no project is specified, the provider project is used.
ÿ
role" ÀThe role that should be applied. Only one
`gcp.notebooks.RuntimeIamBinding` can be used per role. Note that custom roles must be of the format
`[projects|organizations]/{parent-name}/roles/{role-name}`.
N
runtimeName" ;Used to find the parent resource to bind the IAM policy to
"|
	conditionoBm:k
i
	notebooksRuntimeIamMemberConditionAgcp:notebooks/RuntimeIamMemberCondition:RuntimeIamMemberCondition"3
etag" '(Computed) The etag of the IAM policy.
"÷
location" ≈A reference to the zone where the machine resides. Used to find the parent resource to bind the IAM policy to. If not specified,
the value will be parsed from the identifier of the parent resource. If no location is provided in the parent identifier and no
location is specified, it is taken from the provider configuration.
"”	
member" ƒ	Identities that will be granted the privilege in `role`.
Each entry can have one of the following values:
* **allUsers**: A special identifier that represents anyone who is on the internet; with or without a Google account.
* **allAuthenticatedUsers**: A special identifier that represents anyone who is authenticated with a Google account or a service account.
* **user:{emailid}**: An email address that represents a specific Google account. For example, alice@gmail.com or joe@example.com.
* **serviceAccount:{emailid}**: An email address that represents a service account. For example, my-other-app@appspot.gserviceaccount.com.
* **group:{emailid}**: An email address that represents a Google group. For example, admins@example.com.
* **domain:{domain}**: A G Suite domain (primary, instead of alias) name that represents all the users of that domain. For example, google.com or example.com.
* **projectOwner:projectid**: Owners of the given project. For example, "projectOwner:my-example-project"
* **projectEditor:projectid**: Editors of the given project. For example, "projectEditor:my-example-project"
* **projectViewer:projectid**: Viewers of the given project. For example, "projectViewer:my-example-project"
"ë
project" ÅThe ID of the project in which the resource belongs.
If it is not provided, the project will be parsed from the identifier of the parent resource. If no project is provided in the parent identifier and no project is specified, the provider project is used.
"ÿ
role" ÀThe role that should be applied. Only one
`gcp.notebooks.RuntimeIamBinding` can be used per role. Note that custom roles must be of the format
`[projects|organizations]/{parent-name}/roles/{role-name}`.
"N
runtimeName" ;Used to find the parent resource to bind the IAM policy to
*‚»
N
	notebooksRuntimeIamPolicy/gcp:notebooks/runtimeIamPolicy:RuntimeIamPolicyôªThree different resources help you manage your IAM policy for Cloud AI Notebooks Runtime. Each of these resources serves a different use case:

* `gcp.notebooks.RuntimeIamPolicy`: Authoritative. Sets the IAM policy for the runtime and replaces any existing policy already attached.
* `gcp.notebooks.RuntimeIamBinding`: Authoritative for a given role. Updates the IAM policy to grant a role to a list of members. Other roles within the IAM policy for the runtime are preserved.
* `gcp.notebooks.RuntimeIamMember`: Non-authoritative. Updates the IAM policy to grant a role to a new member. Other members for the role for the runtime are preserved.

A data source can be used to retrieve policy data in advent you do not need creation

* `gcp.notebooks.RuntimeIamPolicy`: Retrieves the IAM policy for the runtime

> **Note:** `gcp.notebooks.RuntimeIamPolicy` **cannot** be used in conjunction with `gcp.notebooks.RuntimeIamBinding` and `gcp.notebooks.RuntimeIamMember` or they will fight over what your policy should be.

> **Note:** `gcp.notebooks.RuntimeIamBinding` resources **can be** used in conjunction with `gcp.notebooks.RuntimeIamMember` resources **only if** they do not grant privilege to the same role.



## gcp.notebooks.RuntimeIamPolicy

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const admin = gcp.organizations.getIAMPolicy({
    bindings: [{
        role: "roles/viewer",
        members: ["user:jane@example.com"],
    }],
});
const policy = new gcp.notebooks.RuntimeIamPolicy("policy", {
    project: runtime.project,
    location: runtime.location,
    runtimeName: runtime.name,
    policyData: admin.then(admin => admin.policyData),
});
```
```python
import pulumi
import pulumi_gcp as gcp

admin = gcp.organizations.get_iam_policy(bindings=[{
    "role": "roles/viewer",
    "members": ["user:jane@example.com"],
}])
policy = gcp.notebooks.RuntimeIamPolicy("policy",
    project=runtime["project"],
    location=runtime["location"],
    runtime_name=runtime["name"],
    policy_data=admin.policy_data)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var admin = Gcp.Organizations.GetIAMPolicy.Invoke(new()
    {
        Bindings = new[]
        {
            new Gcp.Organizations.Inputs.GetIAMPolicyBindingInputArgs
            {
                Role = "roles/viewer",
                Members = new[]
                {
                    "user:jane@example.com",
                },
            },
        },
    });

    var policy = new Gcp.Notebooks.RuntimeIamPolicy("policy", new()
    {
        Project = runtime.Project,
        Location = runtime.Location,
        RuntimeName = runtime.Name,
        PolicyData = admin.Apply(getIAMPolicyResult => getIAMPolicyResult.PolicyData),
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		admin, err := organizations.LookupIAMPolicy(ctx, &organizations.LookupIAMPolicyArgs{
			Bindings: []organizations.GetIAMPolicyBinding{
				{
					Role: "roles/viewer",
					Members: []string{
						"user:jane@example.com",
					},
				},
			},
		}, nil)
		if err != nil {
			return err
		}
		_, err = notebooks.NewRuntimeIamPolicy(ctx, "policy", &notebooks.RuntimeIamPolicyArgs{
			Project:     pulumi.Any(runtime.Project),
			Location:    pulumi.Any(runtime.Location),
			RuntimeName: pulumi.Any(runtime.Name),
			PolicyData:  pulumi.String(admin.PolicyData),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.organizations.OrganizationsFunctions;
import com.pulumi.gcp.organizations.inputs.GetIAMPolicyArgs;
import com.pulumi.gcp.notebooks.RuntimeIamPolicy;
import com.pulumi.gcp.notebooks.RuntimeIamPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var admin = OrganizationsFunctions.getIAMPolicy(GetIAMPolicyArgs.builder()
            .bindings(GetIAMPolicyBindingArgs.builder()
                .role("roles/viewer")
                .members("user:jane@example.com")
                .build())
            .build());

        var policy = new RuntimeIamPolicy("policy", RuntimeIamPolicyArgs.builder()
            .project(runtime.project())
            .location(runtime.location())
            .runtimeName(runtime.name())
            .policyData(admin.applyValue(getIAMPolicyResult -> getIAMPolicyResult.policyData()))
            .build());

    }
}
```
```yaml
resources:
  policy:
    type: gcp:notebooks:RuntimeIamPolicy
    properties:
      project: ${runtime.project}
      location: ${runtime.location}
      runtimeName: ${runtime.name}
      policyData: ${admin.policyData}
variables:
  admin:
    fn::invoke:
      function: gcp:organizations:getIAMPolicy
      arguments:
        bindings:
          - role: roles/viewer
            members:
              - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.RuntimeIamBinding

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const binding = new gcp.notebooks.RuntimeIamBinding("binding", {
    project: runtime.project,
    location: runtime.location,
    runtimeName: runtime.name,
    role: "roles/viewer",
    members: ["user:jane@example.com"],
});
```
```python
import pulumi
import pulumi_gcp as gcp

binding = gcp.notebooks.RuntimeIamBinding("binding",
    project=runtime["project"],
    location=runtime["location"],
    runtime_name=runtime["name"],
    role="roles/viewer",
    members=["user:jane@example.com"])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var binding = new Gcp.Notebooks.RuntimeIamBinding("binding", new()
    {
        Project = runtime.Project,
        Location = runtime.Location,
        RuntimeName = runtime.Name,
        Role = "roles/viewer",
        Members = new[]
        {
            "user:jane@example.com",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewRuntimeIamBinding(ctx, "binding", &notebooks.RuntimeIamBindingArgs{
			Project:     pulumi.Any(runtime.Project),
			Location:    pulumi.Any(runtime.Location),
			RuntimeName: pulumi.Any(runtime.Name),
			Role:        pulumi.String("roles/viewer"),
			Members: pulumi.StringArray{
				pulumi.String("user:jane@example.com"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.RuntimeIamBinding;
import com.pulumi.gcp.notebooks.RuntimeIamBindingArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var binding = new RuntimeIamBinding("binding", RuntimeIamBindingArgs.builder()
            .project(runtime.project())
            .location(runtime.location())
            .runtimeName(runtime.name())
            .role("roles/viewer")
            .members("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  binding:
    type: gcp:notebooks:RuntimeIamBinding
    properties:
      project: ${runtime.project}
      location: ${runtime.location}
      runtimeName: ${runtime.name}
      role: roles/viewer
      members:
        - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.RuntimeIamMember

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const member = new gcp.notebooks.RuntimeIamMember("member", {
    project: runtime.project,
    location: runtime.location,
    runtimeName: runtime.name,
    role: "roles/viewer",
    member: "user:jane@example.com",
});
```
```python
import pulumi
import pulumi_gcp as gcp

member = gcp.notebooks.RuntimeIamMember("member",
    project=runtime["project"],
    location=runtime["location"],
    runtime_name=runtime["name"],
    role="roles/viewer",
    member="user:jane@example.com")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var member = new Gcp.Notebooks.RuntimeIamMember("member", new()
    {
        Project = runtime.Project,
        Location = runtime.Location,
        RuntimeName = runtime.Name,
        Role = "roles/viewer",
        Member = "user:jane@example.com",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewRuntimeIamMember(ctx, "member", &notebooks.RuntimeIamMemberArgs{
			Project:     pulumi.Any(runtime.Project),
			Location:    pulumi.Any(runtime.Location),
			RuntimeName: pulumi.Any(runtime.Name),
			Role:        pulumi.String("roles/viewer"),
			Member:      pulumi.String("user:jane@example.com"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.RuntimeIamMember;
import com.pulumi.gcp.notebooks.RuntimeIamMemberArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var member = new RuntimeIamMember("member", RuntimeIamMemberArgs.builder()
            .project(runtime.project())
            .location(runtime.location())
            .runtimeName(runtime.name())
            .role("roles/viewer")
            .member("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  member:
    type: gcp:notebooks:RuntimeIamMember
    properties:
      project: ${runtime.project}
      location: ${runtime.location}
      runtimeName: ${runtime.name}
      role: roles/viewer
      member: user:jane@example.com
```
<!--End PulumiCodeChooser -->


## This resource supports User Project Overrides.

-

# IAM policy for Cloud AI Notebooks Runtime
Three different resources help you manage your IAM policy for Cloud AI Notebooks Runtime. Each of these resources serves a different use case:

* `gcp.notebooks.RuntimeIamPolicy`: Authoritative. Sets the IAM policy for the runtime and replaces any existing policy already attached.
* `gcp.notebooks.RuntimeIamBinding`: Authoritative for a given role. Updates the IAM policy to grant a role to a list of members. Other roles within the IAM policy for the runtime are preserved.
* `gcp.notebooks.RuntimeIamMember`: Non-authoritative. Updates the IAM policy to grant a role to a new member. Other members for the role for the runtime are preserved.

A data source can be used to retrieve policy data in advent you do not need creation

* `gcp.notebooks.RuntimeIamPolicy`: Retrieves the IAM policy for the runtime

> **Note:** `gcp.notebooks.RuntimeIamPolicy` **cannot** be used in conjunction with `gcp.notebooks.RuntimeIamBinding` and `gcp.notebooks.RuntimeIamMember` or they will fight over what your policy should be.

> **Note:** `gcp.notebooks.RuntimeIamBinding` resources **can be** used in conjunction with `gcp.notebooks.RuntimeIamMember` resources **only if** they do not grant privilege to the same role.



## gcp.notebooks.RuntimeIamPolicy

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const admin = gcp.organizations.getIAMPolicy({
    bindings: [{
        role: "roles/viewer",
        members: ["user:jane@example.com"],
    }],
});
const policy = new gcp.notebooks.RuntimeIamPolicy("policy", {
    project: runtime.project,
    location: runtime.location,
    runtimeName: runtime.name,
    policyData: admin.then(admin => admin.policyData),
});
```
```python
import pulumi
import pulumi_gcp as gcp

admin = gcp.organizations.get_iam_policy(bindings=[{
    "role": "roles/viewer",
    "members": ["user:jane@example.com"],
}])
policy = gcp.notebooks.RuntimeIamPolicy("policy",
    project=runtime["project"],
    location=runtime["location"],
    runtime_name=runtime["name"],
    policy_data=admin.policy_data)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var admin = Gcp.Organizations.GetIAMPolicy.Invoke(new()
    {
        Bindings = new[]
        {
            new Gcp.Organizations.Inputs.GetIAMPolicyBindingInputArgs
            {
                Role = "roles/viewer",
                Members = new[]
                {
                    "user:jane@example.com",
                },
            },
        },
    });

    var policy = new Gcp.Notebooks.RuntimeIamPolicy("policy", new()
    {
        Project = runtime.Project,
        Location = runtime.Location,
        RuntimeName = runtime.Name,
        PolicyData = admin.Apply(getIAMPolicyResult => getIAMPolicyResult.PolicyData),
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/organizations"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		admin, err := organizations.LookupIAMPolicy(ctx, &organizations.LookupIAMPolicyArgs{
			Bindings: []organizations.GetIAMPolicyBinding{
				{
					Role: "roles/viewer",
					Members: []string{
						"user:jane@example.com",
					},
				},
			},
		}, nil)
		if err != nil {
			return err
		}
		_, err = notebooks.NewRuntimeIamPolicy(ctx, "policy", &notebooks.RuntimeIamPolicyArgs{
			Project:     pulumi.Any(runtime.Project),
			Location:    pulumi.Any(runtime.Location),
			RuntimeName: pulumi.Any(runtime.Name),
			PolicyData:  pulumi.String(admin.PolicyData),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.organizations.OrganizationsFunctions;
import com.pulumi.gcp.organizations.inputs.GetIAMPolicyArgs;
import com.pulumi.gcp.notebooks.RuntimeIamPolicy;
import com.pulumi.gcp.notebooks.RuntimeIamPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var admin = OrganizationsFunctions.getIAMPolicy(GetIAMPolicyArgs.builder()
            .bindings(GetIAMPolicyBindingArgs.builder()
                .role("roles/viewer")
                .members("user:jane@example.com")
                .build())
            .build());

        var policy = new RuntimeIamPolicy("policy", RuntimeIamPolicyArgs.builder()
            .project(runtime.project())
            .location(runtime.location())
            .runtimeName(runtime.name())
            .policyData(admin.applyValue(getIAMPolicyResult -> getIAMPolicyResult.policyData()))
            .build());

    }
}
```
```yaml
resources:
  policy:
    type: gcp:notebooks:RuntimeIamPolicy
    properties:
      project: ${runtime.project}
      location: ${runtime.location}
      runtimeName: ${runtime.name}
      policyData: ${admin.policyData}
variables:
  admin:
    fn::invoke:
      function: gcp:organizations:getIAMPolicy
      arguments:
        bindings:
          - role: roles/viewer
            members:
              - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.RuntimeIamBinding

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const binding = new gcp.notebooks.RuntimeIamBinding("binding", {
    project: runtime.project,
    location: runtime.location,
    runtimeName: runtime.name,
    role: "roles/viewer",
    members: ["user:jane@example.com"],
});
```
```python
import pulumi
import pulumi_gcp as gcp

binding = gcp.notebooks.RuntimeIamBinding("binding",
    project=runtime["project"],
    location=runtime["location"],
    runtime_name=runtime["name"],
    role="roles/viewer",
    members=["user:jane@example.com"])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var binding = new Gcp.Notebooks.RuntimeIamBinding("binding", new()
    {
        Project = runtime.Project,
        Location = runtime.Location,
        RuntimeName = runtime.Name,
        Role = "roles/viewer",
        Members = new[]
        {
            "user:jane@example.com",
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewRuntimeIamBinding(ctx, "binding", &notebooks.RuntimeIamBindingArgs{
			Project:     pulumi.Any(runtime.Project),
			Location:    pulumi.Any(runtime.Location),
			RuntimeName: pulumi.Any(runtime.Name),
			Role:        pulumi.String("roles/viewer"),
			Members: pulumi.StringArray{
				pulumi.String("user:jane@example.com"),
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.RuntimeIamBinding;
import com.pulumi.gcp.notebooks.RuntimeIamBindingArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var binding = new RuntimeIamBinding("binding", RuntimeIamBindingArgs.builder()
            .project(runtime.project())
            .location(runtime.location())
            .runtimeName(runtime.name())
            .role("roles/viewer")
            .members("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  binding:
    type: gcp:notebooks:RuntimeIamBinding
    properties:
      project: ${runtime.project}
      location: ${runtime.location}
      runtimeName: ${runtime.name}
      role: roles/viewer
      members:
        - user:jane@example.com
```
<!--End PulumiCodeChooser -->

## gcp.notebooks.RuntimeIamMember

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const member = new gcp.notebooks.RuntimeIamMember("member", {
    project: runtime.project,
    location: runtime.location,
    runtimeName: runtime.name,
    role: "roles/viewer",
    member: "user:jane@example.com",
});
```
```python
import pulumi
import pulumi_gcp as gcp

member = gcp.notebooks.RuntimeIamMember("member",
    project=runtime["project"],
    location=runtime["location"],
    runtime_name=runtime["name"],
    role="roles/viewer",
    member="user:jane@example.com")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var member = new Gcp.Notebooks.RuntimeIamMember("member", new()
    {
        Project = runtime.Project,
        Location = runtime.Location,
        RuntimeName = runtime.Name,
        Role = "roles/viewer",
        Member = "user:jane@example.com",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.NewRuntimeIamMember(ctx, "member", &notebooks.RuntimeIamMemberArgs{
			Project:     pulumi.Any(runtime.Project),
			Location:    pulumi.Any(runtime.Location),
			RuntimeName: pulumi.Any(runtime.Name),
			Role:        pulumi.String("roles/viewer"),
			Member:      pulumi.String("user:jane@example.com"),
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.RuntimeIamMember;
import com.pulumi.gcp.notebooks.RuntimeIamMemberArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var member = new RuntimeIamMember("member", RuntimeIamMemberArgs.builder()
            .project(runtime.project())
            .location(runtime.location())
            .runtimeName(runtime.name())
            .role("roles/viewer")
            .member("user:jane@example.com")
            .build());

    }
}
```
```yaml
resources:
  member:
    type: gcp:notebooks:RuntimeIamMember
    properties:
      project: ${runtime.project}
      location: ${runtime.location}
      runtimeName: ${runtime.name}
      role: roles/viewer
      member: user:jane@example.com
```
<!--End PulumiCodeChooser -->

## Import

For all import syntaxes, the "resource in question" can take any of the following forms:

* projects/{{project}}/locations/{{location}}/runtimes/{{runtime_name}}

* {{project}}/{{location}}/{{runtime_name}}

* {{location}}/{{runtime_name}}

* {{runtime_name}}

Any variables not passed in the import command will be taken from the provider configuration.

Cloud AI Notebooks runtime IAM resources can be imported using the resource identifiers, role, and member.

IAM member imports use space-delimited identifiers: the resource in question, the role, and the member identity, e.g.

```sh
$ pulumi import gcp:notebooks/runtimeIamPolicy:RuntimeIamPolicy editor "projects/{{project}}/locations/{{location}}/runtimes/{{runtime_name}} roles/viewer user:jane@example.com"
```

IAM binding imports use space-delimited identifiers: the resource in question and the role, e.g.

```sh
$ pulumi import gcp:notebooks/runtimeIamPolicy:RuntimeIamPolicy editor "projects/{{project}}/locations/{{location}}/runtimes/{{runtime_name}} roles/viewer"
```

IAM policy imports use the identifier of the resource in question, e.g.

```sh
$ pulumi import gcp:notebooks/runtimeIamPolicy:RuntimeIamPolicy editor projects/{{project}}/locations/{{location}}/runtimes/{{runtime_name}}
```

-> **Custom Roles** If you're importing a IAM resource with a custom role, make sure to use the

 full name of the custom role, e.g. `[projects/my-project|organizations/my-org]/roles/my-custom-role`.

ÿ
locationB" ≈A reference to the zone where the machine resides. Used to find the parent resource to bind the IAM policy to. If not specified,
the value will be parsed from the identifier of the parent resource. If no location is provided in the parent identifier and no
location is specified, it is taken from the provider configuration.
_

policyData" MThe policy data generated by
a `gcp.organizations.getIAMPolicy` data source.
ì
projectB" ÅThe ID of the project in which the resource belongs.
If it is not provided, the project will be parsed from the identifier of the parent resource. If no project is provided in the parent identifier and no project is specified, the provider project is used.
N
runtimeName" ;Used to find the parent resource to bind the IAM policy to
"3
etag" '(Computed) The etag of the IAM policy.
"÷
location" ≈A reference to the zone where the machine resides. Used to find the parent resource to bind the IAM policy to. If not specified,
the value will be parsed from the identifier of the parent resource. If no location is provided in the parent identifier and no
location is specified, it is taken from the provider configuration.
"_

policyData" MThe policy data generated by
a `gcp.organizations.getIAMPolicy` data source.
"ë
project" ÅThe ID of the project in which the resource belongs.
If it is not provided, the project will be parsed from the identifier of the parent resource. If no project is provided in the parent identifier and no project is specified, the provider project is used.
"N
runtimeName" ;Used to find the parent resource to bind the IAM policy to
2´T
Y

monitoringgetAppEngineService6gcp:monitoring/getAppEngineService:getAppEngineServiceÚKA Monitoring Service is the root resource under which operational aspects of a
generic service are accessible. A service is some discrete, autonomous, and
network-accessible unit, designed to solve an individual concern

An App Engine monitoring service is automatically created by GCP to monitor
App Engine services.


To get more information about Service, see:

* [API documentation](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/services)
* How-to Guides
    * [Service Monitoring](https://cloud.google.com/monitoring/service-monitoring)
    * [Monitoring API Documentation](https://cloud.google.com/monitoring/api/v3/)

## Example Usage

### Monitoring App Engine Service


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const bucket = new gcp.storage.Bucket("bucket", {
    name: "appengine-static-content",
    location: "US",
});
const object = new gcp.storage.BucketObject("object", {
    name: "hello-world.zip",
    bucket: bucket.name,
    source: new pulumi.asset.FileAsset("./test-fixtures/hello-world.zip"),
});
const myapp = new gcp.appengine.StandardAppVersion("myapp", {
    versionId: "v1",
    service: "myapp",
    runtime: "nodejs20",
    entrypoint: {
        shell: "node ./app.js",
    },
    deployment: {
        zip: {
            sourceUrl: pulumi.interpolate`https://storage.googleapis.com/${bucket.name}/${object.name}`,
        },
    },
    envVariables: {
        port: "8080",
    },
    deleteServiceOnDestroy: false,
});
// Monitors the default AppEngine service
const srv = gcp.monitoring.getAppEngineServiceOutput({
    moduleId: myapp.service,
});
```
```python
import pulumi
import pulumi_gcp as gcp

bucket = gcp.storage.Bucket("bucket",
    name="appengine-static-content",
    location="US")
object = gcp.storage.BucketObject("object",
    name="hello-world.zip",
    bucket=bucket.name,
    source=pulumi.FileAsset("./test-fixtures/hello-world.zip"))
myapp = gcp.appengine.StandardAppVersion("myapp",
    version_id="v1",
    service="myapp",
    runtime="nodejs20",
    entrypoint={
        "shell": "node ./app.js",
    },
    deployment={
        "zip": {
            "source_url": pulumi.Output.all(
                bucketName=bucket.name,
                objectName=object.name
).apply(lambda resolved_outputs: f"https://storage.googleapis.com/{resolved_outputs['bucketName']}/{resolved_outputs['objectName']}")
,
        },
    },
    env_variables={
        "port": "8080",
    },
    delete_service_on_destroy=False)
# Monitors the default AppEngine service
srv = gcp.monitoring.get_app_engine_service_output(module_id=myapp.service)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var bucket = new Gcp.Storage.Bucket("bucket", new()
    {
        Name = "appengine-static-content",
        Location = "US",
    });

    var @object = new Gcp.Storage.BucketObject("object", new()
    {
        Name = "hello-world.zip",
        Bucket = bucket.Name,
        Source = new FileAsset("./test-fixtures/hello-world.zip"),
    });

    var myapp = new Gcp.AppEngine.StandardAppVersion("myapp", new()
    {
        VersionId = "v1",
        Service = "myapp",
        Runtime = "nodejs20",
        Entrypoint = new Gcp.AppEngine.Inputs.StandardAppVersionEntrypointArgs
        {
            Shell = "node ./app.js",
        },
        Deployment = new Gcp.AppEngine.Inputs.StandardAppVersionDeploymentArgs
        {
            Zip = new Gcp.AppEngine.Inputs.StandardAppVersionDeploymentZipArgs
            {
                SourceUrl = Output.Tuple(bucket.Name, @object.Name).Apply(values =>
                {
                    var bucketName = values.Item1;
                    var objectName = values.Item2;
                    return $"https://storage.googleapis.com/{bucketName}/{objectName}";
                }),
            },
        },
        EnvVariables = 
        {
            { "port", "8080" },
        },
        DeleteServiceOnDestroy = false,
    });

    // Monitors the default AppEngine service
    var srv = Gcp.Monitoring.GetAppEngineService.Invoke(new()
    {
        ModuleId = myapp.Service,
    });

});
```
```go
package main

import (
	"fmt"

	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/appengine"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/storage"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		bucket, err := storage.NewBucket(ctx, "bucket", &storage.BucketArgs{
			Name:     pulumi.String("appengine-static-content"),
			Location: pulumi.String("US"),
		})
		if err != nil {
			return err
		}
		object, err := storage.NewBucketObject(ctx, "object", &storage.BucketObjectArgs{
			Name:   pulumi.String("hello-world.zip"),
			Bucket: bucket.Name,
			Source: pulumi.NewFileAsset("./test-fixtures/hello-world.zip"),
		})
		if err != nil {
			return err
		}
		myapp, err := appengine.NewStandardAppVersion(ctx, "myapp", &appengine.StandardAppVersionArgs{
			VersionId: pulumi.String("v1"),
			Service:   pulumi.String("myapp"),
			Runtime:   pulumi.String("nodejs20"),
			Entrypoint: &appengine.StandardAppVersionEntrypointArgs{
				Shell: pulumi.String("node ./app.js"),
			},
			Deployment: &appengine.StandardAppVersionDeploymentArgs{
				Zip: &appengine.StandardAppVersionDeploymentZipArgs{
					SourceUrl: pulumi.All(bucket.Name, object.Name).ApplyT(func(_args []interface{}) (string, error) {
						bucketName := _args[0].(string)
						objectName := _args[1].(string)
						return fmt.Sprintf("https://storage.googleapis.com/%v/%v", bucketName, objectName), nil
					}).(pulumi.StringOutput),
				},
			},
			EnvVariables: pulumi.StringMap{
				"port": pulumi.String("8080"),
			},
			DeleteServiceOnDestroy: pulumi.Bool(false),
		})
		if err != nil {
			return err
		}
		// Monitors the default AppEngine service
		_ = monitoring.GetAppEngineServiceOutput(ctx, monitoring.GetAppEngineServiceOutputArgs{
			ModuleId: myapp.Service,
		}, nil)
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.storage.Bucket;
import com.pulumi.gcp.storage.BucketArgs;
import com.pulumi.gcp.storage.BucketObject;
import com.pulumi.gcp.storage.BucketObjectArgs;
import com.pulumi.gcp.appengine.StandardAppVersion;
import com.pulumi.gcp.appengine.StandardAppVersionArgs;
import com.pulumi.gcp.appengine.inputs.StandardAppVersionEntrypointArgs;
import com.pulumi.gcp.appengine.inputs.StandardAppVersionDeploymentArgs;
import com.pulumi.gcp.appengine.inputs.StandardAppVersionDeploymentZipArgs;
import com.pulumi.gcp.monitoring.MonitoringFunctions;
import com.pulumi.gcp.monitoring.inputs.GetAppEngineServiceArgs;
import com.pulumi.asset.FileAsset;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        var bucket = new Bucket("bucket", BucketArgs.builder()
            .name("appengine-static-content")
            .location("US")
            .build());

        var object = new BucketObject("object", BucketObjectArgs.builder()
            .name("hello-world.zip")
            .bucket(bucket.name())
            .source(new FileAsset("./test-fixtures/hello-world.zip"))
            .build());

        var myapp = new StandardAppVersion("myapp", StandardAppVersionArgs.builder()
            .versionId("v1")
            .service("myapp")
            .runtime("nodejs20")
            .entrypoint(StandardAppVersionEntrypointArgs.builder()
                .shell("node ./app.js")
                .build())
            .deployment(StandardAppVersionDeploymentArgs.builder()
                .zip(StandardAppVersionDeploymentZipArgs.builder()
                    .sourceUrl(Output.tuple(bucket.name(), object.name()).applyValue(values -> {
                        var bucketName = values.t1;
                        var objectName = values.t2;
                        return String.format("https://storage.googleapis.com/%s/%s", bucketName,objectName);
                    }))
                    .build())
                .build())
            .envVariables(Map.of("port", "8080"))
            .deleteServiceOnDestroy(false)
            .build());

        // Monitors the default AppEngine service
        final var srv = MonitoringFunctions.getAppEngineService(GetAppEngineServiceArgs.builder()
            .moduleId(myapp.service())
            .build());

    }
}
```
```yaml
resources:
  myapp:
    type: gcp:appengine:StandardAppVersion
    properties:
      versionId: v1
      service: myapp
      runtime: nodejs20
      entrypoint:
        shell: node ./app.js
      deployment:
        zip:
          sourceUrl: https://storage.googleapis.com/${bucket.name}/${object.name}
      envVariables:
        port: '8080'
      deleteServiceOnDestroy: false
  bucket:
    type: gcp:storage:Bucket
    properties:
      name: appengine-static-content
      location: US
  object:
    type: gcp:storage:BucketObject
    properties:
      name: hello-world.zip
      bucket: ${bucket.name}
      source:
        fn::FileAsset: ./test-fixtures/hello-world.zip
variables:
  # Monitors the default AppEngine service
  srv:
    fn::invoke:
      function: gcp:monitoring:getAppEngineService
      arguments:
        moduleId: ${myapp.service}
```
<!--End PulumiCodeChooser -->
ú
moduleId" ãThe ID of the App Engine module underlying this
service. Corresponds to the moduleId resource label in the [gae_app](https://cloud.google.com/monitoring/api/resources#tag_gae_app) monitored resource, or the service/module name.

- - -

Other optional fields include:
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"P
displayName" =Name used for UI elements listing this (Monitoring) Service.
"E
id" ;The provider-assigned unique ID for this managed resource.
"
moduleId" "x
name" lThe full REST resource name for this channel. The syntax is:
`projects/[PROJECT_ID]/services/[SERVICE_ID]`.
"
projectB" "
	serviceId" "„
telemetriesz*x:v
t

monitoringgetAppEngineServiceTelemetryHgcp:monitoring/getAppEngineServiceTelemetry:getAppEngineServiceTelemetryXConfiguration for how to query telemetry on the Service. Structure is documented below.
"

userLabels2" 2ﬁ'
b

monitoringgetClusterIstioService<gcp:monitoring/getClusterIstioService:getClusterIstioService∂A Monitoring Service is the root resource under which operational aspects of a
generic service are accessible. A service is some discrete, autonomous, and
network-accessible unit, designed to solve an individual concern

An Cluster Istio monitoring service is automatically created by GCP to monitor
Cluster Istio services.


To get more information about Service, see:

* [API documentation](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/services)
* How-to Guides
    * [Service Monitoring](https://cloud.google.com/monitoring/service-monitoring)
    * [Monitoring API Documentation](https://cloud.google.com/monitoring/api/v3/)

## Example Usage

### Monitoring Cluster Istio Service


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

// Monitors the default ClusterIstio service
const default = gcp.monitoring.getClusterIstioService({
    location: "us-west2-a",
    clusterName: "west",
    serviceNamespace: "istio-system",
    serviceName: "istio-policy",
});
```
```python
import pulumi
import pulumi_gcp as gcp

# Monitors the default ClusterIstio service
default = gcp.monitoring.get_cluster_istio_service(location="us-west2-a",
    cluster_name="west",
    service_namespace="istio-system",
    service_name="istio-policy")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    // Monitors the default ClusterIstio service
    var @default = Gcp.Monitoring.GetClusterIstioService.Invoke(new()
    {
        Location = "us-west2-a",
        ClusterName = "west",
        ServiceNamespace = "istio-system",
        ServiceName = "istio-policy",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		// Monitors the default ClusterIstio service
		_, err := monitoring.GetClusterIstioService(ctx, &monitoring.GetClusterIstioServiceArgs{
			Location:         "us-west2-a",
			ClusterName:      "west",
			ServiceNamespace: "istio-system",
			ServiceName:      "istio-policy",
		}, nil)
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.MonitoringFunctions;
import com.pulumi.gcp.monitoring.inputs.GetClusterIstioServiceArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        // Monitors the default ClusterIstio service
        final var default = MonitoringFunctions.getClusterIstioService(GetClusterIstioServiceArgs.builder()
            .location("us-west2-a")
            .clusterName("west")
            .serviceNamespace("istio-system")
            .serviceName("istio-policy")
            .build());

    }
}
```
```yaml
variables:
  # Monitors the default ClusterIstio service
  default:
    fn::invoke:
      function: gcp:monitoring:getClusterIstioService
      arguments:
        location: us-west2-a
        clusterName: west
        serviceNamespace: istio-system
        serviceName: istio-policy
```
<!--End PulumiCodeChooser -->
®
clusterName" îThe name of the Kubernetes cluster in which this Istio service 
is defined. Corresponds to the clusterName resource label in k8s_cluster resources.
¶
location" ïThe location of the Kubernetes cluster in which this Istio service 
is defined. Corresponds to the location resource label in k8s_cluster resources.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
Ω
serviceName" ©The name of the Istio service underlying this service.
Corresponds to the destination_service_name metric label in Istio metrics.

- - -

Other optional fields include:
•
serviceNamespace" åThe namespace of the Istio service underlying this service.
Corresponds to the destination_service_namespace metric label in Istio metrics.
"
clusterName" "P
displayName" =Name used for UI elements listing this (Monitoring) Service.
"E
id" ;The provider-assigned unique ID for this managed resource.
"
location" "x
name" lThe full REST resource name for this channel. The syntax is:
`projects/[PROJECT_ID]/services/[SERVICE_ID]`.
"
projectB" "
	serviceId" "
serviceName" "
serviceNamespace" "Ó
telemetriesÑ*Å:
}

monitoringgetClusterIstioServiceTelemetryNgcp:monitoring/getClusterIstioServiceTelemetry:getClusterIstioServiceTelemetryXConfiguration for how to query telemetry on the Service. Structure is documented below.
"

userLabels2" 2™&
h

monitoringgetIstioCanonicalService@gcp:monitoring/getIstioCanonicalService:getIstioCanonicalServiceèA Monitoring Service is the root resource under which operational aspects of a
generic service are accessible. A service is some discrete, autonomous, and
network-accessible unit, designed to solve an individual concern

A monitoring Istio Canonical Service is automatically created by GCP to monitor
Istio Canonical Services.


To get more information about Service, see:

* [API documentation](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/services)
* How-to Guides
    * [Service Monitoring](https://cloud.google.com/monitoring/service-monitoring)
    * [Monitoring API Documentation](https://cloud.google.com/monitoring/api/v3/)

## Example Usage

### Monitoring Istio Canonical Service


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

// Monitors the default MeshIstio service
const default = gcp.monitoring.getIstioCanonicalService({
    meshUid: "proj-573164786102",
    canonicalServiceNamespace: "istio-system",
    canonicalService: "prometheus",
});
```
```python
import pulumi
import pulumi_gcp as gcp

# Monitors the default MeshIstio service
default = gcp.monitoring.get_istio_canonical_service(mesh_uid="proj-573164786102",
    canonical_service_namespace="istio-system",
    canonical_service="prometheus")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    // Monitors the default MeshIstio service
    var @default = Gcp.Monitoring.GetIstioCanonicalService.Invoke(new()
    {
        MeshUid = "proj-573164786102",
        CanonicalServiceNamespace = "istio-system",
        CanonicalService = "prometheus",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		// Monitors the default MeshIstio service
		_, err := monitoring.GetIstioCanonicalService(ctx, &monitoring.GetIstioCanonicalServiceArgs{
			MeshUid:                   "proj-573164786102",
			CanonicalServiceNamespace: "istio-system",
			CanonicalService:          "prometheus",
		}, nil)
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.MonitoringFunctions;
import com.pulumi.gcp.monitoring.inputs.GetIstioCanonicalServiceArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        // Monitors the default MeshIstio service
        final var default = MonitoringFunctions.getIstioCanonicalService(GetIstioCanonicalServiceArgs.builder()
            .meshUid("proj-573164786102")
            .canonicalServiceNamespace("istio-system")
            .canonicalService("prometheus")
            .build());

    }
}
```
```yaml
variables:
  # Monitors the default MeshIstio service
  default:
    fn::invoke:
      function: gcp:monitoring:getIstioCanonicalService
      arguments:
        meshUid: proj-573164786102
        canonicalServiceNamespace: istio-system
        canonicalService: prometheus
```
<!--End PulumiCodeChooser -->
Ÿ
canonicalService" ¿The name of the canonical service underlying this service.
Corresponds to the destination_canonical_service_name metric label in label in Istio metrics.

- - -

Other optional fields include:
º
canonicalServiceNamespace" öThe namespace of the canonical service underlying this service.
Corresponds to the destination_canonical_service_namespace metric label in Istio metrics.
â
meshUid" zIdentifier for the mesh in which this Istio service is defined.
Corresponds to the meshUid metric label in Istio metrics.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
"
canonicalService" "
canonicalServiceNamespace" "P
displayName" =Name used for UI elements listing this (Monitoring) Service.
"E
id" ;The provider-assigned unique ID for this managed resource.
"
meshUid" "x
name" lThe full REST resource name for this channel. The syntax is:
`projects/[PROJECT_ID]/services/[SERVICE_ID]`.
"
projectB" "
	serviceId" "ˆ
telemetrieså*â:Ü
É

monitoring!getIstioCanonicalServiceTelemetryRgcp:monitoring/getIstioCanonicalServiceTelemetry:getIstioCanonicalServiceTelemetryXConfiguration for how to query telemetry on the Service. Structure is documented below.
"

userLabels2" 2™$
Y

monitoringgetMeshIstioService6gcp:monitoring/getMeshIstioService:getMeshIstioServiceÚA Monitoring Service is the root resource under which operational aspects of a
generic service are accessible. A service is some discrete, autonomous, and
network-accessible unit, designed to solve an individual concern

An Mesh Istio monitoring service is automatically created by GCP to monitor
Mesh Istio services.


To get more information about Service, see:

* [API documentation](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/services)
* How-to Guides
    * [Service Monitoring](https://cloud.google.com/monitoring/service-monitoring)
    * [Monitoring API Documentation](https://cloud.google.com/monitoring/api/v3/)

## Example Usage

### Monitoring Mesh Istio Service


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

// Monitors the default MeshIstio service
const default = gcp.monitoring.getMeshIstioService({
    meshUid: "proj-573164786102",
    serviceNamespace: "istio-system",
    serviceName: "prometheus",
});
```
```python
import pulumi
import pulumi_gcp as gcp

# Monitors the default MeshIstio service
default = gcp.monitoring.get_mesh_istio_service(mesh_uid="proj-573164786102",
    service_namespace="istio-system",
    service_name="prometheus")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    // Monitors the default MeshIstio service
    var @default = Gcp.Monitoring.GetMeshIstioService.Invoke(new()
    {
        MeshUid = "proj-573164786102",
        ServiceNamespace = "istio-system",
        ServiceName = "prometheus",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		// Monitors the default MeshIstio service
		_, err := monitoring.GetMeshIstioService(ctx, &monitoring.GetMeshIstioServiceArgs{
			MeshUid:          "proj-573164786102",
			ServiceNamespace: "istio-system",
			ServiceName:      "prometheus",
		}, nil)
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.MonitoringFunctions;
import com.pulumi.gcp.monitoring.inputs.GetMeshIstioServiceArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        // Monitors the default MeshIstio service
        final var default = MonitoringFunctions.getMeshIstioService(GetMeshIstioServiceArgs.builder()
            .meshUid("proj-573164786102")
            .serviceNamespace("istio-system")
            .serviceName("prometheus")
            .build());

    }
}
```
```yaml
variables:
  # Monitors the default MeshIstio service
  default:
    fn::invoke:
      function: gcp:monitoring:getMeshIstioService
      arguments:
        meshUid: proj-573164786102
        serviceNamespace: istio-system
        serviceName: prometheus
```
<!--End PulumiCodeChooser -->
â
meshUid" zIdentifier for the mesh in which this Istio service is defined.
Corresponds to the meshUid metric label in Istio metrics.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
Ω
serviceName" ©The name of the Istio service underlying this service.
Corresponds to the destination_service_name metric label in Istio metrics.

- - -

Other optional fields include:
•
serviceNamespace" åThe namespace of the Istio service underlying this service.
Corresponds to the destination_service_namespace metric label in Istio metrics.
"P
displayName" =Name used for UI elements listing this (Monitoring) Service.
"E
id" ;The provider-assigned unique ID for this managed resource.
"
meshUid" "x
name" lThe full REST resource name for this channel. The syntax is:
`projects/[PROJECT_ID]/services/[SERVICE_ID]`.
"
projectB" "
	serviceId" "
serviceName" "
serviceNamespace" "„
telemetriesz*x:v
t

monitoringgetMeshIstioServiceTelemetryHgcp:monitoring/getMeshIstioServiceTelemetry:getMeshIstioServiceTelemetryXConfiguration for how to query telemetry on the Service. Structure is documented below.
"

userLabels2" 2∑K
b

monitoringgetNotificationChannel<gcp:monitoring/getNotificationChannel:getNotificationChannelÆ?A NotificationChannel is a medium through which an alert is delivered
when a policy violation is detected. Examples of channels include email, SMS,
and third-party messaging applications. Fields containing sensitive information
like authentication tokens or contact info are only partially populated on retrieval.


To get more information about NotificationChannel, see:

* [API documentation](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.notificationChannels)
* How-to Guides
    * [Notification Options](https://cloud.google.com/monitoring/support/notification-options)
    * [Monitoring API Documentation](https://cloud.google.com/monitoring/api/v3/)


## Example Usage

### Notification Channel Basic


<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const basic = gcp.monitoring.getNotificationChannel({
    displayName: "Test Notification Channel",
});
const alertPolicy = new gcp.monitoring.AlertPolicy("alert_policy", {
    displayName: "My Alert Policy",
    notificationChannels: [basic.then(basic => basic.name)],
    combiner: "OR",
    conditions: [{
        displayName: "test condition",
        conditionThreshold: {
            filter: "metric.type=\"compute.googleapis.com/instance/disk/write_bytes_count\" AND resource.type=\"gce_instance\"",
            duration: "60s",
            comparison: "COMPARISON_GT",
            aggregations: [{
                alignmentPeriod: "60s",
                perSeriesAligner: "ALIGN_RATE",
            }],
        },
    }],
});
```
```python
import pulumi
import pulumi_gcp as gcp

basic = gcp.monitoring.get_notification_channel(display_name="Test Notification Channel")
alert_policy = gcp.monitoring.AlertPolicy("alert_policy",
    display_name="My Alert Policy",
    notification_channels=[basic.name],
    combiner="OR",
    conditions=[{
        "display_name": "test condition",
        "condition_threshold": {
            "filter": "metric.type=\"compute.googleapis.com/instance/disk/write_bytes_count\" AND resource.type=\"gce_instance\"",
            "duration": "60s",
            "comparison": "COMPARISON_GT",
            "aggregations": [{
                "alignment_period": "60s",
                "per_series_aligner": "ALIGN_RATE",
            }],
        },
    }])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var basic = Gcp.Monitoring.GetNotificationChannel.Invoke(new()
    {
        DisplayName = "Test Notification Channel",
    });

    var alertPolicy = new Gcp.Monitoring.AlertPolicy("alert_policy", new()
    {
        DisplayName = "My Alert Policy",
        NotificationChannels = new[]
        {
            basic.Apply(getNotificationChannelResult => getNotificationChannelResult.Name),
        },
        Combiner = "OR",
        Conditions = new[]
        {
            new Gcp.Monitoring.Inputs.AlertPolicyConditionArgs
            {
                DisplayName = "test condition",
                ConditionThreshold = new Gcp.Monitoring.Inputs.AlertPolicyConditionConditionThresholdArgs
                {
                    Filter = "metric.type=\"compute.googleapis.com/instance/disk/write_bytes_count\" AND resource.type=\"gce_instance\"",
                    Duration = "60s",
                    Comparison = "COMPARISON_GT",
                    Aggregations = new[]
                    {
                        new Gcp.Monitoring.Inputs.AlertPolicyConditionConditionThresholdAggregationArgs
                        {
                            AlignmentPeriod = "60s",
                            PerSeriesAligner = "ALIGN_RATE",
                        },
                    },
                },
            },
        },
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		basic, err := monitoring.LookupNotificationChannel(ctx, &monitoring.LookupNotificationChannelArgs{
			DisplayName: pulumi.StringRef("Test Notification Channel"),
		}, nil)
		if err != nil {
			return err
		}
		_, err = monitoring.NewAlertPolicy(ctx, "alert_policy", &monitoring.AlertPolicyArgs{
			DisplayName: pulumi.String("My Alert Policy"),
			NotificationChannels: pulumi.StringArray{
				pulumi.String(basic.Name),
			},
			Combiner: pulumi.String("OR"),
			Conditions: monitoring.AlertPolicyConditionArray{
				&monitoring.AlertPolicyConditionArgs{
					DisplayName: pulumi.String("test condition"),
					ConditionThreshold: &monitoring.AlertPolicyConditionConditionThresholdArgs{
						Filter:     pulumi.String("metric.type=\"compute.googleapis.com/instance/disk/write_bytes_count\" AND resource.type=\"gce_instance\""),
						Duration:   pulumi.String("60s"),
						Comparison: pulumi.String("COMPARISON_GT"),
						Aggregations: monitoring.AlertPolicyConditionConditionThresholdAggregationArray{
							&monitoring.AlertPolicyConditionConditionThresholdAggregationArgs{
								AlignmentPeriod:  pulumi.String("60s"),
								PerSeriesAligner: pulumi.String("ALIGN_RATE"),
							},
						},
					},
				},
			},
		})
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.MonitoringFunctions;
import com.pulumi.gcp.monitoring.inputs.GetNotificationChannelArgs;
import com.pulumi.gcp.monitoring.AlertPolicy;
import com.pulumi.gcp.monitoring.AlertPolicyArgs;
import com.pulumi.gcp.monitoring.inputs.AlertPolicyConditionArgs;
import com.pulumi.gcp.monitoring.inputs.AlertPolicyConditionConditionThresholdArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var basic = MonitoringFunctions.getNotificationChannel(GetNotificationChannelArgs.builder()
            .displayName("Test Notification Channel")
            .build());

        var alertPolicy = new AlertPolicy("alertPolicy", AlertPolicyArgs.builder()
            .displayName("My Alert Policy")
            .notificationChannels(basic.applyValue(getNotificationChannelResult -> getNotificationChannelResult.name()))
            .combiner("OR")
            .conditions(AlertPolicyConditionArgs.builder()
                .displayName("test condition")
                .conditionThreshold(AlertPolicyConditionConditionThresholdArgs.builder()
                    .filter("metric.type=\"compute.googleapis.com/instance/disk/write_bytes_count\" AND resource.type=\"gce_instance\"")
                    .duration("60s")
                    .comparison("COMPARISON_GT")
                    .aggregations(AlertPolicyConditionConditionThresholdAggregationArgs.builder()
                        .alignmentPeriod("60s")
                        .perSeriesAligner("ALIGN_RATE")
                        .build())
                    .build())
                .build())
            .build());

    }
}
```
```yaml
resources:
  alertPolicy:
    type: gcp:monitoring:AlertPolicy
    name: alert_policy
    properties:
      displayName: My Alert Policy
      notificationChannels:
        - ${basic.name}
      combiner: OR
      conditions:
        - displayName: test condition
          conditionThreshold:
            filter: metric.type="compute.googleapis.com/instance/disk/write_bytes_count" AND resource.type="gce_instance"
            duration: 60s
            comparison: COMPARISON_GT
            aggregations:
              - alignmentPeriod: 60s
                perSeriesAligner: ALIGN_RATE
variables:
  basic:
    fn::invoke:
      function: gcp:monitoring:getNotificationChannel
      arguments:
        displayName: Test Notification Channel
```
<!--End PulumiCodeChooser -->
E
displayNameB" 0The display name for this notification channel.
}
labelsB2" kLabels (corresponding to the
NotificationChannelDescriptor schema) to filter the notification channels by.
{
projectB" jThe ID of the project in which the resource belongs.
If it is not provided, the provider project is used.
[
typeB" MThe type of the notification channel.

- - -

Other optional fields include:
C

userLabelsB2" -User-provided key-value labels to filter by.
"X
description" EAn optional human-readable description of this notification channel.
"
displayNameB" "M
enabled
 >Whether notifications are forwarded to the described channel.
"
forceDelete
 "E
id" ;The provider-assigned unique ID for this managed resource.
"Q
labelsB2" ?Configuration fields that define the channel and its behavior.
"Ñ
name" xThe full REST resource name for this channel. The syntax is:
`projects/[PROJECT_ID]/notificationChannels/[CHANNEL_ID]`.
"
projectB" "©
sensitiveLabelsï*í:è
å

monitoring$getNotificationChannelSensitiveLabelXgcp:monitoring/getNotificationChannelSensitiveLabel:getNotificationChannelSensitiveLabel"
typeB" "®

userLabelsB2" ëUser-supplied key/value data that does not need to conform to the corresponding NotificationChannelDescriptor's schema, unlike the labels field.
"S
verificationStatus" 9Indicates whether this channel has been verified or not.
2ù
P

monitoringgetSecretVersion0gcp:monitoring/getSecretVersion:getSecretVersionåGet the value and metadata from a Secret Manager secret version. For more information see the [official documentation](https://cloud.google.com/secret-manager/docs/) and [API](https://cloud.google.com/secret-manager/docs/reference/rest/v1/projects.secrets.versions). If you don't need the metadata (i.e., if you want to use a more limited role to access the secret version only), see also the gcp.secretmanager.getSecretVersionAccess datasource.

## Example Usage

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const basic = gcp.secretmanager.getSecretVersion({
    secret: "my-secret",
});
```
```python
import pulumi
import pulumi_gcp as gcp

basic = gcp.secretmanager.get_secret_version(secret="my-secret")
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var basic = Gcp.SecretManager.GetSecretVersion.Invoke(new()
    {
        Secret = "my-secret",
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/secretmanager"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := secretmanager.LookupSecretVersion(ctx, &secretmanager.LookupSecretVersionArgs{
			Secret: "my-secret",
		}, nil)
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.secretmanager.SecretmanagerFunctions;
import com.pulumi.gcp.secretmanager.inputs.GetSecretVersionArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var basic = SecretmanagerFunctions.getSecretVersion(GetSecretVersionArgs.builder()
            .secret("my-secret")
            .build());

    }
}
```
```yaml
variables:
  basic:
    fn::invoke:
      function: gcp:secretmanager:getSecretVersion
      arguments:
        secret: my-secret
```
<!--End PulumiCodeChooser -->
g
isSecretDataBase64B
 KIf set to 'true', the secret data is
expected to be base64-encoded string.
q
projectB" `The project to get the secret version for. If it
is not provided, the provider project is used.
8
secret" *The secret to get the secret version for.
k
versionB" ZThe version of the secret to get. If it
is not provided, the latest version is retrieved.
"<

createTime" *The time at which the Secret was created.
"c
destroyTime" PThe time at which the Secret was destroyed. Only present if state is DESTROYED.
"J
enabled
 ;True if the current state of the SecretVersion is enabled.
"E
id" ;The provider-assigned unique ID for this managed resource.
"
isSecretDataBase64B
 "~
name" rThe resource name of the SecretVersion. Format:
`projects/{{project}}/secrets/{{secret_id}}/versions/{{version}}`
"
project" "
secret" "9

secretData" 'The secret data. No larger than 64KiB.
"
version" 2á
S

monitoringgetUptimeCheckIPs2gcp:monitoring/getUptimeCheckIPs:getUptimeCheckIPsÙReturns the list of IP addresses that checkers run from. For more information see
the [official documentation](https://cloud.google.com/monitoring/uptime-checks#get-ips).

## Example Usage

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const ips = gcp.monitoring.getUptimeCheckIPs({});
export const ipList = ips.then(ips => ips.uptimeCheckIps);
```
```python
import pulumi
import pulumi_gcp as gcp

ips = gcp.monitoring.get_uptime_check_i_ps()
pulumi.export("ipList", ips.uptime_check_ips)
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var ips = Gcp.Monitoring.GetUptimeCheckIPs.Invoke();

    return new Dictionary<string, object?>
    {
        ["ipList"] = ips.Apply(getUptimeCheckIPsResult => getUptimeCheckIPsResult.UptimeCheckIps),
    };
});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/monitoring"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		ips, err := monitoring.GetUptimeCheckIPs(ctx, map[string]interface{}{}, nil)
		if err != nil {
			return err
		}
		ctx.Export("ipList", ips.UptimeCheckIps)
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.monitoring.MonitoringFunctions;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var ips = MonitoringFunctions.getUptimeCheckIPs();

        ctx.export("ipList", ips.applyValue(getUptimeCheckIPsResult -> getUptimeCheckIPsResult.uptimeCheckIps()));
    }
}
```
```yaml
variables:
  ips:
    fn::invoke:
      function: gcp:monitoring:getUptimeCheckIPs
      arguments: {}
outputs:
  ipList: ${ips.uptimeCheckIps}
```
<!--End PulumiCodeChooser -->
"E
id" ;The provider-assigned unique ID for this managed resource.
"Ò
uptimeCheckIpsÄ*~:|
z

monitoringgetUptimeCheckIPsUptimeCheckIpLgcp:monitoring/getUptimeCheckIPsUptimeCheckIp:getUptimeCheckIPsUptimeCheckIp\A list of uptime check IPs used by Stackdriver Monitoring. Each `uptime_check_ip` contains:
2≥	
r
networksecuritygetAddressGroupIamPolicyEgcp:networksecurity/getAddressGroupIamPolicy:getAddressGroupIamPolicy@Retrieves the current IAM policy data for projectaddressgroup


“
locationB" øThe location of the gateway security policy.
Used to find the parent resource to bind the IAM policy to. If not specified,
the value will be parsed from the identifier of the parent resource. If no location is provided in the parent identifier and no
location is specified, it is taken from the provider configuration.
G
name" ;Used to find the parent resource to bind the IAM policy to
ì
projectB" ÅThe ID of the project in which the resource belongs.
If it is not provided, the project will be parsed from the identifier of the parent resource. If no project is provided in the parent identifier and no project is specified, the provider project is used.
"3
etag" '(Computed) The etag of the IAM policy.
"E
id" ;The provider-assigned unique ID for this managed resource.
"
location" "

name" "ü

policyData" å(Required only by `gcp.networksecurity.AddressGroupIamPolicy`) The policy data generated by
a `gcp.organizations.getIAMPolicy` data source.
"
project" 2ˆ
Z
	notebooksgetInstanceIamPolicy7gcp:notebooks/getInstanceIamPolicy:getInstanceIamPolicyéRetrieves the current IAM policy data for instance


## example

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const policy = gcp.notebooks.getInstanceIamPolicy({
    project: instance.project,
    location: instance.location,
    instanceName: instance.name,
});
```
```python
import pulumi
import pulumi_gcp as gcp

policy = gcp.notebooks.get_instance_iam_policy(project=instance["project"],
    location=instance["location"],
    instance_name=instance["name"])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var policy = Gcp.Notebooks.GetInstanceIamPolicy.Invoke(new()
    {
        Project = instance.Project,
        Location = instance.Location,
        InstanceName = instance.Name,
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.LookupInstanceIamPolicy(ctx, &notebooks.LookupInstanceIamPolicyArgs{
			Project:      pulumi.StringRef(instance.Project),
			Location:     pulumi.StringRef(instance.Location),
			InstanceName: instance.Name,
		}, nil)
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.NotebooksFunctions;
import com.pulumi.gcp.notebooks.inputs.GetInstanceIamPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var policy = NotebooksFunctions.getInstanceIamPolicy(GetInstanceIamPolicyArgs.builder()
            .project(instance.project())
            .location(instance.location())
            .instanceName(instance.name())
            .build());

    }
}
```
```yaml
variables:
  policy:
    fn::invoke:
      function: gcp:notebooks:getInstanceIamPolicy
      arguments:
        project: ${instance.project}
        location: ${instance.location}
        instanceName: ${instance.name}
```
<!--End PulumiCodeChooser -->
O
instanceName" ;Used to find the parent resource to bind the IAM policy to
ÿ
locationB" ≈A reference to the zone where the machine resides. Used to find the parent resource to bind the IAM policy to. If not specified,
the value will be parsed from the identifier of the parent resource. If no location is provided in the parent identifier and no
location is specified, it is taken from the provider configuration.
ì
projectB" ÅThe ID of the project in which the resource belongs.
If it is not provided, the project will be parsed from the identifier of the parent resource. If no project is provided in the parent identifier and no project is specified, the provider project is used.
"3
etag" '(Computed) The etag of the IAM policy.
"E
id" ;The provider-assigned unique ID for this managed resource.
"
instanceName" "
location" "ï

policyData" Ç(Required only by `gcp.notebooks.InstanceIamPolicy`) The policy data generated by
a `gcp.organizations.getIAMPolicy` data source.
"
project" 2Ã
W
	notebooksgetRuntimeIamPolicy5gcp:notebooks/getRuntimeIamPolicy:getRuntimeIamPolicyÍRetrieves the current IAM policy data for runtime


## example

<!--Start PulumiCodeChooser -->
```typescript
import * as pulumi from "@pulumi/pulumi";
import * as gcp from "@pulumi/gcp";

const policy = gcp.notebooks.getRuntimeIamPolicy({
    project: runtime.project,
    location: runtime.location,
    runtimeName: runtime.name,
});
```
```python
import pulumi
import pulumi_gcp as gcp

policy = gcp.notebooks.get_runtime_iam_policy(project=runtime["project"],
    location=runtime["location"],
    runtime_name=runtime["name"])
```
```csharp
using System.Collections.Generic;
using System.Linq;
using Pulumi;
using Gcp = Pulumi.Gcp;

return await Deployment.RunAsync(() => 
{
    var policy = Gcp.Notebooks.GetRuntimeIamPolicy.Invoke(new()
    {
        Project = runtime.Project,
        Location = runtime.Location,
        RuntimeName = runtime.Name,
    });

});
```
```go
package main

import (
	"github.com/pulumi/pulumi-gcp/sdk/v8/go/gcp/notebooks"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func main() {
	pulumi.Run(func(ctx *pulumi.Context) error {
		_, err := notebooks.LookupRuntimeIamPolicy(ctx, &notebooks.LookupRuntimeIamPolicyArgs{
			Project:     pulumi.StringRef(runtime.Project),
			Location:    pulumi.StringRef(runtime.Location),
			RuntimeName: runtime.Name,
		}, nil)
		if err != nil {
			return err
		}
		return nil
	})
}
```
```java
package generated_program;

import com.pulumi.Context;
import com.pulumi.Pulumi;
import com.pulumi.core.Output;
import com.pulumi.gcp.notebooks.NotebooksFunctions;
import com.pulumi.gcp.notebooks.inputs.GetRuntimeIamPolicyArgs;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

public class App {
    public static void main(String[] args) {
        Pulumi.run(App::stack);
    }

    public static void stack(Context ctx) {
        final var policy = NotebooksFunctions.getRuntimeIamPolicy(GetRuntimeIamPolicyArgs.builder()
            .project(runtime.project())
            .location(runtime.location())
            .runtimeName(runtime.name())
            .build());

    }
}
```
```yaml
variables:
  policy:
    fn::invoke:
      function: gcp:notebooks:getRuntimeIamPolicy
      arguments:
        project: ${runtime.project}
        location: ${runtime.location}
        runtimeName: ${runtime.name}
```
<!--End PulumiCodeChooser -->
ÿ
locationB" ≈A reference to the zone where the machine resides. Used to find the parent resource to bind the IAM policy to. If not specified,
the value will be parsed from the identifier of the parent resource. If no location is provided in the parent identifier and no
location is specified, it is taken from the provider configuration.
ì
projectB" ÅThe ID of the project in which the resource belongs.
If it is not provided, the project will be parsed from the identifier of the parent resource. If no project is provided in the parent identifier and no project is specified, the provider project is used.
N
runtimeName" ;Used to find the parent resource to bind the IAM policy to
"3
etag" '(Computed) The etag of the IAM policy.
"E
id" ;The provider-assigned unique ID for this managed resource.
"
location" "î

policyData" Å(Required only by `gcp.notebooks.RuntimeIamPolicy`) The policy data generated by
a `gcp.organizations.getIAMPolicy` data source.
"
project" "
runtimeName" :ñ
Ç
memorystore InstanceDesiredPscAutoConnectionQgcp:memorystore/InstanceDesiredPscAutoConnection:InstanceDesiredPscAutoConnectioné
ãú
network" å(Output)
Output only. The consumer network where the IP address resides, in the form of
projects/{project_id}/global/networks/{network_id}.
j
	projectId" Y(Output)
Output only. The consumer project_id where the forwarding rule is created from.
:ª
m
memorystoreInstanceDiscoveryEndpointCgcp:memorystore/InstanceDiscoveryEndpoint:InstanceDiscoveryEndpoint…
∆^
addressB" M(Output)
Output only. IP address of the exposed endpoint clients connect to.
û
networkB" å(Output)
Output only. The consumer network where the IP address resides, in the form of
projects/{project_id}/global/networks/{network_id}.
C
portB 5(Output)
Output only. Ports of the exposed endpoint.
:•
X
memorystoreInstanceNodeConfig5gcp:memorystore/InstanceNodeConfig:InstanceNodeConfigI
GE
sizeGbB 5(Output)
Output only. Memory size in GB of the node.
:”
m
memorystoreInstancePersistenceConfigCgcp:memorystore/InstancePersistenceConfig:InstancePersistenceConfig·
ﬁÈ
	aofConfigëBé:ã
à
memorystore"InstancePersistenceConfigAofConfigUgcp:memorystore/InstancePersistenceConfigAofConfig:InstancePersistenceConfigAofConfigHConfiguration for AOF based persistence.
Structure is documented below.
É
modeB" uOptional. Current persistence mode.
Possible values:
DISABLED
RDB
AOF
Possible values are: `DISABLED`, `RDB`, `AOF`.
È
	rdbConfigëBé:ã
à
memorystore"InstancePersistenceConfigRdbConfigUgcp:memorystore/InstancePersistenceConfigRdbConfig:InstancePersistenceConfigRdbConfigHConfiguration for RDB based persistence.
Structure is documented below.
:Ë
à
memorystore"InstancePersistenceConfigAofConfigUgcp:memorystore/InstancePersistenceConfigAofConfig:InstancePersistenceConfigAofConfig[
YW
appendFsyncB" BOptional. The fsync mode.
Possible values:
NEVER
EVERY_SEC
ALWAYS
:Ÿ
à
memorystore"InstancePersistenceConfigRdbConfigUgcp:memorystore/InstancePersistenceConfigRdbConfig:InstancePersistenceConfigRdbConfigÀ
»Ü
rdbSnapshotPeriodB" kOptional. Period between RDB snapshots.
Possible values:
ONE_HOUR
SIX_HOURS
TWELVE_HOURS
TWENTY_FOUR_HOURS
º
rdbSnapshotStartTimeB" ùOptional. Time that the first snapshot was/will be attempted, and to which future
snapshots will be aligned. If not provided, the current time will be
used.
:•
m
memorystoreInstancePscAutoConnectionCgcp:memorystore/InstancePscAutoConnection:InstancePscAutoConnection≥

∞
£
connectionTypeB" ä(Output)
Output Only. Type of a PSC Connection.
Possible values:
CONNECTION_TYPE_DISCOVERY
CONNECTION_TYPE_PRIMARY
CONNECTION_TYPE_READER
´
forwardingRuleB" í(Output)
Output only. The URI of the consumer side forwarding rule.
Format:
projects/{project}/regions/{region}/forwardingRules/{forwarding_rule}
o
	ipAddressB" \(Output)
Output only. The IP allocated on the consumer network for the PSC forwarding rule.
û
networkB" å(Output)
Output only. The consumer network where the IP address resides, in the form of
projects/{project_id}/global/networks/{network_id}.
C
portB 5(Output)
Output only. Ports of the exposed endpoint.
l
	projectIdB" Y(Output)
Output only. The consumer project_id where the forwarding rule is created from.
Å
pscConnectionIdB" h(Output)
Output only. The PSC connection id of the forwarding rule connected to the
service attachment.
∑
pscConnectionStatusB" ô(Output)
Output Only. The status of the PSC connection: whether a connection exists and ACTIVE or it no longer exists.
Possible values:
ACTIVE
NOT_FOUND
÷
serviceAttachmentB" ∫(Output)
Output only. The service attachment which is the target of the PSC connection, in the form of projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
:œ
U
memorystoreInstanceStateInfo3gcp:memorystore/InstanceStateInfo:InstanceStateInfoı
ÚÔ
updateInfos{By*w:u
s
memorystoreInstanceStateInfoUpdateInfoGgcp:memorystore/InstanceStateInfoUpdateInfo:InstanceStateInfoUpdateInfoc(Output)
Represents information about instance with state UPDATING.
Structure is documented below.
:∆
s
memorystoreInstanceStateInfoUpdateInfoGgcp:memorystore/InstanceStateInfoUpdateInfo:InstanceStateInfoUpdateInfoŒ
Àm
targetReplicaCountB Q(Output)
Output only. Target number of replica nodes per shard for the instance.
Z
targetShardCountB @(Output)
Output only. Target number of shards for the instance.
:≥
|
memorystoreInstanceZoneDistributionConfigMgcp:memorystore/InstanceZoneDistributionConfig:InstanceZoneDistributionConfig≤
Ø´
modeB" úOptional. Current zone distribution mode. Defaults to MULTI_ZONE.
Possible values:
MULTI_ZONE
SINGLE_ZONE
Possible values are: `MULTI_ZONE`, `SINGLE_ZONE`.

zoneB" qOptional. Defines zone where all resources will be allocated with SINGLE_ZONE mode.
Ignored for MULTI_ZONE mode.
:Ú
ú
migrationcenter&PreferenceSetVirtualMachinePreferencesagcp:migrationcenter/PreferenceSetVirtualMachinePreferences:PreferenceSetVirtualMachinePreferences–
Õ‰
commitmentPlanB" ÀCommitment plan to consider when calculating costs for virtual machine insights and recommendations. If you are unsure which value to set, a 3 year commitment plan is often a good value to start with. Possible values: `COMMITMENT_PLAN_UNSPECIFIED`, `COMMITMENT_PLAN_NONE`, `COMMITMENT_PLAN_ONE_YEAR`, `COMMITMENT_PLAN_THREE_YEARS`
Ì
computeEnginePreferencesÓBÎ:Ë
Â
migrationcenter>PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesëgcp:migrationcenter/PreferenceSetVirtualMachinePreferencesComputeEnginePreferences:PreferenceSetVirtualMachinePreferencesComputeEnginePreferences`The user preferences relating to Compute Engine target platform.
Structure is documented below.
¡
regionPreferencesŸB÷:”
–
migrationcenter7PreferenceSetVirtualMachinePreferencesRegionPreferencesÉgcp:migrationcenter/PreferenceSetVirtualMachinePreferencesRegionPreferences:PreferenceSetVirtualMachinePreferencesRegionPreferencesPThe user preferences relating to target regions.
Structure is documented below.
˘
sizingOptimizationStrategyB" ‘Sizing optimization strategy specifies the preferred strategy used when extrapolating usage data to calculate insights and recommendations for a virtual machine. If you are unsure which value to set, a moderate sizing optimization strategy is often a good value to start with. Possible values: `SIZING_OPTIMIZATION_STRATEGY_UNSPECIFIED`, `SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE`, `SIZING_OPTIMIZATION_STRATEGY_MODERATE`, `SIZING_OPTIMIZATION_STRATEGY_AGGRESSIVE`
◊
soleTenancyPreferencesËBÂ:‚
ﬂ
migrationcenter<PreferenceSetVirtualMachinePreferencesSoleTenancyPreferencesçgcp:migrationcenter/PreferenceSetVirtualMachinePreferencesSoleTenancyPreferences:PreferenceSetVirtualMachinePreferencesSoleTenancyPreferencesRPreferences concerning Sole Tenancy nodes and VMs.
Structure is documented below.
·
targetProductB" …Target product for assets using this preference set. Specify either target product or business goal, but not both. Possible values: `COMPUTE_MIGRATION_TARGET_PRODUCT_UNSPECIFIED`, `COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE`, `COMPUTE_MIGRATION_TARGET_PRODUCT_VMWARE_ENGINE`, `COMPUTE_MIGRATION_TARGET_PRODUCT_SOLE_TENANCY`
ı
vmwareEnginePreferencesÎBË:Â
‚
migrationcenter=PreferenceSetVirtualMachinePreferencesVmwareEnginePreferencesègcp:migrationcenter/PreferenceSetVirtualMachinePreferencesVmwareEnginePreferences:PreferenceSetVirtualMachinePreferencesVmwareEnginePreferenceslThe user preferences relating to Google Cloud VMware Engine target platform.
Structure is documented below.
:¶
Â
migrationcenter>PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesëgcp:migrationcenter/PreferenceSetVirtualMachinePreferencesComputeEnginePreferences:PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesª
∏≠
licenseTypeB" óLicense type to consider when calculating costs for virtual machine insights and recommendations. If unspecified, costs are calculated based on the default licensing plan. Possible values: `LICENSE_TYPE_UNSPECIFIED`, `LICENSE_TYPE_DEFAULT`, `LICENSE_TYPE_BRING_YOUR_OWN_LICENSE`
Ö
machinePreferences§B°:û
õ
migrationcenterPPreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferencesµgcp:migrationcenter/PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferences:PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferences«The type of machines to consider when calculating virtual machine migration insights and recommendations. Not all machine types are available in all zones and regions.
Structure is documented below.
:Ã
õ
migrationcenterPPreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferencesµgcp:migrationcenter/PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferences:PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferences´
®•
allowedMachineSeries„B‡*›:⁄
◊
migrationcenterdPreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferencesAllowedMachineSeries›gcp:migrationcenter/PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferencesAllowedMachineSeries:PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferencesAllowedMachineSeries¶Compute Engine machine series to consider for insights and recommendations. If empty, no restriction is applied on the machine series.
Structure is documented below.
:•
◊
migrationcenterdPreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferencesAllowedMachineSeries›gcp:migrationcenter/PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferencesAllowedMachineSeries:PreferenceSetVirtualMachinePreferencesComputeEnginePreferencesMachinePreferencesAllowedMachineSeries»
≈¬
codeB" ≥Code to identify a Compute Engine machine series. Consult https://cloud.google.com/compute/docs/machine-resource#machine_type_comparison for more details on the available series.
:ª
–
migrationcenter7PreferenceSetVirtualMachinePreferencesRegionPreferencesÉgcp:migrationcenter/PreferenceSetVirtualMachinePreferencesRegionPreferences:PreferenceSetVirtualMachinePreferencesRegionPreferencesÂ
‚ﬂ
preferredRegionsB*" ¬A list of preferred regions, ordered by the most preferred region first. Set only valid Google Cloud region names. See https://cloud.google.com/compute/docs/regions-zones for available regions.
:æ

ﬂ
migrationcenter<PreferenceSetVirtualMachinePreferencesSoleTenancyPreferencesçgcp:migrationcenter/PreferenceSetVirtualMachinePreferencesSoleTenancyPreferences:PreferenceSetVirtualMachinePreferencesSoleTenancyPreferencesŸ
÷»
commitmentPlanB" ØCommitment plan to consider when calculating costs for virtual machine insights and recommendations. If you are unsure which value to set, a 3 year commitment plan is often a good value to start with. Possible values: `COMMITMENT_PLAN_UNSPECIFIED`, `ON_DEMAND`, `COMMITMENT_1_YEAR`, `COMMITMENT_3_YEAR`
g
cpuOvercommitRatioB KCPU overcommit ratio. Acceptable values are between 1.0 and 2.0 inclusive.
Ç
hostMaintenancePolicyB" ‚Sole Tenancy nodes maintenance policy. Possible values: `HOST_MAINTENANCE_POLICY_UNSPECIFIED`, `HOST_MAINTENANCE_POLICY_DEFAULT`, `HOST_MAINTENANCE_POLICY_RESTART_IN_PLACE`, `HOST_MAINTENANCE_POLICY_MIGRATE_WITHIN_NODE_GROUP`
ö
	nodeTypesÉBÄ*˝:˙
˜
migrationcenterDPreferenceSetVirtualMachinePreferencesSoleTenancyPreferencesNodeTypeùgcp:migrationcenter/PreferenceSetVirtualMachinePreferencesSoleTenancyPreferencesNodeType:PreferenceSetVirtualMachinePreferencesSoleTenancyPreferencesNodeTypeÜA list of sole tenant node types. An empty list means that all possible node types will be considered.
Structure is documented below.
:ˆ
˜
migrationcenterDPreferenceSetVirtualMachinePreferencesSoleTenancyPreferencesNodeTypeùgcp:migrationcenter/PreferenceSetVirtualMachinePreferencesSoleTenancyPreferencesNodeType:PreferenceSetVirtualMachinePreferencesSoleTenancyPreferencesNodeTypez
xv
nodeNameB" dName of the Sole Tenant node. Consult https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes
:º
‚
migrationcenter=PreferenceSetVirtualMachinePreferencesVmwareEnginePreferencesègcp:migrationcenter/PreferenceSetVirtualMachinePreferencesVmwareEnginePreferences:PreferenceSetVirtualMachinePreferencesVmwareEnginePreferences‘	
—	µ
commitmentPlanB" úCommitment plan to consider when calculating costs for virtual machine insights and recommendations. If you are unsure which value to set, a 3 year commitment plan is often a good value to start with. Possible values: `COMMITMENT_PLAN_UNSPECIFIED`, `ON_DEMAND`, `COMMITMENT_1_YEAR_MONTHLY_PAYMENTS`, `COMMITMENT_3_YEAR_MONTHLY_PAYMENTS`, `COMMITMENT_1_YEAR_UPFRONT_PAYMENT`, `COMMITMENT_3_YEAR_UPFRONT_PAYMENT`,
q
cpuOvercommitRatioB UCPU overcommit ratio. Acceptable values are between 1.0 and 8.0, with 0.1 increment.
l
memoryOvercommitRatioB MMemory overcommit ratio. Acceptable values are 1.0, 1.25, 1.5, 1.75 and 2.0.
µ
$storageDeduplicationCompressionRatioB ÜThe Deduplication and Compression ratio is based on the logical (Used Before) space required to store data before applying deduplication and compression, in relation to the physical (Used After) space required after applying deduplication and compression. Specifically, the ratio is the Used Before space divided by the Used After space. For example, if the Used Before space is 3 GB, but the physical Used After space is 1 GB, the deduplication and compression ratio is 3x. Acceptable values are between 1.0 and 4.0.
:ß
[
mlEngineModelDefaultVersion:gcp:ml/EngineModelDefaultVersion:EngineModelDefaultVersionH
FD
name" 8The name specified for the version when it was created.
:ˇ
h

monitoringAlertPolicyAlertStrategy@gcp:monitoring/AlertPolicyAlertStrategy:AlertPolicyAlertStrategyí
èp
	autoCloseB" ]If an alert policy that was active has no data for this long, any open incidents will close.
ã
notificationChannelStrategies≈B¬*ø:º
π

monitoring3AlertPolicyAlertStrategyNotificationChannelStrategyvgcp:monitoring/AlertPolicyAlertStrategyNotificationChannelStrategy:AlertPolicyAlertStrategyNotificationChannelStrategy°Control over how the notification channels in `notification_channels`
are notified when this alert fires, on a per-channel basis.
Structure is documented below.
ù
notificationPromptsB*" ~Control when notifications will be sent out.
Each value may be one of: `NOTIFICATION_PROMPT_UNSPECIFIED`, `OPENED`, `CLOSED`.
Ï
notificationRateLimit∞B≠:™
ß

monitoring-AlertPolicyAlertStrategyNotificationRateLimitjgcp:monitoring/AlertPolicyAlertStrategyNotificationRateLimit:AlertPolicyAlertStrategyNotificationRateLimitüRequired for alert policies with a LogMatch condition.
This limit is not implemented for alert policies that are not log-based.
Structure is documented below.
:Ú
π

monitoring3AlertPolicyAlertStrategyNotificationChannelStrategyvgcp:monitoring/AlertPolicyAlertStrategyNotificationChannelStrategy:AlertPolicyAlertStrategyNotificationChannelStrategy≥
∞«
notificationChannelNamesB*" ¢The notification channels that these settings apply to. Each of these
correspond to the name field in one of the NotificationChannel objects
referenced in the notification_channels field of this AlertPolicy. The format is
`projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]`
d
renotifyIntervalB" JThe frequency at which to send reminder notifications for open incidents.
:Ã
ß

monitoring-AlertPolicyAlertStrategyNotificationRateLimitjgcp:monitoring/AlertPolicyAlertStrategyNotificationRateLimit:AlertPolicyAlertStrategyNotificationRateLimitü
úô
periodB" àNot more than one notification per period.
A duration in seconds with up to nine fractional digits, terminated by 's'. Example "60.5s".
:õ
\

monitoringAlertPolicyCondition8gcp:monitoring/AlertPolicyCondition:AlertPolicyCondition∫
∑ò
conditionAbsentíBè:å
â

monitoring#AlertPolicyConditionConditionAbsentVgcp:monitoring/AlertPolicyConditionConditionAbsent:AlertPolicyConditionConditionAbsentpA condition that checks that a time series
continues to receive new data points.
Structure is documented below.
…
conditionMatchedLogûBõ:ò
ï

monitoring'AlertPolicyConditionConditionMatchedLog^gcp:monitoring/AlertPolicyConditionConditionMatchedLog:AlertPolicyConditionConditionMatchedLogêA condition that checks for log messages matching given constraints.
If set, no other conditions can be present.
Structure is documented below.
À
 conditionMonitoringQueryLanguage≈B¬:ø
º

monitoring4AlertPolicyConditionConditionMonitoringQueryLanguagexgcp:monitoring/AlertPolicyConditionConditionMonitoringQueryLanguage:AlertPolicyConditionConditionMonitoringQueryLanguage_A Monitoring Query Language query that outputs a boolean stream
Structure is documented below.
Ò
 conditionPrometheusQueryLanguage≈B¬:ø
º

monitoring4AlertPolicyConditionConditionPrometheusQueryLanguagexgcp:monitoring/AlertPolicyConditionConditionPrometheusQueryLanguage:AlertPolicyConditionConditionPrometheusQueryLanguageÑA condition type that allows alert policies to be defined using
Prometheus Query Language (PromQL).
The PrometheusQueryLanguageCondition message contains information
from a Prometheus alerting rule and its associated rule group.
Structure is documented below.
ê
conditionThresholdõBò:ï
í

monitoring&AlertPolicyConditionConditionThreshold\gcp:monitoring/AlertPolicyConditionConditionThreshold:AlertPolicyConditionConditionThreshold\A condition that compares a time series against a
threshold.
Structure is documented below.
◊
displayName" √A short name or phrase used to identify the
condition in dashboards, notifications, and
incidents. To avoid confusion, don't use the same
display name for multiple conditions in the same
policy.
û
nameB" è(Output)
The unique resource name for this condition.
Its syntax is:
projects/[PROJECT_ID]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]
[CONDITION_ID] is assigned by Stackdriver Monitoring when
the condition is created as part of a new or updated alerting
policy.
:‰
â

monitoring#AlertPolicyConditionConditionAbsentVgcp:monitoring/AlertPolicyConditionConditionAbsent:AlertPolicyConditionConditionAbsent’
“À
aggregations∂B≥*∞:≠
™

monitoring.AlertPolicyConditionConditionAbsentAggregationlgcp:monitoring/AlertPolicyConditionConditionAbsentAggregation:AlertPolicyConditionConditionAbsentAggregationÅSpecifies the alignment of data points in
individual time series as well as how to
combine the retrieved time series together
(such as when aggregating multiple streams
on each resource to a single stream for each
resource or when aggregating streams across
all members of a group of resources).
Multiple aggregations are applied in the
order specified.
Structure is documented below.
œ
duration" æThe amount of time that a time series must
fail to report new data to be considered
failing. Currently, only values that are a
multiple of a minute--e.g. 60s, 120s, or 300s
--are supported.
–
filterB" øA filter that identifies which time series
should be compared with the threshold.The
filter is similar to the one that is
specified in the
MetricService.ListTimeSeries request (that
call is useful to verify the time series
that will be retrieved / processed) and must
specify the metric type and optionally may
contain restrictions on resource type,
resource labels, and metric labels. This
field may not exceed 2048 Unicode characters
in length.
‹
triggerßB§:°
û

monitoring*AlertPolicyConditionConditionAbsentTriggerdgcp:monitoring/AlertPolicyConditionConditionAbsentTrigger:AlertPolicyConditionConditionAbsentTrigger¶The number/percent of time series for which
the comparison must hold in order for the
condition to trigger. If unspecified, then
the condition will trigger if the comparison
is true for any of the time series that have
been identified by filter and aggregations.
Structure is documented below.
:ì
™

monitoring.AlertPolicyConditionConditionAbsentAggregationlgcp:monitoring/AlertPolicyConditionConditionAbsentAggregation:AlertPolicyConditionConditionAbsentAggregation„
‡…
alignmentPeriodB" ØThe alignment period for per-time
series alignment. If present,
alignmentPeriod must be at least
60 seconds. After per-time series
alignment, each time series will
contain data points only on the
period boundaries. If
perSeriesAligner is not specified
or equals ALIGN_NONE, then this
field is ignored. If
perSeriesAligner is specified and
does not equal ALIGN_NONE, then
this field must be defined;
otherwise an error is returned.
æ
crossSeriesReducerB" °The approach to be used to combine
time series. Not all reducer
functions may be applied to all
time series, depending on the
metric type and the value type of
the original time series.
Reduction may change the metric
type of value type of the time
series.Time series data must be
aligned in order to perform cross-
time series reduction. If
crossSeriesReducer is specified,
then perSeriesAligner must be
specified and not equal ALIGN_NONE
and alignmentPeriod must be
specified; otherwise, an error is
returned.
Possible values are: `REDUCE_NONE`, `REDUCE_MEAN`, `REDUCE_MIN`, `REDUCE_MAX`, `REDUCE_SUM`, `REDUCE_STDDEV`, `REDUCE_COUNT`, `REDUCE_COUNT_TRUE`, `REDUCE_COUNT_FALSE`, `REDUCE_FRACTION_TRUE`, `REDUCE_PERCENTILE_99`, `REDUCE_PERCENTILE_95`, `REDUCE_PERCENTILE_50`, `REDUCE_PERCENTILE_05`.
∂
groupByFieldsB*" úThe set of fields to preserve when
crossSeriesReducer is specified.
The groupByFields determine how
the time series are partitioned
into subsets prior to applying the
aggregation function. Each subset
contains time series that have the
same value for each of the
grouping fields. Each individual
time series is a member of exactly
one subset. The crossSeriesReducer
is applied to each subset of time
series. It is not possible to
reduce across different resource
types, so this field implicitly
contains resource.type. Fields not
specified in groupByFields are
aggregated away. If groupByFields
is not specified and all the time
series have the same resource
type, then the time series are
aggregated into a single output
time series. If crossSeriesReducer
is not defined, this field is
ignored.
ó
perSeriesAlignerB" ¸The approach to be used to align
individual time series. Not all
alignment functions may be applied
to all time series, depending on
the metric type and value type of
the original time series.
Alignment may change the metric
type or the value type of the time
series.Time series data must be
aligned in order to perform cross-
time series reduction. If
crossSeriesReducer is specified,
then perSeriesAligner must be
specified and not equal ALIGN_NONE
and alignmentPeriod must be
specified; otherwise, an error is
returned.
Possible values are: `ALIGN_NONE`, `ALIGN_DELTA`, `ALIGN_RATE`, `ALIGN_INTERPOLATE`, `ALIGN_NEXT_OLDER`, `ALIGN_MIN`, `ALIGN_MAX`, `ALIGN_MEAN`, `ALIGN_COUNT`, `ALIGN_SUM`, `ALIGN_STDDEV`, `ALIGN_COUNT_TRUE`, `ALIGN_COUNT_FALSE`, `ALIGN_FRACTION_TRUE`, `ALIGN_PERCENTILE_99`, `ALIGN_PERCENTILE_95`, `ALIGN_PERCENTILE_50`, `ALIGN_PERCENTILE_05`, `ALIGN_PERCENT_CHANGE`.
:å
û

monitoring*AlertPolicyConditionConditionAbsentTriggerdgcp:monitoring/AlertPolicyConditionConditionAbsentTrigger:AlertPolicyConditionConditionAbsentTriggerË
Âr
countB cThe absolute number of time series
that must fail the predicate for the
condition to be triggered.
o
percentB ^The percentage of time series that
must fail the predicate for the
condition to be triggered.
:ä
ï

monitoring'AlertPolicyConditionConditionMatchedLog^gcp:monitoring/AlertPolicyConditionConditionMatchedLog:AlertPolicyConditionConditionMatchedLogÔ
Ï#
filter" A logs-based filter.
ƒ
labelExtractorsB2" ®A map from a label key to an extractor expression, which is used to
extract the value for this label key. Each entry in this map is
a specification for how data should be extracted from log entries that
match filter. Each combination of extracted values is treated as
a separate rule for the purposes of triggering notifications.
Label keys and corresponding values can be used in notifications
generated by this condition.
:¯
º

monitoring4AlertPolicyConditionConditionMonitoringQueryLanguagexgcp:monitoring/AlertPolicyConditionConditionMonitoringQueryLanguage:AlertPolicyConditionConditionMonitoringQueryLanguage∂
≥Ò
duration" ‡The amount of time that a time series must
violate the threshold to be considered
failing. Currently, only values that are a
multiple of a minute--e.g., 0, 60, 120, or
300 seconds--are supported. If an invalid
value is given, an error will be returned.
When choosing a duration, it is useful to
keep in mind the frequency of the underlying
time series data (which may also be affected
by any alignments specified in the
aggregations field); a good duration is long
enough so that a single outlier does not
generate spurious alerts, but short enough
that unhealthy states are detected and
alerted on quickly.
à
evaluationMissingDataB" ËA condition control that determines how
metric-threshold conditions are evaluated when
data stops arriving.
Possible values are: `EVALUATION_MISSING_DATA_INACTIVE`, `EVALUATION_MISSING_DATA_ACTIVE`, `EVALUATION_MISSING_DATA_NO_OP`.
L
query" ?Monitoring Query Language query that outputs a boolean stream.
„
trigger€Bÿ:’
“

monitoring;AlertPolicyConditionConditionMonitoringQueryLanguageTriggerÜgcp:monitoring/AlertPolicyConditionConditionMonitoringQueryLanguageTrigger:AlertPolicyConditionConditionMonitoringQueryLanguageTrigger˘The number/percent of time series for which
the comparison must hold in order for the
condition to trigger. If unspecified, then
the condition will trigger if the comparison
is true for any of the time series that have
been identified by filter and aggregations,
or by the ratio, if denominator_filter and
denominator_aggregations are specified.
Structure is documented below.
:¿
“

monitoring;AlertPolicyConditionConditionMonitoringQueryLanguageTriggerÜgcp:monitoring/AlertPolicyConditionConditionMonitoringQueryLanguageTrigger:AlertPolicyConditionConditionMonitoringQueryLanguageTriggerË
Âr
countB cThe absolute number of time series
that must fail the predicate for the
condition to be triggered.
o
percentB ^The percentage of time series that
must fail the predicate for the
condition to be triggered.
:ö
º

monitoring4AlertPolicyConditionConditionPrometheusQueryLanguagexgcp:monitoring/AlertPolicyConditionConditionPrometheusQueryLanguage:AlertPolicyConditionConditionPrometheusQueryLanguageÿ
’
	alertRuleB" ‹The alerting rule name of this alert in the corresponding Prometheus
configuration file.
Some external tools may require this field to be populated correctly
in order to refer to the original Prometheus configuration file.
The rule group name and the alert name are necessary to update the
relevant AlertPolicies in case the definition of the rule group changes
in the future.
This field is optional. If this field is not empty, then it must be a
valid Prometheus label name.

disableMetricValidationB
 é
durationB" ˚Alerts are considered firing once their PromQL expression evaluated
to be "true" for this long. Alerts whose PromQL expression was not
evaluated to be "true" for long enough are considered pending. The
default value is zero. Must be zero or positive.
¥
evaluationIntervalB" óHow often this rule should be evaluated. Must be a positive multiple
of 30 seconds or missing. The default value is 30 seconds. If this
PrometheusQueryLanguageCondition was generated from a Prometheus
alerting rule, then this value should be taken from the enclosing
rule group.
˙
labelsB2" ÁLabels to add to or overwrite in the PromQL query result. Label names
must be valid.
Label values can be templatized by using variables. The only available
variable names are the names of the labels in the PromQL result, including
"__name__" and "value". "labels" may be empty. This field is intended to be
used for organizing and identifying the AlertPolicy
‘
query" ∆The PromQL expression to evaluate. Every evaluation cycle this
expression is evaluated at the current time, and all resultant time
series become pending/firing alerts. This field must not be empty.
¢
	ruleGroupB" éThe rule group name of this alert in the corresponding Prometheus
configuration file.
Some external tools may require this field to be populated correctly
in order to refer to the original Prometheus configuration file.
The rule group name and the alert name are necessary to update the
relevant AlertPolicies in case the definition of the rule group changes
in the future. This field is optional.
:â+
í

monitoring&AlertPolicyConditionConditionThreshold\gcp:monitoring/AlertPolicyConditionConditionThreshold:AlertPolicyConditionConditionThresholdÒ)
Ó)Ì
aggregationsøBº*π:∂
≥

monitoring1AlertPolicyConditionConditionThresholdAggregationrgcp:monitoring/AlertPolicyConditionConditionThresholdAggregation:AlertPolicyConditionConditionThresholdAggregationöSpecifies the alignment of data points in
individual time series as well as how to
combine the retrieved time series together
(such as when aggregating multiple streams
on each resource to a single stream for each
resource or when aggregating streams across
all members of a group of resources).
Multiple aggregations are applied in the
order specified.This field is similar to the
one in the MetricService.ListTimeSeries
request. It is advisable to use the
ListTimeSeries method when debugging this
field.
Structure is documented below.
ÿ

comparison" ≈The comparison to apply between the time
series (indicated by filter and aggregation)
and the threshold (indicated by
threshold_value). The comparison is applied
on each time series, with the time series on
the left-hand side and the threshold on the
right-hand side. Only COMPARISON_LT and
COMPARISON_GT are supported currently.
Possible values are: `COMPARISON_GT`, `COMPARISON_GE`, `COMPARISON_LT`, `COMPARISON_LE`, `COMPARISON_EQ`, `COMPARISON_NE`.
Ø
denominatorAggregations·Bﬁ*€:ÿ
’

monitoring<AlertPolicyConditionConditionThresholdDenominatorAggregationàgcp:monitoring/AlertPolicyConditionConditionThresholdDenominatorAggregation:AlertPolicyConditionConditionThresholdDenominatorAggregationØSpecifies the alignment of data points in
individual time series selected by
denominatorFilter as well as how to combine
the retrieved time series together (such as
when aggregating multiple streams on each
resource to a single stream for each
resource or when aggregating streams across
all members of a group of resources).When
computing ratios, the aggregations and
denominator_aggregations fields must use the
same alignment period and produce time
series that have the same periodicity and
labels.This field is similar to the one in
the MetricService.ListTimeSeries request. It
is advisable to use the ListTimeSeries
method when debugging this field.
Structure is documented below.
ˇ
denominatorFilterB" „A filter that identifies a time series that
should be used as the denominator of a ratio
that will be compared with the threshold. If
a denominator_filter is specified, the time
series specified by the filter field will be
used as the numerator.The filter is similar
to the one that is specified in the
MetricService.ListTimeSeries request (that
call is useful to verify the time series
that will be retrieved / processed) and must
specify the metric type and optionally may
contain restrictions on resource type,
resource labels, and metric labels. This
field may not exceed 2048 Unicode characters
in length.
Ò
duration" ‡The amount of time that a time series must
violate the threshold to be considered
failing. Currently, only values that are a
multiple of a minute--e.g., 0, 60, 120, or
300 seconds--are supported. If an invalid
value is given, an error will be returned.
When choosing a duration, it is useful to
keep in mind the frequency of the underlying
time series data (which may also be affected
by any alignments specified in the
aggregations field); a good duration is long
enough so that a single outlier does not
generate spurious alerts, but short enough
that unhealthy states are detected and
alerted on quickly.
à
evaluationMissingDataB" ËA condition control that determines how
metric-threshold conditions are evaluated when
data stops arriving.
Possible values are: `EVALUATION_MISSING_DATA_INACTIVE`, `EVALUATION_MISSING_DATA_ACTIVE`, `EVALUATION_MISSING_DATA_NO_OP`.
–
filterB" øA filter that identifies which time series
should be compared with the threshold.The
filter is similar to the one that is
specified in the
MetricService.ListTimeSeries request (that
call is useful to verify the time series
that will be retrieved / processed) and must
specify the metric type and optionally may
contain restrictions on resource type,
resource labels, and metric labels. This
field may not exceed 2048 Unicode characters
in length.
ì
forecastOptions»B≈:¬
ø

monitoring5AlertPolicyConditionConditionThresholdForecastOptionszgcp:monitoring/AlertPolicyConditionConditionThresholdForecastOptions:AlertPolicyConditionConditionThresholdForecastOptions¥When this field is present, the `MetricThreshold`
condition forecasts whether the time series is
predicted to violate the threshold within the
`forecastHorizon`. When this field is not set, the
`MetricThreshold` tests the current value of the
timeseries against the threshold.
Structure is documented below.
J
thresholdValueB 2A value against which to compare the time
series.
∏
trigger∞B≠:™
ß

monitoring-AlertPolicyConditionConditionThresholdTriggerjgcp:monitoring/AlertPolicyConditionConditionThresholdTrigger:AlertPolicyConditionConditionThresholdTrigger˘The number/percent of time series for which
the comparison must hold in order for the
condition to trigger. If unspecified, then
the condition will trigger if the comparison
is true for any of the time series that have
been identified by filter and aggregations,
or by the ratio, if denominator_filter and
denominator_aggregations are specified.
Structure is documented below.
:ú
≥

monitoring1AlertPolicyConditionConditionThresholdAggregationrgcp:monitoring/AlertPolicyConditionConditionThresholdAggregation:AlertPolicyConditionConditionThresholdAggregation„
‡…
alignmentPeriodB" ØThe alignment period for per-time
series alignment. If present,
alignmentPeriod must be at least
60 seconds. After per-time series
alignment, each time series will
contain data points only on the
period boundaries. If
perSeriesAligner is not specified
or equals ALIGN_NONE, then this
field is ignored. If
perSeriesAligner is specified and
does not equal ALIGN_NONE, then
this field must be defined;
otherwise an error is returned.
æ
crossSeriesReducerB" °The approach to be used to combine
time series. Not all reducer
functions may be applied to all
time series, depending on the
metric type and the value type of
the original time series.
Reduction may change the metric
type of value type of the time
series.Time series data must be
aligned in order to perform cross-
time series reduction. If
crossSeriesReducer is specified,
then perSeriesAligner must be
specified and not equal ALIGN_NONE
and alignmentPeriod must be
specified; otherwise, an error is
returned.
Possible values are: `REDUCE_NONE`, `REDUCE_MEAN`, `REDUCE_MIN`, `REDUCE_MAX`, `REDUCE_SUM`, `REDUCE_STDDEV`, `REDUCE_COUNT`, `REDUCE_COUNT_TRUE`, `REDUCE_COUNT_FALSE`, `REDUCE_FRACTION_TRUE`, `REDUCE_PERCENTILE_99`, `REDUCE_PERCENTILE_95`, `REDUCE_PERCENTILE_50`, `REDUCE_PERCENTILE_05`.
∂
groupByFieldsB*" úThe set of fields to preserve when
crossSeriesReducer is specified.
The groupByFields determine how
the time series are partitioned
into subsets prior to applying the
aggregation function. Each subset
contains time series that have the
same value for each of the
grouping fields. Each individual
time series is a member of exactly
one subset. The crossSeriesReducer
is applied to each subset of time
series. It is not possible to
reduce across different resource
types, so this field implicitly
contains resource.type. Fields not
specified in groupByFields are
aggregated away. If groupByFields
is not specified and all the time
series have the same resource
type, then the time series are
aggregated into a single output
time series. If crossSeriesReducer
is not defined, this field is
ignored.
ó
perSeriesAlignerB" ¸The approach to be used to align
individual time series. Not all
alignment functions may be applied
to all time series, depending on
the metric type and value type of
the original time series.
Alignment may change the metric
type or the value type of the time
series.Time series data must be
aligned in order to perform cross-
time series reduction. If
crossSeriesReducer is specified,
then perSeriesAligner must be
specified and not equal ALIGN_NONE
and alignmentPeriod must be
specified; otherwise, an error is
returned.
Possible values are: `ALIGN_NONE`, `ALIGN_DELTA`, `ALIGN_RATE`, `ALIGN_INTERPOLATE`, `ALIGN_NEXT_OLDER`, `ALIGN_MIN`, `ALIGN_MAX`, `ALIGN_MEAN`, `ALIGN_COUNT`, `ALIGN_SUM`, `ALIGN_STDDEV`, `ALIGN_COUNT_TRUE`, `ALIGN_COUNT_FALSE`, `ALIGN_FRACTION_TRUE`, `ALIGN_PERCENTILE_99`, `ALIGN_PERCENTILE_95`, `ALIGN_PERCENTILE_50`, `ALIGN_PERCENTILE_05`, `ALIGN_PERCENT_CHANGE`.
:æ
’

monitoring<AlertPolicyConditionConditionThresholdDenominatorAggregationàgcp:monitoring/AlertPolicyConditionConditionThresholdDenominatorAggregation:AlertPolicyConditionConditionThresholdDenominatorAggregation„
‡…
alignmentPeriodB" ØThe alignment period for per-time
series alignment. If present,
alignmentPeriod must be at least
60 seconds. After per-time series
alignment, each time series will
contain data points only on the
period boundaries. If
perSeriesAligner is not specified
or equals ALIGN_NONE, then this
field is ignored. If
perSeriesAligner is specified and
does not equal ALIGN_NONE, then
this field must be defined;
otherwise an error is returned.
æ
crossSeriesReducerB" °The approach to be used to combine
time series. Not all reducer
functions may be applied to all
time series, depending on the
metric type and the value type of
the original time series.
Reduction may change the metric
type of value type of the time
series.Time series data must be
aligned in order to perform cross-
time series reduction. If
crossSeriesReducer is specified,
then perSeriesAligner must be
specified and not equal ALIGN_NONE
and alignmentPeriod must be
specified; otherwise, an error is
returned.
Possible values are: `REDUCE_NONE`, `REDUCE_MEAN`, `REDUCE_MIN`, `REDUCE_MAX`, `REDUCE_SUM`, `REDUCE_STDDEV`, `REDUCE_COUNT`, `REDUCE_COUNT_TRUE`, `REDUCE_COUNT_FALSE`, `REDUCE_FRACTION_TRUE`, `REDUCE_PERCENTILE_99`, `REDUCE_PERCENTILE_95`, `REDUCE_PERCENTILE_50`, `REDUCE_PERCENTILE_05`.
∂
groupByFieldsB*" úThe set of fields to preserve when
crossSeriesReducer is specified.
The groupByFields determine how
the time series are partitioned
into subsets prior to applying the
aggregation function. Each subset
contains time series that have the
same value for each of the
grouping fields. Each individual
time series is a member of exactly
one subset. The crossSeriesReducer
is applied to each subset of time
series. It is not possible to
reduce across different resource
types, so this field implicitly
contains resource.type. Fields not
specified in groupByFields are
aggregated away. If groupByFields
is not specified and all the time
series have the same resource
type, then the time series are
aggregated into a single output
time series. If crossSeriesReducer
is not defined, this field is
ignored.
ó
perSeriesAlignerB" ¸The approach to be used to align
individual time series. Not all
alignment functions may be applied
to all time series, depending on
the metric type and value type of
the original time series.
Alignment may change the metric
type or the value type of the time
series.Time series data must be
aligned in order to perform cross-
time series reduction. If
crossSeriesReducer is specified,
then perSeriesAligner must be
specified and not equal ALIGN_NONE
and alignmentPeriod must be
specified; otherwise, an error is
returned.
Possible values are: `ALIGN_NONE`, `ALIGN_DELTA`, `ALIGN_RATE`, `ALIGN_INTERPOLATE`, `ALIGN_NEXT_OLDER`, `ALIGN_MIN`, `ALIGN_MAX`, `ALIGN_MEAN`, `ALIGN_COUNT`, `ALIGN_SUM`, `ALIGN_STDDEV`, `ALIGN_COUNT_TRUE`, `ALIGN_COUNT_FALSE`, `ALIGN_FRACTION_TRUE`, `ALIGN_PERCENTILE_99`, `ALIGN_PERCENTILE_95`, `ALIGN_PERCENTILE_50`, `ALIGN_PERCENTILE_05`, `ALIGN_PERCENT_CHANGE`.
:Å
ø

monitoring5AlertPolicyConditionConditionThresholdForecastOptionszgcp:monitoring/AlertPolicyConditionConditionThresholdForecastOptions:AlertPolicyConditionConditionThresholdForecastOptionsº
π∂
forecastHorizon" ûThe length of time into the future to forecast
whether a timeseries will violate the threshold.
If the predicted value is found to violate the
threshold, and the violation is observed in all
forecasts made for the Configured `duration`,
then the timeseries is considered to be failing.
:ï
ß

monitoring-AlertPolicyConditionConditionThresholdTriggerjgcp:monitoring/AlertPolicyConditionConditionThresholdTrigger:AlertPolicyConditionConditionThresholdTriggerË
Âr
countB cThe absolute number of time series
that must fail the predicate for the
condition to be triggered.
o
percentB ^The percentage of time series that
must fail the predicate for the
condition to be triggered.
:˚
k

monitoringAlertPolicyCreationRecordBgcp:monitoring/AlertPolicyCreationRecord:AlertPolicyCreationRecordã
à7

mutateTimeB" #(Output)
When the change occurred.
M
	mutatedByB" :(Output)
The email address of the user making the change.
:˛
h

monitoringAlertPolicyDocumentation@gcp:monitoring/AlertPolicyDocumentation:AlertPolicyDocumentationë
éÊ
contentB" ‘The text of the documentation, interpreted according to mimeType.
The content may not exceed 8,192 Unicode characters and may not
exceed more than 10,240 bytes when encoded in UTF-8 format,
whichever is smaller.
ñ
links|Bz*x:v
t

monitoringAlertPolicyDocumentationLinkHgcp:monitoring/AlertPolicyDocumentationLink:AlertPolicyDocumentationLinkéLinks to content such as playbooks, repositories, and other resources. This field can contain up to 3 entries.
Structure is documented below.
k
mimeTypeB" YThe format of the content field. Presently, only the value
"text/markdown" is supported.
ú
subjectB" äThe subject line of the notification. The subject line may not
exceed 10,240 bytes. In notifications generated by this policy the contents
of the subject line after variable expansion will be truncated to 255 bytes
or shorter at the latest UTF-8 character boundary.
:¢
t

monitoringAlertPolicyDocumentationLinkHgcp:monitoring/AlertPolicyDocumentationLink:AlertPolicyDocumentationLink©
¶â
displayNameB" tA short display name for the link. The display name must not be empty or exceed 63 characters. Example: "playbook".
ó
urlB" âThe url of a webpage. A url can be templatized by using variables in the path or the query parameters. The total length of a URL should not exceed 2083 characters before and after variable expansion. Example: "https://my_domain.com/playbook?name=${resource.name}".
:å
b

monitoringCustomServiceTelemetry<gcp:monitoring/CustomServiceTelemetry:CustomServiceTelemetry•
¢ü
resourceNameB" àThe full name of the resource that defines this service.
Formatted as described in
https://cloud.google.com/apis/design/resource_names.
:Ó
n

monitoringGenericServiceBasicServiceDgcp:monitoring/GenericServiceBasicService:GenericServiceBasicService˚
¯å
serviceLabelsB2" sLabels that specify the resource that emits the monitoring data
which is used for SLO reporting of this `Service`.
g
serviceTypeB" RThe type of service that this basic service defines, e.g.
APP_ENGINE service type
:è
e

monitoringGenericServiceTelemetry>gcp:monitoring/GenericServiceTelemetry:GenericServiceTelemetry•
¢ü
resourceNameB" àThe full name of the resource that defines this service.
Formatted as described in
https://cloud.google.com/apis/design/resource_names.
:⁄
_

monitoringMetricDescriptorLabel:gcp:monitoring/MetricDescriptorLabel:MetricDescriptorLabelˆ
ÛA
descriptionB" ,A human-readable description for the label.
ò
key" åThe key for this label. The key must not exceed 100 characters. The first character of the key must be an upper- or lower-case letter, the remaining characters must be letters, digits or underscores, and the key must match the regular expression [a-zA-Z][a-zA-Z0-9_]*
í
	valueTypeB" The type of data that can be assigned to the label.
Default value is `STRING`.
Possible values are: `STRING`, `BOOL`, `INT64`.
:∫
h

monitoringMetricDescriptorMetadata@gcp:monitoring/MetricDescriptorMetadata:MetricDescriptorMetadataÕ
 ˚
ingestDelayB" ÂThe delay of data points caused by ingestion. Data points older than this age are guaranteed to be ingested and available to be read, excluding data loss due to errors. In `[duration format](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf?&_ga=2.264881487.1507873253.1593446723-935052455.1591817775#google.protobuf.Duration)`.
…
samplePeriodB" ≤The sampling period of metric data points. For metrics which are written periodically, consecutive data points are stored at this time interval, excluding data loss due to errors. Metrics with a higher granularity have a smaller sampling period. In `[duration format](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf?&_ga=2.264881487.1507873253.1593446723-935052455.1591817775#google.protobuf.Duration)`.
:Ú
Ü

monitoring"NotificationChannelSensitiveLabelsTgcp:monitoring/NotificationChannelSensitiveLabels:NotificationChannelSensitiveLabelsÊ
„»
	authTokenB" ¥An authorization token for a notification channel. Channel types that support this field include: slack
**Note**: This property is sensitive and will not be displayed in the plan.
»
passwordB" µAn password for a notification channel. Channel types that support this field include: webhook_basicauth
**Note**: This property is sensitive and will not be displayed in the plan.
 

serviceKeyB" µAn servicekey token for a notification channel. Channel types that support this field include: pagerduty
**Note**: This property is sensitive and will not be displayed in the plan.
:˘
A

monitoringSloBasicSli&gcp:monitoring/SloBasicSli:SloBasicSli≥
∞É
availabilitykBi:g
e

monitoringSloBasicSliAvailability>gcp:monitoring/SloBasicSliAvailability:SloBasicSliAvailabilityÖAvailability based SLI, dervied from count of requests made to this service that return successfully.
Structure is documented below.
∞
latency\BZ:X
V

monitoringSloBasicSliLatency4gcp:monitoring/SloBasicSliLatency:SloBasicSliLatencyGParameters for a latency threshold SLI.
Structure is documented below.
Ê
	locationsB*" –An optional set of locations to which this SLI is relevant.
Telemetry from other locations will not be used to calculate
performance for this SLI. If omitted, this SLI applies to all
locations in which the Service has activity. For service types
that don't support breaking down by location, setting this
field will result in an error.
≈
methodsB*" ±An optional set of RPCs to which this SLI is relevant.
Telemetry from other methods will not be used to calculate
performance for this SLI. If omitted, this SLI applies to all
the Service's methods. For service types that don't support
breaking down by method, setting this field will result in an
error.
√
versionsB*" ÆThe set of API versions to which this SLI is relevant.
Telemetry from other API versions will not be used to
calculate performance for this SLI. If omitted,
this SLI applies to all API versions. For service types
that don't support breaking down by version, setting this
field will result in an error.
:◊
e

monitoringSloBasicSliAvailability>gcp:monitoring/SloBasicSliAvailability:SloBasicSliAvailabilityn
lj
enabledB
 YWhether an availability SLI is enabled or not. Must be set to `true. Defaults to `true`.
:Ä
V

monitoringSloBasicSliLatency4gcp:monitoring/SloBasicSliLatency:SloBasicSliLatency•
¢ü
	threshold" çA duration string, e.g. 10s.
Good service is defined to be the count of requests made to
this service that return in no more than threshold.
:Â	
V

monitoringSloRequestBasedSli4gcp:monitoring/SloRequestBasedSli:SloRequestBasedSliä	
á	µ
distributionCutåBâ:Ü
É

monitoring!SloRequestBasedSliDistributionCutRgcp:monitoring/SloRequestBasedSliDistributionCut:SloRequestBasedSliDistributionCutíUsed when good_service is defined by a count of values aggregated in a
Distribution that fall into a good range. The total_service is the
total count of all values aggregated in the Distribution.
Defines a distribution TimeSeries filter and thresholds used for
measuring good service and total service.
Exactly one of `distribution_cut` or `good_total_ratio` can be set.
Structure is documented below.
Ã
goodTotalRatioâBÜ:É
Ä

monitoring SloRequestBasedSliGoodTotalRatioPgcp:monitoring/SloRequestBasedSliGoodTotalRatio:SloRequestBasedSliGoodTotalRatio≠A means to compute a ratio of `good_service` to `total_service`.
Defines computing this ratio with two TimeSeries [monitoring filters](https://cloud.google.com/monitoring/api/v3/filters)
Must specify exactly two of good, bad, and total service filters.
The relationship good_service + bad_service = total_service
will be assumed.
Exactly one of `distribution_cut` or `good_total_ratio` can be set.
Structure is documented below.
:º
É

monitoring!SloRequestBasedSliDistributionCutRgcp:monitoring/SloRequestBasedSliDistributionCut:SloRequestBasedSliDistributionCut≥
∞Ä
distributionFilter" ÂA TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
aggregating values to quantify the good service provided.
Must have ValueType = DISTRIBUTION and
MetricKind = DELTA or MetricKind = CUMULATIVE.
™
rangeò:ï
í

monitoring&SloRequestBasedSliDistributionCutRange\gcp:monitoring/SloRequestBasedSliDistributionCutRange:SloRequestBasedSliDistributionCutRangeÖRange of numerical values. The computed good_service
will be the count of values x in the Distribution such
that range.min <= x <= range.max. inclusive of min and
max. Open ranges can be defined by setting
just one of min or max.
Structure is documented below.
:£
í

monitoring&SloRequestBasedSliDistributionCutRange\gcp:monitoring/SloRequestBasedSliDistributionCutRange:SloRequestBasedSliDistributionCutRangeã
àÅ
maxB tmax value for the range (inclusive). If not given,
will be set to "infinity", defining an open range
">= range.min"
Å
minB tMin value for the range (inclusive). If not given,
will be set to "-infinity", defining an open range
"< range.max"
:µ

Ä

monitoring SloRequestBasedSliGoodTotalRatioPgcp:monitoring/SloRequestBasedSliGoodTotalRatio:SloRequestBasedSliGoodTotalRatioØ	
¨	À
badServiceFilterB" ∞A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
quantifying bad service provided, either demanded service that
was not provided or demanded service that was of inadequate
quality. Exactly two of
good, bad, or total service filter must be defined (where
good + bad = total is assumed)
Must have ValueType = DOUBLE or ValueType = INT64 and
must have MetricKind = DELTA or MetricKind = CUMULATIVE.
Î
goodServiceFilterB" œA TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
quantifying good service provided. Exactly two of
good, bad, or total service filter must be defined (where
good + bad = total is assumed)
Must have ValueType = DOUBLE or ValueType = INT64 and
must have MetricKind = DELTA or MetricKind = CUMULATIVE.
Ì
totalServiceFilterB" –A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
quantifying total demanded service. Exactly two of
good, bad, or total service filter must be defined (where
good + bad = total is assumed)
Must have ValueType = DOUBLE or ValueType = INT64 and
must have MetricKind = DELTA or MetricKind = CUMULATIVE.
:§
V

monitoringSloWindowsBasedSli4gcp:monitoring/SloWindowsBasedSli:SloWindowsBasedSli…
∆ÿ
goodBadMetricFilterB" ∫A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
with ValueType = BOOL. The window is good if any true values
appear in the window. One of `good_bad_metric_filter`,
`good_total_ratio_threshold`, `metric_mean_in_range`,
`metric_sum_in_range` must be set for `windows_based_sli`.
¡
goodTotalRatioThreshold§B°:û
õ

monitoring)SloWindowsBasedSliGoodTotalRatioThresholdbgcp:monitoring/SloWindowsBasedSliGoodTotalRatioThreshold:SloWindowsBasedSliGoodTotalRatioThreshold˛Criterion that describes a window as good if its performance is
high enough. One of `good_bad_metric_filter`,
`good_total_ratio_threshold`, `metric_mean_in_range`,
`metric_sum_in_range` must be set for `windows_based_sli`.
Structure is documented below.
µ
metricMeanInRangeíBè:å
â

monitoring#SloWindowsBasedSliMetricMeanInRangeVgcp:monitoring/SloWindowsBasedSliMetricMeanInRange:SloWindowsBasedSliMetricMeanInRangeäCriterion that describes a window as good if the metric's value
is in a good range, *averaged* across returned streams.
One of `good_bad_metric_filter`,
`good_total_ratio_threshold`, `metric_mean_in_range`,
`metric_sum_in_range` must be set for `windows_based_sli`.
Average value X of `time_series` should satisfy
`range.min <= X <= range.max` for a good window.
Structure is documented below.
∞
metricSumInRangeèBå:â
Ü

monitoring"SloWindowsBasedSliMetricSumInRangeTgcp:monitoring/SloWindowsBasedSliMetricSumInRange:SloWindowsBasedSliMetricSumInRangeâCriterion that describes a window as good if the metric's value
is in a good range, *summed* across returned streams.
Summed value `X` of `time_series` should satisfy
`range.min <= X <= range.max` for a good window.
One of `good_bad_metric_filter`,
`good_total_ratio_threshold`, `metric_mean_in_range`,
`metric_sum_in_range` must be set for `windows_based_sli`.
Structure is documented below.
π
windowPeriodB" ¢Duration over which window quality is evaluated, given as a
duration string "{X}s" representing X seconds. Must be an
integer fraction of a day and at least 60s.
:ı
õ

monitoring)SloWindowsBasedSliGoodTotalRatioThresholdbgcp:monitoring/SloWindowsBasedSliGoodTotalRatioThreshold:SloWindowsBasedSliGoodTotalRatioThreshold‘
—∆
basicSliPerformanceﬁB€:ÿ
’

monitoring<SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceàgcp:monitoring/SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance:SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceNBasic SLI to evaluate to judge window quality.
Structure is documented below.
≠
performance≈B¬:ø
º

monitoring4SloWindowsBasedSliGoodTotalRatioThresholdPerformancexgcp:monitoring/SloWindowsBasedSliGoodTotalRatioThresholdPerformance:SloWindowsBasedSliGoodTotalRatioThresholdPerformanceVRequest-based SLI to evaluate to judge window quality.
Structure is documented below.
V
	thresholdB CIf window performance >= threshold, the window is counted
as good.
:æ
’

monitoring<SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceàgcp:monitoring/SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance:SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance„
‡õ
availabilityÇBˇ:¸
˘

monitoringHSloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability†gcp:monitoring/SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability:SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailabilityÖAvailability based SLI, dervied from count of requests made to this service that return successfully.
Structure is documented below.
»
latencyÛB:Ì
Í

monitoringCSloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatencyñgcp:monitoring/SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency:SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatencyGParameters for a latency threshold SLI.
Structure is documented below.
Ê
	locationsB*" –An optional set of locations to which this SLI is relevant.
Telemetry from other locations will not be used to calculate
performance for this SLI. If omitted, this SLI applies to all
locations in which the Service has activity. For service types
that don't support breaking down by location, setting this
field will result in an error.
≈
methodsB*" ±An optional set of RPCs to which this SLI is relevant.
Telemetry from other methods will not be used to calculate
performance for this SLI. If omitted, this SLI applies to all
the Service's methods. For service types that don't support
breaking down by method, setting this field will result in an
error.
√
versionsB*" ÆThe set of API versions to which this SLI is relevant.
Telemetry from other API versions will not be used to
calculate performance for this SLI. If omitted,
this SLI applies to all API versions. For service types
that don't support breaking down by version, setting this
field will result in an error.
:Ï
˘

monitoringHSloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability†gcp:monitoring/SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability:SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailabilityn
lj
enabledB
 YWhether an availability SLI is enabled or not. Must be set to `true. Defaults to `true`.
:ï
Í

monitoringCSloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatencyñgcp:monitoring/SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency:SloWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency•
¢ü
	threshold" çA duration string, e.g. 10s.
Good service is defined to be the count of requests made to
this service that return in no more than threshold.
:í
º

monitoring4SloWindowsBasedSliGoodTotalRatioThresholdPerformancexgcp:monitoring/SloWindowsBasedSliGoodTotalRatioThresholdPerformance:SloWindowsBasedSliGoodTotalRatioThresholdPerformance–	
Õ	ÿ
distributionCutÛB:Ì
Í

monitoringCSloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutñgcp:monitoring/SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut:SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutŒUsed when good_service is defined by a count of values aggregated in a
Distribution that fall into a good range. The total_service is the
total count of all values aggregated in the Distribution.
Defines a distribution TimeSeries filter and thresholds used for
measuring good service and total service.
Structure is documented below.
Ô
goodTotalRatioBÌ:Í
Á

monitoringBSloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioîgcp:monitoring/SloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio:SloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioÈA means to compute a ratio of `good_service` to `total_service`.
Defines computing this ratio with two TimeSeries [monitoring filters](https://cloud.google.com/monitoring/api/v3/filters)
Must specify exactly two of good, bad, and total service filters.
The relationship good_service + bad_service = total_service
will be assumed.
Structure is documented below.
:ä
Í

monitoringCSloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutñgcp:monitoring/SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut:SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutö
óÄ
distributionFilter" ÂA TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
aggregating values to quantify the good service provided.
Must have ValueType = DISTRIBUTION and
MetricKind = DELTA or MetricKind = CUMULATIVE.
ë
rangeˇ:¸
˘

monitoringHSloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange†gcp:monitoring/SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange:SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeÖRange of numerical values. The computed good_service
will be the count of values x in the Distribution such
that range.min <= x <= range.max. inclusive of min and
max. Open ranges can be defined by setting
just one of min or max.
Structure is documented below.
:ä
˘

monitoringHSloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange†gcp:monitoring/SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange:SloWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeã
àÅ
maxB tmax value for the range (inclusive). If not given,
will be set to "infinity", defining an open range
">= range.min"
Å
minB tMin value for the range (inclusive). If not given,
will be set to "-infinity", defining an open range
"< range.max"
:ú
Á

monitoringBSloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioîgcp:monitoring/SloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio:SloWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioØ	
¨	À
badServiceFilterB" ∞A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
quantifying bad service provided, either demanded service that
was not provided or demanded service that was of inadequate
quality. Exactly two of
good, bad, or total service filter must be defined (where
good + bad = total is assumed)
Must have ValueType = DOUBLE or ValueType = INT64 and
must have MetricKind = DELTA or MetricKind = CUMULATIVE.
Î
goodServiceFilterB" œA TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
quantifying good service provided. Exactly two of
good, bad, or total service filter must be defined (where
good + bad = total is assumed)
Must have ValueType = DOUBLE or ValueType = INT64 and
must have MetricKind = DELTA or MetricKind = CUMULATIVE.
Ì
totalServiceFilterB" –A TimeSeries [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
quantifying total demanded service. Exactly two of
good, bad, or total service filter must be defined (where
good + bad = total is assumed)
Must have ValueType = DOUBLE or ValueType = INT64 and
must have MetricKind = DELTA or MetricKind = CUMULATIVE.
:ˆ
â

monitoring#SloWindowsBasedSliMetricMeanInRangeVgcp:monitoring/SloWindowsBasedSliMetricMeanInRange:SloWindowsBasedSliMetricMeanInRangeÁ
‰ò
rangeû:õ
ò

monitoring(SloWindowsBasedSliMetricMeanInRangeRange`gcp:monitoring/SloWindowsBasedSliMetricMeanInRangeRange:SloWindowsBasedSliMetricMeanInRangeRangeÌRange of numerical values. The computed good_service
will be the count of values x in the Distribution such
that range.min <= x <= range.max. inclusive of min and
max. Open ranges can be defined by setting
just one of min or max. Mean value `X` of `time_series`
values should satisfy `range.min <= X <= range.max` for a
good service.
Structure is documented below.
∆

timeSeries" ≥A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
specifying the TimeSeries to use for evaluating window
The provided TimeSeries must have ValueType = INT64 or
ValueType = DOUBLE and MetricKind = GAUGE. Mean value `X`
should satisfy `range.min <= X <= range.max`
under good service.
:©
ò

monitoring(SloWindowsBasedSliMetricMeanInRangeRange`gcp:monitoring/SloWindowsBasedSliMetricMeanInRangeRange:SloWindowsBasedSliMetricMeanInRangeRangeã
àÅ
maxB tmax value for the range (inclusive). If not given,
will be set to "infinity", defining an open range
">= range.min"
Å
minB tMin value for the range (inclusive). If not given,
will be set to "-infinity", defining an open range
"< range.max"
:„
Ü

monitoring"SloWindowsBasedSliMetricSumInRangeTgcp:monitoring/SloWindowsBasedSliMetricSumInRange:SloWindowsBasedSliMetricSumInRange◊
‘˛
rangeõ:ò
ï

monitoring'SloWindowsBasedSliMetricSumInRangeRange^gcp:monitoring/SloWindowsBasedSliMetricSumInRangeRange:SloWindowsBasedSliMetricSumInRangeRange÷Range of numerical values. The computed good_service
will be the count of values x in the Distribution such
that range.min <= x <= range.max. inclusive of min and
max. Open ranges can be defined by setting
just one of min or max. Summed value `X` should satisfy
`range.min <= X <= range.max` for a good window.
Structure is documented below.
–

timeSeries" ΩA [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
specifying the TimeSeries to use for evaluating window
quality. The provided TimeSeries must have
ValueType = INT64 or ValueType = DOUBLE and
MetricKind = GAUGE.
Summed value `X` should satisfy
`range.min <= X <= range.max` for a good window.
:¶
ï

monitoring'SloWindowsBasedSliMetricSumInRangeRange^gcp:monitoring/SloWindowsBasedSliMetricSumInRangeRange:SloWindowsBasedSliMetricSumInRangeRangeã
àÅ
maxB tmax value for the range (inclusive). If not given,
will be set to "infinity", defining an open range
">= range.min"
Å
minB tMin value for the range (inclusive). If not given,
will be set to "-infinity", defining an open range
"< range.max"
:õ
}

monitoringUptimeCheckConfigContentMatcherNgcp:monitoring/UptimeCheckConfigContentMatcher:UptimeCheckConfigContentMatcherô
ñA
content" 2String or regex content to match (max 1024 bytes)
á
jsonPathMatcher≥B∞:≠
™

monitoring.UptimeCheckConfigContentMatcherJsonPathMatcherlgcp:monitoring/UptimeCheckConfigContentMatcherJsonPathMatcher:UptimeCheckConfigContentMatcherJsonPathMatcherΩInformation needed to perform a JSONPath content match. Used for `ContentMatcherOption::MATCHES_JSON_PATH` and `ContentMatcherOption::NOT_MATCHES_JSON_PATH`.
Structure is documented below.
∆
matcherB" ¥The type of content matcher that will be applied to the server output, compared to the content string when the check is run.
Default value is `CONTAINS_STRING`.
Possible values are: `CONTAINS_STRING`, `NOT_CONTAINS_STRING`, `MATCHES_REGEX`, `NOT_MATCHES_REGEX`, `MATCHES_JSON_PATH`, `NOT_MATCHES_JSON_PATH`.
:»
™

monitoring.UptimeCheckConfigContentMatcherJsonPathMatcherlgcp:monitoring/UptimeCheckConfigContentMatcherJsonPathMatcher:UptimeCheckConfigContentMatcherJsonPathMatcherò
ïó
jsonMatcherB" ÅOptions to perform JSONPath content matching.
Default value is `EXACT_MATCH`.
Possible values are: `EXACT_MATCH`, `REGEX_MATCH`.
y
jsonPath" iJSONPath within the response output pointing to the expected `ContentMatcher::content` to match against.
:ê$
n

monitoringUptimeCheckConfigHttpCheckDgcp:monitoring/UptimeCheckConfigHttpCheck:UptimeCheckConfigHttpCheckù#
ö#¬
acceptedResponseStatusCodes»B≈*¬:ø
º

monitoring4UptimeCheckConfigHttpCheckAcceptedResponseStatusCodexgcp:monitoring/UptimeCheckConfigHttpCheckAcceptedResponseStatusCode:UptimeCheckConfigHttpCheckAcceptedResponseStatusCode◊If present, the check will only pass if the HTTP response status code is in this set of status codes. If empty, the HTTP status code will only pass if the HTTP status code is 200-299.
Structure is documented below.
‡
authInfoèBå:â
Ü

monitoring"UptimeCheckConfigHttpCheckAuthInfoTgcp:monitoring/UptimeCheckConfigHttpCheckAuthInfo:UptimeCheckConfigHttpCheckAuthInfo¡The authentication information using username and password. Optional when creating an HTTP check; defaults to empty. Do not use with other authentication fields.
Structure is documented below.
î
bodyB" ÖThe request body associated with the HTTP POST request. If `content_type` is `URL_ENCODED`, the body passed in must be URL-encoded. Users can provide a `Content-Length` header via the `headers` field or the API will do so. If the `request_method` is `GET` and `body` is not empty, the API will return an error. The maximum byte size is 1 megabyte. Note - As with all bytes fields JSON representations are base64 encoded. e.g. `foo=bar` in URL-encoded form is `foo%3Dbar` and in base64 encoding is `Zm9vJTI1M0RiYXI=`.
Ö
contentTypeB" pThe content type to use for the check.
Possible values are: `TYPE_UNSPECIFIED`, `URL_ENCODED`, `USER_PROVIDED`.
ﬁ
customContentTypeB" ¬A user provided content type header to use for the check. The invalid configurations outlined in the `content_type` field apply to custom_content_type`, as well as the following 1. `content_type` is `URL_ENCODED` and `custom_content_type` is set. 2. `content_type` is `USER_PROVIDED` and `custom_content_type` is not set.
˙
headersB2" ÊThe list of headers to send as part of the uptime check request. If two headers have the same key and different values, they should be entered as a single header, with the value being a comma-separated list of all the desired values as described in [RFC 2616 (page 31)](https://www.w3.org/Protocols/rfc2616/rfc2616.txt). Entering two separate headers with the same key in a Create call will cause the first to be overwritten by the second. The maximum number of headers allowed is 100.
Ç
maskHeadersB
 ÏBoolean specifying whether to encrypt the header information. Encryption should be specified for any headers related to authentication that you do not wish to be seen when retrieving the configuration. The server will be responsible for encrypting the headers. On Get/List calls, if `mask_headers` is set to `true` then the headers will be obscured with `******`.
õ
pathB" åThe path to the page to run the check against. Will be combined with the host (specified within the MonitoredResource) and port to construct the full URL. If the provided path does not begin with `/`, a `/` will be prepended automatically. Optional (defaults to `/`).
Ä

pingConfigïBí:è
å

monitoring$UptimeCheckConfigHttpCheckPingConfigXgcp:monitoring/UptimeCheckConfigHttpCheckPingConfig:UptimeCheckConfigHttpCheckPingConfigZContains information needed to add pings to an HTTP check.
Structure is documented below.
„
portB ‘The port to the page to run the check against. Will be combined with `host` (specified within the `monitored_resource`) and path to construct the full URL. Optional (defaults to 80 without SSL, or 443 with SSL).
‡
requestMethodB" »The HTTP request method to use for the check. If set to `METHOD_UNSPECIFIED` then `request_method` defaults to `GET`.
Default value is `GET`.
Possible values are: `METHOD_UNSPECIFIED`, `GET`, `POST`.
∞
serviceAgentAuthentication≈B¬:ø
º

monitoring4UptimeCheckConfigHttpCheckServiceAgentAuthenticationxgcp:monitoring/UptimeCheckConfigHttpCheckServiceAgentAuthentication:UptimeCheckConfigHttpCheckServiceAgentAuthentication…The authentication information using the Monitoring Service Agent. Optional when creating an HTTPS check; defaults to empty. Do not use with other authentication fields.
Structure is documented below.
E
useSslB
 5If true, use HTTPS instead of HTTP to run the check.
â
validateSslB
 ÛBoolean specifying whether to include SSL certificate validation as a part of the Uptime check. Only applies to checks where `monitored_resource` is set to `uptime_url`. If `use_ssl` is `false`, setting `validate_ssl` to `true` has no effect.
:æ
º

monitoring4UptimeCheckConfigHttpCheckAcceptedResponseStatusCodexgcp:monitoring/UptimeCheckConfigHttpCheckAcceptedResponseStatusCode:UptimeCheckConfigHttpCheckAcceptedResponseStatusCode¸
˘∆
statusClassB" ∞A class of status codes to accept.
Possible values are: `STATUS_CLASS_1XX`, `STATUS_CLASS_2XX`, `STATUS_CLASS_3XX`, `STATUS_CLASS_4XX`, `STATUS_CLASS_5XX`, `STATUS_CLASS_ANY`.
.
statusValueB A status code to accept.
:ª
Ü

monitoring"UptimeCheckConfigHttpCheckAuthInfoTgcp:monitoring/UptimeCheckConfigHttpCheckAuthInfo:UptimeCheckConfigHttpCheckAuthInfoØ
¨z
password" jThe password to authenticate.
**Note**: This property is sensitive and will not be displayed in the plan.
.
username" The username to authenticate.
:Ô
å

monitoring$UptimeCheckConfigHttpCheckPingConfigXgcp:monitoring/UptimeCheckConfigHttpCheckPingConfig:UptimeCheckConfigHttpCheckPingConfig^
\Z

pingsCount HNumber of ICMP pings. A maximum of 3 ICMP pings is currently supported.
:Õ
º

monitoring4UptimeCheckConfigHttpCheckServiceAgentAuthenticationxgcp:monitoring/UptimeCheckConfigHttpCheckServiceAgentAuthentication:UptimeCheckConfigHttpCheckServiceAgentAuthenticationã
àÖ
typeB" wThe type of authentication to use.
Possible values are: `SERVICE_AGENT_AUTHENTICATION_TYPE_UNSPECIFIED`, `OIDC_TOKEN`.
:›
Ü

monitoring"UptimeCheckConfigMonitoredResourceTgcp:monitoring/UptimeCheckConfigMonitoredResource:UptimeCheckConfigMonitoredResource—
Œ«
labels2" ∂Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels `project_id`, `instance_id`, and `zone`.
Å
type" ÙThe monitored resource type. This field must match the type field of a [`MonitoredResourceDescriptor`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.monitoredResourceDescriptors#MonitoredResourceDescriptor) object. For example, the type of a Compute Engine VM instance is `gce_instance`. For a list of types, see [Monitoring resource types](https://cloud.google.com/monitoring/api/resources) and [Logging resource types](https://cloud.google.com/logging/docs/api/v2/resource-list).
:ı
z

monitoringUptimeCheckConfigResourceGroupLgcp:monitoring/UptimeCheckConfigResourceGroup:UptimeCheckConfigResourceGroupˆ
ÛY
groupIdB" HThe group of resources being monitored. Should be the `name` of a group
ï
resourceTypeB" The resource type of the group members.
Possible values are: `RESOURCE_TYPE_UNSPECIFIED`, `INSTANCE`, `AWS_ELB_LOAD_BALANCER`.
:ˆ
É

monitoring!UptimeCheckConfigSyntheticMonitorRgcp:monitoring/UptimeCheckConfigSyntheticMonitor:UptimeCheckConfigSyntheticMonitorÌ
ÍÁ
cloudFunctionV2∂:≥
∞

monitoring0UptimeCheckConfigSyntheticMonitorCloudFunctionV2pgcp:monitoring/UptimeCheckConfigSyntheticMonitorCloudFunctionV2:UptimeCheckConfigSyntheticMonitorCloudFunctionV2öTarget a Synthetic Monitor GCFv2 Instance
Structure is documented below.


<a name="nested_cloud_function_v2"></a>The `cloud_function_v2` block supports:
:«
∞

monitoring0UptimeCheckConfigSyntheticMonitorCloudFunctionV2pgcp:monitoring/UptimeCheckConfigSyntheticMonitorCloudFunctionV2:UptimeCheckConfigSyntheticMonitorCloudFunctionV2ë
éã
name" A unique resource name for this UptimeCheckConfig. The format is `projects/[PROJECT_ID]/uptimeCheckConfigs/[UPTIME_CHECK_ID]`.
:í
k

monitoringUptimeCheckConfigTcpCheckBgcp:monitoring/UptimeCheckConfigTcpCheck:UptimeCheckConfigTcpCheck¢
ü˚

pingConfigíBè:å
â

monitoring#UptimeCheckConfigTcpCheckPingConfigVgcp:monitoring/UptimeCheckConfigTcpCheckPingConfig:UptimeCheckConfigTcpCheckPingConfigXContains information needed to add pings to a TCP check.
Structure is documented below.
û
port ëThe port to the page to run the check against. Will be combined with host (specified within the `monitored_resource`) to construct the full URL.
:Ï
â

monitoring#UptimeCheckConfigTcpCheckPingConfigVgcp:monitoring/UptimeCheckConfigTcpCheckPingConfig:UptimeCheckConfigTcpCheckPingConfig^
\Z

pingsCount HNumber of ICMP pings. A maximum of 3 ICMP pings is currently supported.
:ú
t

monitoringgetAppEngineServiceTelemetryHgcp:monitoring/getAppEngineServiceTelemetry:getAppEngineServiceTelemetry£
†ù
resourceName" àThe full name of the resource that defines this service.
Formatted as described in
https://cloud.google.com/apis/design/resource_names.
:•
}

monitoringgetClusterIstioServiceTelemetryNgcp:monitoring/getClusterIstioServiceTelemetry:getClusterIstioServiceTelemetry£
†ù
resourceName" àThe full name of the resource that defines this service.
Formatted as described in
https://cloud.google.com/apis/design/resource_names.
:¨
É

monitoring!getIstioCanonicalServiceTelemetryRgcp:monitoring/getIstioCanonicalServiceTelemetry:getIstioCanonicalServiceTelemetry£
†ù
resourceName" àThe full name of the resource that defines this service.
Formatted as described in
https://cloud.google.com/apis/design/resource_names.
:ú
t

monitoringgetMeshIstioServiceTelemetryHgcp:monitoring/getMeshIstioServiceTelemetry:getMeshIstioServiceTelemetry£
†ù
resourceName" àThe full name of the resource that defines this service.
Formatted as described in
https://cloud.google.com/apis/design/resource_names.
:à
å

monitoring$getNotificationChannelSensitiveLabelXgcp:monitoring/getNotificationChannelSensitiveLabel:getNotificationChannelSensitiveLabelˆ
Ûy
	authToken" hAn authorization token for a notification channel. Channel types that support this field include: slack
y
password" iAn password for a notification channel. Channel types that support this field include: webhook_basicauth
{

serviceKey" iAn servicekey token for a notification channel. Channel types that support this field include: pagerduty
:Ü
z

monitoringgetUptimeCheckIPsUptimeCheckIpLgcp:monitoring/getUptimeCheckIPsUptimeCheckIp:getUptimeCheckIPsUptimeCheckIpá
ÑÊ
	ipAddress" ‘The IP address from which the Uptime check originates. This is a fully specified IP address
(not an IP address range). Most IP addresses, as of this publication, are in IPv4 format; however, one should not
rely on the IP addresses being in IPv4 format indefinitely, and should support interpreting this field in either
IPv4 or IPv6 format.
Ã
location" ªA more specific location within the region that typically encodes a particular city/town/metro
(and its containing state/province or country) within the broader umbrella region category.
J
region" <A broad region category in which the IP address is located.
:‚
N
netappVolumeBackupConfig0gcp:netapp/VolumeBackupConfig:VolumeBackupConfigè
å∞
backupPoliciesB*" ïSpecify a single backup policy ID for scheduled backups. Format: `projects/{{projectId}}/locations/{{location}}/backupPolicies/{{backupPolicyName}}`
œ
backupVaultB" πID of the backup vault to use. A backup vault is reqired to create manual or scheduled backups.
Format: `projects/{{projectId}}/locations/{{location}}/backupVaults/{{backupVaultName}}`
Ñ
scheduledBackupEnabledB
 dWhen set to true, scheduled backup is enabled on the volume. Omit if no backup_policy is specified.
:ï
N
netappVolumeExportPolicy0gcp:netapp/VolumeExportPolicy:VolumeExportPolicy¬
øº
rules`*^:\
Z
netappVolumeExportPolicyRule8gcp:netapp/VolumeExportPolicyRule:VolumeExportPolicyRuleQExport rules (up to 5) control NFS volume access.
Structure is documented below.
:±
Z
netappVolumeExportPolicyRule8gcp:netapp/VolumeExportPolicyRule:VolumeExportPolicyRule“
œ£

accessTypeB" éDefines the access type for clients matching the `allowedClients` specification.
Possible values are: `READ_ONLY`, `READ_WRITE`, `READ_NONE`.
ï
allowedClientsB" }Defines the client ingress specification (allowed clients) as a comma separated list with IPv4 CIDRs or IPv4 host addresses.
ß
hasRootAccessB" èIf enabled, the root user (UID = 0) of the specified clients doesn't get mapped to nobody (UID = 65534). This is also known as no_root_squash.
⁄
kerberos5ReadOnlyB
 æIf enabled (true) the rule defines a read only access for clients matching the 'allowedClients' specification. It enables nfs clients to mount using 'authentication' kerberos security mode.
õ
kerberos5ReadWriteB
 ˛If enabled (true) the rule defines read and write access for clients matching the 'allowedClients' specification. It enables nfs clients to mount using 'authentication' kerberos security mode. The 'kerberos5ReadOnly' value is ignored if this is enabled.
÷
kerberos5iReadOnlyB
 πIf enabled (true) the rule defines a read only access for clients matching the 'allowedClients' specification. It enables nfs clients to mount using 'integrity' kerberos security mode.
ò
kerberos5iReadWriteB
 ˙If enabled (true) the rule defines read and write access for clients matching the 'allowedClients' specification. It enables nfs clients to mount using 'integrity' kerberos security mode. The 'kerberos5iReadOnly' value is ignored if this is enabled.
‘
kerberos5pReadOnlyB
 ∑If enabled (true) the rule defines a read only access for clients matching the 'allowedClients' specification. It enables nfs clients to mount using 'privacy' kerberos security mode.
ñ
kerberos5pReadWriteB
 ¯If enabled (true) the rule defines read and write access for clients matching the 'allowedClients' specification. It enables nfs clients to mount using 'privacy' kerberos security mode. The 'kerberos5pReadOnly' value is ignored if this is enabled.
A
nfsv3B
 2Enable to apply the export rule to NFSV3 clients.
C
nfsv4B
 4Enable to apply the export rule to NFSV4.1 clients.
:“
K
netappVolumeMountOption.gcp:netapp/VolumeMountOption:VolumeMountOptionÇ
ˇ4
exportB" $(Output)
Export path of the volume.
Õ

exportFullB" ∏(Output)
Full export path of the volume.
Format for NFS volumes: `<export_ip>:/<shareName>`
Format for SMB volumes: `\\\\netbios_prefix-four_random_hex_letters.domain_name\\shareName`
B
instructionsB" ,(Output)
Human-readable mount instructions.
3
protocolB" !(Output)
Protocol to mount with.
:Ü
ú
netapp,VolumeReplicationDestinationVolumeParametersdgcp:netapp/VolumeReplicationDestinationVolumeParameters:VolumeReplicationDestinationVolumeParameters‰
·=
descriptionB" (Description for the destination volume.
y
	shareNameB" fShare name for destination volume. If not specified, name of source volume's share name will be used.
£
storagePool" èName of an existing storage pool for the destination volume with format: `projects/{{project}}/locations/{{location}}/storagePools/{{poolId}}`

volumeIdB" mName for the destination volume to be created. If not specified, the name of the source volume will be used.
:ù	
o
netappVolumeReplicationTransferStatFgcp:netapp/VolumeReplicationTransferStat:VolumeReplicationTransferStat©
¶å
lagDurationB" ˆ(Output)
The elapsed time since the creation of the snapshot on the source volume that was last replicated
to the destination volume. Lag time represents the difference in age of the destination volume
data in relation to the source volume data.
N
lastTransferBytesB" 3(Output)
Size of last completed transfer in bytes.
R
lastTransferDurationB" 4(Output)
Time taken during last completed transfer.
ô
lastTransferEndTimeB" |(Output)
Time when last transfer completed. A timestamp in RFC3339 UTC "Zulu" format. Examples: "2023-06-22T09:13:01.617Z".
a
lastTransferErrorB" F(Output)
A message describing the cause of the last transfer failure.
u
totalTransferDurationB" V(Output)
Cumulative time taken across all transfers for the replication relationship.
f
transferBytesB" O(Output)
Cumulative bytes transferred so far for the replication relationship.
í

updateTimeB" ~(Output)
Time when progress was updated last. A timestamp in RFC3339 UTC "Zulu" format. Examples: "2023-06-22T09:13:01.617Z".
:Â
]
netappVolumeRestoreParameters:gcp:netapp/VolumeRestoreParameters:VolumeRestoreParametersÉ
ÄÄ
sourceBackupB" ÈFull name of the snapshot to use for creating this volume.
`source_snapshot` and `source_backup` cannot be used simultaneously.
Format: `projects/{{project}}/locations/{{location}}/backupVaults/{{backupVaultId}}/backups/{{backup}}`.
˙
sourceSnapshotB" ·Full name of the snapshot to use for creating this volume.
`source_snapshot` and `source_backup` cannot be used simultaneously.
Format: `projects/{{project}}/locations/{{location}}/volumes/{{volume}}/snapshots/{{snapshot}}`.
:Ù
T
netappVolumeSnapshotPolicy4gcp:netapp/VolumeSnapshotPolicy:VolumeSnapshotPolicyõ
òÀ
dailyScheduleÅB:}
{
netapp!VolumeSnapshotPolicyDailyScheduleNgcp:netapp/VolumeSnapshotPolicyDailySchedule:VolumeSnapshotPolicyDailySchedule6Daily schedule policy.
Structure is documented below.
¬
enabledB
 ∞Enables automated snapshot creation according to defined schedule. Default is false.
To disable automatic snapshot creation you have to remove the whole snapshot_policy block.
“
hourlyScheduleÜBÉ:Ä
~
netapp"VolumeSnapshotPolicyHourlySchedulePgcp:netapp/VolumeSnapshotPolicyHourlySchedule:VolumeSnapshotPolicyHourlySchedule7Hourly schedule policy.
Structure is documented below.
ÿ
monthlyScheduleäBá:Ñ
Å
netapp#VolumeSnapshotPolicyMonthlyScheduleRgcp:netapp/VolumeSnapshotPolicyMonthlySchedule:VolumeSnapshotPolicyMonthlySchedule8Monthly schedule policy.
Structure is documented below.
“
weeklyScheduleÜBÉ:Ä
~
netapp"VolumeSnapshotPolicyWeeklySchedulePgcp:netapp/VolumeSnapshotPolicyWeeklySchedule:VolumeSnapshotPolicyWeeklySchedule7Weekly schedule policy.
Structure is documented below.
:£
{
netapp!VolumeSnapshotPolicyDailyScheduleNgcp:netapp/VolumeSnapshotPolicyDailySchedule:VolumeSnapshotPolicyDailySchedule£
†T
hourB FSet the hour to create the snapshot (0-23), defaults to midnight (0).
o
minuteB _Set the minute of the hour to create the snapshot (0-59), defaults to the top of the hour (0).
W
snapshotsToKeep @The maximum number of snapshots to keep for the daily schedule.
:—
~
netapp"VolumeSnapshotPolicyHourlySchedulePgcp:netapp/VolumeSnapshotPolicyHourlySchedule:VolumeSnapshotPolicyHourlyScheduleŒ
Ào
minuteB _Set the minute of the hour to create the snapshot (0-59), defaults to the top of the hour (0).
X
snapshotsToKeep AThe maximum number of snapshots to keep for the hourly schedule.
:∫
Å
netapp#VolumeSnapshotPolicyMonthlyScheduleRgcp:netapp/VolumeSnapshotPolicyMonthlySchedule:VolumeSnapshotPolicyMonthlySchedule≥
∞å
daysOfMonthB" wSet the day or days of the month to make a snapshot (1-31). Accepts a comma separated number of days. Defaults to '1'.
T
hourB FSet the hour to create the snapshot (0-23), defaults to midnight (0).
o
minuteB _Set the minute of the hour to create the snapshot (0-59), defaults to the top of the hour (0).
X
snapshotsToKeep AThe maximum number of snapshots to keep for the monthly schedule
:≠
~
netapp"VolumeSnapshotPolicyWeeklySchedulePgcp:netapp/VolumeSnapshotPolicyWeeklySchedule:VolumeSnapshotPolicyWeeklySchedule™
ßÉ
dayB" vSet the day or days of the week to make a snapshot. Accepts a comma separated days of the week. Defaults to 'Sunday'.
T
hourB FSet the hour to create the snapshot (0-23), defaults to midnight (0).
o
minuteB _Set the minute of the hour to create the snapshot (0-59), defaults to the top of the hour (0).
X
snapshotsToKeep AThe maximum number of snapshots to keep for the weekly schedule.
:Ω
Q
netappVolumeTieringPolicy2gcp:netapp/VolumeTieringPolicy:VolumeTieringPolicyÁ
‰®
coolingThresholdDaysB âOptional. Time in days to mark the volume's data block as cold and make it eligible for tiering, can be range from 7-183.
Default is 31.
∂

tierActionB" °Optional. Flag indicating if the volume has tiering policy enable/pause. Default is PAUSED.
Default value is `PAUSED`.
Possible values are: `ENABLED`, `PAUSED`.
:≥
_
networkconnectivityGroupAutoAccept7gcp:networkconnectivity/GroupAutoAccept:GroupAutoAcceptœ
Ã…
autoAcceptProjects*" ¨A list of project ids or project numbers for which you want to enable auto-accept. The auto-accept setting is applied to spokes being created or updated in these projects.
:ä
Y
networkconnectivityHubRoutingVpc3gcp:networkconnectivity/HubRoutingVpc:HubRoutingVpc-
+)
uriB" The URI of the VPC network.
:·
t
networkconnectivityInternalRangeMigrationEgcp:networkconnectivity/InternalRangeMigration:InternalRangeMigrationË
ÂÓ
source" ﬂResource path as an URI of the source resource, for example a subnet.
The project for the source resource should match the project for the
InternalRange.
An example /projects/{project}/regions/{region}/subnetworks/{subnet}
Ò
target" ‚Resource path of the target resource. The target project can be
different, as in the cases when migrating to peer networks. The resource
may not exist yet.
For example /projects/{project}/regions/{region}/subnetworks/{subnet}
:¿
t
networkconnectivityPolicyBasedRouteFilterEgcp:networkconnectivity/PolicyBasedRouteFilter:PolicyBasedRouteFilter«
ƒ•
	destRangeB" ëThe destination IP range of outgoing packets that this policy-based route applies to. Default is "0.0.0.0/0" if protocol version is IPv4.

- - -
â

ipProtocolB" uThe IP protocol that this policy-based route applies to. Valid values are 'TCP', 'UDP', and 'ALL'. Default is 'ALL'.
s
protocolVersion" \Internet protocol versions this policy-based route applies to.
Possible values are: `IPV4`.
ò
srcRangeB" ÖThe source IP range of outgoing packets that this policy-based route applies to. Default is "0.0.0.0/0" if protocol version is IPv4.
:…
§
networkconnectivity&PolicyBasedRouteInterconnectAttachmentegcp:networkconnectivity/PolicyBasedRouteInterconnectAttachment:PolicyBasedRouteInterconnectAttachmentü
úô
region" äCloud region to install this policy-based route on for Interconnect attachments. Use `all` to install it on all Interconnect attachments.
:¥
å
networkconnectivityPolicyBasedRouteVirtualMachineUgcp:networkconnectivity/PolicyBasedRouteVirtualMachine:PolicyBasedRouteVirtualMachine¢
üú
tags*" çA list of VM instance tags that this policy-based route applies to. VM instances that have ANY of tags specified here will install this PBR.
:ö
w
networkconnectivityPolicyBasedRouteWarningGgcp:networkconnectivity/PolicyBasedRouteWarning:PolicyBasedRouteWarningû
õ6
codeB" ((Output)
A warning code, if applicable.
ã
dataB2" ˙(Output)
Metadata about this warning in key: value format. The key should provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement.
S
warningMessageB" ;(Output)
A human-readable description of the warning code.
:º
í
networkconnectivity ServiceConnectionPolicyPscConfigYgcp:networkconnectivity/ServiceConnectionPolicyPscConfig:ServiceConnectionPolicyPscConfig§
°>
limitB" /Max number of PSC connections for this policy.
_
subnetworks*" JIDs of the subnetworks or fully qualified identifiers for the subnetworks
:§
û
networkconnectivity$ServiceConnectionPolicyPscConnectionagcp:networkconnectivity/ServiceConnectionPolicyPscConnection:ServiceConnectionPolicyPscConnectionÄ
˝
I
consumerAddressB" 0The resource reference of the consumer address.
k
consumerForwardingRuleB" KThe resource reference of the PSC Forwarding Rule within the consumer VPC.
P
consumerTargetProjectB" 1The project where the PSC connection is created.
ô
error∂B≥:∞
≠
networkconnectivity)ServiceConnectionPolicyPscConnectionErrorkgcp:networkconnectivity/ServiceConnectionPolicyPscConnectionError:ServiceConnectionPolicyPscConnectionErrorWThe most recent error during operating this connection.
Structure is documented below.
∑
	errorInfo¬Bø:º
π
networkconnectivity-ServiceConnectionPolicyPscConnectionErrorInfosgcp:networkconnectivity/ServiceConnectionPolicyPscConnectionErrorInfo:ServiceConnectionPolicyPscConnectionErrorInfoeThe error info for the latest error during operating this connection.
Structure is documented below.
Ò
	errorTypeB" ›The error type indicates whether the error is consumer facing, producer
facing or system internal.
Possible values are: `CONNECTION_ERROR_TYPE_UNSPECIFIED`, `ERROR_INTERNAL`, `ERROR_CONSUMER_SIDE`, `ERROR_PRODUCER_SIDE`.
Q
gceOperationB" ;The last Compute Engine operation to setup PSC connection.
K
pscConnectionIdB" 2The PSC connection id of the PSC forwarding rule.
Ü
stateB" wThe state of the PSC connection.
Possible values are: `STATE_UNSPECIFIED`, `ACTIVE`, `CREATING`, `DELETING`, `FAILED`.
:ì
≠
networkconnectivity)ServiceConnectionPolicyPscConnectionErrorkgcp:networkconnectivity/ServiceConnectionPolicyPscConnectionError:ServiceConnectionPolicyPscConnectionError‡
›U
codeB GThe status code, which should be an enum value of [google.rpc.Code][].
O
detailsB*2" :(Output)
A list of messages that carry the error details.
3
messageB" "A developer-facing error message.
:˘
π
networkconnectivity-ServiceConnectionPolicyPscConnectionErrorInfosgcp:networkconnectivity/ServiceConnectionPolicyPscConnectionErrorInfo:ServiceConnectionPolicyPscConnectionErrorInfo∫
∑D
domainB" 4The logical grouping to which the "reason" belongs.
D
metadataB2" 0Additional structured details about this error.
)
reasonB" The reason of the error.
:‹
ò
networkconnectivity"SpokeLinkedInterconnectAttachments]gcp:networkconnectivity/SpokeLinkedInterconnectAttachments:SpokeLinkedInterconnectAttachmentsæ
ª∂
includeImportRangesB*" ñIP ranges allowed to be included during import from hub (does not control transit connectivity).
The only allowed value for now is "ALL_IPV4_RANGES".
∫
siteToSiteDataTransfer
 õA value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
C
uris*" 5The URIs of linked interconnect attachment resources
:©
â
networkconnectivitySpokeLinkedProducerVpcNetworkSgcp:networkconnectivity/SpokeLinkedProducerVpcNetwork:SpokeLinkedProducerVpcNetworkö
ó_
excludeExportRangesB*" @IP ranges encompassing the subnets to be excluded from peering.
N
includeExportRangesB*" /IP ranges allowed to be included from peering.
Y
network" JThe URI of the Service Consumer VPC that the Producer VPC is peered with.
«
peering" ∑The name of the VPC peering between the Service Consumer VPC and the Producer VPC (defined in the Tenant project) which is added to the NCC hub. This peering must be in ACTIVE state.
?
producerNetworkB" &(Output)
The URI of the Producer VPC.
:Ø
õ
networkconnectivity#SpokeLinkedRouterApplianceInstances_gcp:networkconnectivity/SpokeLinkedRouterApplianceInstances:SpokeLinkedRouterApplianceInstancesé
ã∂
includeImportRangesB*" ñIP ranges allowed to be included during import from hub (does not control transit connectivity).
The only allowed value for now is "ALL_IPV4_RANGES".
í
	instancesº*π:∂
≥
networkconnectivity+SpokeLinkedRouterApplianceInstancesInstanceogcp:networkconnectivity/SpokeLinkedRouterApplianceInstancesInstance:SpokeLinkedRouterApplianceInstancesInstanceFThe list of router appliance instances
Structure is documented below.
∫
siteToSiteDataTransfer
 õA value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
:º
≥
networkconnectivity+SpokeLinkedRouterApplianceInstancesInstanceogcp:networkconnectivity/SpokeLinkedRouterApplianceInstancesInstance:SpokeLinkedRouterApplianceInstancesInstanceÉ
Ä>
	ipAddress" -The IP address on the VM to use for peering.
>
virtualMachine" (The URI of the virtual machine resource
:‹
q
networkconnectivitySpokeLinkedVpcNetworkCgcp:networkconnectivity/SpokeLinkedVpcNetwork:SpokeLinkedVpcNetworkÊ
„_
excludeExportRangesB*" @IP ranges encompassing the subnets to be excluded from peering.
N
includeExportRangesB*" /IP ranges allowed to be included from peering.
0
uri" %The URI of the VPC network resource.
:®
q
networkconnectivitySpokeLinkedVpnTunnelsCgcp:networkconnectivity/SpokeLinkedVpnTunnels:SpokeLinkedVpnTunnels≤
Ø∂
includeImportRangesB*" ñIP ranges allowed to be included during import from hub (does not control transit connectivity).
The only allowed value for now is "ALL_IPV4_RANGES".
∫
siteToSiteDataTransfer
 õA value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
7
uris*" )The URIs of linked VPN tunnel resources.
:¯

networkmanagementConnectivityTestDestinationMgcp:networkmanagement/ConnectivityTestDestination:ConnectivityTestDestinationÙ
Ò1
instanceB" A Compute Engine instance URI.
∏
	ipAddressB" §The IP address of the endpoint, which can be an external or
internal IP. An IPv6 address is only allowed when the test's
destination is a global load balancer VIP.
/
networkB" A Compute Engine network URI.
a
portB SThe IP protocol port of the endpoint. Only applicable when
protocol is TCP or UDP.
Ï
	projectIdB" ÿProject ID where the endpoint is located. The Project ID can be
derived from the URI if you provide a VM instance or network URI.
The following are two cases where you must provide the project ID:
1. Only the IP address is specified, and the IP address is within
a GCP project. 2. When you are using Shared VPC and the IP address
that you provide is from the service project. In this case, the
network that the IP address resides in is defined in the host
project.

- - -
:„
p
networkmanagementConnectivityTestSourceCgcp:networkmanagement/ConnectivityTestSource:ConnectivityTestSourceÓ
Î1
instanceB" A Compute Engine instance URI.
∏
	ipAddressB" §The IP address of the endpoint, which can be an external or
internal IP. An IPv6 address is only allowed when the test's
destination is a global load balancer VIP.
/
networkB" A Compute Engine network URI.

networkTypeB" jType of the network where the endpoint is located.
Possible values are: `GCP_NETWORK`, `NON_GCP_NETWORK`.
a
portB SThe IP protocol port of the endpoint. Only applicable when
protocol is TCP or UDP.
Â
	projectIdB" —Project ID where the endpoint is located. The Project ID can be
derived from the URI if you provide a VM instance or network URI.
The following are two cases where you must provide the project ID:
1. Only the IP address is specified, and the IP address is
within a GCP project.
2. When you are using Shared VPC and the IP address
that you provide is from the service project. In this case,
the network that the IP address resides in is defined in the
host project.
:¬
á
networksecurityAddressGroupIamBindingConditionSgcp:networksecurity/AddressGroupIamBindingCondition:AddressGroupIamBindingCondition6
4
descriptionB" 

expression" 
title" :ø
Ñ
networksecurityAddressGroupIamMemberConditionQgcp:networksecurity/AddressGroupIamMemberCondition:AddressGroupIamMemberCondition6
4
descriptionB" 

expression" 
title" :¶
o
networksecurityAuthorizationPolicyRuleCgcp:networksecurity/AuthorizationPolicyRule:AuthorizationPolicyRule≤
Ø˙
destinationsúBô*ñ:ì
ê
networksecurity"AuthorizationPolicyRuleDestinationYgcp:networksecurity/AuthorizationPolicyRuleDestination:AuthorizationPolicyRuleDestination List of attributes for the traffic destination. All of the destinations must match. A destination is a match if a request matches all the specified hosts, ports, methods and headers.
If not set, the action specified in the 'action' field will be applied without any rule checks for the destination.
Structure is documented below.
Ø
sourcesçBä*á:Ñ
Å
networksecurityAuthorizationPolicyRuleSourceOgcp:networksecurity/AuthorizationPolicyRuleSource:AuthorizationPolicyRuleSourceìList of attributes for the traffic source. All of the sources must match. A source is a match if both principals and ipBlocks match.
If not set, the action specified in the 'action' field will be applied without any rule checks for the source.
Structure is documented below.
:ø	
ê
networksecurity"AuthorizationPolicyRuleDestinationYgcp:networksecurity/AuthorizationPolicyRuleDestination:AuthorizationPolicyRuleDestination©
¶ö
hosts*" äList of host names to match. Matched against the ":authority" header in http requests. At least one host should match. Each host can be an exact match, or a prefix match (example "mydomain.*") or a suffix match (example "*.myorg.com") or a presence (any) match "*".
∂
httpHeaderMatch∆B√:¿
Ω
networksecurity1AuthorizationPolicyRuleDestinationHttpHeaderMatchwgcp:networksecurity/AuthorizationPolicyRuleDestinationHttpHeaderMatch:AuthorizationPolicyRuleDestinationHttpHeaderMatchŸMatch against key:value pair in http header. Provides a flexible match based on HTTP headers, for potentially advanced use cases. At least one header should match.
Avoid using header matches to make authorization decisions unless there is a strong guarantee that requests arrive through a trusted client or proxy.
Structure is documented below.
y
methods*" hA list of HTTP methods to match. At least one method should match. Should not be set for gRPC services.
S
ports* DList of destination ports to match. At least one port should match.
:§
Ω
networksecurity1AuthorizationPolicyRuleDestinationHttpHeaderMatchwgcp:networksecurity/AuthorizationPolicyRuleDestinationHttpHeaderMatch:AuthorizationPolicyRuleDestinationHttpHeaderMatch·
ﬁ‡

headerName" ÕThe name of the HTTP header to match. For matching against the HTTP request's authority, use a headerMatch with the header name ":authority". For matching a request's method, use the headerName ":method".
¯

regexMatch" ÂThe value of the header must match the regular expression specified in regexMatch. For regular expression grammar, please see: en.cppreference.com/w/cpp/regex/ecmascript For matching against a port specified in the HTTP request, use a headerMatch with headerName set to Host and a regular expression that satisfies the RFC2616 Host header's port specifier.
:Á
Å
networksecurityAuthorizationPolicyRuleSourceOgcp:networksecurity/AuthorizationPolicyRuleSource:AuthorizationPolicyRuleSource‡
›«
ipBlocksB*" ≤List of CIDR ranges to match based on source IP address. At least one IP block should match. Single IP (e.g., "1.2.3.4") and CIDR (e.g., "1.2.3.0/24") are supported. Authorization based on source IP alone should be avoided.
The IP addresses of any load balancers or proxies should be considered untrusted.
ê

principalsB*" ˘List of peer identities to match for authorization. At least one principal should match. Each peer can be an exact match, or a prefix match (example, "namespace/*") or a suffix match (example, "*/service-account") or a presence match "*".
Authorization based on the principal name without certificate validation (configured by ServerTlsPolicy resource) is considered insecure.
:ä
u
networksecurityAuthzPolicyCustomProviderGgcp:networksecurity/AuthzPolicyCustomProvider:AuthzPolicyCustomProviderê
ç⁄
authzExtension®B•:¢
ü
networksecurity'AuthzPolicyCustomProviderAuthzExtensioncgcp:networksecurity/AuthzPolicyCustomProviderAuthzExtension:AuthzPolicyCustomProviderAuthzExtensionúDelegate authorization decision to user authored Service Extension. Only one of cloudIap or authzExtension can be specified.
Structure is documented below.
≠
cloudIapñBì:ê
ç
networksecurity!AuthzPolicyCustomProviderCloudIapWgcp:networksecurity/AuthzPolicyCustomProviderCloudIap:AuthzPolicyCustomProviderCloudIapáDelegates authorization decisions to Cloud IAP. Applicable only for managed load balancers. Enabling Cloud IAP at the AuthzPolicy level is not compatible with Cloud IAP settings in the BackendService. Enabling IAP in both places will result in request failure. Ensure that IAP is enabled in either the AuthzPolicy or the BackendService but not in both places.
Structure is documented below.
:∆
ü
networksecurity'AuthzPolicyCustomProviderAuthzExtensioncgcp:networksecurity/AuthzPolicyCustomProviderAuthzExtension:AuthzPolicyCustomProviderAuthzExtension°
ûõ
	resources*" áA list of references to authorization extensions that will be invoked for requests matching this policy. Limited to 1 custom provider.
:–
ç
networksecurity!AuthzPolicyCustomProviderCloudIapWgcp:networksecurity/AuthzPolicyCustomProviderCloudIap:AuthzPolicyCustomProviderCloudIap>
<:
enabled
 +Enable Cloud IAP at the AuthzPolicy level.
:ˇ
c
networksecurityAuthzPolicyHttpRule;gcp:networksecurity/AuthzPolicyHttpRule:AuthzPolicyHttpRuleó
îÿ
fromuBs:q
o
networksecurityAuthzPolicyHttpRuleFromCgcp:networksecurity/AuthzPolicyHttpRuleFrom:AuthzPolicyHttpRuleFromYDescribes properties of one or more sources of a request.
Structure is documented below.
œ
tooBm:k
i
networksecurityAuthzPolicyHttpRuleTo?gcp:networksecurity/AuthzPolicyHttpRuleTo:AuthzPolicyHttpRuleToXDescribes properties of one or more targets of a request
Structure is documented below.
‰
whenB" ’CEL expression that describes the conditions to be satisfied for the action. The result of the CEL expression is ANDed with the from and to. Refer to the CEL language reference for a list of available attributes.
:á

o
networksecurityAuthzPolicyHttpRuleFromCgcp:networksecurity/AuthzPolicyHttpRuleFrom:AuthzPolicyHttpRuleFromì	
ê	À

notSourcesñBì*ê:ç
ä
networksecurity AuthzPolicyHttpRuleFromNotSourceUgcp:networksecurity/AuthzPolicyHttpRuleFromNotSource:AuthzPolicyHttpRuleFromNotSource£Describes the properties of a request's sources. At least one of sources or notSources must be specified. Limited to 5 sources. A match occurs when ANY source (in sources or notSources) matches the request. Within a single source, the match follows AND semantics across fields and OR semantics within a single field, i.e. a match occurs when ANY principal matches AND ANY ipBlocks match.
Structure is documented below.
ø
sourcesçBä*á:Ñ
Å
networksecurityAuthzPolicyHttpRuleFromSourceOgcp:networksecurity/AuthzPolicyHttpRuleFromSource:AuthzPolicyHttpRuleFromSource£Describes the properties of a request's sources. At least one of sources or notSources must be specified. Limited to 5 sources. A match occurs when ANY source (in sources or notSources) matches the request. Within a single source, the match follows AND semantics across fields and OR semantics within a single field, i.e. a match occurs when ANY principal matches AND ANY ipBlocks match.
Structure is documented below.
:˚
ä
networksecurity AuthzPolicyHttpRuleFromNotSourceUgcp:networksecurity/AuthzPolicyHttpRuleFromNotSource:AuthzPolicyHttpRuleFromNotSourceÎ
Ëõ

principals±BÆ*´:®
•
networksecurity)AuthzPolicyHttpRuleFromNotSourcePrincipalggcp:networksecurity/AuthzPolicyHttpRuleFromNotSourcePrincipal:AuthzPolicyHttpRuleFromNotSourcePrincipalÿA list of identities derived from the client's certificate. This field will not match on a request unless mutual TLS is enabled for the Forwarding rule or Gateway. Each identity is a string whose value is matched against the URI SAN, or DNS SAN or the subject field in the client's certificate. The match can be exact, prefix, suffix or a substring match. One of exact, prefix, suffix or contains must be specified.
Limited to 5 principals.
Structure is documented below.
«
	resourcesÆB´*®:•
¢
networksecurity(AuthzPolicyHttpRuleFromNotSourceResourceegcp:networksecurity/AuthzPolicyHttpRuleFromNotSourceResource:AuthzPolicyHttpRuleFromNotSourceResourceàA list of resources to match against the resource of the source VM of a request.
Limited to 5 resources.
Structure is documented below.
:ò
•
networksecurity)AuthzPolicyHttpRuleFromNotSourcePrincipalggcp:networksecurity/AuthzPolicyHttpRuleFromNotSourcePrincipal:AuthzPolicyHttpRuleFromNotSourcePrincipalÌ
Íø
containsB" ¨The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc.def
z
exactB" kThe input string must match exactly the string specified here.
Examples:
* abc only matches the value abc.
«

ignoreCaseB
 ≤If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
Æ
prefixB" ùThe input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value abc.xyz
Æ
suffixB" ùThe input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc
:∏
¢
networksecurity(AuthzPolicyHttpRuleFromNotSourceResourceegcp:networksecurity/AuthzPolicyHttpRuleFromNotSourceResource:AuthzPolicyHttpRuleFromNotSourceResourceê
ç˘
iamServiceAccountﬂB‹:Ÿ
÷
networksecurity9AuthzPolicyHttpRuleFromNotSourceResourceIamServiceAccountágcp:networksecurity/AuthzPolicyHttpRuleFromNotSourceResourceIamServiceAccount:AuthzPolicyHttpRuleFromNotSourceResourceIamServiceAccountÅAn IAM service account to match against the source service account of the VM sending the request.
Structure is documented below.
é
tagValueIdSet“Bœ:Ã
…
networksecurity5AuthzPolicyHttpRuleFromNotSourceResourceTagValueIdSetgcp:networksecurity/AuthzPolicyHttpRuleFromNotSourceResourceTagValueIdSet:AuthzPolicyHttpRuleFromNotSourceResourceTagValueIdSetßA list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request.
Structure is documented below.
:…
÷
networksecurity9AuthzPolicyHttpRuleFromNotSourceResourceIamServiceAccountágcp:networksecurity/AuthzPolicyHttpRuleFromNotSourceResourceIamServiceAccount:AuthzPolicyHttpRuleFromNotSourceResourceIamServiceAccountÌ
Íø
containsB" ¨The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc.def
z
exactB" kThe input string must match exactly the string specified here.
Examples:
* abc only matches the value abc.
«

ignoreCaseB
 ≤If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
Æ
prefixB" ùThe input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value abc.xyz
Æ
suffixB" ùThe input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc
:«
…
networksecurity5AuthzPolicyHttpRuleFromNotSourceResourceTagValueIdSetgcp:networksecurity/AuthzPolicyHttpRuleFromNotSourceResourceTagValueIdSet:AuthzPolicyHttpRuleFromNotSourceResourceTagValueIdSet¯
ıÚ
idsB*" ‚A list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request. The match follows AND semantics which means all the ids must match.
Limited to 5 matches.
:‡
Å
networksecurityAuthzPolicyHttpRuleFromSourceOgcp:networksecurity/AuthzPolicyHttpRuleFromSource:AuthzPolicyHttpRuleFromSourceŸ
÷í

principals®B•*¢:ü
ú
networksecurity&AuthzPolicyHttpRuleFromSourcePrincipalagcp:networksecurity/AuthzPolicyHttpRuleFromSourcePrincipal:AuthzPolicyHttpRuleFromSourcePrincipalÿA list of identities derived from the client's certificate. This field will not match on a request unless mutual TLS is enabled for the Forwarding rule or Gateway. Each identity is a string whose value is matched against the URI SAN, or DNS SAN or the subject field in the client's certificate. The match can be exact, prefix, suffix or a substring match. One of exact, prefix, suffix or contains must be specified.
Limited to 5 principals.
Structure is documented below.
æ
	resources•B¢*ü:ú
ô
networksecurity%AuthzPolicyHttpRuleFromSourceResource_gcp:networksecurity/AuthzPolicyHttpRuleFromSourceResource:AuthzPolicyHttpRuleFromSourceResourceàA list of resources to match against the resource of the source VM of a request.
Limited to 5 resources.
Structure is documented below.
:è
ú
networksecurity&AuthzPolicyHttpRuleFromSourcePrincipalagcp:networksecurity/AuthzPolicyHttpRuleFromSourcePrincipal:AuthzPolicyHttpRuleFromSourcePrincipalÌ
Íø
containsB" ¨The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc.def
z
exactB" kThe input string must match exactly the string specified here.
Examples:
* abc only matches the value abc.
«

ignoreCaseB
 ≤If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
Æ
prefixB" ùThe input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value abc.xyz
Æ
suffixB" ùThe input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc
:ù
ô
networksecurity%AuthzPolicyHttpRuleFromSourceResource_gcp:networksecurity/AuthzPolicyHttpRuleFromSourceResource:AuthzPolicyHttpRuleFromSourceResource˛
˚
iamServiceAccount÷B”:–
Õ
networksecurity6AuthzPolicyHttpRuleFromSourceResourceIamServiceAccountÅgcp:networksecurity/AuthzPolicyHttpRuleFromSourceResourceIamServiceAccount:AuthzPolicyHttpRuleFromSourceResourceIamServiceAccountÅAn IAM service account to match against the source service account of the VM sending the request.
Structure is documented below.
Ö
tagValueIdSet…B∆:√
¿
networksecurity2AuthzPolicyHttpRuleFromSourceResourceTagValueIdSetygcp:networksecurity/AuthzPolicyHttpRuleFromSourceResourceTagValueIdSet:AuthzPolicyHttpRuleFromSourceResourceTagValueIdSetßA list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request.
Structure is documented below.
:¿
Õ
networksecurity6AuthzPolicyHttpRuleFromSourceResourceIamServiceAccountÅgcp:networksecurity/AuthzPolicyHttpRuleFromSourceResourceIamServiceAccount:AuthzPolicyHttpRuleFromSourceResourceIamServiceAccountÌ
Íø
containsB" ¨The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc.def
z
exactB" kThe input string must match exactly the string specified here.
Examples:
* abc only matches the value abc.
«

ignoreCaseB
 ≤If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
Æ
prefixB" ùThe input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value abc.xyz
Æ
suffixB" ùThe input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc
:æ
¿
networksecurity2AuthzPolicyHttpRuleFromSourceResourceTagValueIdSetygcp:networksecurity/AuthzPolicyHttpRuleFromSourceResourceTagValueIdSet:AuthzPolicyHttpRuleFromSourceResourceTagValueIdSet¯
ıÚ
idsB*" ‚A list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request. The match follows AND semantics which means all the ids must match.
Limited to 5 matches.
:–
i
networksecurityAuthzPolicyHttpRuleTo?gcp:networksecurity/AuthzPolicyHttpRuleTo:AuthzPolicyHttpRuleTo‚
ﬂ‹

operationsêBç*ä:á
Ñ
networksecurityAuthzPolicyHttpRuleToOperationQgcp:networksecurity/AuthzPolicyHttpRuleToOperation:AuthzPolicyHttpRuleToOperation∫Describes properties of one or more targets of a request. At least one of operations or notOperations must be specified. Limited to 5 operations. A match occurs when ANY operation (in operations or notOperations) matches. Within an operation, the match follows AND semantics across fields and OR semantics within a field, i.e. a match occurs when ANY path matches AND ANY header matches and ANY method matches.
Structure is documented below.
:≠
Ñ
networksecurityAuthzPolicyHttpRuleToOperationQgcp:networksecurity/AuthzPolicyHttpRuleToOperation:AuthzPolicyHttpRuleToOperation£
†ä
	headerSet®B•:¢
ü
networksecurity'AuthzPolicyHttpRuleToOperationHeaderSetcgcp:networksecurity/AuthzPolicyHttpRuleToOperationHeaderSet:AuthzPolicyHttpRuleToOperationHeaderSetRA list of headers to match against in http header.
Structure is documented below.
ì
hostsúBô*ñ:ì
ê
networksecurity"AuthzPolicyHttpRuleToOperationHostYgcp:networksecurity/AuthzPolicyHttpRuleToOperationHost:AuthzPolicyHttpRuleToOperationHostÍA list of HTTP Hosts to match against. The match can be one of exact, prefix, suffix, or contains (substring match). Matches are always case sensitive unless the ignoreCase is set.
Limited to 5 matches.
Structure is documented below.
“
methodsB*" æA list of HTTP methods to match against. Each entry must be a valid HTTP method name (GET, PUT, POST, HEAD, PATCH, DELETE, OPTIONS). It only allows exact match and is always case sensitive.
•
pathsúBô*ñ:ì
ê
networksecurity"AuthzPolicyHttpRuleToOperationPathYgcp:networksecurity/AuthzPolicyHttpRuleToOperationPath:AuthzPolicyHttpRuleToOperationPath¸A list of paths to match against. The match can be one of exact, prefix, suffix, or contains (substring match). Matches are always case sensitive unless the ignoreCase is set.
Limited to 5 matches.
Note that this path match includes the query parameters. For gRPC services, this should be a fully-qualified name of the form /package.service/method.
Structure is documented below.
:µ
ü
networksecurity'AuthzPolicyHttpRuleToOperationHeaderSetcgcp:networksecurity/AuthzPolicyHttpRuleToOperationHeaderSet:AuthzPolicyHttpRuleToOperationHeaderSetê
çä
headersΩB∫*∑:¥
±
networksecurity-AuthzPolicyHttpRuleToOperationHeaderSetHeaderogcp:networksecurity/AuthzPolicyHttpRuleToOperationHeaderSetHeader:AuthzPolicyHttpRuleToOperationHeaderSetHeaderæA list of headers to match against in http header. The match can be one of exact, prefix, suffix, or contains (substring match). The match follows AND semantics which means all the headers must match. Matches are always case sensitive unless the ignoreCase is set. Limited to 5 matches.
Structure is documented below.
:§
±
networksecurity-AuthzPolicyHttpRuleToOperationHeaderSetHeaderogcp:networksecurity/AuthzPolicyHttpRuleToOperationHeaderSetHeader:AuthzPolicyHttpRuleToOperationHeaderSetHeaderÌ
Í?
nameB" 1Specifies the name of the header in the request.
¶
value…B∆:√
¿
networksecurity2AuthzPolicyHttpRuleToOperationHeaderSetHeaderValueygcp:networksecurity/AuthzPolicyHttpRuleToOperationHeaderSetHeaderValue:AuthzPolicyHttpRuleToOperationHeaderSetHeaderValueQSpecifies how the header match will be performed.
Structure is documented below.
:≥
¿
networksecurity2AuthzPolicyHttpRuleToOperationHeaderSetHeaderValueygcp:networksecurity/AuthzPolicyHttpRuleToOperationHeaderSetHeaderValue:AuthzPolicyHttpRuleToOperationHeaderSetHeaderValueÌ
Íø
containsB" ¨The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc.def
z
exactB" kThe input string must match exactly the string specified here.
Examples:
* abc only matches the value abc.
«

ignoreCaseB
 ≤If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
Æ
prefixB" ùThe input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value abc.xyz
Æ
suffixB" ùThe input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc
:É
ê
networksecurity"AuthzPolicyHttpRuleToOperationHostYgcp:networksecurity/AuthzPolicyHttpRuleToOperationHost:AuthzPolicyHttpRuleToOperationHostÌ
Íø
containsB" ¨The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc.def
z
exactB" kThe input string must match exactly the string specified here.
Examples:
* abc only matches the value abc.
«

ignoreCaseB
 ≤If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
Æ
prefixB" ùThe input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value abc.xyz
Æ
suffixB" ùThe input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc
:É
ê
networksecurity"AuthzPolicyHttpRuleToOperationPathYgcp:networksecurity/AuthzPolicyHttpRuleToOperationPath:AuthzPolicyHttpRuleToOperationPathÌ
Íø
containsB" ¨The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc.def
z
exactB" kThe input string must match exactly the string specified here.
Examples:
* abc only matches the value abc.
«

ignoreCaseB
 ≤If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
Æ
prefixB" ùThe input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value abc.xyz
Æ
suffixB" ùThe input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
Examples:
* abc matches the value xyz.abc
:ª
]
networksecurityAuthzPolicyTarget7gcp:networksecurity/AuthzPolicyTarget:AuthzPolicyTargetŸ
÷‚
loadBalancingScheme" ∆All gateways and forwarding rules referenced by this policy and extensions must share the same load balancing scheme.
For more information, refer to [Backend services overview](https://cloud.google.com/load-balancing/docs/backend-service).
Possible values are: `INTERNAL_MANAGED`, `EXTERNAL_MANAGED`, `INTERNAL_SELF_MANAGED`.
o
	resourcesB*" ZA list of references to the Forwarding Rules on which this policy will be applied.

- - -
:ó
ä
networksecurity ClientTlsPolicyClientCertificateUgcp:networksecurity/ClientTlsPolicyClientCertificate:ClientTlsPolicyClientCertificateá
Ñª
certificateProviderInstanceÂB‚:ﬂ
‹
networksecurity;ClientTlsPolicyClientCertificateCertificateProviderInstanceãgcp:networksecurity/ClientTlsPolicyClientCertificateCertificateProviderInstance:ClientTlsPolicyClientCertificateCertificateProviderInstance≥The certificate provider instance specification that will be passed to the data plane, which will be used to load necessary credential information.
Structure is documented below.
√
grpcEndpoint∑B¥:±
Æ
networksecurity,ClientTlsPolicyClientCertificateGrpcEndpointmgcp:networksecurity/ClientTlsPolicyClientCertificateGrpcEndpoint:ClientTlsPolicyClientCertificateGrpcEndpointygRPC specific configuration to access the gRPC server to obtain the cert and private key.
Structure is documented below.
:¬
‹
networksecurity;ClientTlsPolicyClientCertificateCertificateProviderInstanceãgcp:networksecurity/ClientTlsPolicyClientCertificateCertificateProviderInstance:ClientTlsPolicyClientCertificateCertificateProviderInstance‡
›⁄
pluginInstance" √Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "google_cloud_private_spiffe" to use Certificate Authority Service certificate provider instance.
:®
Æ
networksecurity,ClientTlsPolicyClientCertificateGrpcEndpointmgcp:networksecurity/ClientTlsPolicyClientCertificateGrpcEndpoint:ClientTlsPolicyClientCertificateGrpcEndpointu
sq
	targetUri" `The target URI of the gRPC endpoint. Only UDS path is supported, and should start with "unix:".
:†
ç
networksecurity!ClientTlsPolicyServerValidationCaWgcp:networksecurity/ClientTlsPolicyServerValidationCa:ClientTlsPolicyServerValidationCaç
äæ
certificateProviderInstanceËBÂ:‚
ﬂ
networksecurity<ClientTlsPolicyServerValidationCaCertificateProviderInstanceçgcp:networksecurity/ClientTlsPolicyServerValidationCaCertificateProviderInstance:ClientTlsPolicyServerValidationCaCertificateProviderInstance≥The certificate provider instance specification that will be passed to the data plane, which will be used to load necessary credential information.
Structure is documented below.
∆
grpcEndpoint∫B∑:¥
±
networksecurity-ClientTlsPolicyServerValidationCaGrpcEndpointogcp:networksecurity/ClientTlsPolicyServerValidationCaGrpcEndpoint:ClientTlsPolicyServerValidationCaGrpcEndpointygRPC specific configuration to access the gRPC server to obtain the cert and private key.
Structure is documented below.
:≈
ﬂ
networksecurity<ClientTlsPolicyServerValidationCaCertificateProviderInstanceçgcp:networksecurity/ClientTlsPolicyServerValidationCaCertificateProviderInstance:ClientTlsPolicyServerValidationCaCertificateProviderInstance‡
›⁄
pluginInstance" √Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "google_cloud_private_spiffe" to use Certificate Authority Service certificate provider instance.
:´
±
networksecurity-ClientTlsPolicyServerValidationCaGrpcEndpointogcp:networksecurity/ClientTlsPolicyServerValidationCaGrpcEndpoint:ClientTlsPolicyServerValidationCaGrpcEndpointu
sq
	targetUri" `The target URI of the gRPC endpoint. Only UDS path is supported, and should start with "unix:".
:á
¥
networksecurity.InterceptDeploymentGroupConnectedEndpointGroupqgcp:networksecurity/InterceptDeploymentGroupConnectedEndpointGroup:InterceptDeploymentGroupConnectedEndpointGroupN
LJ
nameB" <(Output)
Output only. A connected intercept endpoint group.
:á
¥
networksecurity.MirroringDeploymentGroupConnectedEndpointGroupqgcp:networksecurity/MirroringDeploymentGroupConnectedEndpointGroup:MirroringDeploymentGroupConnectedEndpointGroupN
LJ
nameB" <(Output)
Output only. A connected mirroring endpoint group.
:‚
∫
networksecurity0MirroringEndpointGroupAssociationLocationsDetailugcp:networksecurity/MirroringEndpointGroupAssociationLocationsDetail:MirroringEndpointGroupAssociationLocationsDetail¢
üñ
locationB" ÉResource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122. See documentation for resource type `networksecurity.googleapis.com/MirroringEndpointGroupAssociation`.


- - -
É
stateB" t(Output)
Output only. The association state in this location.
Possible values:
STATE_UNSPECIFIED
ACTIVE
OUT_OF_SYNC
:÷
ú
networksecurity&SecurityProfileThreatPreventionProfileagcp:networksecurity/SecurityProfileThreatPreventionProfile:SecurityProfileThreatPreventionProfile¥
±‘
severityOverridesŸB÷*”:–
Õ
networksecurity6SecurityProfileThreatPreventionProfileSeverityOverrideÅgcp:networksecurity/SecurityProfileThreatPreventionProfileSeverityOverride:SecurityProfileThreatPreventionProfileSeverityOverridecThe configuration for overriding threats actions by severity match.
Structure is documented below.
◊
threatOverrides“Bœ*Ã:…
∆
networksecurity4SecurityProfileThreatPreventionProfileThreatOverride}gcp:networksecurity/SecurityProfileThreatPreventionProfileThreatOverride:SecurityProfileThreatPreventionProfileThreatOverrideÓThe configuration for overriding threats actions by threat id match.
If a threat is matched both by configuration provided in severity overrides
and threat overrides, the threat overrides action is applied.
Structure is documented below.
:µ
Õ
networksecurity6SecurityProfileThreatPreventionProfileSeverityOverrideÅgcp:networksecurity/SecurityProfileThreatPreventionProfileSeverityOverride:SecurityProfileThreatPreventionProfileSeverityOverride‚
ﬂg
action" YThreat action override.
Possible values are: `ALERT`, `ALLOW`, `DEFAULT_ACTION`, `DENY`.
t
severity" dSeverity level to match.
Possible values are: `CRITICAL`, `HIGH`, `INFORMATIONAL`, `LOW`, `MEDIUM`.
:ñ
∆
networksecurity4SecurityProfileThreatPreventionProfileThreatOverride}gcp:networksecurity/SecurityProfileThreatPreventionProfileThreatOverride:SecurityProfileThreatPreventionProfileThreatOverride 
«^
action" PThreat action.
Possible values are: `ALERT`, `ALLOW`, `DEFAULT_ACTION`, `DENY`.
<
threatId" ,Vendor-specific ID of a threat to override.
'
typeB" (Output)
Type of threat.
:´

u
networksecurityServerTlsPolicyMtlsPolicyGgcp:networksecurity/ServerTlsPolicyMtlsPolicy:ServerTlsPolicyMtlsPolicy±	
Æ	À
clientValidationCas∑B¥*±:Æ
´
networksecurity+ServerTlsPolicyMtlsPolicyClientValidationCakgcp:networksecurity/ServerTlsPolicyMtlsPolicyClientValidationCa:ServerTlsPolicyMtlsPolicyClientValidationCa˘Required if the policy is to be used with Traffic Director. For external HTTPS load balancers it must be empty.
Defines the mechanism to obtain the Certificate Authority certificate to validate the client certificate.
Structure is documented below.
©
clientValidationModeB" äWhen the client presents an invalid certificate or no certificate to the load balancer, the clientValidationMode specifies how the client connection is handled.
Required if the policy is to be used with the external HTTPS load balancing. For Traffic Director it must be empty.
Possible values are: `CLIENT_VALIDATION_MODE_UNSPECIFIED`, `ALLOW_INVALID_OR_MISSING_CLIENT_CERT`, `REJECT_INVALID`.
±
clientValidationTrustConfigB" ãReference to the TrustConfig from certificatemanager.googleapis.com namespace.
If specified, the chain validation will be performed against certificates configured in the given TrustConfig.
Allowed only if the policy is to be used with external HTTPS load balancers.
:à	
´
networksecurity+ServerTlsPolicyMtlsPolicyClientValidationCakgcp:networksecurity/ServerTlsPolicyMtlsPolicyClientValidationCa:ServerTlsPolicyMtlsPolicyClientValidationCa◊
‘È
certificateProviderInstanceÜBÉ:Ä
˝
networksecurityFServerTlsPolicyMtlsPolicyClientValidationCaCertificateProviderInstance°gcp:networksecurity/ServerTlsPolicyMtlsPolicyClientValidationCaCertificateProviderInstance:ServerTlsPolicyMtlsPolicyClientValidationCaCertificateProviderInstance¿Optional if policy is to be used with Traffic Director. For external HTTPS load balancer must be empty.
Defines a mechanism to provision server identity (public and private keys). Cannot be combined with allowOpen as a permissive mode that allows both plain text and TLS is not supported.
Structure is documented below.
Â
grpcEndpointŸB÷:”
–
networksecurity7ServerTlsPolicyMtlsPolicyClientValidationCaGrpcEndpointÉgcp:networksecurity/ServerTlsPolicyMtlsPolicyClientValidationCaGrpcEndpoint:ServerTlsPolicyMtlsPolicyClientValidationCaGrpcEndpointygRPC specific configuration to access the gRPC server to obtain the cert and private key.
Structure is documented below.
:„
˝
networksecurityFServerTlsPolicyMtlsPolicyClientValidationCaCertificateProviderInstance°gcp:networksecurity/ServerTlsPolicyMtlsPolicyClientValidationCaCertificateProviderInstance:ServerTlsPolicyMtlsPolicyClientValidationCaCertificateProviderInstance‡
›⁄
pluginInstance" √Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "google_cloud_private_spiffe" to use Certificate Authority Service certificate provider instance.
: 
–
networksecurity7ServerTlsPolicyMtlsPolicyClientValidationCaGrpcEndpointÉgcp:networksecurity/ServerTlsPolicyMtlsPolicyClientValidationCaGrpcEndpoint:ServerTlsPolicyMtlsPolicyClientValidationCaGrpcEndpointu
sq
	targetUri" `The target URI of the gRPC endpoint. Only UDS path is supported, and should start with "unix:".
:§
ä
networksecurity ServerTlsPolicyServerCertificateUgcp:networksecurity/ServerTlsPolicyServerCertificate:ServerTlsPolicyServerCertificateî
ë»
certificateProviderInstanceÂB‚:ﬂ
‹
networksecurity;ServerTlsPolicyServerCertificateCertificateProviderInstanceãgcp:networksecurity/ServerTlsPolicyServerCertificateCertificateProviderInstance:ServerTlsPolicyServerCertificateCertificateProviderInstance¿Optional if policy is to be used with Traffic Director. For external HTTPS load balancer must be empty.
Defines a mechanism to provision server identity (public and private keys). Cannot be combined with allowOpen as a permissive mode that allows both plain text and TLS is not supported.
Structure is documented below.
√
grpcEndpoint∑B¥:±
Æ
networksecurity,ServerTlsPolicyServerCertificateGrpcEndpointmgcp:networksecurity/ServerTlsPolicyServerCertificateGrpcEndpoint:ServerTlsPolicyServerCertificateGrpcEndpointygRPC specific configuration to access the gRPC server to obtain the cert and private key.
Structure is documented below.
:¬
‹
networksecurity;ServerTlsPolicyServerCertificateCertificateProviderInstanceãgcp:networksecurity/ServerTlsPolicyServerCertificateCertificateProviderInstance:ServerTlsPolicyServerCertificateCertificateProviderInstance‡
›⁄
pluginInstance" √Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "google_cloud_private_spiffe" to use Certificate Authority Service certificate provider instance.
:®
Æ
networksecurity,ServerTlsPolicyServerCertificateGrpcEndpointmgcp:networksecurity/ServerTlsPolicyServerCertificateGrpcEndpoint:ServerTlsPolicyServerCertificateGrpcEndpointu
sq
	targetUri" `The target URI of the gRPC endpoint. Only UDS path is supported, and should start with "unix:".
:Õ
r
networkservicesEdgeCacheKeysetPublicKeyEgcp:networkservices/EdgeCacheKeysetPublicKey:EdgeCacheKeysetPublicKey÷
”æ
id" ≥The ID of the public key. The ID must be 1-63 characters long, and comply with RFC1035.
The name must be 1-64 characters long, and match the regular expression [a-zA-Z][a-zA-Z0-9_-]*
which means the first character must be a letter, and all following characters must be a dash, underscore, letter or digit.
Y
managedB
 HSet to true to have the CDN automatically manage this public key value.
¥
valueB" §The base64-encoded value of the Ed25519 public key. The base64 encoding can be padded (44 bytes) or unpadded (43 bytes).
Representations or encodings of the public key other than this will be rejected with an error.
**Note**: This property is sensitive and will not be displayed in the plan.
:∂
ê
networkservices"EdgeCacheKeysetValidationSharedKeyYgcp:networkservices/EdgeCacheKeysetValidationSharedKey:EdgeCacheKeysetValidationSharedKey†
ùö
secretVersion" ÑThe name of the secret version in Secret Manager.
The resource name of the secret version must be in the format `projects/*/secrets/*/versions/*` where the `*` values are replaced by the secrets themselves.
The secrets must be at least 16 bytes large.  The recommended secret size depends on the signature algorithm you are using.
* If you are using HMAC-SHA1, we suggest 20-byte secrets.
* If you are using HMAC-SHA256, we suggest 32-byte secrets.
See RFC 2104, Section 3 for more details on these recommendations.
:’
ê
networkservices"EdgeCacheOriginAwsV4AuthenticationYgcp:networkservices/EdgeCacheOriginAwsV4Authentication:EdgeCacheOriginAwsV4Authenticationø
ºK
accessKeyId" 8The access key ID your origin uses to identify the key.
G
originRegion" 3The name of the AWS region that your origin is in.
£
secretAccessKeyVersion" ÑThe Secret Manager secret version of the secret access key used by your origin.

This is the resource name of the secret version in the format 'projects/*/secrets/*/versions/*' where the '*' values are replaced by the project, secret, and version you require.
:®
ì
networkservices#EdgeCacheOriginOriginOverrideAction[gcp:networkservices/EdgeCacheOriginOriginOverrideAction:EdgeCacheOriginOriginOverrideActionè
å—
headerAction¿BΩ:∫
∑
networkservices/EdgeCacheOriginOriginOverrideActionHeaderActionsgcp:networkservices/EdgeCacheOriginOriginOverrideActionHeaderAction:EdgeCacheOriginOriginOverrideActionHeaderAction~The header actions, including adding and removing
headers, for request handled by this origin.
Structure is documented below.
µ

urlRewrite∫B∑:¥
±
networkservices-EdgeCacheOriginOriginOverrideActionUrlRewriteogcp:networkservices/EdgeCacheOriginOriginOverrideActionUrlRewrite:EdgeCacheOriginOriginOverrideActionUrlRewritejThe URL rewrite configuration for request that are
handled by this origin.
Structure is documented below.
:¬
∑
networkservices/EdgeCacheOriginOriginOverrideActionHeaderActionsgcp:networkservices/EdgeCacheOriginOriginOverrideActionHeaderAction:EdgeCacheOriginOriginOverrideActionHeaderActionÖ
Çˇ
requestHeadersToAdds˝B˙*˜:Ù
Ò
networkservicesBEdgeCacheOriginOriginOverrideActionHeaderActionRequestHeadersToAddôgcp:networkservices/EdgeCacheOriginOriginOverrideActionHeaderActionRequestHeadersToAdd:EdgeCacheOriginOriginOverrideActionHeaderActionRequestHeadersToAddgDescribes a header to add.
You may add a maximum of 25 request headers.
Structure is documented below.
:ˇ
Ò
networkservicesBEdgeCacheOriginOriginOverrideActionHeaderActionRequestHeadersToAddôgcp:networkservices/EdgeCacheOriginOriginOverrideActionHeaderActionRequestHeadersToAdd:EdgeCacheOriginOriginOverrideActionHeaderActionRequestHeadersToAddà
Ö1

headerName" The name of the header to add.
3
headerValue"  The value of the header to add.
ö
replaceB
 àWhether to replace all existing headers with the same name.
By default, added header values are appended
to the response or request headers with the
same field names. The added values are
separated by commas.
To overwrite existing values, set `replace` to `true`.
:Ñ
±
networkservices-EdgeCacheOriginOriginOverrideActionUrlRewriteogcp:networkservices/EdgeCacheOriginOriginOverrideActionUrlRewrite:EdgeCacheOriginOriginOverrideActionUrlRewriteÕ
 «
hostRewriteB" ±Prior to forwarding the request to the selected
origin, the request's host header is replaced with
contents of the hostRewrite.
This value must be between 1 and 255 characters.
:Ñ
Å
networkservicesEdgeCacheOriginOriginRedirectOgcp:networkservices/EdgeCacheOriginOriginRedirect:EdgeCacheOriginOriginRedirect˝
˙˜
redirectConditionsB*" ÿThe set of redirect response codes that the CDN
follows. Values of
[RedirectConditions](https://cloud.google.com/media-cdn/docs/reference/rest/v1/projects.locations.edgeCacheOrigins#redirectconditions)
are accepted.
:⁄
l
networkservicesEdgeCacheOriginTimeoutAgcp:networkservices/EdgeCacheOriginTimeout:EdgeCacheOriginTimeoutÈ
Ê¬
connectTimeoutB" ©The maximum duration to wait for a single origin connection to be established, including DNS lookup, TLS handshake and TCP/QUIC connection establishment.
Defaults to 5 seconds. The timeout must be a value between 1s and 15s.
The connectTimeout capped by the deadline set by the request's maxAttemptsTimeout.  The last connection attempt may have a smaller connectTimeout in order to adhere to the overall maxAttemptsTimeout.
‡
maxAttemptsTimeoutB" √The maximum time across all connection attempts to the origin, including failover origins, before returning an error to the client. A HTTP 504 will be returned if the timeout is reached before a response is returned.
Defaults to 15 seconds. The timeout must be a value between 1s and 30s.
If a failoverOrigin is specified, the maxAttemptsTimeout of the first configured origin sets the deadline for all connection attempts across all failoverOrigins.
è
readTimeoutB" ˘The maximum duration to wait between reads of a single HTTP connection/stream.
Defaults to 15 seconds.  The timeout must be a value between 1s and 30s.
The readTimeout is capped by the responseTimeout.  All reads of the HTTP connection/stream must be completed by the deadline set by the responseTimeout.
If the response headers have already been written to the connection, the response will be truncated and logged.

<a name="nested_aws_v4_authentication"></a>The `aws_v4_authentication` block supports:
©
responseTimeoutB" èThe maximum duration to wait for the last byte of a response to arrive when reading from the HTTP connection/stream.
Defaults to 30 seconds. The timeout must be a value between 1s and 120s.
The responseTimeout starts after the connection has been established.
This also applies to HTTP Chunked Transfer Encoding responses, and/or when an open-ended Range request is made to the origin. Origins that take longer to write additional bytes to the response than the configured responseTimeout will result in an error being returned to the client.
If the response headers have already been written to the connection, the response will be truncated and logged.
:ä
u
networkservicesEdgeCacheServiceLogConfigGgcp:networkservices/EdgeCacheServiceLogConfig:EdgeCacheServiceLogConfigê
çX
enableB
 HSpecifies whether to enable logging for traffic served by this service.
∞

sampleRateB õConfigures the sampling rate of requests, where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported. The default value is 1.0, and the value of the field must be in [0, 1].
This field can only be specified if logging is enabled for this service.
:«
o
networkservicesEdgeCacheServiceRoutingCgcp:networkservices/EdgeCacheServiceRouting:EdgeCacheServiceRouting”
–⁄
	hostRulesê*ç:ä
á
networkservicesEdgeCacheServiceRoutingHostRuleSgcp:networkservices/EdgeCacheServiceRoutingHostRule:EdgeCacheServiceRoutingHostRuleπThe list of hostRules to match against. These rules define which hostnames the EdgeCacheService will match against, and which route configurations apply.
Structure is documented below.

pathMatchersô*ñ:ì
ê
networkservices"EdgeCacheServiceRoutingPathMatcherYgcp:networkservices/EdgeCacheServiceRoutingPathMatcher:EdgeCacheServiceRoutingPathMatcher√The list of pathMatchers referenced via name by hostRules. PathMatcher is used to match the path portion of the URL when a HostRule matches the URL's host portion.
Structure is documented below.
:Ñ

á
networkservicesEdgeCacheServiceRoutingHostRuleSgcp:networkservices/EdgeCacheServiceRoutingHostRule:EdgeCacheServiceRoutingHostRule˜
ÙC
descriptionB" .A human-readable description of the hostRule.
‹
hosts*" ÃThe list of host patterns to match.
Host patterns must be valid hostnames. Ports are not allowed. Wildcard hosts are supported in the suffix or prefix form. * matches any string of ([a-z0-9-.]*). It does not match the empty string.
When multiple hosts are specified, hosts are matched in the following priority:
1. Exact domain names: ``www.foo.com``.
2. Suffix domain wildcards: ``*.foo.com`` or ``*-bar.foo.com``.
3. Prefix domain wildcards: ``foo.*`` or ``foo-*``.
4. Special wildcard ``*`` matching any domain.
Notes:
The wildcard will not match the empty string. e.g. ``*-bar.foo.com`` will match ``baz-bar.foo.com`` but not ``-bar.foo.com``. The longest wildcards match first. Only a single host in the entire service can match on ``*``. A domain must be unique across all configured hosts within a service.
Hosts are matched against the HTTP Host header, or for HTTP/2 and HTTP/3, the ":authority" header, from the incoming request.
You may specify up to 10 hosts.
N
pathMatcher" ;The name of the pathMatcher associated with this hostRule.
:ƒ
ê
networkservices"EdgeCacheServiceRoutingPathMatcherYgcp:networkservices/EdgeCacheServiceRoutingPathMatcher:EdgeCacheServiceRoutingPathMatcherÆ
´C
descriptionB" .A human-readable description of the resource.
L
name" @The name to which this PathMatcher is referred by the HostRule.
ï

routeRules¥*±:Æ
´
networkservices+EdgeCacheServiceRoutingPathMatcherRouteRulekgcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRule:EdgeCacheServiceRoutingPathMatcherRouteRuleœThe routeRules to match against. routeRules support advanced routing behaviour, and can match on paths, headers and query parameters, as well as status codes and HTTP methods.
Structure is documented below.
:–
´
networkservices+EdgeCacheServiceRoutingPathMatcherRouteRulekgcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRule:EdgeCacheServiceRoutingPathMatcherRouteRuleü
úD
descriptionB" /A human-readable description of the routeRule.
Ë
headerActionŸB÷:”
–
networkservices7EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionÉgcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderAction:EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderAction|The header actions, including adding & removing headers, for requests that match this route.
Structure is documented below.
∆

matchRulesœ*Ã:…
∆
networkservices4EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRule}gcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRule:EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleÂThe list of criteria for matching attributes of a request to this routeRule. This list has OR semantics: the request matches this routeRule when any of the matchRules are satisfied. However predicates
within a given matchRule have AND semantics. All predicates within a matchRule must match for the request to match the rule.
Structure is documented below.
ﬁ
originB" ÕThe Origin resource that requests to this route should fetch from when a matching response is not in cache. Origins can be defined as short names ("my-origin") or fully-qualified resource URLs - e.g. "networkservices.googleapis.com/projects/my-project/global/edgecacheorigins/my-origin"
Only one of origin or urlRedirect can be set.
¨
priority" õThe priority of this route rule, where 1 is the highest priority.
You cannot configure two or more routeRules with the same priority. Priority for each rule must be set to a number between 1 and 999 inclusive.
Priority numbers can have gaps, which enable you to add or remove rules in the future without affecting the rest of the rules. For example, 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers
to which you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the future without any impact on existing rules.
¬
routeAction÷B”:–
Õ
networkservices6EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionÅgcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleRouteAction:EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionŸIn response to a matching path, the routeAction performs advanced routing actions like URL rewrites, header transformations, etc. prior to forwarding the request to the selected origin.
Structure is documented below.
 
urlRedirect÷B”:–
Õ
networkservices6EdgeCacheServiceRoutingPathMatcherRouteRuleUrlRedirectÅgcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleUrlRedirect:EdgeCacheServiceRoutingPathMatcherRouteRuleUrlRedirectbThe URL redirect configuration for requests that match this route.
Structure is documented below.
:˜
–
networkservices7EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionÉgcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderAction:EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderAction°
ûÊ
requestHeaderToAddsíBè*å:â
Ü
networkservicesIEdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToAddßgcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToAdd:EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToAdd:Describes a header to add.
Structure is documented below.
”
requestHeaderToRemovesõBò*ï:í
è
networkservicesLEdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToRemove≠gcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToRemove:EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToRemoveöA list of header names for headers that need to be removed from the request prior to forwarding the request to the origin.
Structure is documented below.
Ç
responseHeaderToAddsïBí*è:å
â
networkservicesJEdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToAdd©gcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToAdd:EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToAdd—Headers to add to the response prior to sending it back to the client.
Response headers are only sent to the client, and do not have an effect on the cache serving the response.
Structure is documented below.
◊
responseHeaderToRemovesûBõ*ò:ï
í
networkservicesMEdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToRemoveØgcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToRemove:EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToRemoveöA list of header names for headers that need to be removed from the request prior to forwarding the request to the origin.
Structure is documented below.
:∆
Ü
networkservicesIEdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToAddßgcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToAdd:EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToAdd∫
∑1

headerName" The name of the header to add.
3
headerValue"  The value of the header to add.
M
replaceB
 <Whether to replace all existing headers with the same name.
:Ã
è
networkservicesLEdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToRemove≠gcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToRemove:EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionRequestHeaderToRemove8
64

headerName" "The name of the header to remove.
:…
â
networkservicesJEdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToAdd©gcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToAdd:EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToAdd∫
∑1

headerName" The name of the header to add.
3
headerValue"  The value of the header to add.
M
replaceB
 <Whether to replace all existing headers with the same name.
:Ë
í
networkservicesMEdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToRemoveØgcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToRemove:EdgeCacheServiceRoutingPathMatcherRouteRuleHeaderActionResponseHeaderToRemove–
Õ 

headerName" ∑Headers to remove from the response prior to sending it back to the client.
Response headers are only sent to the client, and do not have an effect on the cache serving the response.
:√
∆
networkservices4EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRule}gcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRule:EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRule˜
ÙÂ
fullPathMatchB" ÕFor satisfying the matchRule condition, the path of the request must exactly match the value specified in fullPathMatch after removing any query parameters and anchor that may be part of the original URL.
ë
headerMatchesÙBÒ*Ó:Î
Ë
networkservices?EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleHeaderMatchìgcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleHeaderMatch:EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleHeaderMatchàSpecifies a list of header match criteria, all of which must match corresponding headers in the request.
Structure is documented below.
]

ignoreCaseB
 ISpecifies that prefixMatch and fullPathMatch matches are case sensitive.
∞
pathTemplateMatchB" îFor satisfying the matchRule condition, the path of the request
must match the wildcard pattern specified in pathTemplateMatch
after removing any query parameters and anchor that may be part
of the original URL.
pathTemplateMatch must be between 1 and 255 characters
(inclusive).  The pattern specified by pathTemplateMatch may
have at most 5 wildcard operators and at most 5 variable
captures in total.
ù
prefixMatchB" áFor satisfying the matchRule condition, the request's path must begin with the specified prefixMatch. prefixMatch must begin with a /.
√
queryParameterMatchesåBâ*Ü:É
Ä
networkservicesGEdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleQueryParameterMatch£gcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleQueryParameterMatch:EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleQueryParameterMatchöSpecifies a list of query parameter match criteria, all of which must match corresponding query parameters in the request.
Structure is documented below.
:¶
Ë
networkservices?EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleHeaderMatchìgcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleHeaderMatch:EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleHeaderMatch∏
µY

exactMatchB" EThe value of the header should exactly match contents of exactMatch.
/

headerName" The header name to match on.
€
invertMatchB
 ≈If set to false (default), the headerMatch is considered a match if the match criteria above are met.
If set to true, the headerMatch is considered a match if the match criteria above are NOT met.
Z
prefixMatchB" EThe value of the header must start with the contents of prefixMatch.
í
presentMatchB
 |A header with the contents of headerName must exist. The match takes place whether or not the request's header has a value.
X
suffixMatchB" CThe value of the header must end with the contents of suffixMatch.
:”
Ä
networkservicesGEdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleQueryParameterMatch£gcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleQueryParameterMatch:EdgeCacheServiceRoutingPathMatcherRouteRuleMatchRuleQueryParameterMatchÕ
 ~

exactMatchB" jThe queryParameterMatch matches if the value of the parameter exactly matches the contents of exactMatch.
ó
name" äThe name of the query parameter to match. The query parameter must exist in the request, in the absence of which the request match fails.
≠
presentMatchB
 ñSpecifies that the queryParameterMatch matches if the request contains the query parameter, irrespective of whether the parameter has a value or not.
:Ê

Õ
networkservices6EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionÅgcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleRouteAction:EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionì	
ê	â
	cdnPolicyÒBÓ:Î
Ë
networkservices?EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyìgcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicy:EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyáThe policy to use for defining caching and signed request behaviour for requests that match this route.
Structure is documented below.
ò

corsPolicyÙBÒ:Ó
Î
networkservices@EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCorsPolicyïgcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCorsPolicy:EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCorsPolicyíCORSPolicy defines Cross-Origin-Resource-Sharing configuration, including which CORS response headers will be set.
Structure is documented below.
Ê

urlRewriteÙBÒ:Ó
Î
networkservices@EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionUrlRewriteïgcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionUrlRewrite:EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionUrlRewriteaThe URL rewrite configuration for requests that match this route.
Structure is documented below.
:È4
Ë
networkservices?EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyìgcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicy:EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicy˚2
¯2ÿ
addSignaturesòBï:í
è
networkservicesLEdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyAddSignatures≠gcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyAddSignatures:EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyAddSignatures´Enable signature generation or propagation on this route.
This field may only be specified when signedRequestMode is set to REQUIRE_TOKENS.
Structure is documented below.
ê
cacheKeyPolicyõBò:ï
í
networkservicesMEdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyCacheKeyPolicyØgcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyCacheKeyPolicy:EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyCacheKeyPolicy`Defines the request parameters that contribute to the cache key.
Structure is documented below.
∂
	cacheModeB" ¢Cache modes allow users to control the behaviour of the cache, what content it should cache automatically, whether to respect origin headers, or whether to unconditionally cache all responses.
For all cache modes, Cache-Control headers will be passed to the client. Use clientTtl to override what is sent to the client.
Possible values are: `CACHE_ALL_STATIC`, `USE_ORIGIN_HEADERS`, `FORCE_CACHE_ALL`, `BYPASS_CACHE`.
Ë
	clientTtlB" ‘Specifies a separate client (e.g. browser client) TTL, separate from the TTL used by the edge caches. Leaving this empty will use the same cache TTL for both the CDN and the client-facing response.
- The TTL must be > 0 and <= 86400s (1 day)
- The clientTtl cannot be larger than the defaultTtl (if set)
- Fractions of a second are not allowed.
Omit this field to use the defaultTtl, or the max-age set by the origin, as the client-facing TTL.
When the cache mode is set to "USE_ORIGIN_HEADERS" or "BYPASS_CACHE", you must omit this field.
A duration in seconds terminated by 's'. Example: "3s".
‡

defaultTtlB" ÀSpecifies the default TTL for cached content served by this origin for responses that do not have an existing valid TTL (max-age or s-max-age).
Defaults to 3600s (1 hour).
- The TTL must be >= 0 and <= 31,536,000 seconds (1 year)
- Setting a TTL of "0" means "always revalidate" (equivalent to must-revalidate)
- The value of defaultTTL cannot be set to a value greater than that of maxTTL.
- Fractions of a second are not allowed.
- When the cacheMode is set to FORCE_CACHE_ALL, the defaultTTL will overwrite the TTL set in all responses.
Note that infrequently accessed objects may be evicted from the cache before the defined TTL. Objects that expire will be revalidated with the origin.
When the cache mode is set to "USE_ORIGIN_HEADERS" or "BYPASS_CACHE", you must omit this field.
A duration in seconds terminated by 's'. Example: "3s".
Ï
maxTtlB" €Specifies the maximum allowed TTL for cached content served by this origin.
Defaults to 86400s (1 day).
Cache directives that attempt to set a max-age or s-maxage higher than this, or an Expires header more than maxTtl seconds in the future will be capped at the value of maxTTL, as if it were the value of an s-maxage Cache-Control directive.
- The TTL must be >= 0 and <= 31,536,000 seconds (1 year)
- Setting a TTL of "0" means "always revalidate"
- The value of maxTtl must be equal to or greater than defaultTtl.
- Fractions of a second are not allowed.
When the cache mode is set to "USE_ORIGIN_HEADERS", "FORCE_CACHE_ALL", or "BYPASS_CACHE", you must omit this field.
A duration in seconds terminated by 's'. Example: "3s".
Ó
negativeCachingB
 ‘Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects. This can reduce the load on your origin and improve end-user experience by reducing response latency.
By default, the CDNPolicy will apply the following default TTLs to these status codes:
- HTTP 300 (Multiple Choice), 301, 308 (Permanent Redirects): 10m
- HTTP 404 (Not Found), 410 (Gone), 451 (Unavailable For Legal Reasons): 120s
- HTTP 405 (Method Not Found), 414 (URI Too Long), 501 (Not Implemented): 60s
These defaults can be overridden in negativeCachingPolicy
‘
negativeCachingPolicyB2" ≤Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
- Omitting the policy and leaving negativeCaching enabled will use the default TTLs for each status code, defined in negativeCaching.
- TTLs must be >= 0 (where 0 is "always revalidate") and <= 86400s (1 day)
Note that when specifying an explicit negativeCachingPolicy, you should take care to specify a cache TTL for all response codes that you wish to cache. The CDNPolicy will not apply any default negative caching when a policy exists.
Å
signedRequestKeysetB" dThe EdgeCacheKeyset containing the set of public keys used to validate signed requests at the edge.
á
!signedRequestMaximumExpirationTtlB" €Limit how far into the future the expiration time of a signed request may be.
When set, a signed request is rejected if its expiration time is later than now + signedRequestMaximumExpirationTtl, where now is the time at which the signed request is first handled by the CDN.
- The TTL must be > 0.
- Fractions of a second are not allowed.
By default, signedRequestMaximumExpirationTtl is not set and the expiration time of a signed request may be arbitrarily far into future.
ﬂ
signedRequestModeB" √Whether to enforce signed requests. The default value is DISABLED, which means all content is public, and does not authorize access.
You must also set a signedRequestKeyset to enable signed requests.
When set to REQUIRE_SIGNATURES, all matching requests will have their signature validated. Requests that were not signed with the corresponding private key, or that are otherwise invalid (expired, do not match the signature, IP address, or header) will be rejected with a HTTP 403 and (if enabled) logged.
Possible values are: `DISABLED`, `REQUIRE_SIGNATURES`, `REQUIRE_TOKENS`.
Ÿ
signedTokenOptionsßB§:°
û
networkservicesQEdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicySignedTokenOptions∑gcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicySignedTokenOptions:EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicySignedTokenOptionsòAdditional options for signed tokens.
signedTokenOptions may only be specified when signedRequestMode is REQUIRE_TOKENS.
Structure is documented below.
:À
è
networkservicesLEdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyAddSignatures≠gcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyAddSignatures:EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyAddSignatures∂
≥¥
actions" §The actions to take to add signatures to responses.
Each value may be one of: `GENERATE_COOKIE`, `GENERATE_TOKEN_HLS_COOKIELESS`, `PROPAGATE_TOKEN_HLS_COOKIELESS`.
ü
copiedParametersB*" ÇThe parameters to copy from the verified token to the generated token.
Only the following parameters may be copied:
* `PathGlobs`
Â
keysetB" ‘The keyset to use for signature generation.
The following are both valid paths to an EdgeCacheKeyset resource:
* `projects/project/locations/global/edgeCacheKeysets/yourKeyset`
* `yourKeyset`
This must be specified when the GENERATE_COOKIE or GENERATE_TOKEN_HLS_COOKIELESS actions are specified.  This field may not be specified otherwise.
ﬂ
tokenQueryParameterB" ¡The query parameter in which to put the generated token.
If not specified, defaults to `edge-cache-token`.
If specified, the name must be 1-64 characters long and match the regular expression `a-zA-Z*` which means the first character must be a letter, and all following characters must be a dash, underscore, letter or digit.
This field may only be set when the GENERATE_TOKEN_HLS_COOKIELESS or PROPAGATE_TOKEN_HLS_COOKIELESS actions are specified.
ç
tokenTtlB" ˙The duration the token is valid starting from the moment the token is first generated.
Defaults to `86400s` (1 day).
The TTL must be >= 0 and <= 604,800 seconds (1 week).
This field may only be specified when the GENERATE_COOKIE or GENERATE_TOKEN_HLS_COOKIELESS actions are specified.
A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
:Ñ
í
networkservicesMEdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyCacheKeyPolicyØgcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyCacheKeyPolicy:EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicyCacheKeyPolicyÏ
Èƒ
excludeHostB
 ÆIf true, requests to different hosts will be cached separately.
Note: this should only be enabled if hosts share the same origin and content. Removing the host from the cache key may inadvertently result in different objects being cached than intended, depending on which route the first user matched.
’
excludeQueryStringB
 ∏If true, exclude query string parameters from the cache key
If false (the default), include the query string parameters in
the cache key according to includeQueryParameters and
excludeQueryParameters. If neither includeQueryParameters nor
excludeQueryParameters is set, the entire query string will be
included.
ò
excludedQueryParametersB*" ÙNames of query string parameters to exclude from cache keys. All other parameters will be included.
Either specify includedQueryParameters or excludedQueryParameters, not both. '&' and '=' will be percent encoded and not treated as delimiters.
U
includeProtocolB
 <If true, http and https requests will be cached separately.
∞
includedCookieNamesB*" êNames of Cookies to include in cache keys.  The cookie name and cookie value of each cookie named will be used as part of the cache key.
Cookie names:
- must be valid RFC 6265 "cookie-name" tokens
- are case sensitive
- cannot start with "Edge-Cache-" (case insensitive)
Note that specifying several cookies, and/or cookies that have a large range of values (e.g., per-user) will dramatically impact the cache hit rate, and may result in a higher eviction rate and reduced performance.
You may specify up to three cookie names.
â
includedHeaderNamesB*" ÈNames of HTTP request headers to include in cache keys. The value of the header field will be used as part of the cache key.
- Header names must be valid HTTP RFC 7230 header field values.
- Header field names are case insensitive
- To include the HTTP method, use ":method"
Note that specifying several headers, and/or headers that have a large range of values (e.g. per-user) will dramatically impact the cache hit rate, and may result in a higher eviction rate and reduced performance.
ñ
includedQueryParametersB*" ÚNames of query string parameters to include in cache keys. All other parameters will be excluded.
Either specify includedQueryParameters or excludedQueryParameters, not both. '&' and '=' will be percent encoded and not treated as delimiters.
:œ
û
networkservicesQEdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicySignedTokenOptions∑gcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicySignedTokenOptions:EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCdnPolicySignedTokenOptions´
®Á
allowedSignatureAlgorithmsB*" ¿The allowed signature algorithms to use.
Defaults to using only ED25519.
You may specify up to 3 signature algorithms to use.
Each value may be one of: `ED25519`, `HMAC_SHA_256`, `HMAC_SHA1`.
ª
tokenQueryParameterB" ùThe query parameter in which to find the token.
The name must be 1-64 characters long and match the regular expression `a-zA-Z*` which means the first character must be a letter, and all following characters must be a dash, underscore, letter or digit.
Defaults to `edge-cache-token`.
:Ë
Î
networkservices@EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCorsPolicyïgcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCorsPolicy:EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionCorsPolicy˜

Ù
›
allowCredentialsB
 ¬In response to a preflight request, setting this to true indicates that the actual request can include user credentials.
This translates to the Access-Control-Allow-Credentials response header.
d
allowHeadersB*" LSpecifies the content for the Access-Control-Allow-Headers response header.
d
allowMethodsB*" LSpecifies the content for the Access-Control-Allow-Methods response header.
•
allowOriginsB*" åSpecifies the list of origins that will be allowed to do CORS requests.
This translates to the Access-Control-Allow-Origin response header.
ë
disabledB
 If true, specifies the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.
e
exposeHeadersB*" LSpecifies the content for the Access-Control-Allow-Headers response header.
¢
maxAge" ìSpecifies how long results of a preflight request can be cached by a client in seconds. Note that many browser clients enforce a maximum TTL of 600s (10 minutes).
- Setting the value to -1 forces a pre-flight check for all requests (not recommended)
- A maximum TTL of 86400s can be set, but note that (as above) some clients may force pre-flight checks at a more regular interval.
- This translates to the Access-Control-Max-Age header.
A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
:Û
Î
networkservices@EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionUrlRewriteïgcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionUrlRewrite:EdgeCacheServiceRoutingPathMatcherRouteRuleRouteActionUrlRewriteÇ
ˇë
hostRewriteB" |Prior to forwarding the request to the selected origin, the request's host header is replaced with contents of hostRewrite.
°
pathPrefixRewriteB" ÖPrior to forwarding the request to the selected origin, the matching portion of the request's path is replaced by pathPrefixRewrite.
ƒ
pathTemplateRewriteB" ¶Prior to forwarding the request to the selected origin, if the
request matched a pathTemplateMatch, the matching portion of the
request's path is replaced re-written using the pattern specified
by pathTemplateRewrite.
pathTemplateRewrite must be between 1 and 255 characters
(inclusive), must start with a '/', and must only use variables
captured by the route's pathTemplate matchers.
pathTemplateRewrite may only be used when all of a route's
MatchRules specify pathTemplate.
Only one of pathPrefixRewrite and pathTemplateRewrite may be
specified.
:Ë
Õ
networkservices6EdgeCacheServiceRoutingPathMatcherRouteRuleUrlRedirectÅgcp:networkservices/EdgeCacheServiceRoutingPathMatcherRouteRuleUrlRedirect:EdgeCacheServiceRoutingPathMatcherRouteRuleUrlRedirectï
í
hostRedirectB" iThe host that will be used in the redirect response instead of the one that was supplied in the request.
¢
httpsRedirectB
 äIf set to true, the URL scheme in the redirected request is set to https. If set to false, the URL scheme of the redirected request will remain the same as that of the request.
This can only be set if there is at least one (1) edgeSslCertificate set on the service.
È
pathRedirectB" “The path that will be used in the redirect response instead of the one that was supplied in the request.
pathRedirect cannot be supplied together with prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the original request will be used for the redirect.
The path value must be between 1 and 1024 characters.
‹
prefixRedirectB" √The prefix that replaces the prefixMatch specified in the routeRule, retaining the remaining portion of the URL before redirecting the request.
prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or neither. If neither is supplied, the path of the original request will be used for the redirect.
À
redirectResponseCodeB" ¨The HTTP Status code to use for this RedirectAction.
The supported values are:
- `MOVED_PERMANENTLY_DEFAULT`, which is the default value and corresponds to 301.
- `FOUND`, which corresponds to 302.
- `SEE_OTHER` which corresponds to 303.
- `TEMPORARY_REDIRECT`, which corresponds to 307. in this case, the request method will be retained.
- `PERMANENT_REDIRECT`, which corresponds to 308. in this case, the request method will be retained.
Possible values are: `MOVED_PERMANENTLY_DEFAULT`, `FOUND`, `SEE_OTHER`, `TEMPORARY_REDIRECT`, `PERMANENT_REDIRECT`.
–

stripQueryB
 ªIf set to true, any accompanying query portion of the original URL is removed prior to redirecting the request. If set to false, the query portion of the original URL is retained.

- - -
: 
Å
networkservicesEndpointPolicyEndpointMatcherOgcp:networkservices/EndpointPolicyEndpointMatcher:EndpointPolicyEndpointMatcher√
¿Ω
metadataLabelMatcher√:¿
Ω
networkservices1EndpointPolicyEndpointMatcherMetadataLabelMatcherwgcp:networkservices/EndpointPolicyEndpointMatcherMetadataLabelMatcher:EndpointPolicyEndpointMatcherMetadataLabelMatcher_The matcher is based on node metadata presented by xDS clients.
Structure is documented below.
:‘
Ω
networkservices1EndpointPolicyEndpointMatcherMetadataLabelMatcherwgcp:networkservices/EndpointPolicyEndpointMatcherMetadataLabelMatcher:EndpointPolicyEndpointMatcherMetadataLabelMatcherë
éx
metadataLabelMatchCriteria" VSpecifies how matching should be done.
Possible values are: `MATCH_ANY`, `MATCH_ALL`.
ë
metadataLabelsÒBÓ*Î:Ë
Â
networkservices>EndpointPolicyEndpointMatcherMetadataLabelMatcherMetadataLabelëgcp:networkservices/EndpointPolicyEndpointMatcherMetadataLabelMatcherMetadataLabel:EndpointPolicyEndpointMatcherMetadataLabelMatcherMetadataLabeläThe list of label value pairs that must match labels in the provided metadata based on filterMatchCriteria
Structure is documented below.
:∑
Â
networkservices>EndpointPolicyEndpointMatcherMetadataLabelMatcherMetadataLabelëgcp:networkservices/EndpointPolicyEndpointMatcherMetadataLabelMatcherMetadataLabel:EndpointPolicyEndpointMatcherMetadataLabelMatcherMetadataLabelÃ
…M
	labelName" <Required. Label name presented as key in xDS Node Metadata.
x

labelValue" fRequired. Label value presented as value corresponding to the above key, in xDS Node Metadata.

- - -
:¸
ç
networkservices!EndpointPolicyTrafficPortSelectorWgcp:networkservices/EndpointPolicyTrafficPortSelector:EndpointPolicyTrafficPortSelectorÈ
Ê„
ports*" ”List of ports. Can be port numbers or port range (example, [80-90] specifies all ports from 80 to 90, including 80 and 90) or named ports or * to specify all ports. If the list is empty, all ports are selected.
:ï
Q
networkservicesGrpcRouteRule/gcp:networkservices/GrpcRouteRule:GrpcRouteRuleø
ºÕ
actioniBg:e
c
networkservicesGrpcRouteRuleAction;gcp:networkservices/GrpcRouteRuleAction:GrpcRouteRuleActionXRequired. A detailed rule defining how to route traffic.
Structure is documented below.
È
matcheshBf*d:b
`
networkservicesGrpcRouteRuleMatch9gcp:networkservices/GrpcRouteRuleMatch:GrpcRouteRuleMatchtMatches define conditions used for matching the rule against incoming gRPC requests.
Structure is documented below.
:˝
c
networkservicesGrpcRouteRuleAction;gcp:networkservices/GrpcRouteRuleAction:GrpcRouteRuleActionï
í¯
destinationsêBç*ä:á
Ñ
networkservicesGrpcRouteRuleActionDestinationQgcp:networkservices/GrpcRouteRuleActionDestination:GrpcRouteRuleActionDestinationUThe destination to which traffic should be forwarded.
Structure is documented below.
ﬂ
faultInjectionPolicy®B•:¢
ü
networkservices'GrpcRouteRuleActionFaultInjectionPolicycgcp:networkservices/GrpcRouteRuleActionFaultInjectionPolicy:GrpcRouteRuleActionFaultInjectionPolicyõThe specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
Structure is documented below.
ı
retryPolicyçBä:á
Ñ
networkservicesGrpcRouteRuleActionRetryPolicyQgcp:networkservices/GrpcRouteRuleActionRetryPolicy:GrpcRouteRuleActionRetryPolicyVSpecifies the retry policy associated with this route.
Structure is documented below.
;
timeoutB" *Specifies the timeout for selected route.
: 
Ñ
networkservicesGrpcRouteRuleActionDestinationQgcp:networkservices/GrpcRouteRuleActionDestination:GrpcRouteRuleActionDestination¿
ΩF
serviceNameB" 1The URL of a BackendService to route traffic to.
s
weightB cSpecifies the proportion of requests forwarded to the backend referenced by the serviceName field.
:‘
ü
networkservices'GrpcRouteRuleActionFaultInjectionPolicycgcp:networkservices/GrpcRouteRuleActionFaultInjectionPolicy:GrpcRouteRuleActionFaultInjectionPolicyØ
¨”
abort∑B¥:±
Æ
networkservices,GrpcRouteRuleActionFaultInjectionPolicyAbortmgcp:networkservices/GrpcRouteRuleActionFaultInjectionPolicyAbort:GrpcRouteRuleActionFaultInjectionPolicyAbortèSpecification of how client requests are aborted as part of fault injection before being sent to a destination.
Structure is documented below.
”
delay∑B¥:±
Æ
networkservices,GrpcRouteRuleActionFaultInjectionPolicyDelaymgcp:networkservices/GrpcRouteRuleActionFaultInjectionPolicyDelay:GrpcRouteRuleActionFaultInjectionPolicyDelayèSpecification of how client requests are delayed as part of fault injection before being sent to a destination.
Structure is documented below.
:ƒ
Æ
networkservices,GrpcRouteRuleActionFaultInjectionPolicyAbortmgcp:networkservices/GrpcRouteRuleActionFaultInjectionPolicyAbort:GrpcRouteRuleActionFaultInjectionPolicyAbortê
çD

httpStatusB 0The HTTP status code used to abort the request.
E

percentageB 1The percentage of traffic which will be aborted.
:”
Æ
networkservices,GrpcRouteRuleActionFaultInjectionPolicyDelaymgcp:networkservices/GrpcRouteRuleActionFaultInjectionPolicyDelay:GrpcRouteRuleActionFaultInjectionPolicyDelayü
úI

fixedDelayB" 5Specify a fixed delay before forwarding the request.
O

percentageB ;The percentage of traffic on which delay will be injected.
:π
Ñ
networkservicesGrpcRouteRuleActionRetryPolicyQgcp:networkservices/GrpcRouteRuleActionRetryPolicy:GrpcRouteRuleActionRetryPolicyØ
¨D

numRetriesB 0Specifies the allowed number of retries.

- - -
„
retryConditionsB*" «Specifies one or more conditions when this retry policy applies.
Each value may be one of: `connect-failure`, `refused-stream`, `cancelled`, `deadline-exceeded`, `resource-exhausted`, `unavailable`.
:Õ
`
networkservicesGrpcRouteRuleMatch9gcp:networkservices/GrpcRouteRuleMatch:GrpcRouteRuleMatchË
Â·
headerszBx*v:t
r
networkservicesGrpcRouteRuleMatchHeaderEgcp:networkservices/GrpcRouteRuleMatchHeader:GrpcRouteRuleMatchHeaderZSpecifies a list of HTTP request headers to match against.
Structure is documented below.
˛
methodxBv:t
r
networkservicesGrpcRouteRuleMatchMethodEgcp:networkservices/GrpcRouteRuleMatchMethod:GrpcRouteRuleMatchMethodzA gRPC method to match against. If this field is empty or omitted, will match all methods.
Structure is documented below.
:‡
r
networkservicesGrpcRouteRuleMatchHeaderEgcp:networkservices/GrpcRouteRuleMatchHeader:GrpcRouteRuleMatchHeaderÈ
Ê,
key" !Required. The key of the header.
É
typeB" uThe type of match.
Default value is `EXACT`.
Possible values are: `TYPE_UNSPECIFIED`, `EXACT`, `REGULAR_EXPRESSION`.
0
value" #Required. The value of the header.
:·
r
networkservicesGrpcRouteRuleMatchMethodEgcp:networkservices/GrpcRouteRuleMatchMethod:GrpcRouteRuleMatchMethodÍ
Á]
caseSensitiveB
 FSpecifies that matches are case sensitive. The default value is true.
A

grpcMethod" /Required. Name of the method to match against.
C
grpcService" 0Required. Name of the service to match against.
:ƒ
Q
networkservicesHttpRouteRule/gcp:networkservices/HttpRouteRule:HttpRouteRuleÓ
ÎÕ
actioniBg:e
c
networkservicesHttpRouteRuleAction;gcp:networkservices/HttpRouteRuleAction:HttpRouteRuleActionXThe detailed rule defining how to route matched traffic.
Structure is documented below.
ò
matcheshBf*d:b
`
networkservicesHttpRouteRuleMatch9gcp:networkservices/HttpRouteRuleMatch:HttpRouteRuleMatch¢A list of matches define conditions used for matching the rule against incoming HTTP requests. Each match is independent, i.e. this rule will be matched if ANY one of the matches is satisfied.
If no matches field is specified, this rule will unconditionally match traffic.
If a default rule is desired to be configured, add a rule with no matches specified to the end of the rules list.
Structure is documented below.
:ê
c
networkservicesHttpRouteRuleAction;gcp:networkservices/HttpRouteRuleAction:HttpRouteRuleAction®
•¸

corsPolicyäBá:Ñ
Å
networkservicesHttpRouteRuleActionCorsPolicyOgcp:networkservices/HttpRouteRuleActionCorsPolicy:HttpRouteRuleActionCorsPolicyaThe specification for allowing client side cross-origin requests.
Structure is documented below.
¯
destinationsêBç*ä:á
Ñ
networkservicesHttpRouteRuleActionDestinationQgcp:networkservices/HttpRouteRuleActionDestination:HttpRouteRuleActionDestinationUThe destination to which traffic should be forwarded.
Structure is documented below.
ﬂ
faultInjectionPolicy®B•:¢
ü
networkservices'HttpRouteRuleActionFaultInjectionPolicycgcp:networkservices/HttpRouteRuleActionFaultInjectionPolicy:HttpRouteRuleActionFaultInjectionPolicyõThe specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure.
Structure is documented below.
Ï
redirectÅB:}
{
networkservicesHttpRouteRuleActionRedirectKgcp:networkservices/HttpRouteRuleActionRedirect:HttpRouteRuleActionRedirect\If set, the request is directed as configured by this field.
Structure is documented below.
ﬁ
requestHeaderModifier´B®:•
¢
networkservices(HttpRouteRuleActionRequestHeaderModifieregcp:networkservices/HttpRouteRuleActionRequestHeaderModifier:HttpRouteRuleActionRequestHeaderModifierñThe specification for modifying the headers of a matching request prior to delivery of the request to the destination.
Structure is documented below.
Ÿ
requestMirrorPolicy•B¢:ü
ú
networkservices&HttpRouteRuleActionRequestMirrorPolicyagcp:networkservices/HttpRouteRuleActionRequestMirrorPolicy:HttpRouteRuleActionRequestMirrorPolicyôSpecifies the policy on how requests intended for the routes destination are shadowed to a separate mirrored destination.
Structure is documented below.
◊
responseHeaderModifierÆB´:®
•
networkservices)HttpRouteRuleActionResponseHeaderModifierggcp:networkservices/HttpRouteRuleActionResponseHeaderModifier:HttpRouteRuleActionResponseHeaderModifierãThe specification for modifying the headers of a response prior to sending the response back to the client.
Structure is documented below.
ı
retryPolicyçBä:á
Ñ
networkservicesHttpRouteRuleActionRetryPolicyQgcp:networkservices/HttpRouteRuleActionRetryPolicy:HttpRouteRuleActionRetryPolicyVSpecifies the retry policy associated with this route.
Structure is documented below.
;
timeoutB" *Specifies the timeout for selected route.
ã

urlRewriteäBá:Ñ
Å
networkservicesHttpRouteRuleActionUrlRewriteOgcp:networkservices/HttpRouteRuleActionUrlRewrite:HttpRouteRuleActionUrlRewritepThe specification for rewrite URL before forwarding requests to the destination.
Structure is documented below.
:„
Å
networkservicesHttpRouteRuleActionCorsPolicyOgcp:networkservices/HttpRouteRuleActionCorsPolicy:HttpRouteRuleActionCorsPolicy‹
Ÿì
allowCredentialsB
 yIn response to a preflight request, setting this to true indicates that the actual request can include user credentials.
W
allowHeadersB*" ?Specifies the content for Access-Control-Allow-Headers header.
W
allowMethodsB*" ?Specifies the content for Access-Control-Allow-Methods header.
d
allowOriginRegexesB*" FSpecifies the regular expression patterns that match allowed origins.
`
allowOriginsB*" HSpecifies the list of origins that will be allowed to do CORS requests.
é
disabledB
 |If true, the CORS policy is disabled. The default value is false, which indicates that the CORS policy is in effect.

- - -
Y
exposeHeadersB*" @Specifies the content for Access-Control-Expose-Headers header.
[
maxAgeB" KSpecifies how long result of a preflight request can be cached in seconds.
:‰
Ñ
networkservicesHttpRouteRuleActionDestinationQgcp:networkservices/HttpRouteRuleActionDestination:HttpRouteRuleActionDestination⁄
◊F
serviceNameB" 1The URL of a BackendService to route traffic to.
å
weightB ˚Specifies the proportion of requests forwarded to the backend referenced by the serviceName field. This is computed as: weight/Sum(weights in this destination list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports.
If only one serviceName is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend.
If weights are specified for any one service name, they need to be specified for all of them.
If weights are unspecified for all services, then, traffic is distributed in equal proportions to all of them.
:‘
ü
networkservices'HttpRouteRuleActionFaultInjectionPolicycgcp:networkservices/HttpRouteRuleActionFaultInjectionPolicy:HttpRouteRuleActionFaultInjectionPolicyØ
¨”
abort∑B¥:±
Æ
networkservices,HttpRouteRuleActionFaultInjectionPolicyAbortmgcp:networkservices/HttpRouteRuleActionFaultInjectionPolicyAbort:HttpRouteRuleActionFaultInjectionPolicyAbortèSpecification of how client requests are aborted as part of fault injection before being sent to a destination.
Structure is documented below.
”
delay∑B¥:±
Æ
networkservices,HttpRouteRuleActionFaultInjectionPolicyDelaymgcp:networkservices/HttpRouteRuleActionFaultInjectionPolicyDelay:HttpRouteRuleActionFaultInjectionPolicyDelayèSpecification of how client requests are delayed as part of fault injection before being sent to a destination.
Structure is documented below.
:ƒ
Æ
networkservices,HttpRouteRuleActionFaultInjectionPolicyAbortmgcp:networkservices/HttpRouteRuleActionFaultInjectionPolicyAbort:HttpRouteRuleActionFaultInjectionPolicyAbortê
çD

httpStatusB 0The HTTP status code used to abort the request.
E

percentageB 1The percentage of traffic which will be aborted.
:”
Æ
networkservices,HttpRouteRuleActionFaultInjectionPolicyDelaymgcp:networkservices/HttpRouteRuleActionFaultInjectionPolicyDelay:HttpRouteRuleActionFaultInjectionPolicyDelayü
úI

fixedDelayB" 5Specify a fixed delay before forwarding the request.
O

percentageB ;The percentage of traffic on which delay will be injected.
:Í
{
networkservicesHttpRouteRuleActionRedirectKgcp:networkservices/HttpRouteRuleActionRedirect:HttpRouteRuleActionRedirectÍ
Á
hostRedirectB" iThe host that will be used in the redirect response instead of the one that was supplied in the request.
a
httpsRedirectB
 JIf set to true, the URL scheme in the redirected request is set to https.
¥
pathRedirectB" ùThe path that will be used in the redirect response instead of the one that was supplied in the request. pathRedirect can not be supplied together with prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the original request will be used for the redirect.
Ä
portRedirectB jThe port that will be used in the redirected request instead of the one that was supplied in the request.
z
prefixRewriteB" cIndicates that during redirection, the matched prefix (or path) should be swapped with this value.
D
responseCodeB" .The HTTP Status code to use for the redirect.
Ñ

stripQueryB
 pIf set to true, any accompanying query portion of the original URL is removed prior to redirecting the request.
:â
¢
networkservices(HttpRouteRuleActionRequestHeaderModifieregcp:networkservices/HttpRouteRuleActionRequestHeaderModifier:HttpRouteRuleActionRequestHeaderModifier·
ﬁu
addB2" fAdd the headers with given map where key is the name of the header, value is the value of the header.
T
removesB*" ARemove headers (matching by header names) specified in the list.
é
setB2" Completely overwrite/replace the headers with given map where key is the name of the header, value is the value of the header.
:—
ú
networkservices&HttpRouteRuleActionRequestMirrorPolicyagcp:networkservices/HttpRouteRuleActionRequestMirrorPolicy:HttpRouteRuleActionRequestMirrorPolicyØ
¨©
destination∆B√:¿
Ω
networkservices1HttpRouteRuleActionRequestMirrorPolicyDestinationwgcp:networkservices/HttpRouteRuleActionRequestMirrorPolicyDestination:HttpRouteRuleActionRequestMirrorPolicyDestinationQThe destination the requests will be mirrored to.
Structure is documented below.
:ù
Ω
networkservices1HttpRouteRuleActionRequestMirrorPolicyDestinationwgcp:networkservices/HttpRouteRuleActionRequestMirrorPolicyDestination:HttpRouteRuleActionRequestMirrorPolicyDestination⁄
◊F
serviceNameB" 1The URL of a BackendService to route traffic to.
å
weightB ˚Specifies the proportion of requests forwarded to the backend referenced by the serviceName field. This is computed as: weight/Sum(weights in this destination list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports.
If only one serviceName is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend.
If weights are specified for any one service name, they need to be specified for all of them.
If weights are unspecified for all services, then, traffic is distributed in equal proportions to all of them.
:å
•
networkservices)HttpRouteRuleActionResponseHeaderModifierggcp:networkservices/HttpRouteRuleActionResponseHeaderModifier:HttpRouteRuleActionResponseHeaderModifier·
ﬁu
addB2" fAdd the headers with given map where key is the name of the header, value is the value of the header.
T
removesB*" ARemove headers (matching by header names) specified in the list.
é
setB2" Completely overwrite/replace the headers with given map where key is the name of the header, value is the value of the header.
:–
Ñ
networkservicesHttpRouteRuleActionRetryPolicyQgcp:networkservices/HttpRouteRuleActionRetryPolicy:HttpRouteRuleActionRetryPolicy∆
√=

numRetriesB )Specifies the allowed number of retries.
£
perTryTimeoutB" ãSpecifies a non-zero timeout per retry attempt. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
\
retryConditionsB*" ASpecifies one or more conditions when this retry policy applies.
:¥
Å
networkservicesHttpRouteRuleActionUrlRewriteOgcp:networkservices/HttpRouteRuleActionUrlRewrite:HttpRouteRuleActionUrlRewrite≠
™Ü
hostRewriteB" qPrior to forwarding the request to the selected destination, the requests host header is replaced by this value.
û
pathPrefixRewriteB" ÇPrior to forwarding the request to the selected destination, the matching portion of the requests path is replaced by this value.
:Ø	
`
networkservicesHttpRouteRuleMatch9gcp:networkservices/HttpRouteRuleMatch:HttpRouteRuleMatch 
«T
fullPathMatchB" =The HTTP request path value should exactly match this value.
·
headerszBx*v:t
r
networkservicesHttpRouteRuleMatchHeaderEgcp:networkservices/HttpRouteRuleMatchHeader:HttpRouteRuleMatchHeaderZSpecifies a list of HTTP request headers to match against.
Structure is documented below.
w

ignoreCaseB
 cSpecifies if prefixMatch and fullPathMatch matches are case sensitive. The default value is false.
y
prefixMatchB" dThe HTTP request path value must begin with specified prefixMatch. prefixMatch must begin with a /.
Ç
queryParametersñBì*ê:ç
ä
networkservices HttpRouteRuleMatchQueryParameterUgcp:networkservices/HttpRouteRuleMatchQueryParameter:HttpRouteRuleMatchQueryParameterVSpecifies a list of query parameters to match against.
Structure is documented below.
ë

regexMatchB" ¸The HTTP request path value must satisfy the regular expression specified by regexMatch after removing any query parameters and anchor supplied with the original URL. For regular expression grammar, please see https://github.com/google/re2/wiki/Syntax
:«
r
networkservicesHttpRouteRuleMatchHeaderEgcp:networkservices/HttpRouteRuleMatchHeader:HttpRouteRuleMatchHeader–
Õ\

exactMatchB" HThe value of the header should match exactly the content of exactMatch.
>
headerB" .The name of the HTTP header to match against.
u
invertMatchB
 `If specified, the match result will be inverted before checking. Default value is set to false.
Z
prefixMatchB" EThe value of the header must start with the contents of prefixMatch.
x
presentMatchB
 bA header with headerName must exist. The match takes place whether or not the header has a value.
ú

rangeMatchôBñ:ì
ê
networkservices"HttpRouteRuleMatchHeaderRangeMatchYgcp:networkservices/HttpRouteRuleMatchHeaderRangeMatch:HttpRouteRuleMatchHeaderRangeMatchrIf specified, the rule will match if the request header value is within the range.
Structure is documented below.
g

regexMatchB" SThe value of the header must match the regular expression specified in regexMatch.
X
suffixMatchB" CThe value of the header must end with the contents of suffixMatch.
:Ò
ê
networkservices"HttpRouteRuleMatchHeaderRangeMatchYgcp:networkservices/HttpRouteRuleMatchHeaderRangeMatch:HttpRouteRuleMatchHeaderRangeMatch\
Z)
end End of the range (exclusive).
-
start  Start of the range (inclusive).
:Ø
ä
networkservices HttpRouteRuleMatchQueryParameterUgcp:networkservices/HttpRouteRuleMatchQueryParameter:HttpRouteRuleMatchQueryParameterü
úd

exactMatchB" PThe value of the query parameter must exactly match the contents of exactMatch.
ß
presentMatchB
 êSpecifies that the QueryParameterMatcher matches if request contains query parameter, irrespective of whether the parameter has a value or not.
B
queryParameterB" *The name of the query parameter to match.
≈

regexMatchB" ∞The value of the query parameter must match the regular expression specified by regexMatch.For regular expression grammar, please see https://github.com/google/re2/wiki/Syntax
:Ò	
Ñ
networkservicesLbRouteExtensionExtensionChainQgcp:networkservices/LbRouteExtensionExtensionChain:LbRouteExtensionExtensionChainÁ
‰⁄

extensions®*•:¢
ü
networkservices'LbRouteExtensionExtensionChainExtensioncgcp:networkservices/LbRouteExtensionExtensionChainExtension:LbRouteExtensionExtensionChainExtension†A set of extensions to execute for the matching request.
At least one extension is required. Up to 3 extensions can be defined for each extension chain for
LbTrafficExtension resource. LbRouteExtension chains are limited to 1 extension per extension chain.
Structure is documented below.
§
matchCondition¥:±
Æ
networkservices,LbRouteExtensionExtensionChainMatchConditionmgcp:networkservices/LbRouteExtensionExtensionChainMatchCondition:LbRouteExtensionExtensionChainMatchCondition[Conditions under which this chain is invoked for a request.
Structure is documented below.
›
name" –The name for this extension chain. The name is logged as part of the HTTP request logs.
The name must conform with RFC-1034, is restricted to lower-cased letters, numbers and hyphens,
and can have a maximum length of 63 characters. Additionally, the first character must be a letter
and the last character must be a letter or a number.
:€
ü
networkservices'LbRouteExtensionExtensionChainExtensioncgcp:networkservices/LbRouteExtensionExtensionChainExtension:LbRouteExtensionExtensionChainExtension∂
≥g
	authorityB" TThe :authority header in the gRPC request sent from Envoy to the extension service.
›
failOpenB
  Determines how the proxy behaves if the call to the extension fails or times out.
When set to TRUE, request or response processing continues without error.
Any subsequent extensions in the extension chain are also executed.
When set to FALSE: * If response headers have not been delivered to the downstream client,
a generic 500 error is returned to the client. The error response can be tailored by
configuring a custom error response in the load balancer.
Ã
forwardHeadersB*" ±List of the HTTP headers to forward to the extension (from the client or backend).
If omitted, all headers are sent. Each element is a string indicating the header name.

- - -
≈
name" ∏The name for this extension. The name is logged as part of the HTTP request logs.
The name must conform with RFC-1034, is restricted to lower-cased letters, numbers and hyphens,
and can have a maximum length of 63 characters. Additionally, the first character must be a letter
and the last a letter or a number.
n
service" _The reference to the service that runs the extension. Must be a reference to a backend service
‡
timeoutB" ŒSpecifies the timeout for each individual message on the stream. The timeout must be between 10-1000 milliseconds.
A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
:«
Æ
networkservices,LbRouteExtensionExtensionChainMatchConditionmgcp:networkservices/LbRouteExtensionExtensionChainMatchCondition:LbRouteExtensionExtensionChainMatchConditionì
êç
celExpression" xA Common Expression Language (CEL) expression that is used to match requests for which the extension chain is executed.
:Ò	
ä
networkservices LbTrafficExtensionExtensionChainUgcp:networkservices/LbTrafficExtensionExtensionChain:LbTrafficExtensionExtensionChain·
ﬁ‡

extensionsÆ*´:®
•
networkservices)LbTrafficExtensionExtensionChainExtensionggcp:networkservices/LbTrafficExtensionExtensionChainExtension:LbTrafficExtensionExtensionChainExtension†A set of extensions to execute for the matching request.
At least one extension is required. Up to 3 extensions can be defined for each extension chain for
LbTrafficExtension resource. LbRouteExtension chains are limited to 1 extension per extension chain.
Structure is documented below.
™
matchCondition∫:∑
¥
networkservices.LbTrafficExtensionExtensionChainMatchConditionqgcp:networkservices/LbTrafficExtensionExtensionChainMatchCondition:LbTrafficExtensionExtensionChainMatchCondition[Conditions under which this chain is invoked for a request.
Structure is documented below.
À
name" æThe name for this extension chain. The name is logged as part of the HTTP request logs.
The name must conform with RFC-1034, is restricted to lower-cased letters, numbers and hyphens,
and can have a maximum length of 63 characters. Additionally, the first character must be a letter
and the last a letter or a number.
:‚
•
networkservices)LbTrafficExtensionExtensionChainExtensionggcp:networkservices/LbTrafficExtensionExtensionChainExtension:LbTrafficExtensionExtensionChainExtension∑
¥g
	authorityB" TThe :authority header in the gRPC request sent from Envoy to the extension service.
›
failOpenB
  Determines how the proxy behaves if the call to the extension fails or times out.
When set to TRUE, request or response processing continues without error.
Any subsequent extensions in the extension chain are also executed.
When set to FALSE: * If response headers have not been delivered to the downstream client,
a generic 500 error is returned to the client. The error response can be tailored by
configuring a custom error response in the load balancer.
≈
forwardHeadersB*" ™List of the HTTP headers to forward to the extension (from the client or backend).
If omitted, all headers are sent. Each element is a string indicating the header name.
≈
name" ∏The name for this extension. The name is logged as part of the HTTP request logs.
The name must conform with RFC-1034, is restricted to lower-cased letters, numbers and hyphens,
and can have a maximum length of 63 characters. Additionally, the first character must be a letter
and the last a letter or a number.
n
service" _The reference to the service that runs the extension. Must be a reference to a backend service
Ö
supportedEventsB*" ÈA set of events during request or response processing for which this extension is called.
This field is required for the LbTrafficExtension resource. It's not relevant for the LbRouteExtension
resource. Possible values:`EVENT_TYPE_UNSPECIFIED`, `REQUEST_HEADERS`, `REQUEST_BODY`, `RESPONSE_HEADERS`,
`RESPONSE_BODY`, `RESPONSE_BODY` and `RESPONSE_BODY`.

- - -
‡
timeoutB" ŒSpecifies the timeout for each individual message on the stream. The timeout must be between 10-1000 milliseconds.
A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
:Õ
¥
networkservices.LbTrafficExtensionExtensionChainMatchConditionqgcp:networkservices/LbTrafficExtensionExtensionChainMatchCondition:LbTrafficExtensionExtensionChainMatchConditionì
êç
celExpression" xA Common Expression Language (CEL) expression that is used to match requests for which the extension chain is executed.
:—
ê
networkservices"ServiceLbPoliciesAutoCapacityDrainYgcp:networkservices/ServiceLbPoliciesAutoCapacityDrain:ServiceLbPoliciesAutoCapacityDrainª
∏µ
enableB
 §Optional. If set to 'True', an unhealthy MIG/NEG will be set as drained. - An MIG/NEG is considered unhealthy if less than 25% of the instances/endpoints in the MIG/NEG are healthy. - This option will never result in draining more than 50% of the configured IGs/NEGs for the Backend Service.
:Õ
á
networkservicesServiceLbPoliciesFailoverConfigSgcp:networkservices/ServiceLbPoliciesFailoverConfig:ServiceLbPoliciesFailoverConfig¿
Ω∫
failoverHealthThreshold öOptional. The percentage threshold that a load balancer will begin to send traffic to failover backends. If the percentage of endpoints in a MIG/NEG is smaller than this value, traffic would be sent to failover backends if possible. This field should be set to a value between 1 and 99. The default value is 50 for Global external HTTP(S) load balancer (classic) and Proxyless service mesh, and 70 for others.
:˙
N
networkservicesTcpRouteRule-gcp:networkservices/TcpRouteRule:TcpRouteRuleß
§æ
actiond:b
`
networkservicesTcpRouteRuleAction9gcp:networkservices/TcpRouteRuleAction:TcpRouteRuleActionNA detailed rule defining how to route traffic.
Structure is documented below.
‡
matcheseBc*a:_
]
networkservicesTcpRouteRuleMatch7gcp:networkservices/TcpRouteRuleMatch:TcpRouteRuleMatchÌRouteMatch defines the predicate used to match requests to a given action. Multiple match types are "OR"ed for evaluation.
If no routeMatch field is specified, this rule will unconditionally match traffic.
Structure is documented below.
:∫
`
networkservicesTcpRouteRuleAction9gcp:networkservices/TcpRouteRuleAction:TcpRouteRuleAction’
“≠
destinationsçBä*á:Ñ
Å
networkservicesTcpRouteRuleActionDestinationOgcp:networkservices/TcpRouteRuleActionDestination:TcpRouteRuleActionDestinationåThe destination services to which traffic should be forwarded. At least one destination service is required.
Structure is documented below.
å
idleTimeoutB" ˆSpecifies the idle timeout for the selected route. The idle timeout is defined as the period in which there are no bytes sent or received on either the upstream or downstream connection. If not set, the default idle timeout is 30 seconds. If set to 0s, the timeout will be disabled.
A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
ê
originalDestinationB
 sIf true, Router will use the destination IP and port of the original connection as the destination of the request.
:Ë
Å
networkservicesTcpRouteRuleActionDestinationOgcp:networkservices/TcpRouteRuleActionDestination:TcpRouteRuleActionDestination·
ﬁF
serviceNameB" 1The URL of a BackendService to route traffic to.
ì
weightB ÇSpecifies the proportion of requests forwarded to the backend referenced by the serviceName field. This is computed as: weight/Sum(weights in this destination list). For non-zero values, there may be some epsilon from the exact proportion defined here depending on the precision an implementation supports.
If only one serviceName is specified and it has a weight greater than 0, 100% of the traffic is forwarded to that backend.
If weights are specified for any one service name, they need to be specified for all of them.
If weights are unspecified for all services, then, traffic is distributed in equal proportions to all of them.

- - -
:ı
]
networkservicesTcpRouteRuleMatch7gcp:networkservices/TcpRouteRuleMatch:TcpRouteRuleMatchì
êŒ
address" æMust be specified in the CIDR range format. A CIDR range consists of an IP Address and a prefix length to construct the subnet mask.
By default, the prefix length is 32 (i.e. matches a single IP address). Only IPV4 addresses are supported. Examples: "10.0.0.1" - matches against this exact IP address. "10.0.0.0/8" - matches against any IP address within the 10.0.0.0 subnet and 255.255.255.0 mask. "0.0.0.0/0" - matches against any IP address'.
=
port" 1Specifies the destination port to match against.
:˙
N
networkservicesTlsRouteRule-gcp:networkservices/TlsRouteRule:TlsRouteRuleß
§»
actiond:b
`
networkservicesTlsRouteRuleAction9gcp:networkservices/TlsRouteRuleAction:TlsRouteRuleActionXRequired. A detailed rule defining how to route traffic.
Structure is documented below.
÷
matchesc*a:_
]
networkservicesTlsRouteRuleMatch7gcp:networkservices/TlsRouteRuleMatch:TlsRouteRuleMatchfMatches define the predicate used to match requests to a given action.
Structure is documented below.
:‡
`
networkservicesTlsRouteRuleAction9gcp:networkservices/TlsRouteRuleAction:TlsRouteRuleAction˚
¯ı
destinationsçBä*á:Ñ
Å
networkservicesTlsRouteRuleActionDestinationOgcp:networkservices/TlsRouteRuleActionDestination:TlsRouteRuleActionDestinationUThe destination to which traffic should be forwarded.
Structure is documented below.
:Œ
Å
networkservicesTlsRouteRuleActionDestinationOgcp:networkservices/TlsRouteRuleActionDestination:TlsRouteRuleActionDestination«
ƒF
serviceNameB" 1The URL of a BackendService to route traffic to.
z
weightB jSpecifies the proportion of requests forwarded to the backend referenced by the serviceName field.

- - -
:Ω
]
networkservicesTlsRouteRuleMatch7gcp:networkservices/TlsRouteRuleMatch:TlsRouteRuleMatch€
ÿ…
alpnsB*" ∑ALPN (Application-Layer Protocol Negotiation) to match against. Examples: "http/1.1", "h2". At least one of sniHost and alpn is required. Up to 5 alpns across all matches can be set.
â
sniHostsB*" ÙSNI (server name indicator) to match against. SNI will be matched against all wildcard domains, i.e. www.example.com will be first matched against www.example.com, then *.example.com, then *.com.
Partial wildcards are not supported, and values like *w.example.com are invalid. At least one of sniHost and alpn is required. Up to 5 sni hosts across all matches can be set.
:¿
i
	notebooksEnvironmentContainerImageAgcp:notebooks/EnvironmentContainerImage:EnvironmentContainerImage“
œk

repository" YThe path to the container image repository.
For example: gcr.io/{project_id}/{imageName}
`
tagB" SThe tag of the container image. If not specified, this defaults to the latest tag.
:˙
T
	notebooksEnvironmentVmImage3gcp:notebooks/EnvironmentVmImage:EnvironmentVmImage°
ûo
imageFamilyB" ZUse this VM image family to find the image; the newest image in this family will be used.
8
	imageNameB" %Use VM image name to find the image.
q
project" bThe name of the Google Cloud project that this VM image belongs to.
Format: projects/{project_id}
:€
i
	notebooksInstanceAcceleratorConfigAgcp:notebooks/InstanceAcceleratorConfig:InstanceAcceleratorConfigÌ
Í5
	coreCount $Count of cores of this accelerator.
∞
type" £Type of this accelerator.
Possible values are: `ACCELERATOR_TYPE_UNSPECIFIED`, `NVIDIA_TESLA_K80`, `NVIDIA_TESLA_P100`, `NVIDIA_TESLA_V100`, `NVIDIA_TESLA_P4`, `NVIDIA_TESLA_T4`, `NVIDIA_TESLA_T4_VWS`, `NVIDIA_TESLA_P100_VWS`, `NVIDIA_TESLA_P4_VWS`, `NVIDIA_TESLA_A100`, `TPU_V2`, `TPU_V3`.
:∑
`
	notebooksInstanceContainerImage;gcp:notebooks/InstanceContainerImage:InstanceContainerImage“
œk

repository" YThe path to the container image repository.
For example: gcr.io/{project_id}/{imageName}
`
tagB" SThe tag of the container image. If not specified, this defaults to the latest tag.
:©
o
	notebooksInstanceIamBindingConditionEgcp:notebooks/InstanceIamBindingCondition:InstanceIamBindingCondition6
4
descriptionB" 

expression" 
title" :¶
l
	notebooksInstanceIamMemberConditionCgcp:notebooks/InstanceIamMemberCondition:InstanceIamMemberCondition6
4
descriptionB" 

expression" 
title" :ù
o
	notebooksInstanceReservationAffinityEgcp:notebooks/InstanceReservationAffinity:InstanceReservationAffinity©
¶ë
consumeReservationType" sThe type of Compute Reservation.
Possible values are: `NO_RESERVATION`, `ANY_RESERVATION`, `SPECIFIC_RESERVATION`.
C
keyB" 6Corresponds to the label key of reservation resource.
K
valuesB*" 9Corresponds to the label values of reservation resource.
:ı
x
	notebooksInstanceShieldedInstanceConfigKgcp:notebooks/InstanceShieldedInstanceConfig:InstanceShieldedInstanceConfig¯
ıÌ
enableIntegrityMonitoringB
 …Defines whether the instance has integrity monitoring enabled. Enables monitoring and attestation of the
boot integrity of the instance. The attestation is performed against the integrity policy baseline.
This baseline is initially derived from the implicitly trusted boot image when the instance is created.
Enabled by default.
•
enableSecureBootB
 äDefines whether the instance has Secure Boot enabled. Secure Boot helps ensure that the system only runs
authentic software by verifying the digital signature of all boot components, and halting the boot process
if signature verification fails.
Disabled by default.
[

enableVtpmB
 GDefines whether the instance has the vTPM enabled.
Enabled by default.
:Ò
K
	notebooksInstanceVmImage-gcp:notebooks/InstanceVmImage:InstanceVmImage°
ûo
imageFamilyB" ZUse this VM image family to find the image; the newest image in this family will be used.
8
	imageNameB" %Use VM image name to find the image.
q
project" bThe name of the Google Cloud project that this VM image belongs to.
Format: projects/{project_id}
:Å
W
	notebooksRuntimeAccessConfig5gcp:notebooks/RuntimeAccessConfig:RuntimeAccessConfig•
¢»

accessTypeB" ≥The type of access mode this instance. For valid values, see
`https://cloud.google.com/vertex-ai/docs/workbench/reference/
rest/v1/projects.locations.runtimes#RuntimeAccessType`.
R
proxyUriB" @(Output)
The proxy endpoint that is used to access the runtime.
Ä
runtimeOwnerB" jThe owner of this runtime after creation. Format: `alias@example.com`.
Currently supports one owner only.
:¶
l
	notebooksRuntimeIamBindingConditionCgcp:notebooks/RuntimeIamBindingCondition:RuntimeIamBindingCondition6
4
descriptionB" 

expression" 
title" :£
i
	notebooksRuntimeIamMemberConditionAgcp:notebooks/RuntimeIamMemberCondition:RuntimeIamMemberCondition6
4
descriptionB" 

expression" 
title" :ª
E
	notebooksRuntimeMetric)gcp:notebooks/RuntimeMetric:RuntimeMetricr
pn
systemMetricsB2" U(Output)
Contains runtime daemon metrics, such as OS and kernels and
sessions stats.
:â
]
	notebooksRuntimeSoftwareConfig9gcp:notebooks/RuntimeSoftwareConfig:RuntimeSoftwareConfigß
§™
customGpuDriverPathB" åSpecify a custom Cloud Storage path where the GPU driver is stored.
If not specified, we'll automatically choose from official GPU drivers.
\
enableHealthMonitoringB
 <Verifies core internal services are running. Default: True.
b
idleShutdownB
 LRuntime will automatically shutdown after idle_shutdown_time.
Default: True
g
idleShutdownTimeoutB JTime in minutes to wait before shuting down runtime.
Default: 180 minutes
?
installGpuDriverB
 %Install Nvidia Driver automatically.
Ó
kernelswBu*s:q
o
	notebooksRuntimeSoftwareConfigKernelEgcp:notebooks/RuntimeSoftwareConfigKernel:RuntimeSoftwareConfigKerneljUse a list of container images to use as Kernels in the notebook instance.
Structure is documented below.
´
notebookUpgradeScheduleB" âCron expression in UTC timezone for schedule instance auto upgrade.
Please follow the [cron format](https://en.wikipedia.org/wiki/Cron).
¿
postStartupScriptB" §Path to a Bash script that automatically runs after a notebook instance
fully boots up. The path must be a URL or
Cloud Storage path (gs://path-to-file/file-name).
æ
postStartupScriptBehaviorB" öBehavior for the post startup script.
Possible values are: `POST_STARTUP_SCRIPT_BEHAVIOR_UNSPECIFIED`, `RUN_EVERY_START`, `DOWNLOAD_AND_RUN_EVERY_START`.
f
upgradeableB
 Q(Output)
Bool indicating whether an newer image is available in an image family.
:∆
o
	notebooksRuntimeSoftwareConfigKernelEgcp:notebooks/RuntimeSoftwareConfigKernel:RuntimeSoftwareConfigKernel“
œk

repository" YThe path to the container image repository.
For example: gcr.io/{project_id}/{imageName}
`
tagB" SThe tag of the container image. If not specified, this defaults to the latest tag.
:©
]
	notebooksRuntimeVirtualMachine9gcp:notebooks/RuntimeVirtualMachine:RuntimeVirtualMachine«
ƒ[

instanceIdB" G(Output)
The unique identifier of the Managed Compute Engine instance.
^
instanceNameB" H(Output)
The user-friendly name of the Managed Compute Engine instance.
Ñ
virtualMachineConfig¢Bü:ú
ô
	notebooks)RuntimeVirtualMachineVirtualMachineConfigagcp:notebooks/RuntimeVirtualMachineVirtualMachineConfig:RuntimeVirtualMachineVirtualMachineConfigGVirtual Machine configuration settings.
Structure is documented below.
:Ã$
ô
	notebooks)RuntimeVirtualMachineVirtualMachineConfigagcp:notebooks/RuntimeVirtualMachineVirtualMachineConfig:RuntimeVirtualMachineVirtualMachineConfig≠#
™#Ã
acceleratorConfig÷B”:–
Õ
	notebooks:RuntimeVirtualMachineVirtualMachineConfigAcceleratorConfigÉgcp:notebooks/RuntimeVirtualMachineVirtualMachineConfigAcceleratorConfig:RuntimeVirtualMachineVirtualMachineConfigAcceleratorConfig^The Compute Engine accelerator configuration for this runtime.
Structure is documented below.
√
containerImagesœBÃ*…:∆
√
	notebooks7RuntimeVirtualMachineVirtualMachineConfigContainerImage}gcp:notebooks/RuntimeVirtualMachineVirtualMachineConfigContainerImage:RuntimeVirtualMachineVirtualMachineConfigContainerImage^Use a list of container images to start the notebook instance.
Structure is documented below.
é
dataDisk∑:¥
±
	notebooks1RuntimeVirtualMachineVirtualMachineConfigDataDiskqgcp:notebooks/RuntimeVirtualMachineVirtualMachineConfigDataDisk:RuntimeVirtualMachineVirtualMachineConfigDataDiskHData disk option configuration settings.
Structure is documented below.
º
encryptionConfig”B–:Õ
 
	notebooks9RuntimeVirtualMachineVirtualMachineConfigEncryptionConfigÅgcp:notebooks/RuntimeVirtualMachineVirtualMachineConfigEncryptionConfig:RuntimeVirtualMachineVirtualMachineConfigEncryptionConfigREncryption settings for virtual machine data disk.
Structure is documented below.
Œ
guestAttributesB2" ≤(Output)
The Compute Engine guest attributes. (see [Project and instance
guest attributes](https://cloud.google.com/compute/docs/
storing-retrieving-metadata#guest_attributes)).
Ü
internalIpOnlyB
 ÌIf true, runtime will only have internal IP addresses. By default,
runtimes are not restricted to internal IP addresses, and will
have ephemeral external IP addresses assigned to each vm. This
`internal_ip_only` restriction can only be enabled for subnetwork
enabled networks, and all dependencies must be configured to be
accessible without external IP addresses.
Ö
labelsB2" ÚThe labels to associate with this runtime. Label **keys** must
contain 1 to 63 characters, and must conform to [RFC 1035]
(https://www.ietf.org/rfc/rfc1035.txt). Label **values** may be
empty, but, if present, must contain 1 to 63 characters, and must
conform to [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt). No
more than 32 labels can be associated with a cluster.
F
machineType" 3The Compute Engine machine type used for runtimes.
ﬁ
metadataB2" …The Compute Engine metadata entries to add to virtual machine.
(see [Project and instance metadata](https://cloud.google.com
/compute/docs/storing-retrieving-metadata#project_and_instance
_metadata)).
˝
networkB" ÎThe Compute Engine network to be used for machine communications.
Cannot be specified with subnetwork. If neither `network` nor
`subnet` is specified, the "default" network of the project is
used, if it exists. A full URL or partial URI. Examples:
* `https://www.googleapis.com/compute/v1/projects/[project_id]/
regions/global/default`
* `projects/[project_id]/regions/global/default`
Runtimes are managed resources inside Google Infrastructure.
Runtimes support the following network configurations:
* Google Managed Network (Network & subnet are empty)
* Consumer Project VPC (network & subnet are required). Requires
configuring Private Service Access.
* Shared VPC (network & subnet are required). Requires
configuring Private Service Access.
•
nicTypeB" ìThe type of vNIC to be used on this interface. This may be gVNIC
or VirtioNet.
Possible values are: `UNSPECIFIED_NIC_TYPE`, `VIRTIO_NET`, `GVNIC`.
è
reservedIpRangeB" vReserved IP Range name is used for VPC Peering. The
subnetwork allocation will use the range *name* if it's assigned.
Œ
shieldedInstanceConfigÂB‚:ﬂ
‹
	notebooks?RuntimeVirtualMachineVirtualMachineConfigShieldedInstanceConfigçgcp:notebooks/RuntimeVirtualMachineVirtualMachineConfigShieldedInstanceConfig:RuntimeVirtualMachineVirtualMachineConfigShieldedInstanceConfigLShielded VM Instance configuration settings.
Structure is documented below.
∆
subnetB" µThe Compute Engine subnetwork to be used for machine
communications. Cannot be specified with network. A full URL or
partial URI are valid. Examples:
* `https://www.googleapis.com/compute/v1/projects/[project_id]/
regions/us-east1/subnetworks/sub0`
* `projects/[project_id]/regions/us-east1/subnetworks/sub0`
õ
tagsB*" äThe Compute Engine tags to add to runtime (see [Tagging instances]
(https://cloud.google.com/compute/docs/
label-or-tag-resources#tags)).
F
zoneB" 8(Output)
The zone where the virtual machine is located.
:Ω
Õ
	notebooks:RuntimeVirtualMachineVirtualMachineConfigAcceleratorConfigÉgcp:notebooks/RuntimeVirtualMachineVirtualMachineConfigAcceleratorConfig:RuntimeVirtualMachineVirtualMachineConfigAcceleratorConfigÍ
Á7
	coreCountB $Count of cores of this accelerator.
´
typeB" úAccelerator model. For valid values, see
`https://cloud.google.com/vertex-ai/docs/workbench/reference/
rest/v1/projects.locations.runtimes#AcceleratorType`
:õ
√
	notebooks7RuntimeVirtualMachineVirtualMachineConfigContainerImage}gcp:notebooks/RuntimeVirtualMachineVirtualMachineConfigContainerImage:RuntimeVirtualMachineVirtualMachineConfigContainerImage“
œk

repository" YThe path to the container image repository.
For example: gcr.io/{project_id}/{imageName}
`
tagB" SThe tag of the container image. If not specified, this defaults to the latest tag.
:«
±
	notebooks1RuntimeVirtualMachineVirtualMachineConfigDataDiskqgcp:notebooks/RuntimeVirtualMachineVirtualMachineConfigDataDisk:RuntimeVirtualMachineVirtualMachineConfigDataDiskê
ç¨

autoDeleteB
 ó(Output)
Optional. Specifies whether the disk will be auto-deleted
when the instance is deleted (but not when the disk is
detached from the instance).
ú
bootB
 ç(Output)
Optional. Indicates that this is a boot disk. The virtual
machine will use the first partition of the disk for its
root filesystem.
è

deviceNameB" ˙(Output)
Optional. Specifies a unique device name of your choice
that is reflected into the /dev/disk/by-id/google-* tree
of a Linux operating system running within the instance.
This name can be used to reference the device for mounting,
resizing, and so on, from within the instance.
If not specified, the server chooses a default device name
to apply to this disk, in the form persistent-disk-x, where
x is a number assigned by Google Compute Engine. This field
is only applicable for persistent disks.
Ø
guestOsFeaturesB*" ì(Output)
Indicates a list of features to enable on the guest operating
system. Applicable only for bootable images. To see a list of
available features, read `https://cloud.google.com/compute/docs/
images/create-delete-deprecate-private-images#guest-os-features`
options. ``
 
indexB ∫(Output)
Output only. A zero-based index to this disk, where 0 is
reserved for the boot disk. If you have many disks attached
to an instance, each disk would have a unique index number.
ÿ
initializeParamsÎBË:Â
‚
	notebooksARuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParamsëgcp:notebooks/RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParams:RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParams’Input only. Specifies the parameters for a new disk that will
be created alongside the new instance. Use initialization
parameters to create boot disks or local SSDs attached to the
new instance. This property is mutually exclusive with the
source property; you can only define one or the other, but not
both.
Structure is documented below.
£
	interfaceB" è"Specifies the disk interface to use for attaching this disk,
which is either SCSI or NVME. The default is SCSI. Persistent
disks must always use SCSI and the request will fail if you attempt
to attach a persistent disk in any other format than SCSI. Local SSDs
can use either NVME or SCSI. For performance characteristics of SCSI
over NVMe, see Local SSD performance. Valid values: * NVME * SCSI".
]
kindB" O(Output)
Type of the resource. Always compute#attachedDisk for attached
disks.
O
licensesB*" ;(Output)
Output only. Any valid publicly visible licenses.
û
modeB" èThe mode in which to attach this disk, either READ_WRITE
or READ_ONLY. If not specified, the default is to attach
the disk in READ_WRITE mode.
_
sourceB" OSpecifies a valid partial or full URL to an existing
Persistent Disk resource.
y
typeB" kSpecifies the type of the disk, either SCRATCH or PERSISTENT.
If not specified, the default is PERSISTENT.
:é	
‚
	notebooksARuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParamsëgcp:notebooks/RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParams:RuntimeVirtualMachineVirtualMachineConfigDataDiskInitializeParams¶
£C
descriptionB" .Provide this property when creating the disk.
Ê
diskNameB" ”Specifies the disk name. If not specified, the default is
to use the name of the instance. If the disk with the
instance name exists already in the given zone/region, a
new name will be automatically generated.
›

diskSizeGbB »Specifies the size of the disk in base-2 GB. If not
specified, the disk will be the same size as the image
(usually 10GB). If specified, the size must be equal to
or larger than 10GB. Default 100 GB.
Ô
diskTypeB" ‹The type of the boot disk attached to this runtime,
defaults to standard persistent disk. For valid values,
see `https://cloud.google.com/vertex-ai/docs/workbench/
reference/rest/v1/projects.locations.runtimes#disktype`
†
labelsB2" çLabels to apply to this disk. These can be later modified
by the disks.setLabels method. This field is only
applicable for persistent disks.
:’
 
	notebooks9RuntimeVirtualMachineVirtualMachineConfigEncryptionConfigÅgcp:notebooks/RuntimeVirtualMachineVirtualMachineConfigEncryptionConfig:RuntimeVirtualMachineVirtualMachineConfigEncryptionConfigÖ
Çˇ
kmsKeyB" ÓThe Cloud KMS resource identifier of the customer-managed
encryption key used to protect a resource, such as a disks.
It has the following format:
`projects/{PROJECT_ID}/locations/{REGION}/keyRings/
{KEY_RING_NAME}/cryptoKeys/{KEY_NAME}`
:Ÿ
‹
	notebooks?RuntimeVirtualMachineVirtualMachineConfigShieldedInstanceConfigçgcp:notebooks/RuntimeVirtualMachineVirtualMachineConfigShieldedInstanceConfig:RuntimeVirtualMachineVirtualMachineConfigShieldedInstanceConfig˜
ÙÌ
enableIntegrityMonitoringB
 …Defines whether the instance has integrity monitoring enabled.
Enables monitoring and attestation of the boot integrity of
the instance. The attestation is performed against the
integrity policy baseline. This baseline is initially derived
from the implicitly trusted boot image when the instance is
created. Enabled by default.
§
enableSecureBootB
 âDefines whether the instance has Secure Boot enabled.Secure
Boot helps ensure that the system only runs authentic software
by verifying the digital signature of all boot components, and
halting the boot process if signature verification fails.
Disabled by default.
[

enableVtpmB
 GDefines whether the instance has the vTPM enabled. Enabled by
default.
