use anyhow::anyhow;
use anyhow::Error;
use std::sync::Arc;
use std::thread::sleep;
use std::time::Duration;
use wasmtime::component::*;
use wasmtime::{Config, Engine, Store};
use wasmtime_wasi::{preview2, WasiCtx, WasiCtxBuilder};
use wasmtime_wasi_threads::WasiThreadsCtx;
#[derive(Clone)]
struct Host {
    wasi: WasiCtx,
    wasi_threads: Option<Arc<WasiThreadsCtx<Host>>>,
}

#[test]
fn test() -> Result<(), Error> {
    let mut config = Config::new();
    config.wasm_component_model(true);
    let engine = Engine::new(&config)?;

    let component = Component::from_file(&engine, "../target/wasm32-wasi/debug/pulumi_wasm.wasm")?;
    // let module = Module::from_file(&engine, "../target/wasm32-wasi/debug/pulumi_wasm.wasm")?;
    // let module = Module::from_file(&engine, "target/wasm32-wasi-preview1-threads/debug/wasi_threads_testing.wasm")?;
    //
    // // let mut linker = wasmtime::Linker::new(&engine);
    // // wasmtime_wasi::add_to_linker(&mut linker, |s| s)?;
    //
    // let mut wasi = WasiCtxBuilder::new()
    //     .inherit_stdin()
    //     .inherit_stdout()
    //     .inherit_stderr()
    //     .build();
    //
    // // All wasm objects operate within the context of a "store". Each
    // // `Store` has a type parameter to store host-specific data, which in
    // // this case we're using `4` for.
    // let mut store = Store::new(&engine, 4);
    // // linker.module(&mut store, "main", &module)?;
    //
    // // Instantiation of a module requires specifying its imports and then
    // // afterwards we can fetch exports by name, as well as asserting the
    // // type signature of the function with `get_typed_func`.
    // let instance = Instance::new(&mut store, &module, &[wasi.into()])?;
    // let hello = instance.get_typed_func::<(), ()>(&mut store, "hello")?;
    //
    // // And finally we can call the wasm!
    // hello.call(&mut store, ())?;

    let mut linker: Linker<Host> = Linker::new(&engine);

    let wasi = WasiCtxBuilder::new()
        .inherit_stdio()
        .inherit_stdout()
        .inherit_stderr()
        .inherit_args()?
        .build();

    let host = Host {
        wasi,
        wasi_threads: None,
    };

    let mut store = Store::new(&engine, host);

    // Define memory in linker

    // Define the WASI functions globally on the `Config`.
    // let engine = Engine::default();
    // wasmtime_wasi::add_to_linker(&mut linker, |s| &mut s.wasi)?;
    // wasmtime_wasi_threads::add_to_linker(&mut linker, &store, &component, |s| {
    //     s.wasi_threads.as_ref().unwrap()
    // })?;
    wasmtime_wasi::preview2::command::sync::add_to_linker(linker)?;

    // Create a WASI context and put it in a Store; all instances in the store
    // share this context. `WasiCtxBuilder` provides a number of ways to
    // configure what the target program will have access to.

    // Instantiate our module with the imports we've created, and run it.
    // let module = Module::from_file(&engine, "target/wasm32-wasi/debug/wasi.wasm")?;
    // linker.module(&mut store, "main", &module)?;

    linker.instantiate(&mut store, &component)?;

    // let wasi_threads = WasiThreadsCtx::new(module.clone(), Arc::new(linker.clone()))?;
    // store.data_mut().wasi_threads = Some(Arc::new(wasi_threads));
    // host.wasi_threads = Some(Arc::new(wasi_threads));

    let func = linker
        .get(&mut store, "main", "hello")
        .ok_or(anyhow!("no hello function"))?;
    let func = func
        .clone()
        .into_func()
        .unwrap_or_else(|| panic!("expected a function, got {:?}", func))
        .typed::<(), ()>(&store)?;

    func.call(&mut store, ())?;

    sleep(Duration::from_secs(2));

    Ok(())
}

impl preview2::WasiView for Host {
    fn table(&mut self) -> &mut wasmtime::component::ResourceTable {
        Arc::get_mut(&mut self.preview2_table)
            .expect("preview2 is not compatible with threads")
            .get_mut()
            .unwrap()
    }

    fn ctx(&mut self) -> &mut preview2::WasiCtx {
        let ctx = self.preview2_ctx.as_mut().unwrap();
        Arc::get_mut(ctx)
            .expect("preview2 is not compatible with threads")
            .get_mut()
            .unwrap()
    }
}
